/*
------------------------------------------------------------------------------------------------------
		NEWGEN SOFTWARE TECHNOLOGIES LIMITED
------------------------------------------------------------------------------------------------------
	Group					: Genesis
	Product					: iBPS
	Module					: Transaction Server
	File Name				: WFGetNextWorkItemForMail.sql
	Author					: Shahzad Malik
	Date written			: April 13th, 2020
	Description				: This procedure will fetch those workitem whose NotifyStatus is "Y"
------------------------------------------------------------------------------------------------------
			CHANGE HISTORY
------------------------------------------------------------------------------------------------------
Date		Change By			Change Description (Bug No. (If Any))
------------------------------------------------------------------------------------------------------
13/04/2020	Shahzad Malik		Bug 91513 - Optimization in mailing utility.
28/06/2021  Satyanarayan Sharma  Bug99571-In WFGetNextWorkItemForMail procedure the query to fetch WI and session validation is not properly done
25/08/2021  Satyanarayan Sharma iBPS4.0SP1-Mailing Service Error while getting next workitem.
------------------------------------------------------------------------------------------------------
*/

CREATE OR REPLACE FUNCTION WFGetNextWorkItemForMail (
	IN_SESSIOINID INTEGER ,
	IN_CSNAME VARCHAR
) 
RETURNS SETOF REFCURSOR AS $$
DECLARE
	REFCURSOR1 REFCURSOR;
	REFCURSOR2 REFCURSOR;
	MAINCODE INTEGER;
	V_QUERY1 TEXT;
	OUT_MAINCODE INTEGER;
	OUT_CSSESSIONID INTEGER;
	V_DBSTATUS INTEGER;
	V_ROWCOUNT INTEGER;
	V_PROCESSINSTANCEID VARCHAR(255);
	V_PROCESSDEFID INTEGER;
	V_PROCESSNAME VARCHAR(128);
	V_ACTIVITYID INTEGER;
	V_ACTIVITYNAME VARCHAR(128);
	V_PRIORITYLEVEL INTEGER;
	V_INSTRUMENTSTATUS VARCHAR(10);
	V_LOCKSTATUS VARCHAR(10); 
	V_LOCKEDBYNAME VARCHAR(255); 
	V_VALIDTILL TIMESTAMP;
	V_CREATEDBYNAME VARCHAR(255);
	V_CREATEDDATETIME TIMESTAMP;
	V_WORKITEMSTATE INTEGER;
	V_CHECKLISTCOMPLETEFLAG VARCHAR(10);
	V_ENTRYDATETIME TIMESTAMP;
	V_LOCKEDTIME TIMESTAMP;
	V_INTRODUCTIONDATETIME TIMESTAMP;
	V_INTRODUCEDBY VARCHAR(255);
	V_ASSIGNEDUSER VARCHAR(255);
	V_WORKITEMID INTEGER;
	V_QUEUENAME VARCHAR(255);
	V_ASSIGNMENTTYPE VARCHAR(10);
	V_PROCESSINSTANCESTATE INTEGER;
	V_QUEUETYPE VARCHAR(10);
	V_STATUS VARCHAR(255); 
	V_Q_QUEUEID INTEGER;
	V_TURNAROUNDTIME VARCHAR;
	V_Q_USERID INTEGER;
	V_ACTIVITYTYPE INTEGER;
	V_URN VARCHAR(128);
	v_psId					PSREGISTERATIONTABLE.PSID%Type;
BEGIN
	OUT_MAINCODE := 0;
	OUT_CSSESSIONID := IN_SESSIOINID;
	SELECT	PSReg.PSID INTO v_psId 
		FROM	PSRegisterationTable PSReg, WFPSConnection PSCon
		WHERE	PSCon.SessionID	= IN_SESSIOINID AND PSReg.PSID = PSCon.PSID; 
	
		GET DIAGNOSTICS V_ROWCOUNT = ROW_COUNT;	
		IF(V_ROWCOUNT <= 0) THEN
			OUT_MAINCODE :=11;
			OPEN REFCURSOR1 FOR SELECT OUT_MAINCODE AS MAINCODE, IN_SESSIOINID AS CSSESSIONID;
			RETURN NEXT REFCURSOR1;
			RETURN;
		END IF;
	
	
	BEGIN
		V_QUERY1 := 'SELECT PROCESSINSTANCEID, PROCESSDEFID, PROCESSNAME, ACTIVITYID, ACTIVITYNAME, PRIORITYLEVEL, INSTRUMENTSTATUS, LOCKSTATUS, LOCKEDBYNAME, VALIDTILL, CREATEDBYNAME, CREATEDDATETIME, WORKITEMSTATE, CHECKLISTCOMPLETEFLAG, ENTRYDATETIME, LOCKEDTIME, INTRODUCTIONDATETIME, INTRODUCEDBY, ASSIGNEDUSER, WORKITEMID, QUEUENAME, ASSIGNMENTTYPE, PROCESSINSTANCESTATE, QUEUETYPE, STATUS, Q_QUEUEID, date_part(''days'', AGE( To_TIMESTAMP(EXPECTEDWORKITEMDELAY::text , ''YYYY-MM-DD HH24:MI:SS''), To_TIMESTAMP(ENTRYDATETIME::text, ''YYYY-MM-DD HH24:MI:SS'') )* 24 ) AS TURNAROUNDTIME, Q_USERID, URN, ACTIVITYTYPE FROM WFINSTRUMENTTABLE WHERE NOTIFYSTATUS = N''Y'' AND LOCKSTATUS = N''N'' AND (AssignmentType = N''F'' OR AssignmentType = N''E'' ) AND  RoutingStatus = N''N'' AND Q_UserId>0 ORDER BY PRIORITYLEVEL DESC , ENTRYDATETIME ASC LIMIT 1';
		EXECUTE V_QUERY1 INTO V_PROCESSINSTANCEID, V_PROCESSDEFID, V_PROCESSNAME, V_ACTIVITYID, V_ACTIVITYNAME, V_PRIORITYLEVEL, V_INSTRUMENTSTATUS, V_LOCKSTATUS, V_LOCKEDBYNAME, V_VALIDTILL, V_CREATEDBYNAME, V_CREATEDDATETIME, V_WORKITEMSTATE, V_CHECKLISTCOMPLETEFLAG, V_ENTRYDATETIME, V_LOCKEDTIME, V_INTRODUCTIONDATETIME, V_INTRODUCEDBY, V_ASSIGNEDUSER, V_WORKITEMID, V_QUEUENAME, V_ASSIGNMENTTYPE, V_PROCESSINSTANCESTATE, V_QUEUETYPE, V_STATUS, V_Q_QUEUEID, V_TURNAROUNDTIME, V_Q_USERID, V_URN, V_ACTIVITYTYPE;
		GET DIAGNOSTICS V_ROWCOUNT := ROW_COUNT;
	END;
	
	IF(V_ROWCOUNT <= 0) THEN
	BEGIN
		V_QUERY1 := 'SELECT PROCESSINSTANCEID, PROCESSDEFID, PROCESSNAME, ACTIVITYID, ACTIVITYNAME, PRIORITYLEVEL, INSTRUMENTSTATUS, LOCKSTATUS, LOCKEDBYNAME, VALIDTILL, CREATEDBYNAME, CREATEDDATETIME, WORKITEMSTATE, CHECKLISTCOMPLETEFLAG, ENTRYDATETIME, LOCKEDTIME, INTRODUCTIONDATETIME, INTRODUCEDBY, ASSIGNEDUSER, WORKITEMID, QUEUENAME, ASSIGNMENTTYPE, PROCESSINSTANCESTATE, QUEUETYPE, STATUS, Q_QUEUEID, date_part(''days'', AGE( To_TIMESTAMP(EXPECTEDWORKITEMDELAY::text , ''YYYY-MM-DD HH24:MI:SS''), To_TIMESTAMP(ENTRYDATETIME::text, ''YYYY-MM-DD HH24:MI:SS'') )* 24 ) AS TURNAROUNDTIME, Q_USERID, URN, ACTIVITYTYPE FROM WFINSTRUMENTTABLE WHERE NOTIFYSTATUS = N''P'' AND LOCKSTATUS = N''N'' AND (AssignmentType = N''F'' OR AssignmentType = N''E'' ) AND  RoutingStatus = N''N'' AND Q_UserId>0 ORDER BY PRIORITYLEVEL DESC , ENTRYDATETIME ASC LIMIT 1';
		EXECUTE V_QUERY1 INTO V_PROCESSINSTANCEID, V_PROCESSDEFID, V_PROCESSNAME, V_ACTIVITYID, V_ACTIVITYNAME, V_PRIORITYLEVEL, V_INSTRUMENTSTATUS, V_LOCKSTATUS, V_LOCKEDBYNAME, V_VALIDTILL, V_CREATEDBYNAME, V_CREATEDDATETIME, V_WORKITEMSTATE, V_CHECKLISTCOMPLETEFLAG, V_ENTRYDATETIME, V_LOCKEDTIME, V_INTRODUCTIONDATETIME, V_INTRODUCEDBY, V_ASSIGNEDUSER, V_WORKITEMID, V_QUEUENAME, V_ASSIGNMENTTYPE, V_PROCESSINSTANCESTATE, V_QUEUETYPE, V_STATUS, V_Q_QUEUEID, V_TURNAROUNDTIME, V_Q_USERID, V_URN, V_ACTIVITYTYPE;
		GET DIAGNOSTICS V_ROWCOUNT := ROW_COUNT;
		IF(V_ROWCOUNT <= 0) THEN
			OUT_MAINCODE := 18;
			OPEN REFCURSOR1 FOR SELECT OUT_MAINCODE AS MAINCODE, OUT_CSSESSIONID AS CSSESSIONID;
			RETURN NEXT REFCURSOR1;
			RETURN;
		END IF;
	END;
	ELSE
	BEGIN
		V_QUERY1 := 'UPDATE WFINSTRUMENTTABLE SET NOTIFYSTATUS = N''P'' WHERE PROCESSINSTANCEID = $1 AND WORKITEMID = $2 AND NOTIFYSTATUS = N''Y''';
		EXECUTE V_QUERY1 USING V_PROCESSINSTANCEID, V_WORKITEMID;
		GET DIAGNOSTICS V_ROWCOUNT := ROW_COUNT;
	END;
	END IF;
	
	IF(V_ROWCOUNT > 0) THEN
		OPEN REFCURSOR1 FOR SELECT OUT_MAINCODE AS MAINCODE, OUT_CSSESSIONID AS CSSESSIONID;
		RETURN NEXT REFCURSOR1;
		OPEN REFCURSOR2 FOR SELECT V_PROCESSINSTANCEID As ProcessInstanceId, V_PROCESSINSTANCEID As WorkItemName,  V_PROCESSDEFID As RouteId, V_PROCESSNAME As RouteName, V_ACTIVITYID As WorkStageId, V_ACTIVITYNAME As ActivityName, V_PRIORITYLEVEL As PriorityLevel, V_INSTRUMENTSTATUS As InstrumentStatus, V_LOCKSTATUS As LockStatus, V_LOCKEDBYNAME As LockedByUserName, V_VALIDTILL As ExpiryDateTime, V_CREATEDBYNAME As CreatedByUserName, V_CREATEDDATETIME As CreationDateTime, V_WORKITEMSTATE As WorkitemState, V_CHECKLISTCOMPLETEFLAG As CheckListCompleteFlag, V_ENTRYDATETIME As EntryDateTime, V_LOCKEDTIME As LockedTime, V_INTRODUCTIONDATETIME As IntroductionDateTime, V_INTRODUCEDBY As IntroducedBy, V_ASSIGNEDUSER As AssignedTo, V_WORKITEMID As WorkItemId, V_QUEUENAME As QueueName, V_ASSIGNMENTTYPE As AssignmentType, V_PROCESSINSTANCESTATE As ProcessInstanceState, V_QUEUETYPE As QueueType, V_STATUS As Status, V_Q_QUEUEID As QueueId, V_TURNAROUNDTIME As Turnaroundtime, V_Q_USERID As UserID, V_URN As URN, V_ACTIVITYTYPE As ActivityType ;
		RETURN NEXT REFCURSOR2;
		RETURN;
	END IF;
	
END;
$$LANGUAGE plpgsql;