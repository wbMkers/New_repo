//----------------------------------------------------------------------------------------------------
//                       NEWGEN SOFTWARE TECHNOLOGIES LIMITED
//                   Group                    : Application-Products
//                   Product / Project        : WorkFlow
//                   Module                   : Transaction Server
//                   File Name                : WFSUtil.java
//                   Author                   : Prashant
//                   Date written (DD/MM/YYYY): 16/05/2002
//                   Description              : Implements Utility methods used in WAPI Calls
//----------------------------------------------------------------------------------------------------
//                                CHANGE HISTORY
//----------------------------------------------------------------------------------------------------
// Date                        Change By        Change Description (Bug No. (If Any))
// (DD/MM/YYYY)
//  07/07/2004				Dinesh Parikh    WSE_I_5.0.1_693
//  28/07/2004              Ashish Mangla    WSE_5.0.1_PRDP_001
//  08/09/2004              Krishan          wfs_5_001 (For removing JMS)
//  21/09/2004              Ruhi Hira        Oracle support for Message Agent.
//  24/09/2004              Ruhi Hira        To Handle invalid message.
//  27/09/2004              Ruhi Hira        Incorrect data in total duration report.
//  30/09/2004              Ruhi Hira        Removal of JMS.
//  06/01/2004              Harmeet Kaur     Added method WFCheckSession
//  28/01/2005              Harmeet Kaur     Bug WFS_5.2.1_0008
//  08/04/2005              Ruhi Hira        Bug # WFS_6_004.
//  12/04/2005              Ruhi Hira        SrNo-1.
//  13/04/2005              Ruhi Hira        Bug # WFS_6_009.
//  27/04/2005              Ashish Mangla    JBoss DataSource gives WrappedConnection, and getting statement from this connection are not of OracleStatement type.
//                                           First get the underlyongstatement from this wrappedpreparedstatement, and then cast it to OracleStatement
//  16/05/2005              Ashish Mangla    CacheTime related changes / removal of thread, no static hashmap.
//  02/06/2005              Harmeet Kaur     Bug # WFS_6_013.
//  16/11/2005              Virochan         Requirement WFS_6.1_056
//  26/12/2005              Virochan         New Method insertInWFJMSMessageTable added.
//  03/01/2006              Virochan         New method generateLog added.
//  03/01/2006              Virochan         WFS_6.1.2_001. Comments added
//  03/01/2006              Virochan         WFS_6.1.2_002. CLob writer is closed.
//  03/01/2006              Virochan         WFS_6.1.2_003. House keeping statements are properly ordered.
//  06/01/2006              Mandeep/Ashish   SrNo-2. Query WorkStep Related Changes
//  19/01/2006              Virochan         Requirement WFS_6.1.2_035.
//  09/02/2006              Ruhi Hira        Bug # WFS_6.1.2_049.
//  16/02/2006              Ashish Mangla    WFS_6.1.2_054 -Transaction should be commited in Setattribute only in case transaction is opened in the method itself
//  17/02/2006              Ashish Mangla    WFS_6.1.2_056 (old bug no WSE_I_5.0.1_697) if setattribute to be called after routing from OraCreateWorkitem, in case decision WI might be in WorkDoneTable...
//  16/05/2006              Ashish Mangla    SrNo-3. Hourly Report Support
//  14/07/2006              Ruhi Hira        Bug # 29.
//  16/08/2006              Ruhi Hira        Bugzilla Id 68.
//  16/08/2006              Ruhi Hira        Bugzilla Id 54.
//  21/08/2006              Ruhi Hira        Bugzilla Id 75.
//  22/08/2006              Ruhi Hira        Bugzilla Id 122.
//  29/08/2006              Ruhi Hira        Bugzilla Id 119.
//  09/01/2007              Ashish Mangla    Bugzilla Bug 368 (Warning in Jboss Closing a result set you left open! Please close it yourself.)
//  07/02/2007              Ahsan Javed      Added getCalendarData.
//  08/02/2007              Varun Bhansaly   Bugzilla Id 74 (Inconsistency in date-time)
//  22/02/2007              Ruhi Hira        Bugzilla Id 477.
//  14/03/2007              Varun Bhansaly   Bugzilla Id 486. [WMGetWorkItemAttributeValue] Starting End Tag not matching
//  12/05/2007              Ruhi Hira        Custom Interface arch change
//                                           New method for date formulation
//                                           getCalData (DefaultHourRange tag)
//  14/05/2007              Ashish Mangla    Bugzilla Bug 267 (for IBM AIX Websphere Oracle 10g)
//  14/05/2007              Ashish Mangla    Bugzilla Bug 480 (Reports for Average Processing time not correct)
//  23/05/2007              Ruhi Hira        Bugzilla Bug 896.
//  24/05/2007              Ruhi Hira        Bugzilla Bug 944.
//  05/06/2007              Ruhi Hira        WFS_5_161, MultiLingual Support (Inherited from 5.0).
//  10/07/2007              Ruhi Hira        Bugzilla Bug 1241, 1242.
//  06/09/2007              Varun Bhansaly   Method parseQueryFilter added for Parsing of Complex Filters.
//  21/08/2007              Ruhi Hira        SrNo-4, Synchronous routing of workitems.
//  18/10/2007              Varun Bhansaly   SrNo-5, Method readFileAsResource written to read file placed inside Jar
//  18/10/2007              Varun Bhansaly   SrNo-6, Use WFSUtil.printXXX instead of System.out.println()
//                                           System.err.println() & printStackTrace() for logging.
//  29/10/2007              Ashish Mangla    Bugzilla Bug 1671 (After inserting and committing data in WFMessageTable for Oracle DB, code in finally block attempts to 'rollback' an already committed transaction)
//  01/11/2007              Ruhi Hira        Bugzilla Bug 1705.
//  16/11/2007              Varun Bhansaly   SrNo-7, Methods made compatible with Postgres.
//  16/11/2007              Ruhi Hira        SrNo-8, Synchronous routing, Removal of WorkDoneTable.
//  19/11/2007              Varun Bhansaly   getBigData made compatible with Postgres.
//  23/11/2007              Shilpi S         SrNo-9
//  27/11/2007              Varun Bhansaly   Added Method getQueryFilter
//  07/12/2007              Ruhi Hira        SrNo-10, new signature for setAttributes (sync routing mode).
//  19/12/2007              Shilpi           Bug # 1608
//  19/12/2007              Tirupati Srivastava  UPPER removed from getFilter()
//  20/12/2007              Varun Bhansaly    genLog(), genLogTime(), genLogSummary() made compatible with PostgreSQL.
//  08/01/2008              Ruhi Hira         Bugzilla Bug 1649 Method moved from OraCreateWI.
//  09/01/2008              Varun Bhansaly    Bugzilla Id 3284
//                                            (Bug WFS_5_221 Returning the size of variables in case of char/varchar/nvarchar)
//  09/01/2008              Ruhi Hira         Bugzilla Bug 3380, NOLOCK added to select queries in setAttributes.
//  15/01/2008              Ruhi Hira         Bugzilla Bug 3421, new method getLikeFilterStr added.
//  23/01/2008              Varun Bhansaly    Bugzilla Id 3479, Logger required in NGUtility and process server
//  24/01/2008              Sirish Gupta      Added Method insertMessage
//  28/01/2008              Varun Bhansaly    Bugzilla Id 1775, (Same sequence being used for insertion into WFMessageTable & WFJMSMessageTable)
//  28/01/2008              Ashish Mangla     Bugzilla Bug 3430 (Batching not proper in Oracle10g)
//  31/01/2008              Varun Bhansaly    generalError() methods of WFClientServiceHandlerBean shifted to WFSUtil
//  01/02/2008              Ruhi Hira         Bugzilla Bug 3511, createProcessInstance moved to WFSUtil
//                                            wfs_ejb classes not accessible from wfsshared.
//  03/03/2008              Varun Bhansaly    getQueryFilter - Order by if found should be extracted first
//  05/03/2008              Sirish Gupta      Removed import org.postgresql.largeobject.* and gave full path where it is used.
//  14/05/2008              Shilpi S          SrNo-11, BPEL Compliant Omniflow- Support for boolean data type
//  14/05/2008              Shilpi S          SrNo-12, BPEL Compliant Omniflow- Support for complex structures
//  12/05/2008              Shweta Tyagi      SrNo-13, Support for complex structures    new method added fetchAttributeExt
//  19/05/2008              Shweta Tyagi      Bugzilla Bug Id 5128 relation column value was null
//                                            causing null pointer exception in TO_SQL method
//  22/05/2008              Ashish Mangla     Bugzilla Bug 5050 instead of Oracle.sql.CLOB, Use java.sql.clob
//  19/06/2008              Shweta Tyagi      Bugzilla Bug Id 5130 ClassCastException in  setValueInMap
//  19/06/2008              Shweta Tyagi      Bugzilla Bug Id 5138 ClassCastException in    fetchAttributesExt
//  20/06/2008              Shweta Tyagi      Bugzilla Bug Id 5142 ShortDate Time support in BPEL Compliant Omniflow
//  26/06/2008              Shweta Tyagi      SrNo.11 Output XML shouldn't contain any tag if no row in table for complex structure
//  01/07/2008              Ruhi Hira         Bugzilla Bug 5486, NPE in setting multi level complex structures and key is in top level only.
//  01/07/2008              Shweta Tyagi      Bugzilla Bug Id 5431 Webservice Invoker doesnot process Workitems
//  01/07/2008              Ruhi Hira         Bugzilla Bug 5470, Child first approach.
//  03/04/3008              Ruhi Hira         Bugzilla Bug 5515, unable to set system defined columns like PriorityLevel.
//  03/04/3008              Ruhi Hira         Bugzilla Bug 5488, Set command in entry settings does not execute.
//  03-07/2008              Ruhi Hira         Bugzilla Bug 5533, ShortDate/ Boolean/ Time support in Set attributes.
//  04/07/2008              Ruhi Hira         Bugzilla Bug 5537, TableNameStr to WorkDoneTable.
//  07/04/2008              Ruhi Hira         Bugzilla Bug 5589, Rollback will throw error when auto commit is false
//                                            and no query is yet executed. [The COMMIT TRANSACTION request has no corresponding BEGIN TRANSACTION.]
//  08/07/2008              Ruhi Hira         Bugzilla Bug 5142, 5530, Boolean/ ShortDate/ Time support in pick list.
//  09/07/2008              Ruhi Hira         Bugzilla Bug 5493, null handlled beside "".
//  09/07/2008              Ruhi Hira         Bugzilla Bug 5503, Array Support, Delete first, then insert all, then update parent.
//  11/07/2008              Ruhi Hira         Bugzilla Bug 5744, Primitive array support.
//  14/07/2008              Ruhi Hira         Bugzilla Bug 5752, NULL handled in autogen key.
//  14/07/2008              Shweta Tyagi      Bugzilla Bug 5762, NullPointerException in setValueInMap()
//  14/07/2008              Ruhi Hira         Bugzilla Bug 5768, Mapped child not set for external table fields.
//	15/07/2008              Ruhi Hira         Bugzilla Bug 5515, priorityLevel not set, querying wrong table.
//  16/07/2008              Shweta Tyagi      Bugzilla Bug 5785, NullPointerException in fetchAttributesExt
//	23/07/2008				Ashish Mangla		Bugzilla Bug 5823, correction in case of weblogic
//  06/08/2008              Varun Bhansaly    Logging of wsrequest and wsresponse thru logger framework.
//  14/08/2008              Varun Bhansaly    Bugzilla Id 5976, rs.getBigdecimal() to be used instead of getFloatValue of XMLgenerator
//  19/08/2008              Varun Bhansaly    Bugzilla Id 6040, BPEL WSDL files currently being thrown in CWD
//  26/08/2008              Varun Bhansaly    SrNo-15, fetchAttributesExt to be used to open WIs with complex types.
//                                            This method returns XML with XML attributes.
//	28/08/2008				Amul Jain			Optimization Requirement WFS_6.2_033 (Removed DISTINCT clause and added check for WorkitemID in setAttributes method.
//	04/10/2008				Amul Jain			WFS_6.2_013	(Search on process variables and order of Column Display in Search Result.)
//	31/10/2008				Ashish Mangla		Bugzilla Bug 6790
//  10/11/2008              Ruhi Hira			Bugzilla Bug 6924, API setAttributes should set attributes of locked workitems only.
//  10/11/2008              Ruhi Hira			Bugzilla Bug 6855, ItemIndex and ItemType set as null in setAttribute.
//  11/11/2008              Ruhi Hira			Bugzilla Bug 6941, PickList give error when search with some value in int field in Oracle.
//  01/12/2008              Ruhi Hira			Bugzilla Bug 7030, setAttribute not working when child is set and parent is null.
//  02/12/2008              Ruhi Hira			Bugzilla Bug 6991, prorityLevel not set for u type user in setAttributeExt.
//  02/12/2008		Ruhi Hira			Bugzilla Bug 7084, tempValueStr was not initialized.
//  10/12/2008              Ashish Mangla		Bugzilla Bug 7226, JTSException was being thrown in case doc not found
//  10/12/2008              Ashish Mangla		Bugzilla Bug 7227,7357 no space after NULL, query giving error
//  17/12/2008              Shilpi S            SrNo-16, new methods added for bpel event support in omniflow
//  24/12/2008              Ashish Mangla	Bugzilla Bug 7443, QueueId is not coming in summery table
//  26/12/2008              Ruhi Hira		Bugzilla Bug 7477, if path is null in xml file, replace macro with "".
//  28/12/2008              Ashish Mangla	SrNo-16 Supporting both old and new History in case of upgrade
//  29/12/2008              Ruhi Hira           Bugzilla Bug 7273, setAttributeExt does not set data in refered WIs.
//  30/12/2008              Shilpi S            Bug # 7521
//  30/12/2008              Shilpi S            Bug # 7527
//  31/12/2008              Shilpi S            Bug # 7529
//  31/12/2008              Ruhi Hira           Bugzilla Bug 7241, Array in array was not working.
//  02/01/2008              Shilpi S            Bug # 7546
//  06/01/2008              Shweta Tyagi	    Bugzilla Bug 7241, Array in array was not working.
//  18/05/2009              Ashish Mangla	    getLikeFilterStr method modified, convertToSQLString(string, dbType) of OmniDocs does not have break after MSSQL case, it goes to Oracle generating error
//  09/06/2009              Ashish Mangla	    WFS_8.0_004 (fetchAttributesExt fails if "AND" was coming in some column name)
//  02/07/2009              Abhishek Gupta      WFS_8.0_014 (nText support provided for external tables.)
//  20/08/2009		        Minakshi Sharma	    SrNo-17,new method added to check whether SAP License Key is correct or not.
//  31/08/2009              Shilpi Srivastava   WFS_8.0_026, SrNo-18,Workitem Based Calendar
//	03/09/2009				Saurabh Kamal		New method as CreateXMLExtInterface to create xml for Conditional External Interface
//  17/08/2009              Abhishek Gupta      Support for colored display on web.(Requirement)
//	06/10/2009				Preeti Awasthi		WFS_8.0_040 Support for filter using queue variables/aliases on Queue is 'No Assignment' Type.
//	09/10/2009				Ashish Mangla		WFS_8.0_041 (Complex array in array not saving properly)
//  22/10/2009				Saurabh Kamal		WFS_8.0_045, Change in genAdminLog for auditing of Add Calendar action.
//	27/10/2009				Ashish Mangla		WFS_8.0_046 (In case user is member of multiple groups which are added to Queue, One group having no filter, then user should be able to view workitems considering 'no filter')
//	03/10/2009				Saurabh Kamal		WFS_8.0_049 (Method getTimeDiff changed to public)
//  19/11/2009              Ashish Mangla       WFS_8.0_059 Support of UserName macro in ForcedFilter in Query Workstep
//	30/11/2009				Saurabh Kamal		WFS_8.0_061	Method to return OrderBy
//	06/01/2010				Ashish Mangla		fetchAttributesExt returning values of old WI in case exttable is blank
//	06/01/2010				Ashish Mangla		fetchAttributesExt returning blank tag for primitive array in case it is blank
//	06/01/2010				Preeti Awasthi		WFS_8.0_081: Error in opening workitem if workitem is in QueueHistoryTable
//	08/01/2010				Preeti Awasthi		NullpointerException is coming if no complex variable is used in process.
//	15/01/2010				Ashish Mangla		In case complex mapped with QueueDataTable, and Wi is in QueueHistoryTable, that complex attribs is not returned.
//  10/02/2010			    Vikas Saraswat	    WFS_8.0_084 Form Fragment functionality
//  03/03/2010				Ashish Mangla		Bugzilla Bug 12075 //else part removed where primary introduction activity was being fetched,
//  19/04/2010              Saurabh Kamal       Bugzilla Bug 12370/12373 Error description should not come as null in generalError Xml.
//	08/03/2010				Indraneel Dasgupta	WFS_8.0_090	Removing Hyphen from processinstanceid when suffix is not supplied at the time of process registration.	
//	05/05/2010				Saurabh Kamal		Handling for ntext jdbc type for SqlServer2008
//	10/09/2010				Prateek Verma		Postgres Changes - getTimeZoneInfo, genAdminLog, DATEDIFF
//  22/10/2010				Ashish Mangla		Bugzilla Bug 13084 // Error in fetching Attributes Postgres
//	02/11/2010				Saurabh Kamal		Change in getBigData for OTMS postgres support.
//  08/11/2010              Abhishek Gupta      Bugzilla Bug 13207 : Insert fails in case of Postgres.
//	02/07/2010				Preeti Awasthi		WFS_8.0_108 Error in Workitem opening
//	02/07/2010				Vikas Saraswat		WFS_8.0_109 Audit percentage is not working properly so need to be change in the batch of 20.
//	10/08/2010				Saurabh Kamal		SetAttribute optimization in case of multiple workitemId
//  19/08/2010              Saurabh Kamal       writeLog method for writing Threshold.log
//  27/08/2010               Vikas Saraswat  	WFS_8.0_127 Configuring Threshold logs for execution time and size of APIs.
//  02/09/2010               Saurabh Kamal  		WFS_8.0_129 createChildWorkitem with Set attribute.
//  28/12/2010               Saurabh Kamal  		Rule caching for ICICI slowness issue.
//	17/02/2011				 Preeti Awasthi		Bug 1091 Support of multiple records in WFFilterTable
//	10/03/2011				 Saurabh Kamal		WFS_8.0_153, Function Support in QueryFilter.
//  14/03/2011               Abhishek Gupta     WFS_9.0_002 : Error in setting blank value in NText type column.
//  12/02/2011				 Prateek Verma		Support of log4j.xml in logviewer
//	10/05/2012				 Shweta Singhal		Bug 31425 ProjectId is not updated in case of Overwrite a process during CheckIn
//	14/05/2012				 Shweta Singhal		Bug 31861 Registration Number information & CreatedOn not getting updated in case of Overwrite
//	14/05/2012				 Shweta Singhal		Bug 31606 In ImportedProcessDefTable, CallerProcessDefId column is the current process's processdefid not Processdefid column
//	15/05/2012				 Shweta Singhal		Bug 31883 FilterOption in QueueDefTable was not getting updated on the basis of PMWQueueDefTable
//	15/05/2012				 Shweta Singhal		Bug 31825 & Bug 31951 Error Creating new Workitem
//	22/05/2012				 Shweta Singhal		Bug 31877 multiple ProcessFolder exists for the same processname.
//	11/06/2012				 Shweta Singhal		Bug 31829 Calendar Data should be fetched from backend tables in case of global calendar
//	09/08/2012				 Saurabh Kamal		executeGetObjectList(), executeGetQueryParam(), executeGetObjectList1() functions are added for Right Management
//	09/08/2012				 Anwar Danish       Bug 32742 - Error in JMS Producer.
// 17/08/2012           	Shweta Singhal      Bug 32902 : Check out process then register process consider it locally gives inconsistent data.
// 15/10/2012           	Shweta Singhal      Bug 34322 : User should get pop-up for reminder without relogin
// 22/10/2012				Sajid Khan			Bug 33893, standard time format support in WFSetCalendarData and WFGetCalendarData
// 31/10/2012				Shweta Singhal		Bug 36167, Process deployment failed on Oracle.
// 01/11/2012           	Shweta Singhal      Bug 36021 : Unable to deploy the process when the porcess name and registration number is changed
// 02/11/2012           	Shweta Singhal      Bug 35523 : SaveAsLocal" option have inconsistent data for Swimlane and Queues
//	13/07/2011				Bhavneet Kaur		Bugzilla Bug 27472: Average Duration (mins) column in Participant Report shows negative entries
//05/07/2011	Preeti Awasthi	Bug 27418:CreateWorkitem call gets failed at distribute workstep from Process Server if apostrophe is present in any string type queue variable.
// 07/07/2011	Preeti Awasthi/Ashish Mangla 	Bug 27470 : Workitem opening taking time.
// 02/09/2011		   Shweta Singhal	 Change for SQL Injection.
//26/09/2011		   Mandeep Kaur		 BugID 28477, Changes for Worflow Report Folder creation issue(For Saas)
// 02/09/2010                Saurabh Kamal  	WFS_8.0_129 createChildWorkitem with Set attribute.
// 30/01/2012           Neeraj Kumar            Bug 30350 - To provide separate logging of xml and transaction log for each cabinet on application server
// 17/02/2012			Vikas Saraswat			Bug 30511 - values were not fetching correctly for String variable in WFFetchattributesExt
// 08/11/2011    			Bhavneet Kaur       Bug 28935- [Webservice] SAXParserException Handled in Uploadworkitem call caused by special characters in XML [Replicated]
// 30/03/2012               Neeraj Kumar           Replicated -WFS_8.0_148 Data should retrieve from arrary tables in order of its insertion.
// 09/04/2012           	Bhavneet Kaur   	Bug 31002: Workitem History Capture for Document Print Operation and AddtoMail Queue Action
// 14/05/2012	Preeti Awasthi	Bug 31893 - Search is giving error having filter on WFFilterTable
// 18/05/2012		   Saurabh Kamal 	  Bug 32025 - DeadLock in HCL BPO while checking user or UtilitySession
//	01/06/2012	Preeti Awasthi	[Replicated] Bug 30802 - advanced search using funtion filter for groups not working due to missing parenthesis
// 07/06/2012	Sachin Pipal	Bug 32515 - Changes in WMFetchWorklist for SQL injection when using Set Filter option from Webdesktop.
// 05/07/2012   Bhavneet Kaur   Bug 33029 Cabinet Based Logging for Console, Error, PSError, PSXML & PSOut logs
// 06/09/2012	Bhavneet Kaur	Bug 34665 Bugs encountered due to Cabinet Based Logging 
// 12/09/2012	Preeti Awasthi	Bug 34839 - User should get pop-up for reminder without relogin
//	09/10/2012	Preeti Awasthi	Bug 35668 - Services from OFServices not starting since registration information becomes null
//	13/12/2012	Shweta Singhal	Bug 37143 - Unable to intoduce the workitem 
//19/12/2012	Sajid Khan		Bug 36612 - Issue in save as local.
//  24/12/2012  Anwar Ali Danish Bug 36775 - Data inconsistency in JMS Producer tab
//	13/12/2012	Shweta Singhal	Bug 37094 - filterstring value should not be returned as null in getAssignedRightOnObjType() called from WFGetUserObjTypeAssociation API
//  31/12/2012	Shweta Singhal	Bug 37558 - GetRightsOnObjectType() method not returning the correct right string
//  02/01/2013	Shweta Singhal	Bug 37636 - Rights are not getting assigned while registering the new process
//  03/01/2013	Shweta Singhal	Bug 37625 - GetRightsOnObjectType() method query changed for getting union rights on a given ObjectType
//  03/01/2013	Shweta Singhal	Bug 37625 - GetRightsOnObjectType() method query changed for getting union rights on a given ObjectType
// 03/01/2013   Kahkeshan       Reverted Changes done for Bug 33893 and Bug36819 as colon support is to be provided at omniflow web.           
// 04/01/2013   Shweta Singhal  Auditing optimized
//  07/01/2013	Sajid Khan		Bug 37345 - Audit trail Issue.
//	07/01/2013	Sajid Khan		Bug 37632-  Not able to differentiate between checkin of process as same or new version 	
//	08/01/2013	Shweta Singhal	Bug 37625- Rights were not fetched accordingly	
//	15/01/2013	Sajid Khan		Bug 37632- Not able to differentiate between checkin of process as same or new version.
//	15/01/2013	Shweta Singhal	Enhancement 37672- Logging of methods which are called form Other components of OF.
//  16/01/2013	Sajid Khan		Bug 37731 - AuditTrail for Process State Change for registered Processes .
// 22/01/2013	Shweta Singhal	Changes done for removing OD dependency for rights checking .
// 23/01/2013	Sajid Khan		Bug 37965 - While Generate the log for the queue, same description and Date are showing 2 times in log.
//23/01/2013	Sajid Khan		Bug 38002 - History is not generated for operation 'Add Variable in Quick Search     Manangement' in Audit log
//23/01/2013	Sajid Khan		Bug 38003 - History is not generated for operation 'Delete Variable in Quick Search     Manangement' in Audit log
//24/01/2013	Shweta Singhal	Change done for Bug 37991 in getRightsOnObjectType() and getRightsOnObject() method
//28/01/2013	Shweta Singhal	Workitem was not getting created as Process Folder was not created
//28/01/2013	Shweta Singhal	Changes done for BUG 38051, ProjectId required in Delete Process Operation
//28/01/2013	Shweta Singhal	Bug 38083 fixed, WFSException will be returned in case of user = null
//29/01/2013	Bhavneet Kaur	Bug 38113 - Repeater Control Issue: Complex variable values were deleted in the form, but not reflected in cabinet
//30/01/2013	Shweta Singhal	Bug 38101 fixed, Add group to swimlane queue was not getting updated
//31/01/2013    Neeraj Sharma   Bug 38164 - CreatedDateTime tag was missing in the output of WFgetworkitemDataExt call.
//05/02/2013    Shweta Singhal  Bug 38207, Registered process rights are not returned
//07/02/2013    Shweta Singhal  Bug 38270, ProcessName was not changed in case of Oracle while registering process
//07/02/2013    Shweta Singhal  Bug 38254, Handling for FormBuffer in WFForm_Table for Oracle
//22/02/2013    Shweta Singhal  Bug 38374, Registered process 'process' is saved as Local, but showing checked out the process in description of Audit Trail
//05/03/2013    Kahkeshan       Bug 38558 - If Search on Date field (Given input: 01/Jan/2013) from Search Workitem iframe, an error is appeared in search result (while searching proper from Quick Search with same date format ) 
//06/03/2013    Shweta Singhal  Bug 36519, WMAddQueue failed
//07/03/2013    Kahkeshan       getMAXValue function added to get  Maximum Value of nvarchar2 specific to the database
//08/03/2013    Kahkeshan       Bug38565  'Like' operator is not working in advancce search 
//08/03/2013    Shweta Singhal  Bug38665  Process Name was send in Capital, causing deployment failed error.
//14/03/2013    Kahkeshan       Bug 38564 If using 'OR' operator in Advance Search, all WIs of All queues are showing in search result 
//17/05/2013	Shweta Singhal	Process Variant Support Changes
//25/04/2013    Kahkeshan       Bug 38914 - UserIndex and SessionId required in transaction log 
//02/05/2013	Sajid Khan		Bug 38026 - No History generated for operation 'Set Diversion' .
//28/05/2013	Anwar Ali Danish	Bug 39613 - Saved data in JMS Consumer tab is not showing in registered process.
//29/05/2013	Shweta Singhal	Bug 39726, special character # is not handled in ObjectName
//29/05/2013	Anwar Ali Danish   Bug 39473 fixed 
//30/05/2013    Kahkeshan       Bug 39621 - File Upload utility doesn't make entries in created table : NewTable 
// 03/06/2013   Kahkeshan       Use WFSUtil.printXXX instead of System.out.println()
//							    System.err.println() & printStackTrace() for logging.
//03/06/2013     Sajid Khan		Changes Done for Queue conflict Management. 
//06/06/2013	Mohnish Chopra	Bug 39767 - New Method "getQueueInfoXMLForQueueId" added.
//11/06/2013    Shweta Singhal  Bug 40308- Method added to sort a map by values
//11/06/2013    Shweta Singhal  Bug 40315- createdby and lastmodifiedby should be the name of logged-in user rather who created the process
//14/06/2013    Shweta Singhal  Bug 40355- Sequence will be created while registering the process or checkin process as a new version
//18/06/2013    Kahkkeshan      Bug 40277  QM_InValidQueue_Name 
//26/06/2013    Shweta Singhal  Bug 40727- Bug while creating WI after check-out and check-in as new version
//26/06/2013    Shweta Singhal  Bug 40704- CreateChildWorkitem is not in transaction in OraCreateWorkitem
//28/06/2013    Shweta Singhal  Bug 40819-  Unable to save workitem attributes having array of complex variable
//----------------------------------------------------------------------------------------------------
//02/07/2013    Mohnish Chopra  Bug 40367  Replace QueueDataTable with QueueHistoryTable after execution of TransferData
//04/07/2013	Mohnish Chopra	Bug 40365  Allow QueueDataTable in complex structure mapping
//29/07/2013	Sajid Khan		imageToNtext, extractionFromColumn and addTempColumn mehtods added for handling image to ntext conversion.
//16/08/2013 	Anwar Ali Danish	Changes done in methods imageToNtext() and extractionFromColumn() for Oracle 
//02/09/2013    Kahkeshan       Bug 41686  Logging of all the queries in DEBUG mode
//15/11/2013    Kahkeshan       Bug 42580 - Unable to Check-In Process.
//27/11/2013	Sajid Khan		Role Association with RMS.
//23/12/2013	Mohnish Chopra	Changes for Code Optimization
//23/12/2013	Shweta Singhal	Changes for Code Optimization Merged
//24/12/2013	Anwar Ali Danish	Changes done for code optimization
//23/12/2013 	Kahkeshan       Code Optimization Changes For setValueInMap ,fetchAttributes and fetchAttributesExt method.
//23/12/2013	Sajid Khan		Message Agent Optimization.
////23/12/2013	Sajid Khan		Default Queue Creation Changes.
//01/01/2014	Anwar Ali Danish	Changes done for code optimization
//24/01/2014    Shweta Singhal      To_UpdateData method written and UserCount etc commented in getQueueInfoXMLForQueueId() method
//30/01/2014	Sajid Khan			RMSSegregation Phase 2 Development- Methds called from WFSUtil to WFRMSUtil.java
//30/01/2014	Sajid Khan			Error while process check in .
//30/01/2014	Sajid Khan			Changes done for Omniflow Mobile.
//07-02-2014	Sajid Khan			Exception handled in worklistconfig methods.
//10/01/2014    Anwar Danish        New method added for BRMS work
//18/02/2014    Anwar Danish		Changes done for bug Id 43107
//20/02/2014	Kahkeshan			Message Format of Transaction Logs changed and Cabinet Logging of XML Logs Enabled.
//24/02/2014    Anwar Danish		Changes Done for Bug Id 43309  
//07/03/2014	Sajid Khan			Bug 43582 - Error in creating variant in oracle
//20-03-2014	Sajid Khan			Bug 43147 - Inconsistency in getting process; list for admin user
//25-03-2014	Sajid Khan			Using ThreadLocal context to get username and userApiStatus for User/API logging.
//26-03-2014    Kanika Manik        Bug -43730 While save WI with data in boolean type Variant's field, An error is generating While saving proper for others type variables
//26-03-2013    Kanika Manik        Bug 43772 -Checkedout base process and made some changes and checkin >> While create WI, an error is generated
//21/03/2014	Kahkeshan			Merging of Bug 37658  - Mail trigger Mails to be in transaction with create workitem
//28/03/2014	Kahkeshan			Bug 44005 - Specific Case: Workitems are not moving to next workstep if we use "Escalate To" operation in entry settings 
////28-03-2014			Kanika Manik		Bug 43448- CheckIn of the Variant Process as New Version makes the variant list blank. 
// 31/03/2014	Anwar Danish		Changes done for BRMS	
//02/04/2014    Kanika Manik        Bug 43772 Checkedout base process and made some changes and checkin >> While create WI, an error is generated
//02/04/2014    Kanika Manik        Bug-44151 While creating new workitem error message displays
//03/04/2014    Kanika Manik        Bug 43993 - Error while creating workitem on sub process
//03/04/2014    Kanika Manik        Bug 44120 - While check-in the process with same version, an error "operation failed" is generated
//04/04/2014	Mohnish Chopra		Added isWorkItemExpired method
//09/04/2014    Kanika Manik        Bug 44365 - Unable to introduce workitems of Process Variant.
//15/04/2014    Kanika Manik        Bug 43448- CheckIn of the Variant Process as New Version makes the variant list blank. 
//15-04-2014	Sajid Khan			Bug 44286 - If you enter & sign in any text box then it does not lets you save the form and generates error 
//15-04-2014    Kanika Manik        Bug 44429 - While save workitem with filled values in date & shortdate type fields, the error is generated (In case of Variant variables)
//15-04-2014    Kanika Manik        Bug 44440 - Select some variants to be copied in new version and now VariantBase process is checked-in with new version, if Open Assocication window of Registered Baseprocess, an error is showing
//18/04/2014	Kahkeshan			Bug 44459  Unable to Start Export Utility if I use set Filter property in Export Utility. New Method handleSpecialCharInXml added to handle
//                                  special characters 	
//30-04-2014	Sajid Khan			Bug 44536 - Audit Log configuration is not working.
//27-05-2014    Kanika Manik        PRD Bug 42494 - BCC support at each email sending modules
//02-06-2014	Sajid Khan			Bug 40984 - In Search API query return by function filter is invalid.
//03/06/2014    Kanika Manik        PRD Bug 42322 - Issue in presentation of long integral values - View as exponential format
//11/06/2014    Anwar Danish        PRD Bug 42861 merged - In omniflow UserQueueTable is replaced with QUserGroupView to provide omniflow support for applications not using WMconnect call.
// 12/06/2014   Anwar Danish        PRD Bug 41483 merged - "Requested Filter is invalid" message comes when function filter is used and query filter uses closing bracket in sql
//16/06/2014    Kahkeshan	    Columns added in WFAttributeMessageTable as required in Archival
//19-06-2014	Sajid Khan			Bug 46433 - Arabic: While create new workitem, an error is generated (First Time only) After check in the process in new version.
//21-06-2014	Sajid Khan			 Arabic value was not inserting properly in PDBDocument and PDBFolder table.
//23-0-2014		Sajid Khan			Bug 46840 - Android Device-Blank or without Text workitems are shown in Start_Event Queue.
//27/06/2014	Kahkeshan			Bug 46802 - Search is not working proper in User tab of Queue Property
//26/06/2014    Anwar Danish  		PRD Bug 45001 merged - Add new action ids, handle also at front end configuration screen and history generation functionality.
//03/07/2014	Mohnish	Chopra		Bug 39661- Changes for  Comment 31,Test Case 4 in bug 39661.
//20/08/2014	Mohnish Chopra		Prdp Bug 47241 merged -  UPPER(RTRIM)) was removed from processinstanceid While updating QueueDataTable in setAttributesExt.
//22/08/2014	Mohnish Chopra		Changes for Bug 47515 - Create workitem operation is slow with high concurrency (~5 seconds with 100 concurrent users)
//25/09/2014	Mohnish Chopra		Bug 50420 - Subprocess functionality is not working fine
//29/09/2014	Mohnish Chopra		Bug 50438 - WI properties showing 2 start Events 
//28/07/2015 	Anwar Danish		PRDP Bug 51341 merged - To provide support to fetch action description/statement corresponding to each actionId at server end via WFGetWorkItemHistory and WFGetHistory API call itself.
//07/08/2015	Anwar Danish        PRD Bug 51267 - Handling of new ActionIds and optimize usage of current ActionIds regarding OmniFlow Audit Logging functionality.
//30/04/2014	Mohnish Chopra		fetchTaskData method added for Case Management
//18/05/2014	Mohnish Chopra		Methods completeTask,isCaseWorkStepActivity,isCompletedAllTasks added for Case Management.
//29-05-2014	Sajid Khan			Support for Providing Complex Mapping with Task Variables.
//11/08/2015	Mohnish Chopra		Changes for Data Locking issue in Case Management
//27/08/2015	Amar Sharma			Added methods for Handling Event in Calendar
//09/02/2015	Mohnish Chopra		Changes for Case management in register process flow -Task association with form 
//26/11/2015    Kirti Wadhwa 		Changes For saving FormBuffer 
//27/11/2015    Kirti Wadhwa      	 Changes for Bug 57916  Jboss EAP : Null value showing in text variable in case data
//01/12/2015	Mohnish Chopra		Bug 57926 - case worker can initiate task, even when case manager revoked the task from case worker
//04/12/2015	Mohnish Chopra		Changes for Bug 58097 - case worker can add task even when task has been revoked from the worker by case manager.
//28/12/2015    Kirti Wadhwa        Changes for Bug 57652 - while diversion, tasks should also be diverted along with the workitem in generateTaskLog.
//08/02/2016	Kirti Wadhwa		Changes for  Bug 58158 - task worker is able to provide all rights to todo/exception/form/document while initiating task.(Added New Method isUserCaseManager).
//17/02/2016	Kirti Wadhwa		changes for Bug 59184 -Oracle +JBOSEAP : Child workItem was not generated using ChildWorkItem Trigger
//18/02/2016	Mohnish Chopra		Changes for QueryTimeout-Optimisation.
//01/03/2016    Kirti Wadhwa        Code merge for Bug 55484 - Optimization in SetAttributes API : Removal of updation of itemindex and itemtype in External table while updating External Table variables.
//07/03/2016	Mohnish Chopra		Changes for Bug 59392 - At time of check-out of process, users, groups and filers are not copied to local copy
//07/03/2016	Mohnish Chopra		Changes for Threshold routing count(PRDP Bug 56950) 
//17/03/2016	Mohnish Chopra		Bug 59571 - Weblogic +Oracle +Linux >> Error is generating in properties of workitem 
//10/05/2016	Mohnish Chopra		Changes for Postgres 
//20/07/2016    RishiRam Meel		Changes done for Bug : Bug 62681 - IBPS3.0 Postgres(BPM+CM)||Case Management:-On Task form entries are not saved 
//20/07/2016	Mohnish Chopra		Merging for Multi level Nested Complex
//21/07/2016    RishiRam Meel		Changes done for Bug 62871 - Postgres : Error in saving workitem if giving special character < >
//22/07/2016	Mohnish Chopra		Changes done for Bug 62942 - IBPS3.0 Postgres(BPM+CM):checkout swimlane perform changes click on ok button it shows error. 
//22/07/2016    RishiRam Meel       Changes done for Bug 62958 - Postgres : Error is showing to view modified data in workitem history.
//09/08/2016	Mohnish Chopra		Bug 63504 - Postgres : date format should be in format DD/MMM/YYYY in workitem properties
//11/08/2016	Mohnish Chopra		Logging of change in Queue Filter 
//08/09/2016    RishiRam Meel		IsNull and Type added in json object for  attribute logging in setTaskData  API.  
//05/10/2016	Mohnish Chopra		Changes for multiple Arrays in Complex variable
//20/09/2016    RishiRam Meel       Bug 65056  PRDBug 62511/59717 - Support to set the Attributes while creating child workitem through WMCreateChildWorkItem API
//25/10/2016    Mohnish Chopra      Bug 65006 - Data not getting saved from main form to task form even if task variable is mapped to some external variable.
//27/10/2016	Mohnish Chopra		Bug 65137 - Nested Complex array : Single parent mapping id should be sufficient for multiple child mapping field for different child complex arrays
//04/01/2016	Mohnish Chopra		Bug 66548 - Large float values in grids gets converted to Exponential form
//24/01/2017	Mohnish Chopra		Bug 66857 -  All the columns in external table data is updated with the same values while performing Checkin process simultaneously
//16/02/2017	Mohnish Chopra		Bug 67292 - Fragment data not getting saved .Null pointer exception is coming is logs.
//28/07/2015	Sweta Bansal		Bug 56062 - Handling done to use WFUploadWorkitem API for creating workitem in SubProcess(Subprocess/Exit) and to perform operation like: workitem creation in subprocess, Bring ParentWorkitem in flow when child routed to exit, will be performed before CreateWorkitem.
//27/02/2017	RishiRam Meel       PRDP Bug  Merging 67207 - Unable to create workitem on different versions of a process.
//02/03/2017	Mohnish Chopra		Bug 67624 - iBPS 3.0 SP2 : Extra 0 appended in external variable time type in worklist search results
//03/03/2017	Mohnish Chopra		Bug 67742 - iBPS 3.0 SP-2 +Oracle : Search on String queue variable not working
//14/03/2017	Sajid Khan			Bug 67849 - On New Queue Creation, Display Name for ProcessInstanceId needs to be set to Registration No by Default. 
//21/09/2016	Mohnish Chopra		Changes for Upgrade from 10x to iBPS
//	17/03/2017			Sweta Bansal			Changes done for removing support of CurrentRouteLogTable in the system.
//24/03/2017	Mohnish Chopra		Bug 68070 - OF 10.3 SP-2 to iBPS 3.0 Upgrade : Getting error in cabinet upgrade from OFServices
//05/04/2017	Mohnish Chopra		Changes in updateExtDBFeildDefinition for Oracle Upgrade from OF10.3 to iBPS 3.0 PATCH 3
//10/04/2017	Mohnish Chopra		Bug 66857 -  All the columns in external table data is updated with the same values while performing Checkin process simultaneously
//10/04/2017	Rakesh K Saini		Bug 60386 - Set Attribute API fails when called from utilities other than PS.
//17/04/2017	Kumar Kimil		Bug 66718 - Handling of the errorneous cases in the WMCreateWorkItem API to suspend the workitem and also to print the Query execution time to fetch and set queue and external variables
//20/04/2017    Kumar Kimil		Bug 66056-Support to send the Mail Notification when user diversion is set or removed
//21/04/2017    Mohnish Chopra     	Prdp Bug 64446 - Handling to create the childworkitem on multiple activities at the same time with a single CreateChildWorkitem trigger when activity list is coma or semicolon separated and error handling when generate same parent is true   
//01-05-2017    Sajid Khan              Merging Bug 58696-PSID coming for ActionId = 75 as UserName on history page
//01-05-2017    Sajid Khan              Bug 57493 - Audit Log for Mail Initiated is not getting inserted in message table
//02-05-2017 Rakesh K Saini  //01-05-2017    Sajid Khan              Merging Bug 58696-PSID coming for ActionId = 75 as UserName on history page
//01-05-2017    Sajid Khan              Bug 62481 - Variable names are not being displayed in quick search management in 	Omniapp .
//02/05/2017	Mohnish Chopra		Changes for Search Optimization and Postgres
//09-05-2017	Sajid Khan			Queue Varaible Extension Enahncement
//12/05/2017    Sajid Khan       	Bug 69058 - Error in Attribute Details screen
//15/05/2017    Sajid Khan         	Bug 69171 - EAP 6.2 +SQL: Search on Queue with defined alias is not working 
//17/05/2017    Mohnish Chopra  	Changes for Nested Complex array requirement-Updation & Batching
//24/05/2017	Mohnish Chopra		Changes done to fetch data from ExernalTable_History Table for Transfer Data.
//30/05/2016    Kumar Kimil         Bug 64096 - SIT Fixes
//31/05/2017    Kumar Kimil         Bug 63423 - CreateChildWorkitem not creating through create child workitem trigger
//31/05/2017    Sajid Khan              Mergign 69543-Support to generate processinstanceid using WFGenerateRegistration SP in WFCreateProcessInstance API
//06/06/2017	Mohnish Chopra		Bug 69879 - EAP+Postgres: Delete event is not working in listview
//06/06/2017	Mohnish Chopra		Bug 69882 - EAP+Postgres: Functionality of batching/arrow is not working proper in listview
//15/06/2017	Mohnish Chopra		Bug 70110 - WAS+SQL+ibps 2.1.3 upgrade: Nested Array: Last added child row is not showing in child listview
//21/06/2017	Mohnish Chopra		Bug 70117 - Batching is not working proper in CHild listview
//23/06/2017	Mohnish Chopra		Bug 70263 - EAP +Postgres: Same child rows are added for all above master rows of selected row 
//03/07/2017	Ambuj Triapthi		Changes done to support the Calendar Sharing feature in Case Management
//04/07/2017	Shubhankur Manuja	Changes done to support Decline task to be shown in task history and work item history.
//06/07/2017	Ambuj Triapthi		Added hasTaskUpdatePrivileges method to supprt WFReassignTask feature in Case Management
//07/07/2017	Mohnish Chopra		Bug 70509 - Not able to open workitem if primitive arrays is used inside complex data type
//18/07/2017    Kumar Kimil     	Multiple Precondition enhancement
//26/07/2017        Kumar Kimil     Auto-Initiate Task based on Precondition

//01/08/2017        Kumar Kimil     Multiple Precondition(Review Points) 

//31/07/2017	Sajid Khan			Bug 70830 Unable to create a workitem in a subprocess.
//28/07/2017		Ambuj Tripathi  Added the changes for the task expiry feature for Case Management
//08/08/2017		Ambuj Tripathi  Added the changes for the task Escalation feature for Case Management
//11/08/2017	Mohnish Chopra		Changes for Case Summary document generation requirement and Adhoc task approach changes
//16/08/2017		Ambuj Tripathi  Code review points added for the task expiry and task escalation feature for Case Management
//18/08/2017        Ambuj Tripathi  Added the changes related to task reassignment review points (unlocktask) feature for Case Management
//19/08/2017        Kumar Kimil       Process Task Changes(Synchronous and Asynchronous)
//22/08/2017	Mohnish Chopra		Changes for Case Management Requirement(Document to be visible in case when 
//									task is completed) -Changes in completeTask method
//22/08/2017	Sajid Khan			Bug 71038 - Refresh interval of queue not getting<5 
//22/08/2017	Shubhankur Manuja	Bug 71089, 71090 - Null pointer check and special character handling for WFSearchWorkItemList API
//23/08/2017    Ambuj Tripathi  	Bug fixed in itegration server related to task expiry
//04/09/2017	Ambuj Tripathi  	Bug 70680 - Discrepancy in the date time while generating history.
//06/09/2017		Mohnish Chopra	Changes for Adhoc task data saving approach
//06/09/2017        Kumar Kimil             Process task Changes (User Monitored,Synchronous and Asynchronous)
//              Sajid Khan      Common Code Synchronization
//18/09/2017        Kumar Kimil             Color Coding for Rework,escalated,expired taskId(Server changes)
//27/09/2017        Ambuj Tripathi  Logic to Get the Variable Values for getting the Adhoc Task Expiry and Escalation.
//3/10/2017             Kumar Kimil         Bug 72310 - EAP 6.2 +SQL: Getting mandatory error when task is optional
//3/10/2017        	Ambuj Tripathi         Bug 72224 - EAP+SQL: Getting error if save task form
//4/10/2017			Ambuj Tripathi			Added feature for adding the expiry and escalation for adhoc tasks.
//04/10/2017        Kumar Kimil             Changes in Auto-Initiate for Task-Preferences changes
//09/10/2017        Kumar Kimil     TaskPending for Approval should also be checked while marking workitem as "Done"
//10/10/2017        Kumar Kimil     <ActivityType> tag added in OutputXML(Required by WebDesktop for Rendering screen)-Bug 72360 EAP 6.2+SQl:- UI issue screen showing distorted.
//11/10/2017        Kumar Kimil     Bug 72422 - EAP+SQL: Getting error to open some workitems in case Summary View while these are opening properly in pop out window
//18/10/2017        Ambuj Tripathi  Case Registration changes- Added provision to fetch DisplayName from pmweb and insert the urn on create.
//18/10/2017		Sajid Khan		Bug 72681 - Error while executing WMCreateChildWorkitem API if the parent workitem contains apostrpophe(') in WFInsturmentTable
//30/10/2017        Kumar Kimil     Bug 72866 - Task not initiated getting error" The requested filter is invalid." 
//30/10/2017        Kumar Kimil     Bug 72973 - WBL+Oracle: Getting error to register JMS Publisher Utility
//01/11/2017        Ambuj Tripathi  Case registration changes :- Added provision to copy the displayname in case of overwrite process.
//01/11/2017		Mohnish Chopra	Bug 72901 - WBL+Oracle: Search on defined alias is not working for date type queue variable
//06/11/2017		Ambuj Tripathi 	Bug 73225 - Not Getting any output getting error in soap UI"User does not have rights on Introduction Activity - Changed the logic to fetch the mainCode and resultset from wfgenerateregistration sp.
//16/11/2017		Ambuj Tripathi	Bug 73572 - Upgrade from iBPS 3.0 SP-1+WAS+SQL to iBPS 3.2: Getting error in upgrade cabinet
//22/11/2017        Kumar Kimil     Multiple Precondition enhancement
//23/11/2017        Kumar Kimil     Bug 72866 - Task not initiated getting error" The requested filter is invalid."-PostGres
//27/11/2017        Kumar Kimil     Bug 73819 - Retain the existing Adhoc Tasks from old process,when we import process and overwrite existing process
//23/11/2017		Mohnish Chopra	Prdp Bug 71731 - Audit log generation for change/set user preferences
//12/12/2017		AMbuj Tripathi	Bug#74029 On importing a process from an old environment (Alpha release) getting error in 'All tasks' tab- Error in executeRuleCondition method.
//13/12/2017		Ambuj Tripathi	Added URN in generateLog and generateTaskLog methods
//18/12/2017		Ambuj Tripathi	URN Changes for getting the correct action description and o/p of wfgetattributemessage API
//29/12/2017            Kumar Kimil         Bug 74349 - Not able to create adhoc task getting error"The requested operation failed."
//11/01/2018		Ambuj Tripathi	Bug 74240 - Solaries +Oracle+Weblogic:-Not able to initate the task getting error"Error While Saving Task Data."
//12/01/2018		Ambuj Tripathi	Bug 74920 - Arabic ibps 4: Checkin with different version operation giving error message.
//15/01/2018		Ambuj Tripathi	Sonar changes for the rule : Multiline blocks should be enclosed in curly braces
//15/01/2018		Ambuj Tripathi	Bug fix for bug#73014 WBL+Oracle: Getting error message in Picklist of String Type Alias instead of value or relevant message
//17/01/2018		Ambuj Tripathi	QA Showstopper bug resolved for WAS+ORacle
//29/01/2018        Kumar Kimil     Bug 75494 - Arabic:-Task not initiated getting error "The requested operation failed" in case summary window under Task Status.
//29/01/2018		Mohnish Chopra	Bug 75608 - We are able to insert the data in grid with Complex variable but not able to update for 4 level nested complex array inside complex
//30/01/2018        Kumar Kimil     Bug 75281 - jbossEAP+SQL:Process Task Functionality not working .
//16/02/2018		Ambuj Tripathi	Bug 75815 - Enhancement in Case summary document.
//16/02/2018		Ambuj Tripathi	Bug 76141 - Not able to save process as local process getting error "Requested operation failed."
//22/02/2018		Ambuj Tripathi	Bug 75515 - Arabic ibps 4: Validation message is coming in English and that out of colored area 
//26/02/2018		Mohd Faizan		EAP7+sql: User filter is not working for 'Set preferences' audit log option
//26/02/2018        Kumar Kimil     Bug 76215 - Data not getting updated in task details for date variable in i form.
//17/03/2018            Sajid Khan  Merging Bug 76273 - On stop of PS Q_Userid was not getting reset.
//19/03/2018		Ambuj Tripathi	Changes to prevent sending null as string value if there is no value set for a variable.
//22/03/2018		Mohnish Chopra	Bug 76688 - iBPS 3.0 SP1+ORACLE : Not able to search user added in queue in Queue Properties
//20/04/2018        Kumar Kimil     Bug 77228 - Removal of Relation Mapping fields from Update Query of Complex tables in updateData method
//26/04/2018		Sajid Khan		Bug 77375	Requirement to Apply filter on WMFetchAttributesAPI for complex of array data
//07/05/2018		Ambuj Tripathi	Bug 77593 - WMCreateChildWorkItem API is getting failed when called to create child worktem.
//09/05/2018		Mohnish Chopra	Bug 77228 - Removal of Relation Mapping fields from Update Query of Complex tables in updateData method.
//11/05/2018		Ambuj Tripathi	Bug 77170 - EAP6.4+SQL: Filter on user is not getting saved in 'Introduction' type of queue
//28/06/2018		Ambuj Tripathi	Bug Bug 78148 - Assigned task not visible in My task. 
//28/06/2018		Ambuj Tripathi	Bug 77932 - SQL Injection handling for number type variable in WMAssignWorkItemAttributes API
//28/06/2018		Ambuj Tripathi	Helpdesk Development issue - Expiry Utility is throwing error - Error:Operation WMGetNextWorkItem Failed
//05/07/2018		Ambuj Tripathi	Bug 78208 - NOLOCK is missing in WFSessionView, WFUserView and PSRegisterationTable
//13/08/2018	Ambuj Tripathi	Changes for Upgrading the cabinet directly from OD to OD+iBPS.
//05/09/2018		Mohnish Chopra	Bug 80086 - iBPS 4:Provision to call Revoke and Reassign APi's on expiry of task based on some ini. 
//11/09/2018	Mohnish Chopra		Prdp Bug 79373 - Audit log for setAttribute should be generated and shown even when attribute is getting set to null. 
//01/10/2018  	Ambuj Tripathi		Changes related to sharepoint support
//21/11/2018	Ravi Ranjan			Bug 80146 - Task should be deleted if child workitem on case workdesk is deleted through delete on collect functionality 
//21/11/2018		Ravi Ranjan		Bug 80130 - Case visualization showing incorrect if using gateways
//13/12/2018    Ravi Ranjan Kumar  Bug 81935 - Task is not auto inititated when mapped to external variable and contain special character like '@'
//26/12/2018    Ravi Ranjan Kumar  Bug 82091 - Support of view , fetching data from view for complex variable if view is defined otherwise data will fetch from table
//27/12/2018    Shubham Singla     Bug 82143 - iBPS 4.0:When a history table is made for the external table user is not able to fetch external table values.
//02/1/2019			Ambuj Triapthi		Changes related to PMWRequirement of Sections in Proccess Designer.
//03/1/2019     Ravi Ranjan Kumar	Bug 82213 - When Complex Variable contain primitive array and its mapped with external table with column ItemIndex then entering data in primitive variable array only then data should not be saved.
//07/01/2019	Ravi Ranjan Kumar	Bug 82344 - Providing backward compatibility for insertion or deletion of complex data
//08/01/2019	Ravi Ranjan Kumar	Bug 79126 - Issues in variant (SP2 merging)
//23/01/2019	Ravi Ranjan Kumar	Bug 82575 - WM_ATTRIBUTE_ASSIGNMENT_FAILED when updating the value of external table if same variable name exists in complex variable and used in relation mapping with wfinstrumenttable
//25/01/2018	Ravi Ranjan Kumar	Bug 82630 - Requested Operation Failed when registering the process
//29/01/2019	Ravi Ranjan Kumar Bug 82718 - User able to view & search iBps WF system folders .
//04/02/2019    Shubham Singla    Bug 82848 - WMDisconnect is getting called and fixed assigned workitem is getting unlocked which should not be the case.
//01/03/2019    Shubham Singla    Bug 83361 - iBPS4.0: Task is not getting initiated when $ is used in escalated mail message.
//24/04/2019	Mohnish Chopra		Bug 84346 - History of the workitem shows two users are able to simultaneously modify the workitem data.
//30/04/2019      Ravi Ranjan Kumar   PRDP Bug Mergin (Bug 83894 - Support to define explicit History Table for the external table instead of hardcoded '_History')
//5/3/2019			Ravi Ranjan Kumar	Bug 84455 - For shared session for same user , unlocking workitem based on one flag ( UnlockWorkitem)
//22/05/2019	Ambuj Tripathi		Bug 84722 - IBPS 3.0 SP1 : JBossEAP + SQL : Query in generateLog API is taking time to execute and causing slowness
//01/04/2019		Mohnish Chopra		Bug 83717 - Support is required to move/save external variables and complex variables data to Secondary cabinet based on some flag SecondaryDBFlag (edit)
//6/7/2019		Ravi Ranjan Kumar 	Bug 85140 - Enabling to edit workitem (only data and document ) on query workstep if workitem is present 
//13/08/2019	Ravi Ranjan Kumar	Bug 85926 - In Advance Search , searching on queue alias variable is case sensitive (Oracle)
//21/08/2019	Ravi Ranjan Kumar	Bug 86060 - Sub Process: workitem is not getting initated @ child process
//06/09/2019	Ravi Ranjan Kumar	Bug 86460 - Providing support to non-case sensitive search through SetFilter on System variable and alias (Oracle Specific))
//16/09/2019    Sourabh Tantuway    Bug 86685 - iBPS 4.0: User is able to update read-only variables (having no modify rights) using the WMAssignWorkItemAttributes API in custom form.
//26/09/2019	Ambuj Tripathi		Bug 86955	IBPS 4.0 :: Task not getting initiated when the backslash is present in the workitem data.
//27/09/2019    SHubham Singla		Internal Requirement for ExcludeQueuePrefix.
//10/01/2019	Ravi Ranjan Kumar	Bug 86584 - Owner Email Id is not getting saved in process properties.
//25/10/2019		Ambuj Tripathi	Landing page (Criteria Management) Requirement.
//11/11/2019    Shubham Singla      Bug 87985 - iBPS 4.0:Some queries are getting executed without (NOLOCK) statement in it .
//11/112019		Ravi Ranjan 	Bug 87584 - Owner Email Id is not getting saved in properties when user checks out the process and then check in 
//20/11/2019    Pranesh Ramesh      Bug 88412 - iBPS 3.0 SP1 : The workitem searched in 'in-history' is giving error while opening, after running WFTransferData procedure.
//19/11/2019	Ravi Ranjan Kumar	Bug 88378 - Updating first row in complex variable , last row get updated 
//28/11/2019	Ravi Ranjan Kumar	Bug 88535 - Search functionality is not working for ListView/Table.
//11/12/2019	Ambuj Tripathi		Bug 88653 - Not getting output if using system variable with Alias. 
//20/12/2019    Shubham SIngla      Bug 89022 - iBPS 4.0 :Session is getting checked while upgrading the cabinet .
//20/12/2019	Ambuj Tripathi	Changes for DataExchange Functionality
//27/12/2019		Ravi Ranjan Kumar		Bug 89374 - Support for Global Webservice and external method 
//30/12/2019	Ravi Ranjan Kumar	Bug 88802 - On Searching data in a table, batching is getting enable and data is not being displayed.
//02/01/2019	Shahzad Malik		Bug 89626 - Required to reduce fragmentation in UserQueueTable
//27/01/2020	Ravi Ranjan Kumar	Bug 89872 - Unable to delete multiple objects getting Blank error message. 
//02/01/2020        Shubham Singla   Bug 89628 - when "Click here to see modified data" is clicked on workitem hiistory, then "No Data Found" message is getting displayed although values are present in WFAttributeMessageTable .
//29/01/2020	Ambuj Tripathi		Bug 90242 - While giving rights to the queue,getting error"The requested filter is invalid " 
//29/01/2020	Ambuj Tripathi		Bug 89918 - Data Exchange: On Rule Failure, The requested filter invalid is getting displayed in DBExErrCode,DBExErrDesc
//30/01/2020	Ravi Ranjan Kumar	Bug 90310 - Unable to initiate task getting error "Error while saving task data".
//31/01/2020	Ambuj Tripathi		Bug 90425 - Unable to create criteria getting error "The Requested filter is invalid".
//03/02/2020	Ravi Ranjan Kumar	Bug 90412 - Weblogic+ Oracle: After deployment of process, BRT mapping is not getting visible.
//04/02/2020   Sourabh Tantuway     Bug 90530 - iBPS 4.0: Server Down is coming for all utilities as server.xml at default path is being picked instead of the server.xml at relative path for websphere.
//05/02/2020	Shahzad Malik		Bug 90535 - Product query optimization
//13/02/2020   Ravi Raj Mewara      Bug 89872 - Unable to delete multiple objects getting Blank error message.
//14/02/2020	Ambuj Tripathi		Bug 88561 - If any filter field is left blank in criteria, error is shown in landing page 
//24/02/2020	Ravi Ranjan Kumar	Bug 90916 - iBPS 5.0 (Upgarde ) + OmniDocs 10.0 + Jboss-eap-7.1 + Oracle environment with IBPS 4.0 Base version:-Unable to view associated criteria in defined landing view getting error.
//24/02/2020	Ambuj Tripathi		Going to search in external history even if the workitem is present in WFinstrumenttable.(Prod issue in Bank Meshraq).
//18/02/2020   Shubham Singla       Bug 90785 - iBPS 4.0+Oracle+Postgres: Same insertion order is getting created for the workitems if the same complex table is used in two different processes.
//16/04/2020    Chitranshi Nitharia     Bug 91524 - Framework to manage custom utility via ofservices
//21/04/2020		Ravi Ranjan Kumar 	Bug 91844 - Support For Process wise volume id. When User deploying the process, then their workitem folder and document upload or created in the volume which is selected by user at the time of process design
//25/04/2020	Ravi Ranjan Kumar	Bug 92032 - Variable list not opening getting error The requested operation failed. in Process variable mapping window.
//04/05/2020    Sourabh Tantuway    Bug 92140 - iBPS 4.0: CreatedDateTime and CreatedByName is not going in WFInstrumentTable, for the child workitems created by WMCreateChildWorkitem API.
//08/05/2020	Ravi Ranjan Kumar	Bug 92230 - iBPS 5 patch 1+JBOSS +SQL: Unable to deploy process ( created/imported)
//27/05/2020    Shubham Singla      Bug 92421 - iBPS4.0: Task is not getting initiated when $ is used in escalated mail message. 
//08/06/2020	Mohnish Chopra		Internal Bug - Incorrect transaction handling in case of Collecting workitems in Distribute flow.
//11/06/2020    Shubham Singla      Bug 92746 - iBPS 4.0+Oracle:ClassCastException is coming while setting worklist preference. 
//11/06/2020    Ravi Raj Mewara     Bug 92653 - iBPS 4.0 : insertion order Id coming only for first row in WFGetWorkitemDataExt for complex array having more than one row 
//11/06/2020    Ravi Raj Mewara     Bug 92654 - iBPS 4.0 : Applying Check to get BatchInfo only for Complex arrays in setValueInMap()
//08/07/2020    Ravi Raj Mewara     Bug 93203 - iBPS 5.0 : Not able to register process in cabinet of type'R'
//09/07/2020	Mohnish Chopra		Bug 93231 - Validation required in WMAssignWorkItemAttributes API
//14/07/2020	Ravi Ranjan Kumar	Bug 93279 - Advance search on alias variables not working as it shows error on search
//21/07/2020	Ravi Ranjan Kumar	Bug 93535 - Arabic : Filter on queue is not working as invalid values get replaced in filter
//28/07/2020    Sourabh Tantuway    Bug 93790 - iBPS 4.0 : Opening of Queue Property window taking 4 min, if data is present in lacs in WFInstrumenttable and other metadata tables 
//06/08/2020    Ravi Raj Mewara     Bug 93752 - Batching is not working on Table, ListView and Advanced Listiview under Fragment.
//06/08/2020    Ravi Raj Mewara     Bug 93718 - Searching is not working on Table,Listiview and Advacned Listview under fragment.
//12/08/2020    Ashutosh Pandey     Bug 94054 - Optimization in Message Agent
//07/09/2020    Ravi Raj Mewara     Bug 94417 - iBPS 4.0 SP1 : When loading WI with data on demand feature ignorable error is printing
//02/11/2020    Shubham Singla      Bug 95273 - Bypass process validation done during process checkin
//03/11/2020   	Satyanarayan Sharma		Internal bug-Workitems should not get unlock in postdisconnect and wfdisconnect api for S type user  
//12/01/2021        chitranshi nitharia    Added changes for upload error handling.
//29/01/2021    Sourabh Tantuway    Bug 97523 - iBPS 4.0 : NOLOCK is missing in query on WFInstrumenttable in generateLog method  
//12/02/2021    Sourabh Tantuway  Bug 98029 - iBPS 5.0 SP1 : Hold workitems at activity hold are not getting unlocked when user session ends or user logs out.
//13/04/2021    Shubham Singla    Bug 99093 - iBPS 4.0: Auditing for deletion of complex variable rows or any of it's child is not coming in workitem history. 
//21/05/2021    Shubham Singla    Bug 99454 - iBPS 5.0 SP1:Requirement to do Multilevel Diversion .
//26/05/2021    Sourabh Tantuway  Bug 99545 - iBPS 4.0 SP1: Requirement for avoiding unlocking of workitem assigned to user on FIFO queue, when user session ends.
//28/06/2021    Shubham Singla    Bug 99893 - iBPS 4.0 :Unnecessary logs are getting printed in ofserver error logs.
// 28/06/2021	Aqsa hashmi		Bug 100024 - WorkflowReport tag is not required in WFAppConfigParam.xml as it is no more used by BAM
//06/07/2021   Satyanarayan Sharma  Bug100162- iBPS4.0SP1Patch2- Issue coming in convertion of USERPREFERENCESTABLE data from OmniDocs to iBPS while cabinate upgrade.
//16/06/2021    Ravi Raj Mewara   Bug 99693 - Hotfix"iBPS_4.0_SP1_02_034":Under Listview and Table control searching not working with column name. 
//08/07/2021    Ravi Raj Mewara   Bug 100207 - iBPS 5.0 SP1 : Handling of special characters in value of Queuedata in WFSearchWorkitems was missing
//14/07/2021    Ravi Raj Mewara   Bug 100277 - Searching workitem for BLANK values in Advance search and Criteria management.
//19/07/2020    Sourabh Tantuway  Bug 99401 - iBPS 5.0 SP2 : Need to remove license key check for registration of Process Server.
//11/08/2021    Shubham Singla    Bug 99812 - iBPS 5.0 SP1 :AssociatedDateTime value is not getting saved in WFCurrentRouteLogtable .
//01/09/2021 Satyanarayan Sharma   Bug 100973 - iBPS5.0SP2-When prefix is null in workitem name then hyphen Required in processInstanceId or not.
//19/10/2021	Vardaan Arora		Bug 102127 - In User list or Group List ,Only those Users should be fetched whose parent group is same as that of logged in user.
//25/10/2021    Ravi Raj Mewara    Bug 101835 - iBPS 5.0 SP1 : Duplicate entries are going in SUMMARYTABLE for actionID 27
//11/02/2022	Vardaan Arora		Code optimisation for process server so that it does not retrieve data of complex variables in WMGetNextWorkItem call
//24/02/2022    Ashutosh Pandey     Bug 105376 - Support for sorting on complex array primitive member
//24/02/2022   Satyanarayan Sharma  Bug 105870 - iBPS_5.0_SP2-Getting error maximum open cursors exceeded while cabinate upgrade.
//13/03/2022   Satyanarayan Sharma  Bug 106673 - iBPS5.0SP1-Incorrect syntax error coming when using query filter and filter condition returning multiple records.
//24/03/2022 	Rishabh Jain 		Support of addition of documentype in the registered process
//07/07/2022			Aqsa Hashmi			Bug 111643 - Gaps in system queue error for checkin checkout.
//24/09/2022	Shubham Srivastava    Bug 116143 - iBPS5.0SP3--Support provided for pagination in Search functionality.
//20/10/2022	Shubham Srivastava   Bug 116725 - Support provided for Criteria Searching on WorkitemState. 
//27/04/2023	Vaishali Jain	Bug 124910 - iBPS5 - CQRN-0000251289 - Email Initiation Agent issue (Handling in create child WI api to copy the data of Introduceby, IntroducebyId, IntroductiondateTime, CreationDateTime columns)
//----------------------------------------------------------------------------------------------------
package com.newgen.omni.jts.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.RandomAccessFile;
import java.io.Reader;
import java.io.StringReader;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.security.SecureRandom;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.Stack;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


import javax.naming.InitialContext;
import javax.sql.DataSource;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.apache.commons.collections.map.MultiValueMap;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang.StringEscapeUtils;
import org.json.JSONException;
import org.json.JSONObject;
import org.json.XML;
import org.postgresql.largeobject.LargeObject;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;


import com.newgen.commonlogger.NGUserAPIConfig;
import com.newgen.commonlogger.NGUtil;
import com.newgen.omni.jts.admin.CabinetCreation.GetNoOfUsersLic;
import com.newgen.omni.jts.cache.CachedActionObject;
import com.newgen.omni.jts.cache.CachedObjectCollection;
import com.newgen.omni.jts.cmgr.NGXmlList;
import com.newgen.omni.jts.cmgr.XMLGenerator;
import com.newgen.omni.jts.cmgr.XMLParser;
import com.newgen.omni.jts.constt.JTSConstant;
import com.newgen.omni.jts.constt.WFSConstant;
import com.newgen.omni.jts.dataObject.WFAdminLogValue;
import com.newgen.omni.jts.dataObject.WFAttributedef;
import com.newgen.omni.jts.dataObject.WFCalAssocData;
import com.newgen.omni.jts.dataObject.WFFieldInfo;
import com.newgen.omni.jts.dataObject.WFFieldValue;
import com.newgen.omni.jts.dataObject.WFRelationInfo;
import com.newgen.omni.jts.dataObject.WFReportInfo;
import com.newgen.omni.jts.dataObject.WFRuleInfo;
import com.newgen.omni.jts.dataObject.WFUserInfo;
import com.newgen.omni.jts.dataObject.WFVariabledef;
import com.newgen.omni.jts.dataObject.WMAttribute;
import com.newgen.omni.jts.excp.JTSError;
import com.newgen.omni.jts.excp.JTSException;
import com.newgen.omni.jts.excp.JTSSQLError;
import com.newgen.omni.jts.excp.WFSError;
import com.newgen.omni.jts.excp.WFSErrorMsg;
import com.newgen.omni.jts.excp.WFSException;
import com.newgen.omni.jts.security.EncodeImage;
import com.newgen.omni.jts.security.JTSSecurity;
import com.newgen.omni.jts.srvr.DatabaseTransactionServer;
import com.newgen.omni.jts.srvr.NGDBConnection;
import com.newgen.omni.jts.srvr.ServerProperty;
import com.newgen.omni.jts.srvr.WFFindClass;
import com.newgen.omni.jts.srvr.WFServerProperty;
import com.newgen.omni.jts.txn.LargeObjectInterface;
import com.newgen.omni.jts.txn.wapi.WFParticipant;
import com.newgen.omni.jts.util.dx.WFAttribute;
import com.newgen.omni.jts.util.dx.WFDBOperation;
import com.newgen.omni.jts.util.dx.WFDataExchangeActivity;
import com.newgen.omni.jts.util.dx.WFMappedColumn;
import com.newgen.omni.jts.util.dx.WFRule;
import com.newgen.omni.jts.util.dx.WFWorkitem;
import com.newgen.omni.util.cal.WFCalUtil;
import com.newgen.omni.wf.util.app.NGEjbClient;
import com.newgen.omni.wf.util.cache.WFServiceStatusCache;
import com.newgen.omni.wf.util.constant.WFConstants;
import com.newgen.omni.wf.util.data.Location;
import com.newgen.omni.wf.util.misc.Utility;
import com.newgen.omni.wf.util.misc.WFConfigLocator;
import com.newgen.omni.wf.wfdms.WFDMSImpl;
public class WFSUtil {
    static final long ONE_HOUR = 60 * 60 * 1000L;
    private static WFConfigLocator configLocator;
	private static char char21;
	private static String string21;
	private static char char25;
	private static String string25;
	private static XMLParser parserTemp= null;
	private static HashMap locale_process_Map = new HashMap();
	private static Map dataSourceMap = new HashMap();
        private static String sVarVal = "N";
        private static Boolean tarHistoryLog = null;
        private static String targetCabineName = null;
	public static HashMap getLocale_process_Map() {
        return locale_process_Map;
    }

    public static void setLocale_process_Map(HashMap aLocale_process_Map) {
        locale_process_Map = aLocale_process_Map;
    }

    static {
		try {
            new DatabaseTransactionServer().init();
        } catch (Exception exc) {
        }
        Hashtable hCabinetList = ServerProperty.getReference().getCabinetList();
        configLocator = WFConfigLocator.getInstance();
        // WFLogger.initialize(configLocator.getPath("Omniflow_Logs_Config_Location") + WFSConstant.CONST_DIRECTORY_LOG, configLocator.getPath("Omniflow_Config_Location") + WFSConstant.CONST_DIRECTORY_CONFIG + File.separator + WFSConstant.CONST_FILE_LOG4J, hCabinetList);
		char21 = 21;
		string21 = "" + char21;
		char25 = 25;
		string25 = "" + char25;
    
    }
    
    public static String upgradeOmnidocsCabinetToIBPS(Connection con) throws Exception
    {
    	Statement stmt = null;
   	 	String strConfigFileName = configLocator.getPath(Location.IBPS_CONFIG) + WFSConstant.CONST_DIRECTORY_CONFIG + File.separator + WFSConstant.CONST_FILE_WFAPPCONFIGPARAM;
   	 	parserTemp = new XMLParser(WFSUtil.readFile(strConfigFileName));
        String upgradePathForOmnidocscabinet = parserTemp.getValueOf("UpgradePathForOmnidocsCabinet");
        try{     
       	    stmt = con.createStatement();
			executeMiscellaneous(stmt, upgradePathForOmnidocscabinet);
		}finally{
			if (stmt != null) {
				try {
					stmt.close();
		        } catch (SQLException ignored) {
		        }
		        stmt = null;
		    }
		}
        return "";
    }
    
    public static void executeMiscellaneous(Statement stmt, String procedurepath) throws Exception
    {
       WFFileLoader fld = new WFFileLoader(procedurepath);
       boolean load = fld.loadFiles(procedurepath);
       if(load)
       compile1(fld, stmt, procedurepath, "0-All", false, "~");
    }
     
     private static void compile1(WFFileLoader fld, Statement stmt, String procedurePath, String counter, boolean decrypt, String delimiter) throws Exception{
         int startProcId = 0;
         int endProceId = 0;
         StringTokenizer st = new StringTokenizer(counter, "-");
         startProcId = Integer.parseInt(st.nextToken().trim());
         String endProc = st.nextToken();
         st = null;
         if(endProc.equalsIgnoreCase("All")){
             endProceId = fld.getMaxProcedureId() - 1;
         }else{
             endProceId = Integer.parseInt(endProc);
         }
         String strQuery = null;
         for(; startProcId <= endProceId; startProcId++){
             strQuery = fld.getProcedure(startProcId, procedurePath, decrypt);
             printOut("", strQuery);
             if(strQuery.indexOf(delimiter) > -1){
                 executeScript1(strQuery, stmt, delimiter);
             }else{
            	 strQuery=WFSUtil.TO_SANITIZE_STRING(strQuery, true);
                 stmt.execute(strQuery.trim());
             }
             strQuery = null;
         }
     }
     
     static void executeScript1(String strQuery, Statement stmt, String delimiter) throws Exception{
 		StringTokenizer st = new StringTokenizer(strQuery, delimiter);
 		String query = null;
 		while(st.hasMoreTokens()){
			query = st.nextToken().trim();
			query=WFSUtil.TO_SANITIZE_STRING(query, true);
			if (query != null && query.trim().length() > 0){
				stmt.execute(query);
				//System.out.println("query"+ query);
			}
 		}
     }

//----------------------------------------------------------------------------------------------------
//	Function Name 				:	getFilter
//	Date Written (DD/MM/YYYY)	:	16/05/2002
//	Author						:	Prashant
//	Input Parameters			:	XMLParser , Connection
//	Output Parameters			:   none
//	Return Values				:	String
//	Description					:   parses the i/p XML to return the required Filter Criteria
//----------------------------------------------------------------------------------------------------
    public static String getFilter(XMLParser parser, Connection con) throws JTSException {
        StringBuffer outputXml = new StringBuffer(100);
        String tempStr = "";
        String engine = parser.getValueOf("EngineName");
        int dbType = ServerProperty.getReference().getDBType(parser.getValueOf("EngineName"));
        int type = parser.getIntOf("Type", 0, true) - 256;
        if (type == -256) {
            return "";
        }
        String attribute = parser.getValueOf("AttributeName", "", true);
		

        String query = "";
        Statement stmt = null;
        ResultSet rs = null;
        try {
            if (!attribute.equals("")) {
                stmt = con.createStatement();
                query = "Select SystemDefinedName from VarMappingTable " + WFSUtil.getTableLockHintStr(dbType) + "  where " + TO_STRING("UserDefinedName", false, dbType) + " = " + TO_STRING(TO_STRING(attribute, true, dbType), false, dbType);
                rs = stmt.executeQuery(query);
                if (rs.next()) {
                    attribute = rs.getString(1);
                }
                rs.close();
                stmt.close();
            }
        } catch (Exception e) {
            printErr(engine,"", e);
        } finally {
            // WFS_6_004, Statement closed in finally.
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (SQLException sqle) {
            }
            try {
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
            } catch (Exception ignored) {
            }
        }
        outputXml.append(" AND ");
        int op = parser.getIntOf("Comparison", 0, false);
        switch (type) {
            case WFSConstant.WF_STR:
            case WFSConstant.WF_BOOLEAN: {
                outputXml.append(TO_STRING(attribute, false, dbType));
                outputXml.append(getOperator(op));
                if (op != 9 && op != 10) {
                    outputXml.append(TO_STRING(parser.getValueOf("FilterString", "", false).toUpperCase(), true,
                            dbType));
                }
                break;
            }
            case WFSConstant.WF_SHORT_DAT:
            case WFSConstant.WF_TIME: {
                outputXml.append(attribute);
                outputXml.append(getOperator(op));
                if (op != 9 && op != 10) {
                    outputXml.append(TO_SQL(parser.getValueOf("FilterString", "", false), type, dbType, true));
                }
                break;
            }
            case WFSConstant.WF_DAT: {
                outputXml.append(attribute);
                outputXml.append(getOperator(op));
                if (op != 9 && op != 10) {
                    outputXml.append(TO_DATE(parser.getValueOf("FilterString", "", false), true, dbType));
                }
                break;
            }
            case WFSConstant.WF_INT: {
                outputXml.append(attribute);
                outputXml.append(getOperator(op));
                if (op != 9 && op != 10) {
                    outputXml.append(TO_NUMBER(parser.getValueOf("FilterString", "", false), true,
                            dbType));
                }
                break;
            }
            case WFSConstant.WF_SQL - 256: {
                tempStr = parser.getValueOf("FilterString", "", true);
                if (tempStr != null && !tempStr.equals("")) {
                    outputXml.append(tempStr);
                } else {
                    return "";
                }
                break;
            }
            default: {
                outputXml.append(attribute);
                outputXml.append(getOperator(parser.getIntOf("Comparison", 0, false)));
                outputXml.append(parser.getValueOf("FilterString", "", false));
            }
        }
        return WFSUtil.TO_SANITIZE_STRING(outputXml.toString(),true);
    }
    
    
     public static int getDivert(Connection con, int tuserId, int duserId, int dbType, String to, String from) {
	       Statement stmt = null;
	        ResultSet rs = null;
	        int targetUser = 0;
	        try {
	            /*stmt = con.createStatement();

	            rs = stmt.executeQuery(
	                    "Select AssignedUserIndex from UserDiversionTable where DivertedUserIndex = " + tuserId);
	            if (rs.next()) {
	                targetUser = rs.getInt(1);
	                rs.close();
	                stmt.close();
	                if(targetUser > 0)
	                    targetUser = -1;
	               	return targetUser;
	            }
	            
	            rs.close();
	            stmt.close();
	            stmt = con.createStatement();
				rs = stmt.executeQuery(
	                    "Select DivertedUserIndex from UserDiversionTable where AssignedUserIndex = " + duserId);
	            if (rs.next()) {
	                targetUser = rs.getInt(1);
	                rs.close();
	                stmt.close();
	                if(targetUser > 0){
	                    targetUser = -2;
	                }
	               	return targetUser;
	            }
	            
	                rs.close();
	            
	            stmt.close();
	            stmt = null;*/
	        	while(true){
	        		stmt = con.createStatement();
	        		rs = stmt.executeQuery( "Select AssignedUserIndex from UserDiversionTable where DivertedUserIndex = " + tuserId+" and todate <=" +to+ " and fromdate >= "+ from);

	        		if (rs.next()) {
	        			targetUser = rs.getInt(1);
	        			if(targetUser==duserId)
	        			{
	        				//System.out.println("We cannot set this diversion");
	        				rs.close();
	        				stmt.close();
	        				targetUser = -2;
	        				return targetUser;
	        			}
	        			tuserId=targetUser;
	        			rs.close();
	        			stmt.close();   	
	        		}
	        		else
	        		{
	        			rs.close();
	        			stmt.close();
	        			break;
	        		}
	        	}
	        } catch (Exception e) {
	        } finally {
	        	try {
	                if (rs != null) {
	                    rs.close();
	                    rs=null;
	                }
	            } catch (SQLException ex) {
	            }
	            try {
	                if (stmt != null) {
	                    stmt.close();
	                }
	            } catch (SQLException ex) {
	            }
	        }

	        return tuserId;
	    }

//----------------------------------------------------------------------------------------------------
//	Function Name 				:	getBatch
//	Date Written (DD/MM/YYYY)	:	16/05/2002
//	Author						:	Prashant
//	Input Parameters			:	XMLParser , FirstOrder , type1 , SecondOrder , type2
//	Output Parameters			:   none
//	Return Values				:	String
//	Description					:   returns the SQL String required for batching on the basis of Columns FirstOrder and SecondOrder
//----------------------------------------------------------------------------------------------------
    public static String getBatch(XMLParser parser, String FirstOrder, int type1,
            String SecondOrder,
            int type2) throws JTSException {
        boolean batch = false;
        StringBuffer outputXml = new StringBuffer(100);
        int dbType = ServerProperty.getReference().getDBType(parser.getValueOf("EngineName"));
        String firstOrderValue = "";
        String secondOrderValue = "";
        String orderBy = "";

        if ((FirstOrder == null || FirstOrder.equals("")) && SecondOrder != null && !SecondOrder.equals("")) {
            secondOrderValue = parser.getValueOf("LastValue");
            orderBy = " ORDER BY " + TO_SQL(SecondOrder, type2, dbType, false) + " ASC ";
        } else if (FirstOrder != null && !FirstOrder.equals("") && SecondOrder != null && !SecondOrder.equals("")) {
            orderBy = " ORDER BY " + TO_SQL(FirstOrder, type1,
                    dbType, false) + " DESC " + "," +
                    TO_SQL(SecondOrder, type2, dbType, false) + " ASC";
            firstOrderValue = parser.getValueOf("Priority");
            secondOrderValue = parser.getValueOf("LastValue");
        }

        if (firstOrderValue != null && secondOrderValue != null && !(firstOrderValue.equals("") && secondOrderValue.equals(""))) {
            batch = true;

        }
        if (batch) {
            outputXml.append(" AND ( ");

        }
        if (firstOrderValue != null && !firstOrderValue.equals("") && FirstOrder != null && !FirstOrder.equals("")) {
            outputXml.append(TO_SQL(FirstOrder, type1, dbType, false));
            if (secondOrderValue != null && !secondOrderValue.equals("") && SecondOrder != null && !SecondOrder.equals("")) {
                outputXml.append(" = ");
                outputXml.append(TO_SQL(firstOrderValue, type1, dbType, true));
                outputXml.append(" AND  ");
                outputXml.append(TO_SQL(SecondOrder, type2, dbType, false));
                outputXml.append(" > ");
                outputXml.append(TO_SQL(secondOrderValue, type2, dbType, true));
                outputXml.append(" OR ");
                outputXml.append(TO_SQL(FirstOrder, type1, dbType, false));
            }
            outputXml.append(" < ");
            outputXml.append(TO_SQL(firstOrderValue, type1, dbType, true));
        } else if (secondOrderValue != null && !secondOrderValue.equals("") && SecondOrder != null && !SecondOrder.equals("")) {
            outputXml.append(TO_SQL(SecondOrder, type2, dbType, false));
            outputXml.append(" > ");
            outputXml.append(TO_SQL(secondOrderValue, type2, dbType, true));
        }
        if (batch) {
            outputXml.append(" ) ");
        }
        outputXml.append(orderBy);
        return outputXml.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 				:	TO_STRING
//	Date Written (DD/MM/YYYY)	:	16/05/2002
//	Author						:	Prashant
//	Input Parameters			:	String in , boolean isConst, int dbType
//	Output Parameters			:   none
//	Return Values				:	String
//	Description					:   returns the SQL representation of the given value on the basis of the Database Type
//----------------------------------------------------------------------------------------------------
    public static String TO_STRING(String in, boolean isConst, int dbType) {
        StringBuffer outputXml = new StringBuffer(100);
        if (in == null || in.equals("")) {
            outputXml.append(" NULL ");
        } else {
            switch (dbType) {
                case JTSConstant.JTS_MSSQL: {
                    /** Bugzilla Bug 1241, 1242, Refer ReAssign not working in MSSQL 2005 + Japanese N'XXX's MyQueue'
                     * does not work in MSSQL2005 (other than English, case reported for Japanese) - Ruhi Hira */
                    /** Bugzilla Bug 1705, startsWith, endsWith removed. - Ruhi Hira */
                    if (isConst) {
                        outputXml.append(WFSConstant.WF_VARCHARPREFIX);
                        outputXml.append(replace(in, "'", "' + char(39) + N'"));
                        outputXml.append("'");
                    } else {
                        outputXml.append(replace(in, "'", "''"));
                    }
                    break;
                }
                case JTSConstant.JTS_ORACLE: {
                    if (isConst) {
                        outputXml.append(WFSConstant.WF_VARCHARPREFIX);
                        outputXml.append(replace(in, "'", "''"));
                        outputXml.append("'");
                    } else {
                        outputXml.append("UPPER(RTRIM(");
                        outputXml.append(replace(in, "'", "''"));
                        outputXml.append(") )");
                    }
                    break;
                }
                case JTSConstant.JTS_POSTGRES: {
                    if (isConst) {
                        //outputXml.append(WFSConstant.WF_VARCHARPREFIX);
                        outputXml.append("'");
                        outputXml.append(replace(in, "'", "''"));
                        outputXml.append("'");
                    //outputXml.append(" :: VARCHAR ");
                    } else {
                        outputXml.append("UPPER( ");
                        outputXml.append(replace(in, "'", "''"));
                        outputXml.append(" )");
                    }
                    break;
                }
                case JTSConstant.JTS_DB2: {
                    /** Bugzilla Id 68, Aug 16th 2006, N'XXX's MyQueue' does not work - Ruhi Hira */
                    if (isConst) {
                        outputXml.append(WFSConstant.WF_VARCHARPREFIX);
                        outputXml.append(replace(in, "'", "' || chr(39) || '"));
                        outputXml.append("'");
                    } else {
                        outputXml.append("UPPER(RTRIM(");
                        outputXml.append(replace(in, "'", "''"));
                        outputXml.append(") )");
                    }
                    break;
                }
            }
        } 
        	if(isConst)
        	{
        		return outputXml.toString();
        	}
        	else
        	{
        		return outputXml.toString().replaceAll("''", "'");
        	}
    }
    
  //----------------------------------------------------------------------------------------------------
//	Function Name 				:	TO_SANITIZE_STRING
//	Date Written (DD/MM/YYYY)	:	11/04/2018
//	Author						:	Mohd Faizan
//	Input Parameters			:	String in , boolean isString
//	Output Parameters			:   none
//	Return Values				:	String
//	Description					:   returns the sanitize string
//----------------------------------------------------------------------------------------------------
    
	public static String TO_SANITIZE_STRING(String in, boolean isQuery)  {
		
		
		  if (in == null) {
	            return null;
	        }
	        if (!isQuery) {
	            return in.replaceAll("'", "''");
	        } else {
	            String newStr = in.replaceAll("'", "''");

	 

	            return newStr.replaceAll("''", "'");
	        }

	    
	}
	
	 public static String TO_STRING_WITHOUT_RTRIM(String in, boolean isConst, int dbType) {
	        StringBuffer outputXml = new StringBuffer(100);
	        if (in == null || in.equals("")) {
	            outputXml.append(" NULL ");
	        } else {
				if(dbType == JTSConstant.JTS_ORACLE){
					 if (isConst) {
	                        outputXml.append(WFSConstant.WF_VARCHARPREFIX);
	                        outputXml.append(replace(in, "'", "''"));
	                        outputXml.append("'");
	                    } else {
	                        outputXml.append("UPPER( ");
	                        outputXml.append(in);
	                        outputXml.append("  )");
	                    }
				}else{	
					return TO_STRING(in,isConst,dbType).toString();
				}
	        }
	        return outputXml.toString();
	    }
	 
	 
	 /**
	     * *******************************************************************************
	     *                  Function Name       : escapeDN
	     *                  Date Written        : 09/04/2018
	     *                  Author              : Mohd Faizan
	     *                  Input Parameters    : String - commandType
	     *                  Output Parameters   : none
	     *                  Return Values       : String 
	     *                  Description         : escape characters to avoid LDAP injection
	     *                                          
	     * *******************************************************************************
	     */
	    
	    public static String escapeDN(String name) {
	        StringBuffer sb = new StringBuffer(); 
	        if ((name.length() > 0) && ((name.charAt(0) == ' ') || (name.charAt(0) == '#'))) {
	            sb.append('\\'); 
	        }
	        for (int i = 0; i < name.length(); i++) {
	            char curChar = name.charAt(i);
	            switch (curChar) {
	                case '\\':
	                    sb.append("\\\\");
	                    break;
	                case ',':
	                    sb.append("\\,");
	                    break;
	                case '+':
	                    sb.append("\\+");
	                    break;
	                case '"':
	                    sb.append("\\\"");
	                    break;
	                case '<':
	                    sb.append("\\<");
	                    break;
	                case '>':
	                    sb.append("\\>");
	                    break;
	                case ';':
	                    sb.append("\\;");
	                    break;
	                default:
	                    sb.append(curChar);
	            }
	        }
	        if ((name.length() > 1) && (name.charAt(name.length() - 1) == ' ')) {
	            sb.insert(sb.length() - 1, '\\'); // add the trailing backslash if needed
	        }
	        return sb.toString();
	    }
	    
    //----------------------------------------------------------------------------------------------------
//	Function Name 				:	TO_UpdateData
//	Date Written (DD/MM/YYYY)	:	23/01/2014
//	Author						:	Shweta Singhal
//	Input Parameters			:	String in , boolean isConst, int dbType
//	Output Parameters			:   none
//	Return Values				:	String
//	Description					:   returns the SQL representation of the given value on the basis of the Database Type called from updateDate()
//----------------------------------------------------------------------------------------------------
    public static String TO_UpdateData(String in, boolean isConst, int dbType) {
        StringBuffer outputXml = new StringBuffer(100);
        if (in == null || in.equals("")) {
            outputXml.append(" NULL ");
        } else {
            switch (dbType) {
                case JTSConstant.JTS_MSSQL: {
                    if (!isConst) 
                        outputXml.append(in);
                   break;
                }
                case JTSConstant.JTS_ORACLE: {
                    if (!isConst) {
                        outputXml.append("UPPER(");
                        outputXml.append(in);
                        outputXml.append(") ");
                    }
                    break;
                }
                case JTSConstant.JTS_POSTGRES: {
                    if (!isConst) {
                        outputXml.append("UPPER(");
                        outputXml.append(in);
                        outputXml.append(")");
                    }
                    break;
                }
                case JTSConstant.JTS_DB2: {//
                    /** Bugzilla Id 68, Aug 16th 2006, N'XXX's MyQueue' does not work - Ruhi Hira */
                    if (!isConst) {
                        outputXml.append("UPPER(");
                        outputXml.append(in);
                        outputXml.append(") ");
                    }
                    break;
                }
            }
        }
        return outputXml.toString();
    }
//----------------------------------------------------------------------------------------------------
//	Function Name 				:	TO_DATE
//	Date Written (DD/MM/YYYY)	:	16/05/2002
//	Author						:	Prashant
//	Input Parameters			:	String in , boolean isConst, int dbType
//	Output Parameters			:   none
//	Return Values				:	String
//	Description					:   returns the SQL Date representation of the given value on the basis of the Database Type
//----------------------------------------------------------------------------------------------------
    public static String TO_DATE(String in, boolean isConst, int dbType) throws WFSException{
        StringBuffer outputXml = new StringBuffer(100);
		String tempDate = null;
        if (in == null || in.equals("")) {
            outputXml.append(" NULL ");
        } else {
			/*Check if date is valid using reg ex*/
			tempDate = (in.indexOf(".") > 0 ? in.substring(0, in.indexOf(".")) : in);
			if (!checkSQLInjectionInDate(tempDate, isConst)) {
				int mainCode = WFSError.WF_OPERATION_FAILED;
				int subCode = WFSError.WFS_ILP;	//Invalid parameter
				String subject = WFSErrorMsg.getMessage(mainCode);
				String errType = WFSError.WF_TMP;
				String descr = WFSErrorMsg.getMessage(subCode);
					throw new WFSException(mainCode, subCode, errType, subject, descr);
			}
            switch (dbType) {
                case JTSConstant.JTS_MSSQL: {
                    outputXml.append("CONVERT( DateTime , ");
                    if (isConst) {
                        outputXml.append("'");
                    }
                    outputXml.append(in);
                    if (isConst) {
                        outputXml.append("'");
                    }
                    outputXml.append(") ");
                    break;
                }
                case JTSConstant.JTS_ORACLE: {
                    outputXml.append(" TO_DATE( ");
                    if (isConst) {
                        outputXml.append("'");
                        outputXml.append(tempDate);
                        outputXml.append("'");
                    } else {
                        outputXml.append(in);
                    }
                    outputXml.append("," + WFSConstant.WF_DATEFMT + ") ");
                    break;
                }
                case JTSConstant.JTS_POSTGRES: {
                    outputXml.append("CAST( ");
                    if (isConst) {
                        outputXml.append("'");
                    }
                    outputXml.append(in);
                    if (isConst) {
                        outputXml.append("'");
                    }
                    outputXml.append(" AS TIMESTAMP) ");
                    break;
                }
                case JTSConstant.JTS_DB2: {					// Coded for DB2 - Virochan

                    outputXml.append("TIMESTAMP_FORMAT(");
                    if (isConst) {
                        /** Bugzilla Id 119, Constant handled differently
                         * 29/08/2006 - Ruhi Hira */
                        outputXml.append("'");
                        in = in.trim();
                        if (in.length() <= 10) {
                            outputXml.append(in);
                            outputXml.append(" 00:00:00");
                        } else if (in.length() <= 19) {
                            outputXml.append(in);
                        } else {
                            /** Bugzilla Id 75, DB2 function does not support nano second part
                             * 21/08/2006 - Ruhi Hira
                             * */
                            outputXml.append(in.substring(0, 19));
                        }
                        outputXml.append("'");
                    } else {
                        outputXml.append(in);
                    }
                    outputXml.append("," + WFSConstant.WF_DATEFMT + ") ");
                    break;
                }
            }
        }
        return WFSUtil.TO_SANITIZE_STRING(outputXml.toString(),true);
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 				:	TO_SHORT_DATE
//	Date Written (DD/MM/YYYY)	:	29/03/2005
//	Author						:	Ashish Mangla
//	Input Parameters			:	String in , boolean isConst, int dbType
//	Output Parameters			:   none
//	Return Values				:	String
//	Description					:   returns the short SQL Date representation of the given value on the basis of the Database Type
//----------------------------------------------------------------------------------------------------
    public static String TO_SHORT_DATE(String in, boolean isConst, int dbType) throws WFSException{
        String sDateTimeRepresentation = "";
        StringBuffer outputXml = new StringBuffer(100);
        if (in == null || in.equals("")) {
            outputXml.append(" NULL ");
        } else {
            if (isConst) {
                in = TO_DATE(in, isConst, dbType);
            }

            switch (dbType) {
                //First we will convert the string representation to YYYY-MM-DD , then find the short date
                case JTSConstant.JTS_MSSQL: {
                    outputXml.append("LEFT(CONVERT( Varchar , ");
                    outputXml.append(in);
                    outputXml.append(" , 20), 10) ");
                    break;
                }
                case JTSConstant.JTS_ORACLE: {
					outputXml.append(" TO_DATE( ");  /* Bug 38558 */
					outputXml.append(" TO_CHAR( ");
                    outputXml.append(in);
                    outputXml.append(" ," + WFSConstant.WF_SHORT_DATEFMT + ") ");
					outputXml.append(" ," + WFSConstant.WF_SHORT_DATEFMT + ") ");
                    break;
                }
                case JTSConstant.JTS_DB2: {				// Coded for DB2 - Virochan

                    outputXml.append(" WF_TS_FMT( ");
                    outputXml.append(in);
                    outputXml.append("," + WFSConstant.WF_SHORT_DATEFMT + ") ");
                    break;
                }
                case JTSConstant.JTS_POSTGRES: {
                    outputXml.append("CAST( ");
                    outputXml.append(in);
                    outputXml.append(" AS DATE) ");
                    break;
                }
                default: {
                    outputXml.append("LEFT(CONVERT( Varchar , ");
                    outputXml.append(in);
                    outputXml.append(" , 20), 10) ");
                    break;
                }
            }
        }
        return outputXml.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 				:	TO_NUMBER
//	Date Written (DD/MM/YYYY)	:	16/05/2002
//	Author						:	Prashant
//	Input Parameters			:	String in , boolean isConst, int dbType
//	Output Parameters			:   none
//	Return Values				:	String
//	Description					:   returns the SQL NUMBER representation of the given value on the basis of the Database Type
//----------------------------------------------------------------------------------------------------
    public static String TO_NUMBER(String in, boolean isConst, int dbType) {
        StringBuffer outputXml = new StringBuffer(100);
        /** 09/07/2008, Bugzilla Bug 5493, null handlled beside "" - Ruhi Hira */
        if (in == null || in.equals("")) {
            outputXml.append(" NULL ");
        } else {
            if (isConst && !(Pattern.matches("\\d+", in) || Pattern.matches("-\\d+", in) || Pattern.matches("\\d*\\.\\d+", in) || Pattern.matches("-\\d*\\.\\d+", in))) {
                throw new RuntimeException("Invalid input number : " + in);
            }
            switch (dbType) {
                case JTSConstant.JTS_MSSQL: {
                    outputXml.append(in);
                    break;
                }
                case JTSConstant.JTS_ORACLE: {
                    outputXml.append(in);
                    break;
                }
                case JTSConstant.JTS_POSTGRES: {
                    outputXml.append(in);
                    break;
                }
                case JTSConstant.JTS_DB2: {
                    outputXml.append(in);
                    break;
                }
                default: {
                    outputXml.append(in);
                    break;
                }
            }
        }
        return outputXml.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 				:	TO_TIMESTAMP
//	Date Written (DD/MM/YYYY)	:	16/05/2002
//	Author						:	Prashant
//	Input Parameters			:	String in , boolean isConst, int dbType
//	Output Parameters			:   none
//	Return Values				:	String
//	Description					:   returns the SQL TIMESTAMP representation of the given value on the basis of the Database Type
//----------------------------------------------------------------------------------------------------
    public static String TO_TIMESTAMP(String in, boolean isConst, int dbType) {
        StringBuffer outputXml = new StringBuffer(100);
        switch (dbType) {
            case JTSConstant.JTS_MSSQL: {
                outputXml.append("CONVERT( DateTime , ");
                if (isConst) {
                    outputXml.append("'");
                }
                outputXml.append(in);
                if (isConst) {
                    outputXml.append("'");
                }
                outputXml.append(") ");
                break;
            }
            case JTSConstant.JTS_ORACLE: {
                outputXml.append("CONVERT( DateTime , ");
                if (isConst) {
                    outputXml.append("'");
                }
                outputXml.append(in);
                if (isConst) {
                    outputXml.append("'");
                }
                outputXml.append(") ");
                break;
            }
            case JTSConstant.JTS_POSTGRES: {
                outputXml.append("CAST( ");
                if (isConst) {
                    outputXml.append("'");
                }
                outputXml.append(in);
                if (isConst) {
                    outputXml.append("'");
                }
                outputXml.append(" AS TIMESTAMP) ");
                break;
            }
            case JTSConstant.JTS_DB2: {
                outputXml.append("TIMESTAMP_FORMAT(");
                if (isConst) {
                    outputXml.append("'");
                }
                outputXml.append(in);
                if (isConst) {
                    outputXml.append("'");
                }
                outputXml.append("," + WFSConstant.WF_DATEFMT + ") ");
                break;
            }
        }
        return outputXml.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 				:	TO_DECIMAL
//	Date Written (DD/MM/YYYY)	:	16/05/2002
//	Author						:	Advid K. Parmar
//	Input Parameters			:	String in , boolean isConst, int dbType
//	Output Parameters			:   none
//	Return Values				:	String
//	Description					:   returns the SQL Decimal representation of the given value on the basis of the Database Type
//----------------------------------------------------------------------------------------------------

    //Deprecated
    public static String TO_DECIMAL(String in, boolean isConst, int dbType) {
        StringBuffer outputXml = new StringBuffer(100);
        switch (dbType) {
            case JTSConstant.JTS_MSSQL: {
                outputXml.append("CONVERT( DECIMAL(20,6) , ");
                if (isConst) {
                    outputXml.append("'");
                }
                outputXml.append(in);
                if (isConst) {
                    outputXml.append("'");
                }
                outputXml.append(") ");
                break;
            }
            case JTSConstant.JTS_ORACLE: {
                if (isConst) {
                    outputXml.append("'");
                }
                outputXml.append(in);
                if (isConst) {
                    outputXml.append("'");
                }
                break;
            }
            case JTSConstant.JTS_POSTGRES: {
                outputXml.append("CAST( ");
                if (isConst) {
                    outputXml.append("'");
                }
                outputXml.append(in);
                if (isConst) {
                    outputXml.append("'");
                }
                outputXml.append(" AS DECIMAL(20,6)) ");
                break;
            }
            case JTSConstant.JTS_DB2: {
                if (isConst) {
                    outputXml.append("'");
                }
                outputXml.append(in);
                if (isConst) {
                    outputXml.append("'");
                }
                break;
            }
        }
        return outputXml.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 			:	TO_SQL
//	Date Written (DD/MM/YYYY):	16/05/2002
//	Author					:	Prashant
//	Input Parameters		:	String in , int Type, int dbType
//	Output Parameters		:   none
//	Return Values			:	String
//	Description				:   converts the String to required SQL Representation based on the Type and DatabaseType
//----------------------------------------------------------------------------------------------------
    public static String TO_SQL(String in, int Type, int dbType, boolean isConst) throws WFSException{
        StringBuffer outputXml = new StringBuffer(50);
        if (in == null || in.equals("")) {
            outputXml.append(" NULL ");
        } else {
            switch (Type) {
                case WFSConstant.WF_ANY:
                case WFSConstant.WF_STR:
					outputXml.append(TO_STRING(in, isConst, dbType));
                    break;
                case WFSConstant.WF_BOOLEAN: { /*SrNo-11*/
                    outputXml.append(TO_STRING(in, isConst, dbType));
                    break;
                }
                case WFSConstant.WF_DAT: {
                    outputXml.append(TO_DATE(in, isConst, dbType));
                    break;
                }
                /** Bugzilla Bug 5533, ShortDate/ Boolean/ Time support in Set attributes */
                /** 08/07/2008 Bugzilla Bug 5142, 5530, Boolean/ ShortDate/ Time support in pick list. - Ruhi Hira */
                case WFSConstant.WF_SHORT_DAT: {
                    if (isConst) {
                        if (in.indexOf(":") < 0) {
                            in = in + " 00:00:00";
                        }
                    }
                    outputXml.append(TO_DATE(in, isConst, dbType));
                    break;
                }
                case WFSConstant.WF_TIME: {
                    if (isConst) {
                        if (in.indexOf("-") < 0) {
                            in = "1900-01-01 " + in;
                        }
                    }
                    outputXml.append(TO_DATE(in, isConst, dbType));
                    break;
                }
                case WFSConstant.WF_INT: {
                    outputXml.append(TO_NUMBER(in, isConst, dbType));
                    break;
                }
                case WFSConstant.WF_LONG: {
                    outputXml.append(TO_NUMBER(in, isConst, dbType));
                    break;
                }
                case WFSConstant.WF_FLT: {
                    outputXml.append(TO_NUMBER(in, isConst, dbType));
                    break;
                }
                default: {
                    if (isConst) {
                        outputXml.append("'" + in + "'");
                    } else {
                        outputXml.append(in);
                    }
                }
            }
        }
        return outputXml.toString();
    }

	 public static String TO_SQL_WITHOUT_RTRIM(String in, int Type, int dbType, boolean isConst) throws WFSException{
	        StringBuffer outputXml = new StringBuffer(50);
	        if (in == null || in.equals("")) {
	            outputXml.append(" NULL ");
	        } else {
	            switch (Type) {
	                case WFSConstant.WF_ANY:
	                case WFSConstant.WF_STR:
						outputXml.append(TO_STRING_WITHOUT_RTRIM(in, isConst, dbType));
	                    break;
	                case WFSConstant.WF_BOOLEAN: { /*SrNo-11*/
	                    outputXml.append(TO_STRING_WITHOUT_RTRIM(in, isConst, dbType));
	                    break;
	                }
	                case WFSConstant.WF_DAT: {
	                    outputXml.append(TO_DATE(in, isConst, dbType));
	                    break;
	                }
	                /** Bugzilla Bug 5533, ShortDate/ Boolean/ Time support in Set attributes */
	                /** 08/07/2008 Bugzilla Bug 5142, 5530, Boolean/ ShortDate/ Time support in pick list. - Ruhi Hira */
	                case WFSConstant.WF_SHORT_DAT: {
	                    if (isConst) {
	                        if (in.indexOf(":") < 0) {
	                            in = in + " 00:00:00";
	                        }
	                    }
	                    outputXml.append(TO_DATE(in, isConst, dbType));
	                    break;
	                }
	                case WFSConstant.WF_TIME: {
	                    if (isConst) {
	                        if (in.indexOf("-") < 0) {
	                            in = "1900-01-01 " + in;
	                        }
	                    }
	                    outputXml.append(TO_DATE(in, isConst, dbType));
	                    break;
	                }
	                case WFSConstant.WF_INT: {
	                    outputXml.append(TO_NUMBER(in, isConst, dbType));
	                    break;
	                }
	                case WFSConstant.WF_LONG: {
	                    outputXml.append(TO_NUMBER(in, isConst, dbType));
	                    break;
	                }
	                case WFSConstant.WF_FLT: {
	                    outputXml.append(TO_NUMBER(in, isConst, dbType));
	                    break;
	                }
					case WFSConstant.WF_NTEXT:{
						outputXml.append(TO_STRING(in, isConst, dbType));
	                    break;
	                    }
	                default: {
	                    if (isConst) {
	                        outputXml.append("'" + in + "'");
	                    } else {
	                        outputXml.append(in);
	                    }
	                }
	            }
	        }
	        return outputXml.toString();
	    }
//----------------------------------------------------------------------------------------------------
//	Function Name 			:	getOperator
//	Date Written (DD/MM/YYYY):	16/05/2002
//	Author					:	Prashant
//	Input Parameters		:	int i
//	Output Parameters		:   none
//	Return Values			:	String
//	Description				:   returns the Operator mapped to the given constant
//----------------------------------------------------------------------------------------------------
    public static String getOperator(int i) {
        /*
        OP_LESSTHAN = 1            '   <
        OP_LESSTHANEQUALTO = 2     '   <=
        OP_EQUALTO = 3             '   =
        OP_NOTEQUALTO = 4          '   !=
        OP_GREATERTHAN = 5         '   >
        OP_GREATERTHANEQUALTO = 6  '   >=
        OP_LIKE = 7                '   LIKE
        OP_NOTLIKE = 8             '   NOTLIKE
        OP_NULL = 9                '   NULL
        OP_NOTNULL = 10            '   NOTNULL
         */
        String op = "";
        switch (i) {
            case WFSConstant.WF_LESSTHAN:
                op = " < ";
                break;
            case WFSConstant.WF_LESSTHANEQUALTO:
                op = " <= ";
                break;
            case WFSConstant.WF_EQUALTO:
                op = " = ";
                break;
            case WFSConstant.WF_NOTEQUALTO:
                op = " != ";
                break;
            case WFSConstant.WF_GREATERTHAN:
                op = " > ";
                break;
            case WFSConstant.WF_GREATERTHANEQUALTO:
                op = " >= ";
                break;
            case WFSConstant.WF_LIKE:
                op = " LIKE ";
                break;
            case WFSConstant.WF_NOTLIKE:
                op = " NOT LIKE ";
                break;
            case WFSConstant.WF_NULL:
                op = " IS  NULL ";
                break;
            case WFSConstant.WF_NOTNULL:
                op = " IS NOT NULL ";
                break;
            default:
                op = " = ";
        }
        return op;
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 			:	getLogOp
//	Date Written (DD/MM/YYYY):	16/05/2002
//	Author					:	Prashant
//	Input Parameters		:	int i
//	Output Parameters		:   none
//	Return Values			:	String
//	Description				:   returns the Logical Operator mapped to the given constant
//----------------------------------------------------------------------------------------------------
    public static String getLogOp(int i) {
        String op = "";
        switch (i) {
            case 1:
                op = " AND ";
                break;
            case 2:
                op = " OR ";
                break;
            default:
                op = " OR ";
        }
        return op;
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 				:	getFilter
//	Date Written (DD/MM/YYYY)	:	16/05/2002
//	Author						:	Prashant
//	Input Parameters			:	XMLParser
//	Output Parameters			:   none
//	Return Values				:	String
//	Description					:   parses the i/p XML to return the required Filter Criteria
//----------------------------------------------------------------------------------------------------
    public static String getFilter(XMLParser parser, Connection con,
            String preferrdTable) throws JTSException {
        StringBuffer outputXml = new StringBuffer(100);
        String engine = parser.getValueOf("EngineName");
        int dbType = ServerProperty.getReference().getDBType(parser.getValueOf("EngineName"));
        int type = parser.getIntOf("Type", 0, true) - 256;
        if (type == -256) {
            return "";
        }
        String attribute = parser.getValueOf("AttributeName", "", true);
        Statement stmt = null;
        ResultSet rs=null;
        try {
            stmt = con.createStatement();
             rs = stmt.executeQuery(
                    " Select SystemDefinedName from VarMappingTable " + WFSUtil.getTableLockHintStr(dbType) + "  where " + TO_STRING("UserDefinedName", false, dbType) + " = " + TO_STRING(TO_STRING(attribute, true, dbType), false, dbType));
            if (rs.next()) {
                attribute = rs.getString(1);
            }
            rs.close();
            stmt.close();
        } catch (Exception e) {
            printErr(engine,"", e);
        } finally {
        	try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (Exception ignored) {
            }
            try {
                // WFS_6_004, Statement closed in finally.
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
            } catch (Exception ignored) {
            }
        }
        outputXml.append(" AND ");
        switch (type) {
            case WFSConstant.WF_STR:
            case WFSConstant.WF_BOOLEAN: /*SrNo-11*/ {
                outputXml.append(preferrdTable + "." + TO_STRING(attribute, false, dbType));
                outputXml.append(getOperator(parser.getIntOf("Comparison", 0, false)));
                outputXml.append(TO_STRING(parser.getValueOf("FilterString", "", false).toUpperCase(), true,
                        dbType));
                break;
            }
            case WFSConstant.WF_TIME:
            case WFSConstant.WF_SHORT_DAT: {
                outputXml.append(preferrdTable + "." + attribute);
                outputXml.append(getOperator(parser.getIntOf("Comparison", 0, false)));
                outputXml.append(TO_SQL(parser.getValueOf("FilterString", "", false), type, dbType, true));
                break;
            }
            case WFSConstant.WF_DAT: {
                outputXml.append(preferrdTable + "." + attribute);
                outputXml.append(getOperator(parser.getIntOf("Comparison", 0, false)));
                outputXml.append(TO_DATE(parser.getValueOf("FilterString", "", false), true, dbType));
                break;
            }
            case WFSConstant.WF_INT: {
                outputXml.append(preferrdTable + "." + attribute);
                outputXml.append(getOperator(parser.getIntOf("Comparison", 0, false)));
                outputXml.append(TO_NUMBER(parser.getValueOf("FilterString", "", false), true, dbType));
                break;
            }
            case WFSConstant.WF_SQL - 256: {
                outputXml.append(parser.getValueOf("FilterString", "", false));
                break;
            }
            default: {
                outputXml.append(preferrdTable + "." + attribute);
                outputXml.append(getOperator(parser.getIntOf("Comparison", 0, false)));
                outputXml.append(parser.getValueOf("FilterString", "", false));
            }
        }
        return outputXml.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 				:	getFilter
//	Date Written (DD/MM/YYYY)	:	16/05/2002
//	Author						:	Prashant
//	Input Parameters			:	XMLParser
//	Output Parameters			:   none
//	Return Values				:	String
//	Description					:   parses the i/p XML to return the required Filter Criteria
//----------------------------------------------------------------------------------------------------
    public static String getFilter(XMLParser parser, Connection con, int dbType) throws
    JTSException {
    	return getFilter(parser, con, dbType, false);
    }
    public static String getFilterDoubleQuoteCase(XMLParser parser, Connection con, int dbType) throws
    JTSException {
    	return getFilter(parser, con, dbType, false,true);
    }
    public static String getFilter(XMLParser parser, Connection con, int dbType,boolean isCriteriaCase) throws
    JTSException {
    	return getFilter(parser, con, dbType, isCriteriaCase,false);
    }
    public static String getFilter(XMLParser parser, Connection con, int dbType, boolean isCriteriaCase,boolean isDoubleQuoteCase) throws
            JTSException {
        int type = parser.getIntOf("Type", 0, true) - 256;
        if (type == -256) {
            return "";
        }
        StringBuffer outputXml = new StringBuffer(64);
        String attribute = parser.getValueOf("AttributeName", "", true);
        String query = "";
        Statement stmt = null;
        ResultSet rs = null;
        String engine = parser.getValueOf("EngineName");
        try {
		if (type == 0) {
			String tempStr = parser.getValueOf("FilterString", "", true);
			String tempStr2 = parser.getValueOf("FilterXML", "", true);
			if (tempStr != null && !tempStr.equals("")) 
			{
                //Added changes for Bug#73014
				tempStr = WFSUtil.handleSpecialCharInXml(tempStr, false);
				return " AND " + tempStr;
			}
			else if (tempStr2 != null && !tempStr2.equals(""))
			{
				XMLParser localParser = new XMLParser(tempStr2);
				StringBuffer return2 = new StringBuffer("");
				int state = localParser.getIntOf("State", 0, true);
				if(localParser.getValueOf("ProcessDefinitionID") != null && !localParser.getValueOf("ProcessDefinitionID").equals(""))
					return2.append("AND ProcessDefID="+localParser.getValueOf("ProcessDefinitionID"));
				if(localParser.getValueOf("ProcessName") != null && !localParser.getValueOf("ProcessName").equals(""))
					return2.append(" AND ProcessName="+TO_STRING(localParser.getValueOf("ProcessName"),true,dbType));
				if(localParser.getValueOf("ActivityId") != null && !localParser.getValueOf("ActivityId").equals(""))
					return2.append(" AND ActivityId="+localParser.getValueOf("ActivityId"));
				if(localParser.getValueOf("ActivityName") != null && !localParser.getValueOf("ActivityName").equals(""))
					return2.append(" AND ActivityName="+TO_STRING(localParser.getValueOf("ActivityName"),true,dbType));
				if(localParser.getValueOf("ProcessInstanceName") != null && !localParser.getValueOf("ProcessInstanceName").equals(""))
					return2.append(" AND ProcessInstanceID="+TO_STRING(localParser.getValueOf("ProcessInstanceName"),true,dbType));
				if(localParser.getValueOf("Priority") != null && !localParser.getValueOf("Priority").equals(""))
					return2.append(" AND PriorityLevel="+localParser.getValueOf("Priority"));
				if(localParser.getValueOf("ExceptionStatus") != null && !localParser.getValueOf("ExceptionStatus").equals(""))
					return2.append(" AND InstrumentStatus="+TO_STRING(localParser.getValueOf("ExceptionStatus"),true,dbType));	
				if(localParser.getValueOf("LockStatus") != null && !localParser.getValueOf("LockStatus").equals(""))
					return2.append(" AND LockStatus="+TO_STRING(localParser.getValueOf("LockStatus"),true,dbType));
				if(localParser.getValueOf("IntroducedByUser") != null && !localParser.getValueOf("IntroducedByUser").equals("")){
					if(localParser.getValueOf("IntroducedByUser").equals("*")){
						return2.append(" AND IntroducedBy IS NOT NULL ");
					}else{
					return2.append(" AND IntroducedBy="+TO_STRING(localParser.getValueOf("IntroducedByUser"),true,dbType));
					}
				}
				if(localParser.getValueOf("LockedByUser") != null && !localParser.getValueOf("LockedByUser").equals("")){
					if(localParser.getValueOf("LockedByUser").equals("*")){
						return2.append(" AND LockedByName IS NOT NULL ");
					}else{
						return2.append(" AND LockedByName ="+TO_STRING(localParser.getValueOf("LockedByUser"),true,dbType));
					}
				}
				if(localParser.getValueOf("AssignedToUser") != null && !localParser.getValueOf("AssignedToUser").equals(""))
					return2.append(" AND AssignedUser="+TO_STRING(localParser.getValueOf("AssignedToUser"),true,dbType));
				if(localParser.getValueOf("ReferByName") != null && !localParser.getValueOf("ReferByName").equals(""))
					return2.append(" AND ReferredByName="+TO_STRING(localParser.getValueOf("ReferByName"),true,dbType));
				String stateDateRange = parser.getValueOf("StateDateRange", "", true);
				if ((state == 6) && (!stateDateRange.equals("")) )
				{
					return2.append(" AND ").append("Entrydatetime between ")
						.append(WFSUtil.TO_DATE(stateDateRange.substring(0, stateDateRange.indexOf(",")).trim(), false,dbType))
						.append(" and ").append(WFSUtil.TO_DATE(stateDateRange.substring(stateDateRange.indexOf(",") + 1), false,dbType))
						.append(" and ").append("ProcessInstanceState = 6") ;
				}
				else if ( (state == 1) && (!stateDateRange.equals("")) )
				{
					return2.append(" and ").append("CreatedDateTime between ")
						.append(WFSUtil.TO_DATE(stateDateRange.substring(0, stateDateRange.indexOf(",")).trim(), false,dbType))
						.append(" and ").append(WFSUtil.TO_DATE(stateDateRange.substring(stateDateRange.indexOf(",") + 1), false, dbType));
				} 
				else if (state == 2)
				{
					return2.append(" and ").append("ProcessInstanceState in (1, 2)") ;
				}
				Document doc = WFXMLUtil.createDocument("<FilterXML>"+tempStr2+"</FilterXML>");
				Node mainNode = doc.getDocumentElement();
				String tempStr3 = generateSQL(mainNode, dbType, isCriteriaCase,isDoubleQuoteCase);
				String tempStr4 = "and ( ";                      /* 38564 */
				tempStr4 = tempStr4 + tempStr3 + ")";             /* 38564 */
				if((tempStr3!=null)&&(tempStr3.trim().equals(""))){ /* Bug 39473 fixed by Anwar Ali Danish*/
					return  return2.toString() ;
				}
				else {
					return  return2.toString() + tempStr4 ;
				}
			}
			else 
			{
				return "";
			}
		}
            if (attribute != null && !attribute.equals("")) {
                stmt = con.createStatement();
                query = "Select SystemDefinedName from VarMappingTable " + WFSUtil.getTableLockHintStr(dbType) + "  where " + TO_STRING("UserDefinedName", false, dbType) + " = " + TO_STRING(TO_STRING(attribute, true, dbType), false, dbType);
                rs = stmt.executeQuery(query);
                if (rs.next()) {
                    attribute = rs.getString(1);
                }
            }
        } catch (Exception e) {
            printErr(engine,"", e);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (SQLException sqle) {
            }
            try {
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
            } catch (Exception e) {
            }
        }
        outputXml.append(" AND ");
        switch (type) {
            case WFSConstant.WF_STR:
            case WFSConstant.WF_BOOLEAN: /*SrNo-11*/ {
                outputXml.append(TO_STRING(attribute, false, dbType));
                outputXml.append(getOperator(parser.getIntOf("Comparison", 0, false)));
                outputXml.append(TO_STRING(parser.getValueOf("FilterString", "", false).toUpperCase(), true,
                        dbType));
                break;
            }
            case WFSConstant.WF_TIME:
            case WFSConstant.WF_SHORT_DAT: {
                outputXml.append(WFSUtil.TO_SANITIZE_STRING(attribute,true));
                outputXml.append(getOperator(parser.getIntOf("Comparison", 0, false)));
                outputXml.append(TO_SQL(parser.getValueOf("FilterString", "", false), type, dbType, true));
                break;
            }
            case WFSConstant.WF_DAT: {
                outputXml.append(WFSUtil.TO_SANITIZE_STRING(attribute,true));
                outputXml.append(getOperator(parser.getIntOf("Comparison", 0, false)));
                outputXml.append(TO_DATE(parser.getValueOf("FilterString", "", false), true, dbType));
                break;
            }
            case WFSConstant.WF_INT: {
                outputXml.append(WFSUtil.TO_SANITIZE_STRING(attribute,true));
                outputXml.append(getOperator(parser.getIntOf("Comparison", 0, false)));
                outputXml.append(TO_NUMBER(parser.getValueOf("FilterString", "", false), true, dbType));
                break;
            }
            case WFSConstant.WF_SQL - 256: {
                outputXml.append(parser.getValueOf("FilterString", "", false));
                break;
            }
            default: {
                outputXml.append(WFSUtil.TO_SANITIZE_STRING(attribute,true));
                outputXml.append(getOperator(parser.getIntOf("Comparison", 0, false)));
                outputXml.append(parser.getValueOf("FilterString", "", false));
            }
        }
        return outputXml.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 				:	replace
//	Date Written (DD/MM/YYYY)	:	16/05/2002
//	Author						:	Prashant
//	Input Parameters			:	XMLParser
//	Output Parameters			:   none
//	Return Values				:	String
//	Description					:   replaces a character by String
//----------------------------------------------------------------------------------------------------
    public static String replace(String in, String src, String dest) {
        // Bug # WFS_6_009, causing NullPointerException if input is null....
        if (in == null || src == null) {
            return in;
        }
        int offset = 0;
        int startindex = 0;
        int srcLen = src.length();
        StringBuffer strBuf = new StringBuffer();
        do {
            try {
                startindex = in.indexOf(src, offset);
                strBuf.append(in.substring(offset, startindex));
                strBuf.append(dest);
                offset = startindex + srcLen;
            } catch (StringIndexOutOfBoundsException e) {
                break;
            }
        } while (startindex >= 0);
        strBuf.append(in.substring(offset));
        return strBuf.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 				:	replaceIgnoreCase
//	Date Written (DD/MM/YYYY)	:	16/05/2002
//	Author						:	Prashant
//	Input Parameters			:	XMLParser
//	Output Parameters			:   none
//	Return Values				:	String
//	Description					:   replaces a String by String Ignoring Case
//----------------------------------------------------------------------------------------------------
    public static String replaceIgnoreCase(String in, String src, String dest) {
        int offset = 0;
        int startindex = 0;
        int srcLen = src.length();
        StringBuffer strBuf = new StringBuffer();
        do {
            try {
                startindex = in.toLowerCase().indexOf(src.toLowerCase(), offset);
                strBuf.append(in.substring(offset, startindex));
                strBuf.append(dest);
                offset = startindex + srcLen;
            } catch (StringIndexOutOfBoundsException e) {
                break;
            }
        } while (startindex >= 0);
        strBuf.append(in.substring(offset));
        return strBuf.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 				:	getDate
//	Date Written (DD/MM/YYYY)	:	16/05/2002
//	Author						:	Prashant
//	Input Parameters			:	database type
//	Output Parameters			:   none
//	Return Values				:	String
//	Description					:   returns appropriate current Date String
//----------------------------------------------------------------------------------------------------
    public static String getDate(int dbType) {
        String dateStr = " getDate() ";
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                dateStr = " getDate() ";
                break;
            case JTSConstant.JTS_ORACLE:
                dateStr = " sysdate ";
                break;
            case JTSConstant.JTS_POSTGRES:
                dateStr = " CURRENT_TIMESTAMP ";
                break;
            case JTSConstant.JTS_DB2:
                dateStr = " CURRENT TIMESTAMP ";
                break;
            default:
                dateStr = "	getDate() ";
                break;
        }
        return dateStr;
    }
    
    
public static String addMinsToDate(Connection con, int minutes, int dbType) throws SQLException{
    String dateStr = null;
    String dateQry = "";
    Statement stmt = null;
    ResultSet rs = null;
    try{
        stmt = con.createStatement();
        switch (dbType) {
                case JTSConstant.JTS_MSSQL:
                    dateQry = " Select DateAdd(MINUTE,"+minutes+", GETDATE()) ";
                    break;
                case JTSConstant.JTS_ORACLE:
                    dateQry = " Select sysdate + "+minutes/1440+" From Dual ";
                    break;
                case JTSConstant.JTS_POSTGRES:
                    dateStr = " CURRENT_TIMESTAMP ";
                    break;
                case JTSConstant.JTS_DB2:
                    dateStr = " CURRENT TIMESTAMP ";
                    break;
                default:
                    dateStr = "	getDate() ";
                    break;
        }
        rs = stmt.executeQuery(dateQry);
        if(rs!=null && rs.next()){
            dateStr = rs.getString(1);
        }
        
    } catch (SQLException e) {
            printErr("","", e);
    } catch (Exception e) {
            printErr("","", e);
    }finally{
        if (stmt != null) {
            stmt.close();
            stmt = null;
        }
        if(rs!=null){
            rs.close();
            rs = null;
        }
    } 
      return dateStr;

}

//----------------------------------------------------------------------------------------------------
//	Function Name 				:	getDate
//	Date Written (DD/MM/YYYY)	:	16/05/2002
//	Author						:	Prashant
//	Input Parameters			:	database type
//	Output Parameters			:   none
//	Return Values				:	String
//	Description					:   returns appropriate current Date String
//----------------------------------------------------------------------------------------------------
    public static String join(int dbType, int joinType, String table1, String alias1,
            String table2,
            String alias2, String[] columns1, String[] columns2) {
        String queryBuf = new String();
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                queryBuf = SQLJoin(joinType, table1, alias1, table2, alias2, columns1, columns2);
                break;
            case JTSConstant.JTS_ORACLE:
                queryBuf = OraJoin(joinType, table1, alias1, table2, alias2, columns1, columns2);
                break;
            case JTSConstant.JTS_POSTGRES:
                queryBuf = SQLJoin(joinType, table1, alias1, table2, alias2, columns1, columns2);
                break;
            case JTSConstant.JTS_DB2:
                queryBuf = SQLJoin(joinType, table1, alias1, table2, alias2, columns1, columns2);
                break;
            default:
                queryBuf = SQLJoin(joinType, table1, alias1, table2, alias2, columns1, columns2);
                break;
        }
        return queryBuf;
    }

    private static String SQLJoin(int joinType, String table1, String alias1, String table2,
            String alias2, String[] columns1, String[] columns2) {

        StringBuffer queryBuf = new StringBuffer(50);
        int no0fCols = 0;

        if (table1 == null && alias1 == null) { // Later Throw Exception

            return null;
        } else if ((table1 == null || table1.equals("")) && alias1 == null) {
            return null;
        } else if ((table1 == null || table1.equals("")) && alias1.equals("")) {
            return null;
        }

        if (table2 == null) { // Later Throw Exception

            return null;
        } else if (table2.equals("")) { // Later Throw Exception

            return null;
        }

        if (columns1 == null || columns2 == null) { // Later Throw Exception

            return null;
        } else if (columns1.length != columns2.length) {
            return null;
        }

        no0fCols = columns1.length;

        if (table1 != null && !table1.equals("")) {
            queryBuf.append(table1);

        }
        if (alias1 == null) {
            alias1 = table1;
        } else if (alias1.equals("")) {
            alias1 = table1;

        }
        if (alias2 == null) {
            alias2 = table2;
        } else if (alias2.equals("")) {
            alias2 = table2;

        }
        queryBuf.append(" ");
        queryBuf.append(alias1);
        queryBuf.append(" ");

        switch (joinType) {
            case WFSConstant.WF_LEFT:
                queryBuf.append(" LEFT OUTER JOIN ");
                break;
            case WFSConstant.WF_RIGHT:
                queryBuf.append(" RIGHT OUTER JOIN ");
                break;
            case WFSConstant.WF_EQUI:
                queryBuf.append(" JOIN ");
                break;
            case WFSConstant.WF_FULL:
                queryBuf.append(" FULL OUTER JOIN ");
                break;
        }

        queryBuf.append(table2);
        queryBuf.append(" ");
        queryBuf.append(alias2);
        queryBuf.append(" ");
        queryBuf.append(" ON ");

        for (int i = 0; i < columns1.length; i++) {
            queryBuf.append(alias1);
            queryBuf.append(".");
            queryBuf.append(columns1[i]);
            queryBuf.append(" = ");
            queryBuf.append(alias2);
            queryBuf.append(".");
            queryBuf.append(columns2[i]);
            if (i < no0fCols - 1) {
                queryBuf.append(" AND ");
            }
        }
        return queryBuf.toString();
    }

    private static String OraJoin(int joinType, String table1, String alias1, String table2,
            String alias2, String[] columns1, String[] columns2) {

        StringBuffer queryBuf = new StringBuffer(50);
        String operator = "=";
        int no0fCols = 0;

        if (table1 == null && alias1 == null) { // Later Throw Exception

            return null;
        } else if ("".equals(table1) && alias1 == null) {
            return null;
        } else if ("".equals(table1) && alias1.equals("")) {
            return null;
        }

        if (table2 == null) { // Later Throw Exception

            return null;
        } else if (table2.equals("")) { // Later Throw Exception

            return null;
        }

        if (columns1 == null || columns2 == null) { // Later Throw Exception

            return null;
        } else if (columns1.length != columns2.length) {
            return null;
        }

        no0fCols = columns1.length;

        if (table1 != null && !table1.equals("")) {
            queryBuf.append(table1);

        }
        if (alias1 == null) {
            alias1 = table1;
        } else if (alias1.equals("")) {
            alias1 = table1;

        }
        if (alias2 == null) {
            alias2 = table2;
        } else if (alias2.equals("")) {
            alias2 = table2;

        }
        queryBuf.append(" ");
        queryBuf.append(alias1);
        queryBuf.append(" , ");

        switch (joinType) {
            case WFSConstant.WF_LEFT:
                operator = " =+ ";
                break;
            case WFSConstant.WF_RIGHT:
                operator = " (+)= ";
                break;
            case WFSConstant.WF_EQUI:
                operator = " = ";
                break;
            case WFSConstant.WF_FULL:
                operator = " (+)=+ ";
                break;
        }

        queryBuf.append(table2);
        queryBuf.append(" ");
        queryBuf.append(alias2);
        queryBuf.append(" ");
        queryBuf.append(" WHERE ");

        for (int i = 0; i < columns1.length; i++) {
            queryBuf.append(alias1);
            queryBuf.append(".");
            queryBuf.append(columns1[i]);
            queryBuf.append(operator);
            queryBuf.append(alias2);
            queryBuf.append(".");
            queryBuf.append(columns2[i]);
            if (i < no0fCols - 1) {
                queryBuf.append(" AND ");
            }
        }
        return queryBuf.toString();
    }

    public static String join(int dbType, String in) throws Exception {
        String queryBuf;
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                queryBuf = in;
                break;
            case JTSConstant.JTS_ORACLE:
                queryBuf = in.substring(0, in.indexOf("LEFT"));
                queryBuf += OraConvert(in.substring(in.indexOf("LEFT")));
                break;
            case JTSConstant.JTS_POSTGRES:
                queryBuf = in;
                break;
            case JTSConstant.JTS_DB2:
                queryBuf = in;
                break;
            default:
                queryBuf = in;
                break;
        }
        return queryBuf;
    }

    static String OraConvert(String joinString) {
        StringBuffer strBuff = new StringBuffer();
        String strToken = null;
        Object stackElement = null;
        boolean onFound = false;
        java.util.Stack queryStack = new java.util.Stack();
        java.util.Stack tableStack = new java.util.Stack();
        java.util.Stack dummyQueryStack = new java.util.Stack();
        java.util.StringTokenizer st = new java.util.StringTokenizer(joinString);
        while (st.hasMoreTokens()) {
            strToken = st.nextToken();
            if (strToken.equalsIgnoreCase("LEFT")) {

                if (onFound) {
                    queryStack.push(" (+) ");
                    queryStack.push(" AND ");
                }
                queryStack.push("#");
                queryStack.push(",");
            } else if (strToken.equalsIgnoreCase("OUTER") || strToken.equalsIgnoreCase("JOIN")) {
                continue;
            } else if (strToken.equalsIgnoreCase("ON")) {
                onFound = true;
                while (!((String) (stackElement = queryStack.pop())).equals("#")) {
                    tableStack.push(stackElement);
                }
            } else if (strToken.equalsIgnoreCase("AND") || strToken.equalsIgnoreCase("OR")) {
                queryStack.push(" (+) ");
                queryStack.push(strToken);
                queryStack.push(" ");
            } else {
                queryStack.push(strToken);
                queryStack.push(" ");
            }
        }
        queryStack.pop(); //for removing last space

        if (!queryStack.empty() &&
                ((String) (stackElement = queryStack.pop())).equalsIgnoreCase("Where")) {
            queryStack.push(" (+) ");
            queryStack.push(" AND ");
            queryStack.push(" ");
        } else {
            queryStack.push(stackElement);
            queryStack.push(" (+) ");
        }
        while (!tableStack.empty()) {
            strBuff.append(tableStack.pop());
        }
        strBuff.append(" Where ");
        while (!queryStack.empty()) {
            dummyQueryStack.push(queryStack.pop());
        }
        while (!dummyQueryStack.empty()) {
            strBuff.append(dummyQueryStack.pop());
        }
        return strBuff.toString();
    } //end-function

    /*
    public static String OraConvert ( String sql92 ) throws Exception
    {
    StringBuffer queryBuf	=	new StringBuffer();
    java.util.StringTokenizer str = new java.util.StringTokenizer (sql92);
    String tempStr	=	"";
    boolean jcndn	= false;
    boolean condn	= false;
    int op			=	0;
    int joinCond	=	0;
    int i			=	0;
    StringBuffer  tableStr	=	new StringBuffer();
    tableStr.append(str.nextToken());
    tableStr.append(" ");
    while ( str.hasMoreTokens() ) 	{
    tempStr	=	str.nextToken();
    if (!condn)
    {
    if (tempStr.equalsIgnoreCase("LEFT"))
    joinCond	=	4;
    else if (tempStr.equalsIgnoreCase("RIGHT"))
    joinCond	=	6;
    else if (tempStr.equalsIgnoreCase("FULL"))
    joinCond	=	8;
    else if (tempStr.equalsIgnoreCase("OUTER"))
    joinCond	*=	2;
    else if (tempStr.equalsIgnoreCase("JOIN"))
    joinCond	=	(joinCond == 0) ? 2: joinCond/4;
    else if ( joinCond < 5 && joinCond != 0 )
    {
    if (i == 0){
    if (!(tempStr.equalsIgnoreCase("OR") || tempStr.equalsIgnoreCase("AND") || tempStr.equalsIgnoreCase("WHERE"))){
    tableStr.append(" ,");
    tableStr.append(tempStr);
    i++;
    }
    else{
    if (tempStr.equalsIgnoreCase("WHERE") && jcndn)
    queryBuf.append("AND");
    else
    queryBuf.append(tempStr);
    queryBuf.append(" ");
    condn	= true;
    }
    }else if (tempStr.equalsIgnoreCase("ON") || tempStr.equalsIgnoreCase("WHERE")){
    i		=	0;
    condn	=	true;
    if (jcndn)
    queryBuf.append(" AND ");
    else
    queryBuf.append(" WHERE ");
    jcndn	=	true;
    }
    else{
    tableStr.append(" ");
    tableStr.append(tempStr);
    }
    }
    else if ( joinCond == 0 ){
    tableStr.append(tempStr);
    tableStr.append(" ");
    }
    else
    throw new Exception(tempStr+"####"+tableStr.append(queryBuf.toString()));	// Throw Exception later
    }else{
    if (op == 1 )
    {
    switch (joinCond)
    {
    case 1:
    queryBuf.append(tempStr);
    queryBuf.append(" ");
    break;
    case 2:
    queryBuf.append(tempStr+" ");
    tempStr	=	str.nextToken();
    queryBuf.append(tempStr);
    queryBuf.append(" (+) ");
    op++;
    condn	=	false;
    break;
    case 3:
    queryBuf.append(" (+)");
    queryBuf.append(tempStr);
    queryBuf.append(" ");
    break;
    case 4:
    queryBuf.append(tempStr+" ");
    tempStr	=	str.nextToken();
    queryBuf.append(tempStr);
    queryBuf.append(" (+) ");
    op++;
    condn	=	false;
    break;
    default:
    queryBuf.append(tempStr);
    queryBuf.append(" ");
    }
    op++;
    }else{
    queryBuf.append(tempStr);
    queryBuf.append(" ");
    if (op == 2){
    op	=	0;
    condn	=	false;
    }
    else
    op++;
    }
    }
    }
    return tableStr.append(queryBuf).toString();
    }
     */

//----------------------------------------------------------------------------------------------------
//	Function Name 			:	substring
//	Date Written (DD/MM/YYYY):	16/05/2002
//	Author					:	Advid K. Parmar
//	Input Parameters		:	String in , int Type, int dbType
//	Output Parameters		:   none
//	Return Values			:	String
//	Description				:   returns the substring Representation based on the Type of Database
//----------------------------------------------------------------------------------------------------
    public static String substr(String in, int start, int end, int dbType) throws JTSException {
        StringBuffer outputXml = new StringBuffer(100);
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                outputXml.append(" substring(" + in + "," + start + "," + end + ") ");
                break;
            case JTSConstant.JTS_ORACLE:
                outputXml.append(" substr(" + in + "," + start + "," + end + ") ");
                break;
            case JTSConstant.JTS_DB2:				//DB2 Virochan

                outputXml.append(" substr(" + in + "," + start + "," + end + ") ");
                break;
            case JTSConstant.JTS_POSTGRES:
                outputXml.append(" substr(" + in + "," + start + "," + end + ") ");
                break;

        }

        return outputXml.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 			:	isnull
//	Date Written (DD/MM/YYYY):	16/05/2002
//	Author					:	Advid K. Parmar
//	Input Parameters		:	String in , int Type, int dbType
//	Output Parameters		:   none
//	Return Values			:	String
//	Description				:   returns the isnull Representation based on the Type of Database
//----------------------------------------------------------------------------------------------------
    public static String isnull(String src, String target, int dbType) throws JTSException {
        StringBuffer outputXml = new StringBuffer(100);
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                outputXml.append(" isnull(" + src + "," + target + ") ");
                break;
            case JTSConstant.JTS_ORACLE:
                outputXml.append(" nvl(" + src + "," + target + ") ");
                break;
            case JTSConstant.JTS_DB2:			//DB2 Virochan

                outputXml.append(" coalesce(" + src + "," + target + ") ");
                break;
            case JTSConstant.JTS_POSTGRES:
                outputXml.append(" COALESCE(" + src + "," + target + ") ");
                break;
        }

        return outputXml.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 			:	substring
//	Date Written (DD/MM/YYYY):	16/05/2002
//	Author					:	Advid K. Parmar
//	Input Parameters		:	String in , int Type, int dbType
//	Output Parameters		:   none
//	Return Values			:	String
//	Description				:   returns the substring Representation based on the Type of Database
//----------------------------------------------------------------------------------------------------
    public static String substring(int dbType) throws JTSException {
        StringBuffer outputXml = new StringBuffer(100);
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                outputXml.append(" substring ");
                break;
            case JTSConstant.JTS_ORACLE:
                outputXml.append(" substr ");
                break;
            case JTSConstant.JTS_DB2: //DB2 Virochan

                outputXml.append(" substr ");
                break;
            case JTSConstant.JTS_POSTGRES:
                outputXml.append(" SUBSTR ");
                break;
        }

        return outputXml.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 			:	casesql (if then else)
//	Date Written (DD/MM/YYYY):	16/05/2002
//	Author					:	Advid K. Parmar
//	Input Parameters		:	String in , int Type, int dbType
//	Output Parameters		:   none
//	Return Values			:	String
//	Description				:   returns the case Representation based on the Type of Database
//----------------------------------------------------------------------------------------------------
    public static String casesql(String val, String if1, String then1, String elsedo,
            int dbType) throws JTSException {
        StringBuffer outputXml = new StringBuffer(100);
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                outputXml.append(" case " + val + " WHEN " + if1 + " THEN " + then1 + " ELSE  " +
                        elsedo + " END  ");
                break;
            case JTSConstant.JTS_ORACLE:
                outputXml.append(" decode(" + val + "," + if1 + "," + then1 + "," + elsedo + ")");
                break;
            case JTSConstant.JTS_DB2:
                /** @todo check it */
                outputXml.append(" case " + val + " WHEN " + if1 + " THEN " + then1 + " ELSE  " +
                        elsedo + " END  ");
                break;
            case JTSConstant.JTS_POSTGRES:
                outputXml.append(" CASE " + val + " WHEN " + if1 + " THEN " + then1 + " ELSE  " + elsedo + " END  ");
                break;
        }

        return outputXml.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 			:	casesql (if then elseif elseif then else)
//	Date Written (DD/MM/YYYY):	16/05/2002
//	Author					:	Advid K. Parmar
//	Input Parameters		:	String in , int Type, int dbType
//	Output Parameters		:   none
//	Return Values			:	String
//	Description				:   returns the case Representation based on the Type of Database
//----------------------------------------------------------------------------------------------------
    public static String casesql(String val, String if1, String then1, String if2, String then2,
            String if3, String then3, String elsedo, int dbType) throws
            JTSException {
        StringBuffer outputXml = new StringBuffer(100);
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                outputXml.append(" case " + val + " WHEN " + if1 + " THEN " + then1 + " WHEN " + if2 + " THEN " + then2 + " WHEN " + if3 + " THEN " + then3 + " ELSE  " +
                        elsedo + " END  ");
                break;
            case JTSConstant.JTS_ORACLE:
                outputXml.append(" decode(" + val + "," + if1 + "," + then1 + "," + if2 + "," + then2 +
                        "," + if3 + "," + then3 + "," + elsedo + ")");
                break;
            case JTSConstant.JTS_DB2:
                outputXml.append(" case " + val + " WHEN " + if1 + " THEN " + then1 + " WHEN " + if2 + " THEN " + then2 + " WHEN " + if3 + " THEN " + then3 + " ELSE  " +
                        elsedo + " END  ");
                break;
            case JTSConstant.JTS_POSTGRES:
                outputXml.append(" CASE " + val + " WHEN " + if1 + " THEN " + then1 + " WHEN " + if2 + " THEN " + then2 + " WHEN " + if3 + " THEN " + then3 + " ELSE  " +
                        elsedo + " END  ");
                break;
        }

        return outputXml.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 			:	casesql (if then elseif  then else)
//	Date Written (DD/MM/YYYY):	16/05/2002
//	Author					:	Advid K. Parmar
//	Input Parameters		:	String in , int Type, int dbType
//	Output Parameters		:   none
//	Return Values			:	String
//	Description				:   returns the case Representation based on the Type of Database
//----------------------------------------------------------------------------------------------------
    public static String casesql(String val, String if1, String then1, String if2, String then2,
            String elsedo, int dbType) throws JTSException {
        StringBuffer outputXml = new StringBuffer(100);
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                outputXml.append(" case " + val + " WHEN " + if1 + " THEN " + then1 + " WHEN " + if2 + " THEN " + then2 + " ELSE  " + elsedo + " END  ");
                break;
            case JTSConstant.JTS_ORACLE:
                outputXml.append(" decode(" + val + "," + if1 + "," + then1 + "," + if2 + "," + then2 +
                        "," + elsedo + ")");
                break;

            case JTSConstant.JTS_DB2:
                outputXml.append(" case " + val + " WHEN " + if1 + " THEN " + then1 + " WHEN " + if2 + " THEN " + then2 + " ELSE  " + elsedo + " END  ");
                break;
            case JTSConstant.JTS_POSTGRES:
                outputXml.append(" CASE " + val + " WHEN " + if1 + " THEN " + then1 + " WHEN " + if2 + " THEN " + then2 + " ELSE  " + elsedo + " END  ");
                break;

        }
        return outputXml.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 			:	length
//	Date Written (DD/MM/YYYY):	16/05/2002
//	Author					:	Prashant
//	Input Parameters		:	int dbType
//	Output Parameters		:   none
//	Return Values			:	String
//	Description				:   returns the length Representation based on the Type of Database
//----------------------------------------------------------------------------------------------------
    public static String length(int dbType) throws JTSException {
        StringBuffer outputXml = new StringBuffer(100);
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                outputXml.append(" len ");
                break;
            case JTSConstant.JTS_ORACLE:
                outputXml.append(" length ");
                break;
            case JTSConstant.JTS_DB2:		//DB2 Virochan

                outputXml.append(" length ");
                break;
            case JTSConstant.JTS_POSTGRES:
                outputXml.append(" LENGTH ");
                break;
        }
        return outputXml.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 			:	charIndex
//	Date Written (DD/MM/YYYY):	16/05/2002
//	Author					:	Prashant
//	Input Parameters		:	int dbType
//	Output Parameters		:   none
//	Return Values			:	String
//	Description				:   returns the charIndex Representation based on the Type of Database
//----------------------------------------------------------------------------------------------------
    public static String charIndex(int dbType, String src, String pat) throws JTSException {
        StringBuffer outputXml = new StringBuffer(100);
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                outputXml.append(" charIndex ( " + pat + " , " + src + ") ");
                break;
            case JTSConstant.JTS_ORACLE:
                outputXml.append(" INSTR ( " + src + " , " + pat + ") ");
                break;
            case JTSConstant.JTS_DB2:			//DB2 Virochan

                outputXml.append(" POSSTR ( " + src + " , " + pat + ") ");
                break;
            case JTSConstant.JTS_POSTGRES:
                outputXml.append(" STRPOS ( " + src + " , " + pat + ") ");
                break;
        }
        return outputXml.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 			:	charIndex
//	Date Written (DD/MM/YYYY):	16/05/2002
//	Author					:	Advid
//	Input Parameters		:	int dbType
//	Output Parameters		:   none
//	Return Values			:	String
//	Description				:   returns the charIndex Representation based on the Type of Database
//----------------------------------------------------------------------------------------------------
    public static String charIndex(int dbType, String src, String pat,
            String len) throws JTSException {
        StringBuffer outputXml = new StringBuffer(100);
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                outputXml.append(" charIndex ( " + pat + " , " + src + "," + len + ") ");
                break;
            case JTSConstant.JTS_ORACLE:
                outputXml.append(" INSTR ( " + src + " , " + pat + "," + len + ") ");
                break;
            case JTSConstant.JTS_DB2:
                outputXml.append(" LOCATE( " + pat + " , " + src + "," + len + ") ");
                break;
        }
        return outputXml.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 			:	lPAD
//	Date Written (DD/MM/YYYY):	16/05/2002
//	Author					:	Prashant
//	Input Parameters		:	int dbType
//	Output Parameters		:   none
//	Return Values			:	String
//	Description				:   returns the charIndex Representation based on the Type of Database
//----------------------------------------------------------------------------------------------------
    public static String lPAD(int dbType, String src, char repl, int len) throws JTSException {
        StringBuffer outputXml = new StringBuffer(100);
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                outputXml.append(" REVERSE ( SUBSTRING ( REVERSE ( REPLICATE ( '" + repl + "' , " +
                        len + " ) + " + src + " ), 0 , " + (len + 1) + " ) )");
                break;
            case JTSConstant.JTS_ORACLE:
                outputXml.append(" LPAD ( " + src + " , " + len + " , '" + repl + "' ) ");
                break;
            case JTSConstant.JTS_POSTGRES:
                outputXml.append(" LPAD ( " + src + " , " + len + " , '" + repl + "' ) ");
                break;
        }
        return outputXml.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 			:	isnull
//	Date Written (DD/MM/YYYY):	16/05/2002
//	Author					:	Advid K. Parmar
//	Input Parameters		:	String in , int Type, int dbType
//	Output Parameters		:   none
//	Return Values			:	String
//	Description				:   returns the isnull Representation based on the Type of Database
//----------------------------------------------------------------------------------------------------
    public static String isnull(int dbType) throws JTSException {
        StringBuffer outputXml = new StringBuffer(100);
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                outputXml.append(" isnull ");
                break;
            case JTSConstant.JTS_ORACLE:
                outputXml.append(" nvl ");
                break;
            case JTSConstant.JTS_DB2:
                outputXml.append(" Coalesce ");
                break;
            case JTSConstant.JTS_POSTGRES:
                outputXml.append(" COALESCE ");
                break;

        }

        return outputXml.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 			:	concat
//	Date Written (DD/MM/YYYY):	16/05/2002
//	Author					:	Prashant
//	Input Parameters		:	int dbType
//	Output Parameters		:   none
//	Return Values			:	String
//	Description				:   returns the concat Representation based on the Type of Database
//----------------------------------------------------------------------------------------------------
    public static String concat(int dbType) throws JTSException {
        StringBuffer outputXml = new StringBuffer(100);
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                outputXml.append(" + ");
                break;
            case JTSConstant.JTS_ORACLE:
                outputXml.append(" || ");
                break;
            case JTSConstant.JTS_DB2:
                outputXml.append(" || ");
                break;
            case JTSConstant.JTS_POSTGRES:
                outputXml.append(" || ");
                break;

        }
        return outputXml.toString();
    }

    /**
     * *****************************************************************
     * Function Name    :   convertDateToString
     * Programmer' Name :   Ruhi Hira
     * Date Written     :   May 12th 2007
     * Input Parameters :   Calendar gc
     * Output Parameters:   NONE
     * Return Value     :   String -> String for date in omniflow format.
     * Description      :   Convert date to string. (inherited from NGUtility)
     * *****************************************************************
     */
    private static String convertDateToString(Calendar gc) {
        if (gc == null) {
            return "";
        }
        String strDate = "";
        int nMonth = gc.get(Calendar.MONTH) + 1;
        int nDay = gc.get(Calendar.DATE);
        String strMonth;
        String strDay;
        if (nMonth < 10) {
            strMonth = "0" + nMonth;
        } else {
            strMonth = Integer.toString(nMonth);
        }
        if (nDay < 10) {
            strDay = "0" + nDay;
        } else {
            strDay = Integer.toString(nDay);
        }
        strDate = gc.get(Calendar.YEAR) + "-" + strMonth + "-" + strDay + " " + gc.get(Calendar.HOUR_OF_DAY) + ":" + gc.get(Calendar.MINUTE) + ":" + gc.get(Calendar.SECOND);
        return strDate;
    }

    /**
     * *****************************************************************
     * Function Name    :   dateCalculator
     * Programmer' Name :   Ruhi Hira
     * Date Written     :   May 10th 2007
     * Input Parameters :   char -> strReportDuration
     *                      char -> strOption
     *                      int  -> dbType
     * Output Parameters:   NONE
     * Return Value     :   String[] -> From n To Date.
     * Description      :   create from and to date.
     *                          (inherited from Process Manager)
     * *****************************************************************
     */
    public static String[] dateCalculator(char strReportDuration, char strOption, int dbType, XMLParser parser) {
        String strStartDateTime = "";
        String strEndDateTime = "";
        String engine = parser.getValueOf("EngineName");
        try {
            java.util.Date date = new java.util.Date(System.currentTimeMillis());
            String startDate = "";
            String endDate = "";
            String startTime = "";
            String endTime = "";
            int nMonth = 0;
            String strMonth = "";
            String strDay = "";
            int weekDate = 0;
            if (dbType == JTSConstant.JTS_ORACLE) {
                weekDate = 2;
            } else {
                weekDate = 1;
            }
            Calendar cal = Calendar.getInstance();
            cal.setTime(date);
            int mins = cal.get(Calendar.MINUTE);
            int hrs = cal.get(Calendar.HOUR_OF_DAY);
            String strHrs = String.valueOf(hrs);
            String strMins = String.valueOf(mins);
            if (hrs < 10) {
                strHrs = "0" + strHrs;
            }
            if (mins < 10) {
                strMins = "0" + strMins;
            }
            endDate = String.valueOf(cal.get(Calendar.YEAR)) + '-' + String.valueOf(cal.get(Calendar.MONTH)) + '-' + String.valueOf(cal.get(Calendar.DATE));
            if (strReportDuration == WFSConstant.CONST_DURATION_LAST_DAY) {
                endTime = "23" + ":" + "59" + ":" + "59";
            } else {
                endTime = strHrs + ":" + strMins + ":" + "00";
            }
            startTime = "00" + ":" + "00" + ":" + "00";
            String tempDate = endDate;
            int tempYear = Integer.parseInt(tempDate.substring(0, tempDate.indexOf("-")));
            int tempMonth = Integer.parseInt(tempDate.substring(tempDate.indexOf("-") + 1, tempDate.lastIndexOf("-")));
            int tempDay = Integer.parseInt(tempDate.substring(tempDate.lastIndexOf("-") + 1, tempDate.length()));
            GregorianCalendar gc = new GregorianCalendar(tempYear, tempMonth, tempDay);
            if (strReportDuration == WFSConstant.CONST_DURATION_TODAY) {
                endDate = convertDateToString(gc);
                startDate = convertDateToString(gc);
            } else if (strReportDuration == WFSConstant.CONST_DURATION_LAST_DAY) {
                gc.add(Calendar.DATE, -1);
                endDate = convertDateToString(gc);
                startDate = convertDateToString(gc);
            } else if (strReportDuration == WFSConstant.CONST_DURATION_LAST_WEEK) {
                endDate = convertDateToString(gc);
                gc.add(Calendar.DATE, -7);
                int dayOfWeek = gc.get(Calendar.DAY_OF_WEEK);
                gc.add(Calendar.DATE, -dayOfWeek + weekDate);
                startDate = convertDateToString(gc);
            } else if (strReportDuration == WFSConstant.CONST_DURATION_LAST_MONTH) {
                endDate = convertDateToString(gc);
                gc.add(Calendar.MONTH, -1);
                gc.set(Calendar.DATE, 1);
                if (strOption == WFSConstant.CONST_TYPE_WEEK) {
                    int dayOfWeek = gc.get(Calendar.DAY_OF_WEEK);
                    gc.add(Calendar.DATE, -dayOfWeek + weekDate);
                }
                startDate = convertDateToString(gc);
            } else if (strReportDuration == WFSConstant.CONST_DURATION_LAST_QUARTER) {
                endDate = convertDateToString(gc);
                gc.add(Calendar.MONTH, -3);
                nMonth = gc.get(Calendar.MONTH) + 1;
                if (nMonth == 1 || nMonth == 2 || nMonth == 3) {
                    gc = new GregorianCalendar(gc.get(Calendar.YEAR), 0, 1);
                } else if (nMonth == 4 || nMonth == 5 || nMonth == 6) {
                    gc = new GregorianCalendar(gc.get(Calendar.YEAR), 3, 1);
                } else if (nMonth == 7 || nMonth == 8 || nMonth == 9) {
                    gc = new GregorianCalendar(gc.get(Calendar.YEAR), 6, 1);
                } else if (nMonth == 10 || nMonth == 11 || nMonth == 12) {
                    gc = new GregorianCalendar(gc.get(Calendar.YEAR), 9, 1);
                }
                if (strOption == WFSConstant.CONST_TYPE_WEEK) {
                    int dayOfWeek = gc.get(Calendar.DAY_OF_WEEK);
                    gc.add(Calendar.DATE, -dayOfWeek + weekDate);
                }
                startDate = convertDateToString(gc);
            } else if (strReportDuration == WFSConstant.CONST_DURATION_LAST_YEAR) {
                endDate = convertDateToString(gc);
                gc.add(Calendar.YEAR, -1);
                nMonth = gc.get(Calendar.MONTH) + 1;
                if (strOption == WFSConstant.CONST_TYPE_WEEK) {
                    int dayOfWeek = gc.get(Calendar.DAY_OF_WEEK);
                    gc.add(Calendar.DATE, -dayOfWeek + weekDate);
                }
                if (strOption == WFSConstant.CONST_TYPE_QUARTER) {
                    if (nMonth == 1 || nMonth == 2 || nMonth == 3) {
                        gc = new GregorianCalendar(gc.get(Calendar.YEAR), 0, 1);
                    } else if (nMonth == 4 || nMonth == 5 || nMonth == 6) {
                        gc = new GregorianCalendar(gc.get(Calendar.YEAR), 3, 1);
                    } else if (nMonth == 7 || nMonth == 8 || nMonth == 9) {
                        gc = new GregorianCalendar(gc.get(Calendar.YEAR), 6, 1);
                    } else if (nMonth == 10 || nMonth == 11 || nMonth == 12) {
                        gc = new GregorianCalendar(gc.get(Calendar.YEAR), 9, 1);
                    }
                }
                if (strOption == WFSConstant.CONST_TYPE_MONTH || strOption == WFSConstant.CONST_TYPE_QUARTER) {
                    gc.set(Calendar.DATE, 1);
                }
                startDate = convertDateToString(gc);
            }
            startDate = startDate.substring(0, startDate.indexOf(' '));
            endDate = endDate.substring(0, endDate.indexOf(' '));
            strStartDateTime = startDate + " " + startTime;
            strEndDateTime = endDate + " " + endTime;
        } catch (Exception ex) {
            printErr(engine,"", ex);
        }
        return new String[]{strStartDateTime, strEndDateTime};
    }
    public static int getLastDateOfMonth(int iMonth, int iYear) {
        Calendar calendar = Calendar.getInstance();
        calendar.set(iYear, iMonth - 1, 1);
        return calendar.getActualMaximum(Calendar.DAY_OF_MONTH);
    }
    public static long daysBetween(Date d1, Date d2) {
        return ((d2.getTime() - d1.getTime() + ONE_HOUR) / (ONE_HOUR * 24));
    }
    public static String DATEADD(int unit, String no, String date, int dbType) {
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                return sqlDateAdd(unit, no, date);
            case JTSConstant.JTS_ORACLE:
                return oraDateAdd(unit, no, date);
            case JTSConstant.JTS_POSTGRES:
                return postgresDateAdd(unit, no, date);
            case JTSConstant.JTS_DB2:
                return db2DateAdd(unit, no, date);
            default:
                return sqlDateAdd(unit, no, date);
        }
    }
    public static String concatTimeFunc(int iHrs, int iMins) {
        String strTime = "";
        String strAM_PM = "";
        String strMins = "";
        if (iHrs == 0) {
            iHrs = 12;
            strAM_PM = "am";
        } else if (iHrs == 12) {
            strAM_PM = "pm";
        } else if (iHrs > 12) {
            iHrs = iHrs - 12;
            strAM_PM = "pm";
        } else {
            strAM_PM = "am";
        }

        if (iMins == 0) {
            strMins = "00";
        } else if (iMins == 30) {
            strMins = "30";
        }

        strTime = strTime.concat(String.valueOf(iHrs));
        strTime = strTime.concat(":" + strMins + " " + strAM_PM);
        return strTime;
    }
    private static String postgresDateTrunc(int unit, String date) {
        switch (unit) {
            case WFSConstant.WFL_yy:
                return "date_trunc('Year', " + date + ")";
            case WFSConstant.WFL_qq:
                return "date_trunc('Quarter', " + date + ")";
            case WFSConstant.WFL_mm:
                return "date_trunc('Month', " + date + ")";
            case WFSConstant.WFL_wk:

            case WFSConstant.WFL_dd:
                return "date_trunc('day', " + date + ")";
            case WFSConstant.WFL_hh:
                return "date_trunc('Hour', " + date + ")";
            default:
                return "date_trunc('day', " + date + ")";
        }
    }

    private static String postgresDateCeil(int unit, String date) {
        switch (unit) {
            case WFSConstant.WFL_yy:
                return "date_trunc('Year', " + date + ") + '1 year' - interval '1 day' ";
            case WFSConstant.WFL_qq:
                return "date_trunc('Quarter', " + date + ") + '3 Months' - interval '1 day' ";
            case WFSConstant.WFL_mm:
                return "date_trunc('Month', " + date + ") + '1 Months' - interval '1 day' ";
            case WFSConstant.WFL_wk:

            case WFSConstant.WFL_dd:
                return "date_trunc('day', " + date + ")";
            case WFSConstant.WFL_hh:
                return "date_trunc('Hour', " + date + ") + '0 0:59:59' ";
            default:
                return "date_trunc('day', " + date + ")";

        }
    }

    /**
     * *************************************************************
     * Function Name    :   db2DateAdd
     * Programmer' Name :   Virochan Dev
     * Date Written     :   July 10th 2006
     * Input Parameters :   int -> unit
     *                      String -> no
     *                      String -> date
     * Output Parameters:   NONE
     * Return Value     :   String -> resultant date.
     * Description      :   To add some quatity of some unit in date.
     * *************************************************************
     */
    private static String db2DateAdd(int unit, String no, String date) {
        switch (unit) {
            case WFSConstant.WFL_yy:
                return date + " + (" + no + ") YEARS ";
            case WFSConstant.WFL_qq:
                return date + " + (" + no + " * 3) MONTHS ";
            case WFSConstant.WFL_mm:
                return date + " + (" + no + ") MONTHS ";
            case WFSConstant.WFL_wk:
                return date + " + (" + no + " * 7) DAYS ";
            case WFSConstant.WFL_dd:
                return date + " + (" + no + ") DAYS ";
            case WFSConstant.WFL_hh:
                return date + " + (" + no + ") HOURS ";
            case WFSConstant.WFL_mi:
                return date + " + (" + no + ") MINUTES ";
            case WFSConstant.WFL_ss:
                return date + " + (" + no + ") SECONDS ";
            case WFSConstant.WFL_ms:
                return date + " + (" + no + ") MICROSECONDS ";
            default:
                return date + " + (" + no + ") DAYS ";
        }
    }

    /**
     * *************************************************************
     * Function Name    :   sqlDateAdd
     * Programmer' Name :
     * Date Written     :
     * Input Parameters :   int -> unit
     *                      String -> no
     *                      String -> date
     * Output Parameters:   NONE
     * Return Value     :   String -> resultant date.
     * Description      :   To add some quatity of some unit in date.
     * *************************************************************
     */
    private static String sqlDateAdd(int unit, String no, String date) {
        switch (unit) {
            case WFSConstant.WFL_yy:
                return " DATEADD ( yy," + no + ", " + date + ") ";
            case WFSConstant.WFL_qq:
                return " DATEADD ( qq," + no + ", " + date + ") ";
            case WFSConstant.WFL_mm:
                return " DATEADD ( mm," + no + ", " + date + ") ";
            case WFSConstant.WFL_dd:
                return " DATEADD ( dd," + no + ", " + date + ") ";
            case WFSConstant.WFL_wk:
                return " DATEADD ( wk," + no + ", " + date + ") ";
            case WFSConstant.WFL_hh:
                return " DATEADD ( hh," + no + ", " + date + ") ";
            case WFSConstant.WFL_mi:
                return " DATEADD ( mi," + no + ", " + date + ") ";
            case WFSConstant.WFL_ss:
                return " DATEADD ( ss," + no + ", " + date + ") ";
            case WFSConstant.WFL_ms:
                return " DATEADD ( ms," + no + ", " + date + ") ";
            default:
                return " DATEADD ( dd," + no + ", " + date + ") ";
        }
    }

    /**
     * *************************************************************
     * Function Name    :   oraDateAdd
     * Programmer' Name :
     * Date Written     :
     * Input Parameters :   int -> unit
     *                      String -> no
     *                      String -> date
     * Output Parameters:   NONE
     * Return Value     :   String -> resultant date.
     * Description      :   To add some quatity of some unit in date.
     * *************************************************************
     */
    private static String oraDateAdd(int unit, String no, String date) {
        switch (unit) {
            case WFSConstant.WFL_yy:
                return date + "+" + no + "*" + 365;
            case WFSConstant.WFL_qq:

//StringBuffer tempStr=new StringBuffer(100);
//tempStr.append();
//for (int i=0;i<Integer.parseInt(no);i++)
//	tempStr.append("add_months("+tempStr.toString()+",3)");
                return " add_months(" + date + "," + no + "*3) ";
//return date +"+"+no+"*"+365/4;
            case WFSConstant.WFL_mm:
                return " add_months(" + date + "," + no + ") ";
            case WFSConstant.WFL_dd:
                return date + "+" + no;
            case WFSConstant.WFL_wk:
                return date + "+" + no + "*" + 7;
            case WFSConstant.WFL_hh:
                return date + "+" + no + "/" + 24;
            case WFSConstant.WFL_mi:
                return date + "+" + no + "/" + 1440;
            case WFSConstant.WFL_ss:
                return date + "+" + no + "/" + 86400;
            case WFSConstant.WFL_ms:
                return date + "+" + no + "/" + 86400000;
            default:
                return date + "+" + no;
        }
    }

    /**
     * *************************************************************
     * Function Name    :   postgresDateAdd
     * Programmer' Name :   Varun Bhansaly
     * Date Written     :   15/11/2007
     * Input Parameters :   int -> unit
     *                      String -> no
     *                      String -> date
     * Output Parameters:   NONE
     * Return Value     :   String -> resultant date.
     * Description      :   To add some quatity of some unit in date.
     * *************************************************************
     */
    private static String postgresDateAdd(int unit, String no, String date) {
        //   Bugzilla Bug 13207
        String timeStamp = date.trim();
        if(!timeStamp.equalsIgnoreCase(WFSUtil.getDate(JTSConstant.JTS_POSTGRES).trim())){
            if(timeStamp.equalsIgnoreCase("ScheduleTime"))
               timeStamp =  date;
            else
               timeStamp = " TIMESTAMP " + date; 
        }    
        switch (unit) {
            case WFSConstant.WFL_yy:
                return timeStamp + " + INTERVAL ' " + no + " YEAR '";
            case WFSConstant.WFL_qq:
                return timeStamp + " + INTERVAL ' " + " 1 MONTH ' " + " * INT '3'";
            case WFSConstant.WFL_mm:
                return timeStamp + " + INTERVAL ' " + no + " MONTH '";
            case WFSConstant.WFL_dd:
                return timeStamp + " + INTERVAL ' " + no + " DAY '";
            case WFSConstant.WFL_wk:
                return timeStamp + " + INTERVAL ' " + no + " WEEK '";
            case WFSConstant.WFL_hh:
                return timeStamp + " + INTERVAL ' " + no + " HOUR '";
            case WFSConstant.WFL_mi:
                return timeStamp + " + INTERVAL ' " + no + " MINUTE '";
            case WFSConstant.WFL_ss:
                return timeStamp + " + INTERVAL ' " + no + " SECOND '";
            case WFSConstant.WFL_ms:
                return timeStamp + " + INTERVAL ' " + no + " SECOND '" + " / INT '1000'";
            default:
                return timeStamp + " + INTERVAL ' " + no + " DAY '";
        }
    }

    /**
     * *************************************************************
     * Function Name    :   DATEPART
     * Programmer' Name :   Virochan Dev
     * Date Written     :
     * Input Parameters :   int -> unit
     *                      String -> date
     *						int -> dbType
     * Output Parameters:   NONE
     * Return Value     :   String -> date part.
     * Description      :   Returns the required date part from date.
     * *************************************************************
     */
    public static String DATEPART(int unit, String date, int dbType) {
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                return sqlDatePart(unit, date);
            case JTSConstant.JTS_ORACLE:
                return oraDatePart(unit, date);
            case JTSConstant.JTS_POSTGRES:
                return postgresDatePart(unit, date);
            case JTSConstant.JTS_DB2:
                return db2DatePart(unit, date);
            default:
                return sqlDatePart(unit, date);
        }
    }

    /**
     * *************************************************************
     * Function Name    :   db2DatePart
     * Programmer' Name :   Virochan Dev
     * Date Written     :   July 10th 2006
     * Input Parameters :   int -> unit
     *                      String -> date
     * Output Parameters:   NONE
     * Return Value     :   String -> date part.
     * Description      :   Returns the required date part from date.
     * *************************************************************
     */
    private static String db2DatePart(int unit, String date) {
        switch (unit) {
            case WFSConstant.WFL_yy:
                return " YEAR (" + date + ")";
            case WFSConstant.WFL_qq:
                return " QUARTER (" + date + ")";
            case WFSConstant.WFL_mm:
                return " MONTH (" + date + ")";
            case WFSConstant.WFL_dd:
                return " DAY (" + date + ") ";
            case WFSConstant.WFL_wk:
                return " WEEK (" + date + ") ";
            case WFSConstant.WFL_dy:
                return " DAYOFYEAR (" + date + ") ";
            case WFSConstant.WFL_dw:
                return " DAYOFWEEK (" + date + ") ";
            case WFSConstant.WFL_hh:	//SrNo-3. Hourly Report Support

                return " HOUR (" + date + ") ";
        }
        return "";
    }

    /**
     * *************************************************************
     * Function Name    :	sqlDatePart
     * Programmer' Name :
     * Date Written     :
     * Input Parameters :   int -> unit
     *                      String -> date
     * Output Parameters:   NONE
     * Return Value     :   String -> resultant date.
     * Description      :   To add some quatity of some unit in date.
     * *************************************************************
     */
    private static String sqlDatePart(int unit, String date) {
        switch (unit) {
            case WFSConstant.WFL_yy:
                return " DATEPART ( yy," + date + ") ";
            case WFSConstant.WFL_qq:
                return " DATEPART ( qq," + date + ") ";
            case WFSConstant.WFL_mm:
                return " DATEPART ( mm," + date + ") ";
            case WFSConstant.WFL_dd:
                return " DATEPART ( dd," + date + ") ";
            case WFSConstant.WFL_wk:
                return " DATEPART ( wk," + date + ") ";
            case WFSConstant.WFL_dy:
                return " DATEPART ( dy," + date + ") ";
            case WFSConstant.WFL_dw:
                return " DATEPART ( dw," + date + ") ";
            case WFSConstant.WFL_hh:	//SrNo-3. Hourly Report Support

                return " DATEPART ( hh," + date + ") ";
        }
        return "";
    }

    /**
     * *************************************************************
     * Function Name    :	oraDatePart
     * Programmer' Name :
     * Date Written     :
     * Input Parameters :   int -> unit
     *                      String -> date
     * Output Parameters:   NONE
     * Return Value     :   String -> resultant date.
     * Description      :   To add some quatity of some unit in date.
     * *************************************************************
     */
    private static String oraDatePart(int unit, String date) {
        switch (unit) {
            case WFSConstant.WFL_yy:
                return " to_number(to_char(" + date + " ,'yyyy'),'999999') ";
            case WFSConstant.WFL_qq:
                return " to_number(to_char(" + date + " , 'q'),'999999') ";
            case WFSConstant.WFL_mm:
                return " to_number( to_char(" + date + " , 'mm'),'999999') ";
            case WFSConstant.WFL_dd:
                return " to_number ( to_char(" + date + " , 'dd'), '999999') ";
            case WFSConstant.WFL_wk:
                return " to_number ( to_char(" + date + ", 'ww'), '999999') ";
            case WFSConstant.WFL_dy:
                return " to_number( to_char(" + date + ", 'ddd'), '999999') ";
            case WFSConstant.WFL_dw:
                return " to_number( to_char(" + date + ",'d'), '999999') ";
            case WFSConstant.WFL_hh:			//SrNo-3. Hourly Report Support

                return " to_number( to_char(" + date + ",'hh24'), '999999') ";
        }
        return "";
    }

    /**
     * *************************************************************
     * Function Name    :	postgresDatePart
     * Programmer' Name :   Varun Bhansaly
     * Date Written     :   15/11/2007
     * Input Parameters :   int -> unit
     *                      String -> date
     * Output Parameters:   NONE
     * Return Value     :   String -> resultant date.
     * Description      :   To add some quatity of some unit in date.
     * *************************************************************
     */
    private static String postgresDatePart(int unit, String date) {
        switch (unit) {
            case WFSConstant.WFL_yy:
                return " EXTRACT(YEAR FROM " + date + ") ";
            case WFSConstant.WFL_qq:
                return " EXTRACT(QUARTER FROM " + date + ") ";
            case WFSConstant.WFL_mm:
                return " EXTRACT(MONTH FROM " + date + ") ";
            case WFSConstant.WFL_dd:
                return " EXTRACT(DAY FROM " + date + ") ";
            case WFSConstant.WFL_wk:
                return " EXTRACT(WEEK FROM " + date + ") ";
            case WFSConstant.WFL_dy:
                return " EXTRACT(DOY FROM " + date + ") ";
            case WFSConstant.WFL_dw:
                /* DOW -> {0, 1, 2, 3, 4, 5, 6} Mapped As {Sunday, Monday, ..., Saturday}
                 * In MSSQL & Oracle DOW -> {1, 2, 3, 4, 5, 6, 7} Mapped As {Sunday, Monday, ..., Saturday}
                 * Hence, 1 is added for compatibility .
                 * -Varun Bhansaly
                 */
                return " EXTRACT(DOW FROM " + date + ") + 1 ";
            case WFSConstant.WFL_hh:
                return " EXTRACT(HOUR FROM " + date + ") ";
        }
        return "";
    }

    public static String DATENAME(int unit, String date, int dbType) {
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                return sqlDateName(unit, date);
            case JTSConstant.JTS_ORACLE:
                return oraDateName(unit, date);
            case JTSConstant.JTS_POSTGRES:
                return postgresDateName(unit, date);
            case JTSConstant.JTS_DB2:
                return db2DateName(unit, date);
            default:
                return "";
        }
    }

    /**
     * *************************************************************
     * Function Name    :	sqlDateName
     * Programmer' Name :
     * Date Written     :
     * Input Parameters :   int -> unit
     *                      String -> date
     * Output Parameters:   NONE
     * Return Value     :   String -> date name.
     * Description      :   Returns the required date name from date.
     * *************************************************************
     */
    private static String sqlDateName(int unit, String date) {
        switch (unit) {
            case WFSConstant.WFL_yy:
                return " DATENAME ( yy," + date + ") ";
        }
        return "";
    }

    /**
     * *************************************************************
     * Function Name    :	oraDateName
     * Programmer' Name :
     * Date Written     :
     * Input Parameters :   int -> unit
     *                      String -> date
     * Output Parameters:   NONE
     * Return Value     :   String -> date name.
     * Description      :   Returns the required date name from date.
     * *************************************************************
     */
    private static String oraDateName(int unit, String date) {
        switch (unit) {
            case WFSConstant.WFL_yy:
                return "to_date(to_char(" + date + ",'yyyy') || ' 01' ,'yyyy mm')";
        }
        return "";
    }

    /** @todo DB2 */
    /**
     * *************************************************************
     * Function Name    :   db2DateName
     * Programmer' Name :   Ashish Mangla
     * Date Written     :   July 10th 2006
     * Input Parameters :   int -> unit
     *                      String -> date
     * Output Parameters:   NONE
     * Return Value     :   String -> date name.
     * Description      :   Returns the required date name from date.
     * *************************************************************
     */
    private static String db2DateName(int unit, String date) {
        switch (unit) {
            case WFSConstant.WFL_yy:
//                return "to_date(to_char(" + date + ",'yyyy') || ' 01' ,'yyyy mm')";
                return "TIMESTAMP(DATE(RTRIM(CHAR(YEAR(" + date + "))) || '001'), Time('00:00:00'))";
        }
        return "";
    }

    /**
     * *************************************************************
     * Function Name    :	postgresDateName
     * Programmer' Name :	Varun Bhansaly
     * Date Written     :   16/11/2007
     * Input Parameters :   int -> unit
     *                      String -> date
     * Output Parameters:   NONE
     * Return Value     :   String -> date name.
     * Description      :   Returns the required date name from date.
     * *************************************************************
     */
    private static String postgresDateName(int unit, String date) {
        switch (unit) {
            case WFSConstant.WFL_yy:
                return " EXTRACT(YEAR FROM TIMESTAMP " + date + ") ";
        }
        return "";
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 				:	TO_CHAR
//	Date Written (DD/MM/YYYY)	:	16/05/2002
//	Author						:	Advid
//	Input Parameters			:	String in , boolean isConst, int dbType
//	Output Parameters			:   none
//	Return Values				:	String
//	Description					:   returns the SQL char representation of the given value on the basis of the Database Type
//----------------------------------------------------------------------------------------------------
    public static String TO_CHAR(String in, int len, int dbType) throws JTSException {
        StringBuffer outputXml = new StringBuffer(100);
        switch (dbType) {
            case JTSConstant.JTS_MSSQL: {
                outputXml.append("CONVERT( varchar(" + len + ") , ");
                outputXml.append(in);
                outputXml.append(") ");
                break;
            }
            case JTSConstant.JTS_ORACLE: {
                outputXml.append(" TO_CHAR( ");
                outputXml.append(in);
                outputXml.append(",'999999') ");
                break;
            }
            case JTSConstant.JTS_POSTGRES: {
                outputXml.append(" TO_CHAR( ");
                outputXml.append(in);
                outputXml.append(",'999999') ");
                break;
            /*
            outputXml.append("CAST( ");
            outputXml.append(in);
            outputXml.append("AS VARCHAR(len)) ");
            break;
             */
            }
            case JTSConstant.JTS_DB2:
                return " CHAR((INT(ROUND(" + in + ",+0)))) ";
        }
        return outputXml.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 				:	TO_CHAR (for date conversion with style)
//	Date Written (DD/MM/YYYY)	:	16/05/2002
//	Author						:	Advid
//	Input Parameters			:	String in , boolean isConst, int dbType
//	Output Parameters			:   none
//	Return Values				:	String
//	Description					:   returns the SQL char representation of the Date with style on the basis of the Database Type
//----------------------------------------------------------------------------------------------------
    public static String TO_CHAR(String in, int len, int style, int dbType) throws JTSException {
        StringBuffer outputXml = new StringBuffer(100);
        switch (dbType) {
            case JTSConstant.JTS_MSSQL: {
                outputXml.append("CONVERT( varchar(" + len + ") , ");
                outputXml.append(in);
                outputXml.append("," + style);
                outputXml.append(") ");
                break;
            }
            case JTSConstant.JTS_ORACLE: {
                outputXml.append(" TO_CHAR( ");
                outputXml.append(in);
                outputXml.append(",'YYYY MM DD HH24:MI:SS') ");
                break;
            }
            case JTSConstant.JTS_POSTGRES: {
                /* If a string as '2007-11-16 09:40:07.714174+05:30' is provided as Input, it has to be typecasted as,
                 * timestamp '2007-11-16 09:40:07.714174+05:30' & used as
                 * TO_CHAR(timestamp '2007-11-16 09:40:07.714174+05:30', 'YYYY MM DD HH24:MI:SS')
                 * -Varun Bhansaly
                 */
                outputXml.append(" TO_CHAR( ");
                outputXml.append(in);
                outputXml.append(", 'YYYY MM DD HH24:MI:SS') ");
                break;
            }
            case JTSConstant.JTS_DB2:
                outputXml.append("VARCHAR_FORMAT(");
                outputXml.append(in);
                outputXml.append(",'YYYY-MM-DD HH24:MI:SS') ");
                break;
        }
        return outputXml.toString();
    }

    public static String DATEDIFF(int unit, String date1, String date2, int dbType) {
        String unitStr = "";
        float mult = 1F;
        int timeStampUnit;
        switch (unit) {
            case WFSConstant.WFL_yy:
                unitStr = "yy";
                mult = 1F / 365.25F;
                timeStampUnit = 256;
                break;
            case WFSConstant.WFL_qq:
                unitStr = "qq";
                mult = 4F / 365.25F;
                timeStampUnit = 128;
                break;
            case WFSConstant.WFL_mm:
                unitStr = "mm";
                mult = 12F / 365.25F;
                timeStampUnit = 64;
                break;
            case WFSConstant.WFL_dd:
                unitStr = "dd";
                mult = 1F;
                timeStampUnit = 16;
                break;
            case WFSConstant.WFL_wk:
                unitStr = "wk";
                mult = 1F / 7F;
                timeStampUnit = 32;
                break;
            case WFSConstant.WFL_hh:
                unitStr = "hh";
                mult = 24F;
                timeStampUnit = 8;
                break;
            case WFSConstant.WFL_mi:
                unitStr = "mi";
                mult = 1440F;
                timeStampUnit = 4;
                break;
            case WFSConstant.WFL_ss:
                unitStr = "ss";
                mult = 1440 * 60F;
                timeStampUnit = 2;
                break;
            case WFSConstant.WFL_ms:
                unitStr = "ms";
                mult = 1440 * 60 * 1000F;
                timeStampUnit = 1;
                break;
            default:
                unitStr = "hh";
                mult = 24F;
                timeStampUnit = 8;
        }
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                return " DATEDIFF( " + unitStr + ",  " + date1 + " ,  " + date2 + " ) ";
            case JTSConstant.JTS_ORACLE:
                return "(" + date2 + "-" + date1 + ")*" + mult;
            case JTSConstant.JTS_POSTGRES:
				return " date_part('days', AGE( To_TIMESTAMP(" + date2 + "::text " + ", 'YYYY-MM-DD HH24:MI:SS'), To_TIMESTAMP(" + date1 + "::text " + ", 'YYYY-MM-DD HH24:MI:SS') )*" + mult + " ) ";
            case JTSConstant.JTS_DB2:
                return " TIMESTAMPDIFF(" + timeStampUnit + ", CHAR(" + date2 + " -  " + date1 + " )) ";
            default:
                return " DATEDIFF( " + unitStr + ",  " + date1 + " ,  " + date2 + " ) ";
        }
    }


    private void getMappingCondition(PreparedStatement pstmt, String pinstId, int dbType, WFAttributedef attribDef, StringBuffer updateQuery, StringBuffer insertQuery,
            StringBuffer valueSting, HashMap currentValuesMap) throws SQLException {

        boolean condAdded = false;

        //pstmt = con.prepareStatement(" SELECT " + getFetchPrefixStr(dbType, 1) + " Var_Rec_1, Var_Rec_2, Var_Rec_3, Var_Rec_4, Var_Rec_5 FROM QueueDataTable"  + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceID = ? " + getFetchSuffixStr(dbType, 1, QUERY_STR_WHERE)) ;

        WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
        pstmt.execute();

        ResultSet rs = pstmt.getResultSet();

        StringTokenizer st = new StringTokenizer(attribDef.getKeyBuffer().toString(), string21, true);
        int counter = 1;
        String tempStr1 = null;
        String tempStr2 = "";
        WMAttribute oattr = null;

        while (st.hasMoreTokens()) {
            tempStr1 = st.nextToken();
            if (!tempStr1.equals("#")) {
                if (!condAdded) {
                    updateQuery.append(" WHERE ");
                    condAdded = true;
                } else {
                    updateQuery.append(" AND ");
                }

                updateQuery.append(tempStr1);
                insertQuery.append(tempStr1).append(" ,");
                tempStr2 = rs.getString(counter);
                oattr = (WMAttribute) currentValuesMap.get(tempStr1.trim().toUpperCase());
                if (oattr != null) {
                    tempStr2 = oattr.value;
                }

                if ((oattr == null && !rs.wasNull()) || oattr != null) {
                    updateQuery.append(" = ");
                    updateQuery.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                    valueSting.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                } else {
                    updateQuery.append(" IS NULL");
                    valueSting.append(" null");
                }

                valueSting.append(" ,");
            } else {
                rs.getString(counter);
                counter = counter + 1;
            }
        }

        if (rs != null) {
            rs.close();
            rs = null;
        }
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 				:	setAttributes
//	Date Written (DD/MM/YYYY)	:	28/06/2003
//	Author						    :	Prashant
//	Input Parameters			:	Connection con, WFParticipant participant, HashMap ipattributes,
//                          XMLParser parser, XMLGenerator gen
//	Output Parameters			: none
//	Return Values				  :	String
//	Description					  : Multiple attribute assignment.
//----------------------------------------------------------------------------------------------------
//			CHANGE HISTORY
//----------------------------------------------------------------------------------------------------
// Date						Change By		Change Description (Bug No. (If Any))
// (DD/MM/YYYY)
//	7/7/2004				Dinesh Parikh	WSE_I_5.0.1_693
//	17/02/2006				Ashish Mangla	WFS_6.1.2_056
//----------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------
    public static void setAttributes(Connection con, WFParticipant participant,
            HashMap ipattributes,
            String engine, String pinstId, int workItemID,
            XMLGenerator gen, String targetActivity) throws
            JTSException,
            WFSException {
        /* 07/11/2007, SrNo-10, new signature for setAttributes (sync routing mode). - Ruhi Hira */
        setAttributes(con, participant, ipattributes, engine, pinstId, workItemID,
                gen, targetActivity, false);

    }

    public static void setAttributes(Connection con, WFParticipant participant, HashMap ipattributes,
            String engine, String pinstId, int workItemID, XMLGenerator gen, String targetActivity,
            boolean internalServerFlag)
            throws JTSException, WFSException {
    	setAttributes(con, participant, ipattributes, engine, pinstId, workItemID, gen, targetActivity, internalServerFlag, 0,false);
    	/*
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        int mainCode = 0;
        int subCode = 0;
        String subject = null;
        String descr = null;
        String errType = WFSError.WF_TMP;
        boolean commit = false;	//WFS_6.1.2_054

        try {
            int dbType = ServerProperty.getReference().getDBType(engine);
            boolean b_tblset = false;
            String tableStr = "";
            StringBuffer queryStr = null;
            StringBuffer extqueryStr = null;
            ArrayList extQueryList = null;
            StringBuffer insqueryStr = null;
            StringBuffer valqueryStr = null;
            ArrayList valQueryList = null;
            HashMap success = new HashMap();
            Iterator iter = null;

            int userID = participant.getid();
            String username = participant.getname();

            String tableNameStr = null;
            *//** 02/12/2008, Bugzilla Bug 6991, prorityLevel not set for u type user in setAttributeExt. - Ruhi Hira *//*
            if ((participant.gettype() == 'P' && internalServerFlag) || (participant.gettype() == 'U')) {
                tableNameStr = " WorkInProcessTable ";
            } else {
                tableNameStr = " WorkwithPSTable ";
            }
            if (participant.gettype() == 'P') {
                userID = 0;
                username = "System";
                *//** 09/01/2008, Bugzilla Bug 3380, NOLOCK added to select queries - Ruhi Hira *//*
				//Process Variant Support Changes
                pstmt = con.prepareStatement(
                        " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, ProcessVariantId " + " from " + tableNameStr + " " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = ? ");
                WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                pstmt.setInt(2, workItemID);
                tableStr = "Update " + tableNameStr + " Set ";
            } else {
			//Process Variant Support Changes
                pstmt = con.prepareStatement(
                        " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, ProcessVariantId " + " from WorkinProcessTable " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = ? and Q_Userid = ? ");
                WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                pstmt.setInt(2, workItemID);
                pstmt.setInt(3, userID);
                tableStr = "Update WorkinProcessTable Set ";
            }
            pstmt.execute();
            rs = pstmt.getResultSet();
            if (!rs.next()) {
                *//** 10/11/2008, Bugzilla Bug 6924, API setAttributes should set attributes of locked workitems only - Ruhi Hira *//*
                if (participant.gettype() == 'P') {
                    rs.close();
                    rs = null;
                    pstmt.close();
                    pstmt = null;
//Process Variant Support Changes
                    pstmt = con.prepareStatement(
                            " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, ProcessVariantId " + " from WorklistTable " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = ?");
                    WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                    pstmt.setInt(2, workItemID);
                    tableStr = "Update WorklistTable Set ";
                    pstmt.execute();
                    rs = pstmt.getResultSet();
                    if (!rs.next()) {
                        rs.close();
                        rs = null;
                        pstmt.close();
                        pstmt = null;
//Process Variant Support Changes
                        pstmt = con.prepareStatement(
                                " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, ProcessVariantId " + " from PendingWorklistTable " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = ?");
                        WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                        pstmt.setInt(2, workItemID);
                        tableStr = "Update PendingWorklistTable Set ";
                        pstmt.execute();
                        rs = pstmt.getResultSet();
                        if (!rs.next()) {
                            //WFS_6.1.2_056
                            rs.close();
                            rs = null;
                            pstmt.close();
                            pstmt = null;

                            if (participant.gettype() == 'P') {
							//Process Variant Support Changes
                                pstmt = con.prepareStatement(
                                        " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, ProcessVariantId " + " from " + tableNameStr + " " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = ?");
                                WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                                pstmt.setInt(2, workItemID);
                                tableStr = "Update " + tableNameStr + " Set ";
                                pstmt.execute();
                                rs = pstmt.getResultSet();
                                if (!rs.next()) {
                                    rs.close();
                                    rs = null;
                                    pstmt.close();
                                    pstmt = null;

                                    mainCode = WFSError.WM_INVALID_WORK_ITEM;
                                    subCode = 0;
                                    subject = WFSErrorMsg.getMessage(mainCode);
                                    descr = WFSErrorMsg.getMessage(subCode);
                                    errType = WFSError.WF_TMP;
                                }
                            } else {
                                mainCode = WFSError.WM_INVALID_WORK_ITEM;
                                subCode = 0;
                                subject = WFSErrorMsg.getMessage(mainCode);
                                descr = WFSErrorMsg.getMessage(subCode);
                                errType = WFSError.WF_TMP;
                            }
                        }
                    }
                } else {
                    mainCode = WFSError.WM_INVALID_WORK_ITEM;
                    subCode = WFSError.WM_NOT_LOCKED;
                    ;
                    subject = WFSErrorMsg.getMessage(mainCode);
                    descr = WFSErrorMsg.getMessage(subCode);
                    errType = WFSError.WF_TMP;
                }
            }
            if (mainCode == 0) {
                int procDefID = rs.getInt(1);
                int activityId = rs.getInt(2);
                String actName = rs.getString(3);
                int parentWI = rs.getInt(4);
				int procVarId = rs.getInt(5);
                int referby = 0;

                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
                String workitemids = "";

                if (parentWI != 0) {
                    int newWorkitemID = workItemID;

                    //workitemids += parentWI;
                    pstmt = con.prepareStatement(
                            " Select ParentWorkItemID , ReferredBy from QueueDataTable " + WFSUtil.getTableLockHintStr(dbType) + " where " + " ProcessInstanceId = ? and WorkitemId = ? ");

                    while (true) {
                        WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                        pstmt.setInt(2, newWorkitemID);
                        pstmt.execute();
                        rs = pstmt.getResultSet();
                        if (rs.next()) {
                            parentWI = rs.getInt(1);
                            referby = rs.getInt(2);
                            rs.close();
                            rs = null;
                        } else {
                            rs.close();
                            rs = null;
                            break;
                        }
                        if (referby != 0) {
                            workitemids += workitemids.equals("") ? "" + parentWI : "," + parentWI;
                        }
                        newWorkitemID = parentWI;
                    }
                    pstmt.close();
                    pstmt = null;
                }

                int noOfAtt = ipattributes.size();

                if (noOfAtt > 0) {
                    //Changed by Ashish on 16/05/2005
                    WFAttributedef cacheAttr = (WFAttributedef) CachedObjectCollection.getReference().getCacheObject(con, engine, procDefID, WFSConstant.CACHE_CONST_Attribute, "" + (participant.gettype() == 'P' ? 0 : activityId+"#"+procVarId)).getData();

                    HashMap cachemap = cacheAttr.getAttribMap();
                    queryStr = new StringBuffer("Update QueueDataTable Set ");
                    extqueryStr = new StringBuffer();
                    extQueryList = new ArrayList();
                    insqueryStr = new StringBuffer();
                    valqueryStr = new StringBuffer();
                    valQueryList = new ArrayList();
                    String strTemp = "";
                    int extObjId = 0;
                    boolean updateS = false;
                    boolean updateE = false;
                    WMAttribute iattr = null;
                    WMAttribute oattr = null;

                    iter = ipattributes.values().iterator();
                    while (iter.hasNext()) {
                        iattr = (WMAttribute) (iter.next());
                        strTemp = iattr.value;
                        oattr = (WMAttribute) (cachemap.get(iattr.name.toUpperCase()));
                        if (oattr != null) {
                            if (oattr.scope == 'Q' || oattr.scope == 'U') {
                                success.put(iattr.name.toUpperCase(), new WMAttribute(iattr.name, iattr.value,
                                        oattr.type));
                                if (oattr.extObj == 0) {
                                    queryStr.append(oattr.name);
                                    queryStr.append(" = ");
                                    queryStr.append(WFSUtil.TO_SQL(iattr.value, oattr.type, dbType, true));
                                    queryStr.append(" ,");
                                    updateS = true;
                                } else {
                                    extqueryStr.append(oattr.name);
                                    insqueryStr.append(oattr.name);
                                    extqueryStr.append(" = ");
                                    if (oattr.type == WFSConstant.WF_NTEXT) {     //Changed for nText support Bug Id WFS_8.0_014

                                        extqueryStr.append(" ? ");
                                        extQueryList.add(iattr.value);
                                        valqueryStr.append(" ? ");
                                        valQueryList.add(iattr.value);
                                    } else {
                                        extqueryStr.append(WFSUtil.TO_SQL(iattr.value, oattr.type, dbType, true));
                                        valqueryStr.append(WFSUtil.TO_SQL(iattr.value, oattr.type, dbType, true));
                                    }

                                    extqueryStr.append(" ,");
                                    insqueryStr.append(" ,");
                                    valqueryStr.append(" ,");
                                    extObjId = oattr.extObj;
                                    updateE = true;
                                }
                                iter.remove();
                            } else if (oattr.scope == 'M') {
                                if (iattr.name.trim().equalsIgnoreCase("PRIORITYLEVEL")) {
                                    try {
                                        if (Integer.parseInt(iattr.value) > 0 &&
                                                Integer.parseInt(iattr.value) <= 4) {
                                            success.put(iattr.name,
                                                    new WMAttribute(iattr.name, iattr.value, oattr.type));
                                            tableStr += oattr.name;
                                            tableStr += " = ";
                                            tableStr += WFSUtil.TO_SQL(iattr.value, oattr.type, dbType, true);
                                            tableStr += " ,";
                                            b_tblset = true;
                                            iter.remove();
                                        }
                                    } catch (NumberFormatException ex) {
                                    }
                                } else {
                                    success.put(iattr.name, new WMAttribute(iattr.name, iattr.value, oattr.type));
                                    tableStr += oattr.name;
                                    tableStr += " = ";
                                    tableStr += WFSUtil.TO_SQL(iattr.value, oattr.type, dbType, true);
                                    tableStr += " ,";
                                    b_tblset = true;
                                    iter.remove();
                                }
                            }
                        }
                    }



                    if (updateE) {
                        extqueryStr = new StringBuffer("Update " + WFSExtDB.getTableName(engine, procDefID,
                                extObjId) + " Set " + extqueryStr.deleteCharAt(extqueryStr.length() - 1));

                        String tempStr2 = "";
                        String tempStr1 = "";
                        	Changed by Amul Jain on 28/08/2008	for WFS_6.2_033	
                        pstmt = con.prepareStatement(" SELECT Rec1,Var_Rec_1,Rec2,Var_Rec_2,Rec3,Var_Rec_3,Rec4,Var_Rec_4,Rec5,Var_Rec_5 FROM RecordMappingTable " + WFSUtil.getTableLockHintStr(dbType) + ",QueueDataTable " + WFSUtil.getTableLockHintStr(dbType) + " where RecordMappingTable.ProcessDefId = ? and ProcessInstanceID = ? and WorkitemID = ?");
                        pstmt.setInt(1, procDefID);
                        WFSUtil.DB_SetString(2, pinstId, pstmt, dbType);
                        pstmt.setInt(3, workItemID);
                        pstmt.execute();
                        rs = pstmt.getResultSet();
                        if (rs.next()) {
                            extqueryStr.append(" WHERE ");
                            tempStr1 = rs.getString(1);
                            if (!rs.wasNull() && !tempStr1.equals("")) {
                                extqueryStr.append(tempStr1);
                                insqueryStr.append(tempStr1);
                                insqueryStr.append(" ,");
                                tempStr2 = rs.getString(2);
                                oattr = (WMAttribute) success.get(tempStr1.trim().toUpperCase());
                                if (oattr == null) {
                                    if (!rs.wasNull()) {
                                        extqueryStr.append(" = ");
                                        extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                        valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    } else {
                                        extqueryStr.append(" IS NULL");
                                        valqueryStr.append(" null");
                                    }
                                } else {
                                    tempStr2 = oattr.value;
                                    extqueryStr.append(" = ");
                                    extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                }
                                valqueryStr.append(" ,");
                            }
                            tempStr1 = rs.getString(3);
                            if (!rs.wasNull() && !tempStr1.equals("")) {
                                extqueryStr.append(" AND ");
                                extqueryStr.append(tempStr1);
                                insqueryStr.append(tempStr1);
                                insqueryStr.append(" ,");
                                tempStr2 = rs.getString(4);
                                oattr = (WMAttribute) success.get(tempStr1.trim().toUpperCase());
                                if (oattr == null) {
                                    if (!rs.wasNull()) {
                                        extqueryStr.append(" = ");
                                        extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                        valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    } else {
                                        extqueryStr.append(" IS NULL");
                                        valqueryStr.append(" null");
                                    }
                                } else {
                                    tempStr2 = oattr.value;
                                    extqueryStr.append(" = ");
                                    extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                }
                                valqueryStr.append(" ,");
                            }
                            tempStr1 = rs.getString(5);
                            if (!rs.wasNull() && !tempStr1.equals("")) {
                                extqueryStr.append(" AND ");
                                extqueryStr.append(tempStr1);
                                insqueryStr.append(tempStr1);
                                insqueryStr.append(" ,");
                                tempStr2 = rs.getString(6);
                                oattr = (WMAttribute) success.get(tempStr1.trim().toUpperCase());
                                if (oattr == null) {
                                    if (!rs.wasNull()) {
                                        extqueryStr.append(" = ");
                                        extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                        valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    } else {
                                        extqueryStr.append(" IS NULL");
                                        valqueryStr.append(" null");
                                    }
                                } else {
                                    tempStr2 = oattr.value;
                                    extqueryStr.append(" = ");
                                    extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                }
                                valqueryStr.append(" ,");
                            }
                            tempStr1 = rs.getString(7);
                            if (!rs.wasNull() && !tempStr1.equals("")) {
                                extqueryStr.append(" AND ");
                                extqueryStr.append(tempStr1);
                                insqueryStr.append(tempStr1);
                                insqueryStr.append(" ,");
                                tempStr2 = rs.getString(8);
                                oattr = (WMAttribute) success.get(tempStr1.trim().toUpperCase());
                                if (oattr == null) {
                                    if (!rs.wasNull()) {
                                        extqueryStr.append(" = ");
                                        extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                        valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    } else {
                                        extqueryStr.append(" IS NULL");
                                        valqueryStr.append(" null");
                                    }
                                } else {
                                    tempStr2 = oattr.value;
                                    extqueryStr.append(" = ");
                                    extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                }
                                valqueryStr.append(" ,");
                            }
                            tempStr1 = rs.getString(9);
                            if (!rs.wasNull() && !tempStr1.equals("")) {
                                extqueryStr.append(" AND ");
                                extqueryStr.append(tempStr1);
                                insqueryStr.append(tempStr1);
                                insqueryStr.append(" ,");
                                tempStr2 = rs.getString(10);
                                oattr = (WMAttribute) success.get(tempStr1.trim().toUpperCase());
                                if (oattr == null) {
                                    if (!rs.wasNull()) {
                                        extqueryStr.append(" = ");
                                        extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                        valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    } else {
                                        extqueryStr.append(" IS NULL");
                                        valqueryStr.append(" null");
                                    }
                                } else {
                                    tempStr2 = oattr.value;
                                    extqueryStr.append(" = ");
                                    extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                }
                                valqueryStr.append(" ,");
                            }
                            pstmt.close();
                            pstmt = null;
                        }
                    }
                    if (con.getAutoCommit()) {
                        con.setAutoCommit(false);
                        commit = true; //mean yah per false kiya gaya hai.

                    }
                    if (b_tblset) {
                        tableStr = tableStr.substring(0,
                                tableStr.length() - 1) +
                                " where ProcessInstanceID = ? and ( Workitemid = ? " + (workitemids.equals("") ? "" : "OR Workitemid in (" + workitemids + ")") +
                                ")";
                        pstmt = con.prepareStatement(tableStr);
                        WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                        pstmt.setInt(2, workItemID);
                        pstmt.executeUpdate();

                    }
                    if (updateS) {
                        queryStr.deleteCharAt(queryStr.length() -
                                1).append(" where ProcessInstanceID = ? and ( Workitemid = ? " +
                                (workitemids.equals("") ? "" : "OR Workitemid in (" + workitemids + ")") +
                                ")");
                        pstmt = con.prepareStatement(queryStr.toString());
                        WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                        pstmt.setInt(2, workItemID);
                        pstmt.executeUpdate();
                    }
                    if (pstmt != null) {
                        pstmt.close();
                        pstmt = null;
                    }
                    if (updateE) {

                        pstmt = con.prepareStatement(extqueryStr.toString());     //Changed for nText support Bug Id WFS_8.0_014

                        Iterator it = extQueryList.iterator();
                        int iListCount = 1;
                        while (it.hasNext()) {
                            String strListElement = (String) it.next();
							//	WFS_9.0_002
                            if(strListElement == null)
                                strListElement = "";
                            pstmt.setCharacterStream(iListCount, new StringReader(strListElement), strListElement.length());
                            iListCount++;
                        }
                        int res = pstmt.executeUpdate();
                        if (res == 0) {
                            pstmt = con.prepareStatement(" Insert into " + WFSExtDB.getTableName(engine,
                                    procDefID,
                                    extObjId) + " (" + insqueryStr.deleteCharAt(insqueryStr.length() - 1) +
                                    ") VALUES (" + valqueryStr.deleteCharAt(valqueryStr.length() - 1) +
                                    ")");
                            //Changed for nText support Bug Id WFS_8.0_014
                            Iterator it1 = valQueryList.iterator();
                            int iListCount1 = 1;
                            while (it.hasNext()) {
                                String strListElement = (String) it1.next();
								//	WFS_9.0_002
                                if(strListElement == null)
                                    strListElement = "";
                                pstmt.setCharacterStream(iListCount1, new StringReader(strListElement), strListElement.length());
                                iListCount1++;
                            }
                            res = pstmt.executeUpdate();
                        }
                    }

                    if (!con.getAutoCommit() && commit) {	//WFS_6.1.2_054

                        con.commit();
                        con.setAutoCommit(true);
                        commit = false;	//Bugzilla Bug 1671

                    }
                    iter = success.values().iterator();
                    StringBuffer strMessage = new StringBuffer(100);
                    int cnt = 0;
                    while (iter.hasNext()) {
                        if (cnt++ == 0) {
                            strMessage.append("<Attributes>");
                        }
                        oattr = (WMAttribute) iter.next();
                        actName = participant.gettype() == 'P' && targetActivity != null &&
                                !targetActivity.equals("") ? targetActivity : actName;
                        strMessage.append("<Attribute>");
                        strMessage.append("<Name>");
                        strMessage.append(oattr.name);
                        strMessage.append("</Name><Value>");
                        strMessage.append(oattr.value);
                        strMessage.append("</Value>");
                        strMessage.append("</Attribute>");
                    }
                    
                    Changed By : Ruhi Hira
                    Changed On : 24th Set 2004
                    Description: To handle invalid message.
                     
                    if (cnt > 0) {
                        strMessage.append("</Attributes>");
                        WFSUtil.generateLog(engine, con, WFSConstant.WFL_Attribute_Set, pinstId, workItemID,
                                procDefID, activityId, actName, 0, userID, username, 0, strMessage.toString(),
                                null, null, null, null);
                    }
                }
            }
        } catch (SQLException e) {
            printErr(engine,"", e);
            mainCode = WFSError.WM_INVALID_FILTER;
            subCode = WFSError.WFS_SQL;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_FAT;
            if (e.getErrorCode() == 0) {
                if (e.getSQLState().equalsIgnoreCase("08S01")) {
                    descr = (new JTSSQLError(e.getSQLState())).getMessage() + "(SQL State : " +
                            e.getSQLState() + ")";
                }
            } else {
                descr = e.getMessage();
            }
        } catch (NumberFormatException e) {
            printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_ILP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch (NullPointerException e) {
            printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_SYS;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch (JTSException e) {
            printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = e.getErrorCode();
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.getMessage();
        } catch (Exception e) {
            printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch (Error e) {
            printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } finally {
            try {
                if (!con.getAutoCommit() && commit) {			//WFS_6.1.2_054

                    con.rollback();
                    con.setAutoCommit(true);
                }
            } catch (Exception e) {
            }
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (SQLException sqle) {
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
            } catch (SQLException sqle) {
            }

            if (mainCode != 0) {
                throw new WFSException(mainCode, subCode, errType, subject, descr);
            }
        }
    */} // setAttributes


    /** sample xml for attributeXML for this method.
     * <attributes>
     *      <attribName1>attribValue1</attribName1>             // root level attributes are from VarMappingTable inner join ActivityAssociationTable
     *      <attribName2>attribValue1</attribName2>
     *      <attribName3>
     *          <fieldName31>fieldValue31</fieldName31>
     *          <fieldName32>fieldValue32</fieldName32>
     *          <fieldName33>fieldValue33</fieldName33>
     *      </attribName3>
     *      <attribName4>attribValue4</attribName4>
     *      <attribName5>
     *          <fieldName51>fieldValue31</fieldName51>
     *          <fieldName52>fieldValue32</fieldName52>
     *          <fieldName53>fieldValue33_1</fieldName53>       // this is an array
     *          <fieldName53>fieldValue33_2</fieldName53>
     *          <fieldName53>fieldValue33_3</fieldName53>
     *          <fieldName54>                                   // this is a complex structure in a complex structure
     *              <fieldName541>fieldValue31</fieldName541>
     *              <fieldName542>fieldValue32</fieldName542>
     *              <fieldName543>fieldValue33</fieldName543>
     *          </fieldName54>
     *      </attribName5>
     * </attributes>
     */
    //  Change Description          : Changes for Code Optimization-Merging of WorkFlow 
    //								  tables to WFInstrumentTable and logging of Query
    //  Changed by					: Mohnish Chopra  
    public static void setAttributes(Connection con, WFParticipant participant, HashMap ipattributes,
            String engine, String pinstId, int workItemID, XMLGenerator gen, String targetActivity,
            boolean internalServerFlag,int sessionId, boolean debugFlag)
            throws JTSException, WFSException {
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        PreparedStatement pstmt1 = null;
        ResultSet rs1 = null;
        int mainCode = 0;
        int subCode = 0;
        String subject = null;
        String descr = null;
        String errType = WFSError.WF_TMP;
        boolean commit = false;	//WFS_6.1.2_054
        String filterString = null;
        String query = null;
        try {
            int dbType = ServerProperty.getReference().getDBType(engine);
            boolean b_tblset = false;
            String tableStr = "";
            StringBuffer queryStr = null;
            StringBuffer extqueryStr = null;
            ArrayList extQueryList = null;
            StringBuffer insqueryStr = null;
            StringBuffer valqueryStr = null;
            ArrayList valQueryList = null;
            HashMap success = new HashMap();
            Iterator iter = null;
            ArrayList parameters = new ArrayList();
            int userID = participant.getid();
            String username = participant.getname();
        	int taskId = WFTaskThreadLocal.get();
        	
            String tableNameStr = null;
            tableNameStr = " WFInstrumentTable ";
            tableStr= " Update WFInstrumentTable set "; 
            boolean queuehistorydata=false;
            String extTableName=null;
            String extTableName_history=null;
            String queryStr3=null;
            boolean foundHistoryTable=false;

            /** 02/12/2008, Bugzilla Bug 6991, prorityLevel not set for u type user in setAttributeExt. - Ruhi Hira */
  /*          if ((participant.gettype() == 'P' && internalServerFlag) || (participant.gettype() == 'U')) {
                tableNameStr = " WorkInProcessTable ";
            } else {
                tableNameStr = " WorkwithPSTable ";
            }*/
            if ((participant.gettype() == 'P' && internalServerFlag) ) {
                filterString = " RoutingStatus ='Y' and LockStatus='Y'  ";
            } 
            else if((participant.gettype() == 'U')){
            	filterString = "  RoutingStatus in ( 'N', 'R' ) and LockStatus ='Y'  ";
            }
            else {
            	filterString = " RoutingStatus='Y' and LockStatus ='Y' ";
            }
            if(taskId > 0){
            	filterString = "  RoutingStatus='N'  " ;
            }
            if (participant.gettype() == 'P') {
                userID = 0;
                username = "System";
                query=" Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, ProcessVariantId,SecondaryDBFlag , ActivityType  " + " from " + tableNameStr + " " 
                + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = ? and " + filterString;
                /** 09/01/2008, Bugzilla Bug 3380, NOLOCK added to select queries - Ruhi Hira */
                pstmt = con.prepareStatement(WFSUtil.TO_SANITIZE_STRING(query,true));
                WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                pstmt.setInt(2, workItemID);
                parameters.add(pinstId);
                parameters.add(workItemID);
/*                tableStr = "Update " + tableNameStr + " Set ";
*/            } 
            else if(taskId>0){
				query= " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, ProcessVariantId,SecondaryDBFlag , ActivityType  " + " from " + tableNameStr + " " 
						+ WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = ? and " + filterString;
                pstmt = con.prepareStatement(WFSUtil.TO_SANITIZE_STRING(query,true));
                WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                pstmt.setInt(2, workItemID);
                parameters.add(pinstId);
                parameters.add(workItemID);
/*                tableStr = "Update WorkinProcessTable Set ";
*/            }
            else {
				query= " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, ProcessVariantId,SecondaryDBFlag , ActivityType " + " from " + tableNameStr + " " 
						+ WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = ? and Q_Userid = ? and " + filterString;
                pstmt = con.prepareStatement(WFSUtil.TO_SANITIZE_STRING(query,true));
                WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                pstmt.setInt(2, workItemID);
                pstmt.setInt(3, userID);
                parameters.add(pinstId);
                parameters.add(workItemID);
                parameters.add(userID);
/*                tableStr = "Update WorkinProcessTable Set ";
*/            }
/*            pstmt.execute();
*/    			WFSUtil.jdbcExecute(pinstId, sessionId, userID, query, pstmt, parameters,debugFlag, engine)	;
				rs = pstmt.getResultSet();
				parameters.clear();
				if (!rs.next()) {
                /** 10/11/2008, Bugzilla Bug 6924, API setAttributes should set attributes of locked workitems only - Ruhi Hira */
					if (participant.gettype() == 'P') {
						rs.close();
						rs = null;
						pstmt.close();
						pstmt = null;
						query = " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, ProcessVariantId,SecondaryDBFlag , ActivityType " 
							+ " from WFInstrumentTable " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = ?";
						pstmt = con.prepareStatement(WFSUtil.TO_SANITIZE_STRING(query,true));
						WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
						pstmt.setInt(2, workItemID);
						parameters.add(pinstId);
						parameters.add(workItemID);
						/*                    tableStr = "Update WorklistTable Set ";
						 */
						WFSUtil.jdbcExecute(pinstId, sessionId, userID, query, pstmt, parameters, debugFlag, engine);
/*						   pstmt.execute();
*/						 rs = pstmt.getResultSet();
						 if (!rs.next()) {

							 if(rs!=null){
								 rs.close();
								 rs = null;
							 }
							 pstmt.close();
							 pstmt = null;

							 mainCode = WFSError.WM_INVALID_WORK_ITEM;
							 subCode = 0;
							 subject = WFSErrorMsg.getMessage(mainCode);
							 descr = WFSErrorMsg.getMessage(subCode);
							 errType = WFSError.WF_TMP;

							 /*
                        rs.close();
                        rs = null;
                        pstmt.close();
                        pstmt = null;

                        pstmt = con.prepareStatement(
                                " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID " 
                        		+ " from PendingWorklistTable " + WFSUtil.getTableLockHintStr(dbType) 
                        		+ " where ProcessInstanceId = ? and WorkitemId = ? ");
                        WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                        pstmt.setInt(2, workItemID);
                        tableStr = "Update PendingWorklistTable Set ";
                        pstmt.execute();
                        rs = pstmt.getResultSet();
                        if (!rs.next()) {
                            //WFS_6.1.2_056
                            rs.close();
                            rs = null;
                            pstmt.close();
                            pstmt = null;

                            if (participant.gettype() == 'P') {
                                pstmt = con.prepareStatement(
                                        " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID " + " from " 
                                        + tableNameStr + " " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = ? ");
                                WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                                pstmt.setInt(2, workItemID);
                                tableStr = "Update " + tableNameStr + " Set ";
                                pstmt.execute();
                                rs = pstmt.getResultSet();
                                if (!rs.next()) {
                                    rs.close();
                                    rs = null;
                                    pstmt.close();
                                    pstmt = null;

                                    mainCode = WFSError.WM_INVALID_WORK_ITEM;
                                    subCode = 0;
                                    subject = WFSErrorMsg.getMessage(mainCode);
                                    descr = WFSErrorMsg.getMessage(subCode);
                                    errType = WFSError.WF_TMP;
                                }
                            } else {
                                mainCode = WFSError.WM_INVALID_WORK_ITEM;
                                subCode = 0;
                                subject = WFSErrorMsg.getMessage(mainCode);
                                descr = WFSErrorMsg.getMessage(subCode);
                                errType = WFSError.WF_TMP;
                            }
                        }
							  */}
					} else {
						
						if(rs!=null){
							rs.close();
							rs = null;
						}
						if(pstmt!=null){
							pstmt.close();
							pstmt = null;
						}
						query= " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, ProcessVariantId,SecondaryDBFlag , ActivityType " + " from " + " QueueHistoryTable " + " " 
								+ WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = ? and Q_Userid = ? and " + filterString;
		                pstmt = con.prepareStatement(WFSUtil.TO_SANITIZE_STRING(query,true));
		                WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
		                pstmt.setInt(2, workItemID);
		                pstmt.setInt(3, userID);
		                parameters.add(pinstId); 
		                parameters.add(workItemID);
		                parameters.add(userID);
		                WFSUtil.jdbcExecute(pinstId, sessionId, userID, query, pstmt, parameters,debugFlag, engine)	;
						rs = pstmt.getResultSet();
						parameters.clear();
						if (!rs.next()) {
							mainCode = WFSError.WM_INVALID_WORK_ITEM;
							subCode = WFSError.WM_NOT_LOCKED;
							subject = WFSErrorMsg.getMessage(mainCode);
							descr = WFSErrorMsg.getMessage(subCode);
							errType = WFSError.WF_TMP;
						}else{
							queuehistorydata=true;
							tableNameStr=" QueueHistoryTable ";
							tableStr= " Update QueueHistoryTable set "; 
						}
                }
            }

            if (mainCode == 0 && rs!=null) {
                int procDefID = rs.getInt(1);
                int activityId = rs.getInt(2);
                String actName = rs.getString(3);
                int parentWI = rs.getInt(4);
				int procVarId = rs.getInt(5);
				String secondaryDBStr = rs.getString(6);
				int activitytype=rs.getInt(7);
                int queryActivityId=0;
                if(activitytype==WFSConstant.ACT_EXT){
                	queryActivityId=getQueryActivityID(con,dbType,procDefID,userID,WFSConstant.ACT_QUERY);
                	if(queryActivityId>0){
                		activityId=queryActivityId;
                	}
                }
				boolean secondaryDBFlag="Y".equalsIgnoreCase(secondaryDBStr)||"D".equalsIgnoreCase(secondaryDBStr);
                int referby = 0;

                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
                String workitemids = "";
                if(secondaryDBFlag) {
                	String secondaryCabinetName=null;
                	Connection secondaryConn=null;
                	pstmt=con.prepareStatement("Select PropertyValue from WFSYSTEMPROPERTIESTABLE where PropertyKey = ?");
                    pstmt.setString(1,"SECONDARYCABINETNAME");
                    rs= pstmt.executeQuery();
                    if(rs.next()){
                    	secondaryCabinetName=WFSUtil.getFormattedString(rs.getString("PropertyValue"))	;
                    }else {
                         rs.close();
                         pstmt.close();
                         mainCode = WFSError.WF_SECONDARY_CABINET_NOT_SET;
                         subCode = 0;
                         subject = WFSErrorMsg.getMessage(mainCode);
                         descr = WFSErrorMsg.getMessage(subCode);
                         errType = WFSError.WF_TMP;
         			
                     	throw new WFSException(mainCode, subCode, errType, subject, descr);
                    }
                    
                    secondaryConn=WFSUtil.createConnectionToTargetCabinet(secondaryCabinetName,"FetchAttributesExt",engine);
                    if(secondaryConn!=null) {
                    	WFSUtil.printOut(engine,"Connection with Secondary Cabinet "+secondaryCabinetName+" is established.");
                    }
                    if(rs!=null) {
                    	rs.close();
                    	rs=null;
                    }
                    if(pstmt!=null) {
                    	pstmt.close();
                    	pstmt=null;
                    }
                    WFSSecondaryDBUtil.setAttributes(con, secondaryConn,participant, ipattributes,
                             engine, pinstId, workItemID, gen, targetActivity,
                             internalServerFlag,sessionId, debugFlag);
                     return ;
                }
                if (parentWI != 0) {
                    int newWorkitemID = workItemID;

                    //workitemids += parentWI;
                    query= " Select ParentWorkItemID , ReferredBy from WFInstrumentTable " + WFSUtil.getTableLockHintStr(dbType) 
                    + " where " + " ProcessInstanceId = ? and WorkitemId = ? ";
                    pstmt = con.prepareStatement(query);
                            /*" Select ParentWorkItemID , ReferredBy from QueueDataTable " + WFSUtil.getTableLockHintStr(dbType) 
                            + " where " + " ProcessInstanceId = ? and WorkitemId = ? ");
*/
                    while (true) {
                        WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                        pstmt.setInt(2, newWorkitemID);
                        WFSUtil.jdbcExecute(pinstId, sessionId, userID, query, pstmt, parameters, debugFlag, engine);
/*                        pstmt.execute();
*/                        rs = pstmt.getResultSet();
                        parameters.clear();
                        if (rs.next()) {
                            parentWI = rs.getInt(1);
                            referby = rs.getInt(2);
                            rs.close();
                            rs = null;
                        } else {
                            rs.close();
                            rs = null;
                            break;
                        }
                        if (referby != 0) {
                            workitemids += workitemids.equals("") ? "" + Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(parentWI),false)) : "," + Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(parentWI),false));
                        }
                        newWorkitemID = parentWI;
                    }
                    pstmt.close();
                    pstmt = null;
                }

                int noOfAtt = ipattributes.size();

                if (noOfAtt > 0) {
                    //Changed by Ashish on 16/05/2005
                    WFAttributedef cacheAttr = (WFAttributedef) CachedObjectCollection.getReference().getCacheObject(con, engine, procDefID, WFSConstant.CACHE_CONST_Attribute, "" + (participant.gettype() == 'P' ? 0 : activityId+string21+procVarId)).getData();

                    HashMap cachemap = cacheAttr.getAttribMap();
                    if(queuehistorydata){
                    	queryStr = new StringBuffer("Update QueueHistoryTable Set ");
                    }
                    else{
                    	 queryStr = new StringBuffer("Update WFInstrumentTable Set ");
                    }
                    extqueryStr = new StringBuffer();
                    extQueryList = new ArrayList();
                    insqueryStr = new StringBuffer();
                    valqueryStr = new StringBuffer();
                    valQueryList = new ArrayList();
                    String strTemp = "";
                    int extObjId = 0;
                    boolean updateS = false;
                    boolean updateE = false;
                    WMAttribute iattr = null;
                    WMAttribute oattr = null;

                    iter = ipattributes.values().iterator();
                    while (iter.hasNext()) {
                        iattr = (WMAttribute) (iter.next());
                        strTemp = iattr.value;
                        oattr = (WMAttribute) (cachemap.get(iattr.name.toUpperCase()));
                        if (oattr != null) {
                            if (oattr.scope == 'Q' || oattr.scope == 'U') {
                                success.put(iattr.name.toUpperCase(), new WMAttribute(iattr.name, iattr.value,
                                        oattr.type));
                                if (oattr.extObj == 0) {
                                    queryStr.append(oattr.name);
                                    queryStr.append(" = ");
                                    queryStr.append(WFSUtil.TO_SQL(iattr.value, oattr.type, dbType, true));
                                    queryStr.append(" ,");
                                    updateS = true;
                                } else {
                                    extqueryStr.append(oattr.name);
                                    insqueryStr.append(oattr.name);
                                    extqueryStr.append(" = ");
                                    if (oattr.type == WFSConstant.WF_NTEXT) {     //Changed for nText support Bug Id WFS_8.0_014

                                        extqueryStr.append(" ? ");
                                        extQueryList.add(iattr.value);
                                        valqueryStr.append(" ? ");
                                        valQueryList.add(iattr.value);
                                    } else {
                                        extqueryStr.append(WFSUtil.TO_SQL(iattr.value, oattr.type, dbType, true));
                                        valqueryStr.append(WFSUtil.TO_SQL(iattr.value, oattr.type, dbType, true));
                                    }

                                    extqueryStr.append(" ,");
                                    insqueryStr.append(" ,");
                                    valqueryStr.append(" ,");
                                    extObjId = oattr.extObj;
                                    updateE = true;
                                }
                                iter.remove();
                            } else if (oattr.scope == 'M') {
                                if (iattr.name.trim().equalsIgnoreCase("PRIORITYLEVEL")) {
                                    try {
                                        if (Integer.parseInt(iattr.value) > 0 &&
                                                Integer.parseInt(iattr.value) <= 4) {
                                            success.put(iattr.name,
                                                    new WMAttribute(iattr.name, iattr.value, oattr.type));
                                            tableStr += oattr.name;
                                            tableStr += " = ";
                                            tableStr += WFSUtil.TO_SQL(iattr.value, oattr.type, dbType, true);
                                            tableStr += " ,";
                                            b_tblset = true;
                                            iter.remove();
                                        }
                                    } catch (NumberFormatException ex) {
                                    }
                                } else {
                                    success.put(iattr.name, new WMAttribute(iattr.name, iattr.value, oattr.type));
                                    tableStr += oattr.name;
                                    tableStr += " = ";
                                    tableStr += WFSUtil.TO_SQL(iattr.value, oattr.type, dbType, true);
                                    tableStr += " ,";
                                    b_tblset = true;
                                    iter.remove();
                                }
                            }
                        }
                    }



                    if (updateE) {
                    	
                    	extTableName=WFSExtDB.getTableName(engine, procDefID,extObjId);
                    	if(extObjId==1){
                    		if(extTableName!=null&&extTableName!="" && queuehistorydata){
                    			extTableName_history=extTableName+"_history";
                            	if(dbType == JTSConstant.JTS_MSSQL)
                            		queryStr3= "SELECT 1 FROM sysObjects"+WFSUtil.getTableLockHintStr(dbType)+" WHERE Upper(NAME) = Upper('"+WFSUtil.TO_SANITIZE_STRING(extTableName_history, false)+"')";
                                else if(dbType == JTSConstant.JTS_ORACLE)
                                	queryStr3="select 1 from user_tables where upper(table_name) = Upper('"+WFSUtil.TO_SANITIZE_STRING(extTableName_history, false)+"')";
                                else if(dbType == JTSConstant.JTS_POSTGRES)
                                	queryStr3="select 1 from pg_class where upper(relname)=  Upper('"+WFSUtil.TO_SANITIZE_STRING(extTableName_history, false)+"')";
                            	
                            	pstmt1=con.prepareStatement(queryStr3);
                            	pstmt1.execute();
                            	rs1=pstmt1.getResultSet();
                            	if(rs1!=null){
                            		if(rs1.next()){
                            			foundHistoryTable=true;
                            		}
                            		rs1.close();
                            		rs1=null;
                            	}
                            	if(pstmt1!=null){
                            		pstmt1.close();
                            		pstmt1=null;
                            	}
                            	pstmt1 = con.prepareStatement(" SELECT HISTORYTABLENAME FROM EXTDBCONFTABLE " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessDefID =  ? and ExtObjId = ? ");
             					pstmt1.setInt(1, procDefID);
             					pstmt1.setInt(2, 1);
             					pstmt1.execute();
             					rs1 = pstmt1.getResultSet();
             					if(rs1!=null && rs1.next()) {
             						extTableName_history = rs1.getString("HISTORYTABLENAME");
             					}
             					if(rs1 != null){
             						rs1.close();
             						rs1 = null;
             					}
             					if(pstmt1 != null){
             						pstmt1.close();
             						pstmt1 = null;
             					}
             					if(!foundHistoryTable){
	             					if(dbType == JTSConstant.JTS_MSSQL)
	                            		queryStr3= "SELECT 1 FROM sysObjects"+WFSUtil.getTableLockHintStr(dbType)+" WHERE Upper(NAME) = Upper('"+WFSUtil.TO_SANITIZE_STRING(extTableName_history, false)+"')";
	                                else if(dbType == JTSConstant.JTS_ORACLE)
	                                	queryStr3="select 1 from user_tables where upper(table_name) = Upper('"+WFSUtil.TO_SANITIZE_STRING(extTableName_history, false)+"')";
	                                else if(dbType == JTSConstant.JTS_POSTGRES)
	                                	queryStr3="select 1 from pg_class where upper(relname)=  Upper('"+WFSUtil.TO_SANITIZE_STRING(extTableName_history, false)+"')";
	                            	
	                            	pstmt1=con.prepareStatement(queryStr3);
	                            	pstmt1.execute();
	                            	rs1=pstmt1.getResultSet();
	                            	if(rs1!=null){
	                            		if(rs1.next()){
	                            			foundHistoryTable=true;
	                            		}
	                            		rs1.close();
	                            		rs1=null;
	                            	}
	                            	if(pstmt1!=null){
	                            		pstmt1.close();
	                            		pstmt1=null;
	                            	}
             					}
                            }
                    	}
                    	
                        extqueryStr = new StringBuffer("Update " + extTableName + " Set " + extqueryStr.deleteCharAt(extqueryStr.length() - 1));

                        String tempStr2 = "";
                        String tempStr1 = "";
                        /*	Changed by Amul Jain on 28/08/2008	for WFS_6.2_033	*/
                        
                        if(queuehistorydata){
                       	 pstmt = con.prepareStatement(" SELECT Rec1,Var_Rec_1,Rec2,Var_Rec_2,Rec3,Var_Rec_3,Rec4,Var_Rec_4,Rec5,Var_Rec_5 FROM RecordMappingTable " + WFSUtil.getTableLockHintStr(dbType) + ",QueueHistoryTable " + WFSUtil.getTableLockHintStr(dbType) + " where RecordMappingTable.ProcessDefId = ? and ProcessInstanceID = ? and WorkitemID = ?");
                       }
                       else{
                       	 pstmt = con.prepareStatement(" SELECT Rec1,Var_Rec_1,Rec2,Var_Rec_2,Rec3,Var_Rec_3,Rec4,Var_Rec_4,Rec5,Var_Rec_5 FROM RecordMappingTable " + WFSUtil.getTableLockHintStr(dbType) + ",WFInstrumentTable " + WFSUtil.getTableLockHintStr(dbType) + " where RecordMappingTable.ProcessDefId = ? and ProcessInstanceID = ? and WorkitemID = ?");
                       }
                        
                        pstmt.setInt(1, procDefID);
                        WFSUtil.DB_SetString(2, pinstId, pstmt, dbType);
                        pstmt.setInt(3, workItemID);
                        pstmt.execute();
                        rs = pstmt.getResultSet();
                        if (rs.next()) {
                            extqueryStr.append(" WHERE ");
                            tempStr1 = rs.getString(1);
                            if (!rs.wasNull() && !tempStr1.equals("")) {
                                extqueryStr.append(WFSUtil.TO_SANITIZE_STRING(tempStr1,true));
                                insqueryStr.append(WFSUtil.TO_SANITIZE_STRING(tempStr1,true));
                                insqueryStr.append(" ,");
                                tempStr2 = rs.getString(2);
                                oattr = (WMAttribute) success.get(tempStr1.trim().toUpperCase());
                                if (oattr == null) {
                                    if (!rs.wasNull()) {
                                        extqueryStr.append(" = ");
                                        extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                        valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    } else {
                                        extqueryStr.append(" IS NULL");
                                        valqueryStr.append(" null");
                                    }
                                } else {
                                    tempStr2 = oattr.value;
                                    extqueryStr.append(" = ");
                                    extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                }
                                valqueryStr.append(" ,");
                            }
                            tempStr1 = rs.getString(3);
                            if (!rs.wasNull() && !tempStr1.equals("")) {
                                extqueryStr.append(" AND ");
                                extqueryStr.append(WFSUtil.TO_SANITIZE_STRING(tempStr1,true));
                                insqueryStr.append(WFSUtil.TO_SANITIZE_STRING(tempStr1,true));
                                insqueryStr.append(" ,");
                                tempStr2 = rs.getString(4);
                                oattr = (WMAttribute) success.get(tempStr1.trim().toUpperCase());
                                if (oattr == null) {
                                    if (!rs.wasNull()) {
                                        extqueryStr.append(" = ");
                                        extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                        valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    } else {
                                        extqueryStr.append(" IS NULL");
                                        valqueryStr.append(" null");
                                    }
                                } else {
                                    tempStr2 = oattr.value;
                                    extqueryStr.append(" = ");
                                    extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                }
                                valqueryStr.append(" ,");
                            }
                            tempStr1 = rs.getString(5);
                            if (!rs.wasNull() && !tempStr1.equals("")) {
                                extqueryStr.append(" AND ");
                                extqueryStr.append(WFSUtil.TO_SANITIZE_STRING(tempStr1,true));
                                insqueryStr.append(WFSUtil.TO_SANITIZE_STRING(tempStr1,true));
                                insqueryStr.append(" ,");
                                tempStr2 = rs.getString(6);
                                oattr = (WMAttribute) success.get(tempStr1.trim().toUpperCase());
                                if (oattr == null) {
                                    if (!rs.wasNull()) {
                                        extqueryStr.append(" = ");
                                        extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                        valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    } else {
                                        extqueryStr.append(" IS NULL");
                                        valqueryStr.append(" null");
                                    }
                                } else {
                                    tempStr2 = oattr.value;
                                    extqueryStr.append(" = ");
                                    extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                }
                                valqueryStr.append(" ,");
                            }
                            tempStr1 = rs.getString(7);
                            if (!rs.wasNull() && !tempStr1.equals("")) {
                                extqueryStr.append(" AND ");
                                extqueryStr.append(WFSUtil.TO_SANITIZE_STRING(tempStr1,true));
                                insqueryStr.append(WFSUtil.TO_SANITIZE_STRING(tempStr1,true));
                                insqueryStr.append(" ,");
                                tempStr2 = rs.getString(8);
                                oattr = (WMAttribute) success.get(tempStr1.trim().toUpperCase());
                                if (oattr == null) {
                                    if (!rs.wasNull()) {
                                        extqueryStr.append(" = ");
                                        extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                        valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    } else {
                                        extqueryStr.append(" IS NULL");
                                        valqueryStr.append(" null");
                                    }
                                } else {
                                    tempStr2 = oattr.value;
                                    extqueryStr.append(" = ");
                                    extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                }
                                valqueryStr.append(" ,");
                            }
                            tempStr1 = rs.getString(9);
                            if (!rs.wasNull() && !tempStr1.equals("")) {
                                extqueryStr.append(" AND ");
                                extqueryStr.append(WFSUtil.TO_SANITIZE_STRING(tempStr1,true));
                                insqueryStr.append(WFSUtil.TO_SANITIZE_STRING(tempStr1,true));
                                insqueryStr.append(" ,");
                                tempStr2 = rs.getString(10);
                                oattr = (WMAttribute) success.get(tempStr1.trim().toUpperCase());
                                if (oattr == null) {
                                    if (!rs.wasNull()) {
                                        extqueryStr.append(" = ");
                                        extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                        valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    } else {
                                        extqueryStr.append(" IS NULL");
                                        valqueryStr.append(" null");
                                    }
                                } else {
                                    tempStr2 = oattr.value;
                                    extqueryStr.append(" = ");
                                    extqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                    valqueryStr.append(WFSUtil.TO_STRING(tempStr2, true, dbType));
                                }
                                valqueryStr.append(" ,");
                            }
                            pstmt.close();
                            pstmt = null;
                        }
                    }
                    if (con.getAutoCommit()) {
                        con.setAutoCommit(false);
                        commit = true; //mean yah per false kiya gaya hai.

                    }
                    if (b_tblset) {
                        tableStr = tableStr.substring(0,
                                tableStr.length() - 1) +
                                " where ProcessInstanceID = ? and ( Workitemid = ? " + ((WFSUtil.TO_SANITIZE_STRING(workitemids,true)).equals("") ? "" : "OR Workitemid in (" + WFSUtil.TO_SANITIZE_STRING(workitemids,true) + ")") +
                                ")";
                        pstmt = con.prepareStatement(WFSUtil.TO_SANITIZE_STRING(tableStr,true));
                        WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                        pstmt.setInt(2, workItemID);
                        pstmt.executeUpdate();

                    }
                    if (updateS) {
                        queryStr.deleteCharAt(queryStr.length() -
                                1).append(" where ProcessInstanceID = ? and ( Workitemid = ? " +
                                (workitemids.equals("") ? "" : "OR Workitemid in (" + WFSUtil.TO_SANITIZE_STRING(workitemids,true) + ")") +
                                ")");
                        pstmt = con.prepareStatement(WFSUtil.TO_SANITIZE_STRING(queryStr.toString(),true));
                        WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                        pstmt.setInt(2, workItemID);
                        pstmt.executeUpdate();
                    }
                    if (pstmt != null) {
                        pstmt.close();
                        pstmt = null;
                    }
                    if (updateE) {

                        pstmt = con.prepareStatement(WFSUtil.TO_SANITIZE_STRING(extqueryStr.toString(),true));     //Changed for nText support Bug Id WFS_8.0_014
                        if(queuehistorydata && foundHistoryTable && extObjId==1 ){
                       	 pstmt1 = con.prepareStatement(WFSUtil.TO_SANITIZE_STRING(extqueryStr.toString().replace(extTableName, extTableName_history),true));
                       }

                        Iterator it = extQueryList.iterator();
                        int iListCount = 1;
                        while (it.hasNext()) {
                            String strListElement = (String) it.next();
							//	WFS_9.0_002
                            if(strListElement == null)
                                strListElement = "";
                            pstmt.setCharacterStream(iListCount, new StringReader(strListElement), strListElement.length());
                            if(queuehistorydata && foundHistoryTable && extObjId==1 ){
                           	 pstmt1.setCharacterStream(iListCount, new StringReader(strListElement), strListElement.length());
                           }
                            iListCount++;
                        }
                        int res=0;
                        if(queuehistorydata && foundHistoryTable && extObjId==1 ){
                        	res=pstmt1.executeUpdate();
                       }
                       if(res==0){
                         res = pstmt.executeUpdate();
                       }
                        if (res == 0) {
                            pstmt = con.prepareStatement(" Insert into " + WFSExtDB.getTableName(engine,
                                    procDefID,
                                    extObjId) + " (" + WFSUtil.TO_SANITIZE_STRING(insqueryStr.deleteCharAt(insqueryStr.length() - 1).toString(),true) +
                                    ") VALUES (" + WFSUtil.TO_SANITIZE_STRING(valqueryStr.deleteCharAt(valqueryStr.length() - 1).toString(),true) +
                                    ")");
                            //Changed for nText support Bug Id WFS_8.0_014
                            Iterator it1 = valQueryList.iterator();
                            int iListCount1 = 1;
                            while (it.hasNext()) {
                                String strListElement = (String) it1.next();
								//	WFS_9.0_002
                                if(strListElement == null)
                                    strListElement = "";
                                pstmt.setCharacterStream(iListCount1, new StringReader(strListElement), strListElement.length());
                                iListCount1++;
                            }
                            res = pstmt.executeUpdate();
                        }
                        if(pstmt1!=null){
                        	pstmt1.close();
                        	pstmt1=null;
                        }
                    }

                    if (!con.getAutoCommit() && commit) {	//WFS_6.1.2_054

                        con.commit();
                        con.setAutoCommit(true);
                        commit = false;	//Bugzilla Bug 1671

                    }
                    iter = success.values().iterator();
                    StringBuffer strMessage = new StringBuffer(100);
                    int cnt = 0;
                    while (iter.hasNext()) {
                        if (cnt++ == 0) {
                            strMessage.append("<Attributes>");
                        }
                        oattr = (WMAttribute) iter.next();
                        actName = participant.gettype() == 'P' && targetActivity != null &&
                                !targetActivity.equals("") ? targetActivity : actName;
                        strMessage.append("<Attribute>");
                        strMessage.append("<Name>");
                        strMessage.append(oattr.name);
                        strMessage.append("</Name><Value>");
                        strMessage.append(oattr.value);
                        strMessage.append("</Value>");
                        strMessage.append("</Attribute>");
                    }
                    /*
                    Changed By : Ruhi Hira
                    Changed On : 24th Set 2004
                    Description: To handle invalid message.
                     */
                    if (cnt > 0) {
                        strMessage.append("</Attributes>");
                        WFSUtil.generateLog(engine, con, WFSConstant.WFL_Attribute_Set, pinstId, workItemID,
                                procDefID, activityId, actName, 0, userID, username, 0, strMessage.toString(),
                                null, null, null, null);
                    }
                }
            }
        } catch (SQLException e) {
            printErr(engine,"", e);
            mainCode = WFSError.WM_INVALID_FILTER;
            subCode = WFSError.WFS_SQL;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_FAT;
            if (e.getErrorCode() == 0) {
                if (e.getSQLState().equalsIgnoreCase("08S01")) {
                    descr = (new JTSSQLError(e.getSQLState())).getMessage() + "(SQL State : " +
                            e.getSQLState() + ")";
                }
            } else {
                descr = e.getMessage();
            }
        } catch (NumberFormatException e) {
            printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_ILP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch (NullPointerException e) {
            printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_SYS;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch (JTSException e) {
            printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = e.getErrorCode();
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.getMessage();
        } catch (Exception e) {
            printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch (Error e) {
            printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } finally {
            try {
                if (!con.getAutoCommit() && commit) {			//WFS_6.1.2_054

                    con.rollback();
                    con.setAutoCommit(true);
                }
            } catch (Exception e) {
            }
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (SQLException sqle) {
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
            } catch (SQLException sqle) {
            }

           
        }
        if (mainCode != 0) {
            throw new WFSException(mainCode, subCode, errType, subject, descr);
        }
    } // setAttributes

    
	//----------------------------------------------------------------------------------------------------
    //  Change Description          : Changes for Code Optimization-Merging of WorkFlow 
    //								  tables to WFInstrumentTable and logging of Query
    //  Changed by					: Mohnish Chopra  
    public static void setAttributesExt(Connection con, WFParticipant participant, String attributeXML,
            String engine, String pinstId, int workItemID, XMLGenerator gen, String targetActivity,
            boolean internalServerFlag, boolean debugFlag, boolean upload)
            throws Exception {
    	setAttributesExt(con,participant,attributeXML,engine, pinstId, workItemID,gen, targetActivity,
            internalServerFlag, debugFlag, upload,0);
    }
    
	//----------------------------------------------------------------------------------------------------
    //  Change Description          : Changes for Code Optimization-Merging of WorkFlow 
    //								  tables to WFInstrumentTable and logging of Query
    //  Changed by					: Mohnish Chopra  
    public static void setAttributesExt(Connection con, WFParticipant participant, String attributeXML,
            String engine, String pinstId, int workItemID, XMLGenerator gen, String targetActivity,
            boolean internalServerFlag, boolean debugFlag, boolean upload, int sessionId)
            throws Exception {       
            setAttributesExt(con, participant, attributeXML, engine, pinstId, workItemID,
                    gen, targetActivity, internalServerFlag, debugFlag, upload, sessionId,null, true);//checkSQLExcFlag passed as true 
    }
    
    public static void setAttributesExt(Connection con, WFParticipant participant, String attributeXML,
            String engine, String pinstId, int workItemID, XMLGenerator gen, String targetActivity,
            boolean internalServerFlag, boolean debugFlag, boolean upload,int sessionId,HashMap timeElapsedInfoMap, boolean checkSQLExcFlag) throws Exception{
    	HashMap hashIdInsertionIdMap = new HashMap();
    	setAttributesExt(con, participant, attributeXML, engine, pinstId, workItemID,
                gen, targetActivity, internalServerFlag, debugFlag, upload, sessionId,null, checkSQLExcFlag,hashIdInsertionIdMap);
    }
    public static void setAttributesExt(Connection con, WFParticipant participant, String attributeXML,
            String engine, String pinstId, int workItemID, XMLGenerator gen, String targetActivity,
            boolean internalServerFlag, boolean debugFlag, boolean upload,int sessionId,HashMap timeElapsedInfoMap, boolean checkSQLExcFlag,HashMap hashIdInsertionIdMap) throws Exception{
    	setAttributesExt(con, participant, attributeXML, engine, pinstId, workItemID,
                gen, targetActivity, internalServerFlag, debugFlag, upload, sessionId,null, checkSQLExcFlag,hashIdInsertionIdMap,false);
    }
    public static void setAttributesExt(Connection con, WFParticipant participant, String attributeXML,
            String engine, String pinstId, int workItemID, XMLGenerator gen, String targetActivity,
            boolean internalServerFlag, boolean debugFlag, boolean upload,int sessionId,HashMap timeElapsedInfoMap, boolean checkSQLExcFlag,HashMap hashIdInsertionIdMap,boolean isDeleteInsertFlag) throws Exception{
    	setAttributesExt(con, participant, attributeXML, engine, pinstId, workItemID,
                gen, targetActivity, internalServerFlag, debugFlag, upload, sessionId,null, checkSQLExcFlag,hashIdInsertionIdMap,isDeleteInsertFlag,false);
    }
    public static void setAttributesExt(Connection con, WFParticipant participant, String attributeXML,
            String engine, String pinstId, int workItemID, XMLGenerator gen, String targetActivity,
            boolean internalServerFlag, boolean debugFlag, boolean upload,int sessionId,HashMap timeElapsedInfoMap, boolean checkSQLExcFlag,HashMap hashIdInsertionIdMap,boolean isDeleteInsertFlag,boolean isValidationRequired) throws Exception
           {
    	
    	       setAttributesExt(con, participant, attributeXML, engine, pinstId, workItemID,
                gen, targetActivity, internalServerFlag, debugFlag, upload, sessionId,null, checkSQLExcFlag,hashIdInsertionIdMap,isDeleteInsertFlag,false,false); 
	
    		}
    public static void setAttributesExt(Connection con, WFParticipant participant, String attributeXML,
            String engine, String pinstId, int workItemID, XMLGenerator gen, String targetActivity,
            boolean internalServerFlag, boolean debugFlag, boolean upload,int sessionId,HashMap timeElapsedInfoMap, boolean checkSQLExcFlag,HashMap hashIdInsertionIdMap,boolean isDeleteInsertFlag,boolean isValidationRequired,boolean byPassWorkitemLock) throws Exception{
       
        //     debugFlag = true;
        //   printOut("setAttributesExt >> setting debugFlag to true");
        printOut(engine,  " [WFSUtil] setAttributesExt() started ... attributeXML >> " + attributeXML);
        /** 03/04/2008, Bugzilla Bug 5488, Set command in entry settings does not execute. - Ruhi Hira */
        if (attributeXML != null && attributeXML.trim().length() <= 0) {
            return;
        }
        attributeXML = "<Attributes>" + attributeXML + "</Attributes>";
        ArrayList attribList = WFXMLUtil.convertXMLToObject(attributeXML, engine);
  /*      debugFlag = true;
*/        if (debugFlag) {
            printOut(engine,  " [WFSUtil] setAttributesExt() attributeXML >> " + attributeXML);
//            WFXMLUtil.printList(attribList, 0);
        }
        if (attribList != null && attribList.size() > 0) {
            setAttributesExt(con, participant, attribList, engine, pinstId, workItemID,
                    gen, targetActivity, internalServerFlag, debugFlag, upload,sessionId ,timeElapsedInfoMap,checkSQLExcFlag,hashIdInsertionIdMap,isDeleteInsertFlag,isValidationRequired,byPassWorkitemLock);
        }
    }
	/**
     * *************************************************************
     * Function Name    :   splitTimeIStartEnd
     * Programmer' Name :   Amar Sharma
     * Date Written     :   27/08/2015
     * Input Parameters :   String sFullTime
     * Description      :   Splits time in min hrs sec
     * *************************************************************
     */
    public static int[] splitTimeIStartEnd(String sFullTime) {
        String strTimeam_pm = sFullTime.substring(sFullTime.length() - 2, sFullTime.length());
        int timeArray[] = new int[2];
        String sStartAndEndTimes[] = sFullTime.split(":");
        String sStartTime = sStartAndEndTimes[0];
        if (strTimeam_pm.equalsIgnoreCase("pm")) {
            if (sStartTime.equalsIgnoreCase("12")) {
                timeArray[0] = Integer.parseInt(sStartTime); //case of 12:00/12:30 pm
            } else {
                timeArray[0] = Integer.parseInt(sStartTime) + 12;
            }
        } else {
            if (sStartTime.equalsIgnoreCase("12")) {
                timeArray[0] = 0; //case of 12:00/12:30 am
            } else {
                timeArray[0] = Integer.parseInt(sStartTime);
            }
        }
        String sEndTime = sStartAndEndTimes[1].substring(0, 2);
        timeArray[1] = Integer.parseInt(sEndTime);
        return timeArray;
    }
    // Added By Amar
    public static String convertDayNameToNumber(String strDayName) {
        String strDayNo = "0";
                if(strDayName.equalsIgnoreCase("MonDay")) {
            strDayNo = "2";
        } else if (strDayName.equalsIgnoreCase("TuesDay")) {
            strDayNo = "3";
        } else if (strDayName.equalsIgnoreCase("WednesDay")) {
            strDayNo = "4";
        } else if (strDayName.equalsIgnoreCase("ThursDay")) {
            strDayNo = "5";
        } else if (strDayName.equalsIgnoreCase("FriDay")) {
            strDayNo = "6";
        } else if (strDayName.equalsIgnoreCase("SaturDay")) {
            strDayNo = "7";
        } else if (strDayName.equalsIgnoreCase("SunDay")) {
            strDayNo = "1";
        } else {
            strDayNo = "0";
        }
        return strDayNo;
    }
	//----------------------------------------------------------------------------------------------------
    //  Change Description          : Changes for Code Optimization-Merging of WorkFlow 
    //								  tables to WFInstrumentTable and logging of Query
    //  Changed by					: Mohnish Chopra  
//    public static void setAttributesExt(Connection con, WFParticipant participant, ArrayList attribList,
//            String engine, String pinstId, int workItemID, XMLGenerator gen, String targetActivity,
//            boolean internalServerFlag, boolean debugFlag, boolean upload)
//            throws JTSException, WFSException {
//    	setAttributesExt(con, participant, attribList,
//                engine, pinstId, workItemID, gen, targetActivity,
//                internalServerFlag, debugFlag, upload,0);
//    }
    
    //----------------------------------------------------------------------------------------------------
    //  Change Description          : Changes for Code Optimization-Merging of WorkFlow 
    //								  tables to WFInstrumentTable and logging of Query
    //  Changed by					: Mohnish Chopra  
    public static void setAttributesExt(Connection con, WFParticipant participant, ArrayList attribList,
            String engine, String pinstId, int workItemID, XMLGenerator gen, String targetActivity,
            boolean internalServerFlag, boolean debugFlag, boolean upload,int sessionId,HashMap timeElapsedInfoMap, boolean checkSQLExcFlag)
            throws JTSException, WFSException,SQLException {
    	
    	HashMap hashIdInsertionIdMap = new HashMap();
    	
    	setAttributesExt(con, participant, attribList,
                engine, pinstId, workItemID, gen, targetActivity,
                internalServerFlag, debugFlag, upload,sessionId,timeElapsedInfoMap, checkSQLExcFlag,null);
    }
    public static void setAttributesExt(Connection con, WFParticipant participant, ArrayList attribList,
            String engine, String pinstId, int workItemID, XMLGenerator gen, String targetActivity,
            boolean internalServerFlag, boolean debugFlag, boolean upload,int sessionId,HashMap timeElapsedInfoMap, boolean checkSQLExcFlag,HashMap hashIdInsertionIdMap)
            throws JTSException, WFSException,SQLException {
    	
    	setAttributesExt(con, participant, attribList,
                engine, pinstId, workItemID, gen, targetActivity,
                internalServerFlag, debugFlag, upload,sessionId,timeElapsedInfoMap, checkSQLExcFlag,hashIdInsertionIdMap,false);
    }
    
    
    public static void setAttributesExt(Connection con, WFParticipant participant, ArrayList attribList,
            String engine, String pinstId, int workItemID, XMLGenerator gen, String targetActivity,
            boolean internalServerFlag, boolean debugFlag, boolean upload,int sessionId,HashMap timeElapsedInfoMap, boolean checkSQLExcFlag,HashMap hashIdInsertionIdMap,boolean isDeleteInsertFlag)
            throws JTSException, WFSException,SQLException {
    	setAttributesExt(con, participant, attribList,
                engine, pinstId, workItemID, gen, targetActivity,
                internalServerFlag, debugFlag, upload,sessionId,timeElapsedInfoMap, checkSQLExcFlag,hashIdInsertionIdMap,isDeleteInsertFlag,false);
    }
    
    public static void setAttributesExt(Connection con, WFParticipant participant, ArrayList attribList,
            String engine, String pinstId, int workItemID, XMLGenerator gen, String targetActivity,
            boolean internalServerFlag, boolean debugFlag, boolean upload,int sessionId,HashMap timeElapsedInfoMap, boolean checkSQLExcFlag,HashMap hashIdInsertionIdMap,boolean isDeleteInsertFlag,boolean validationRequired)
            throws JTSException, WFSException,SQLException 
    {
    	
    	setAttributesExt(con, participant, attribList,
                engine, pinstId, workItemID, gen, targetActivity,
                internalServerFlag, debugFlag, upload,sessionId,timeElapsedInfoMap, checkSQLExcFlag,hashIdInsertionIdMap,isDeleteInsertFlag,false,false);
    
    }
    public static void setAttributesExt(Connection con, WFParticipant participant, ArrayList attribList,
            String engine, String pinstId, int workItemID, XMLGenerator gen, String targetActivity,
            boolean internalServerFlag, boolean debugFlag, boolean upload,int sessionId,HashMap timeElapsedInfoMap, boolean checkSQLExcFlag,HashMap hashIdInsertionIdMap,boolean isDeleteInsertFlag,boolean validationRequired,boolean byPassWorkitemLock)
            throws JTSException, WFSException,SQLException {

        PreparedStatement pstmt = null;
        ResultSet rs = null;
        int mainCode = 0;
        int subCode = 0;
        String subject = null;
        String descr = null;
        String errType = WFSError.WF_TMP;
        boolean commit = false;
        //debugFlag = true;
        String filterString ="";
        String query = null;
        ArrayList parameters = new ArrayList();
        long startTime = 0l;
        long endTime = 0l;
        boolean callTaskListThread=false;
        int procDefID=0;
        int activityId=0;
        boolean queuehistorydata=false;
        try {
        	int taskId = WFTaskThreadLocal.get();
            int dbType = ServerProperty.getReference().getDBType(engine);
            boolean b_tblset = false;
            String tableStr = "";
            StringBuffer qdtQueryStr = null;
            StringBuffer extqueryStr = null;
            StringBuffer insqueryStr = null;
            StringBuffer valqueryStr = null;
            HashMap success = new HashMap();
            Iterator iter = null;
            
            int userID = participant.getid();
            String username = participant.getname();
       
            String tableNameStr = null;
            if (debugFlag) {
                printOut(engine, "[WFSUtil] setAttributeExt() internalServerFlag >> " + internalServerFlag);
            }
            tableNameStr = " WFInstrumentTable ";
            /** 02/12/2008, Bugzilla Bug 6991, prorityLevel not set for u type user in setAttributeExt. - Ruhi Hira */
            if(upload) {
				filterString = " and RoutingStatus='N' and LockStatus ='N'  ";
			}
            else if ((participant.gettype() == 'U')) {
            	filterString = " and RoutingStatus in ('N', 'R') and LockStatus ='Y'   "; // Need to check condition for WorkInProcessTable
            }
            else if(internalServerFlag && participant.gettype() == 'P'){
            	//filterString = "  ((RoutingStatus='Y' and LockStatus ='N') or (RoutingStatus='N' and LockStatus ='Y'))   "; // Need to check condition for WorkInProcessTable
            }
            else if(!internalServerFlag && participant.gettype() == 'P'){
            	filterString = "  and LockStatus ='Y'  and Q_UserId = " + userID ;
            }
            
            if(taskId>0){
            	filterString = " and RoutingStatus='N' ";
            }
            if(byPassWorkitemLock)
            {
            	filterString ="";
            }
			/*if(upload) {
				tableNameStr = " WorkListTable ";
			}
            else if ((internalServerFlag && participant.gettype() == 'P') || (participant.gettype() == 'U')) {
                tableNameStr = " WorkInProcessTable ";
            } else {
                tableNameStr = " WorkwithPSTable ";
            }*/
			/*if(upload)
			{//Process Variant Support Changes
				pstmt = con.prepareStatement(
                        " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, " +
                        "ProcessVariantId " + " from WorkListTable " + WFSUtil.getTableLockHintStr(dbType)
                        + " where ProcessInstanceId = ? and WorkitemId = ? and Q_Userid = ? ");
                WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                pstmt.setInt(2, workItemID);
					pstmt.setInt(3, userID);
                tableStr = "Update WorkListTable Set ";
                if (debugFlag) {
                    printOut(engine, "[WFSUtil] setAttributeExt() participant.gettype() is U and tableNameStr >> WorkListTable ");
                }
			}
            else if (participant.gettype() == 'P') {
                userID = 0;
                username = "System";
				//Process Variant Support Changes
                String st = " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, ProcessVariantId " + " from " + tableNameStr + " " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = "+workItemID+" ";            
                pstmt = con.prepareStatement(
                        " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, ProcessVariantId " + " from " + tableNameStr + " " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = ? ");
                WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                pstmt.setInt(2, workItemID);
                tableStr = "Update " + tableNameStr + " Set ";
                if (debugFlag) {
                    printOut(engine,"[WFSUtil] setAttributeExt() participant.gettype() is P and tableNameStr >> " + tableNameStr);
                }
            } else {
			//Process Variant Support Changes
                pstmt = con.prepareStatement(
                        " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, ProcessVariantId " + " from WorkinProcessTable " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = ? and Q_Userid = ? ");
                WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                pstmt.setInt(2, workItemID);
                pstmt.setInt(3, userID);
                tableStr = "Update WorkinProcessTable Set ";
                if (debugFlag) {
                    printOut(engine,"[WFSUtil] setAttributeExt() participant.gettype() is U and tableNameStr >> WorkinProcessTable ");
                }
            }*/
       /*     if(upload)
			{//Process Variant Support Changes
				pstmt = con.prepareStatement(
                        " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, " +
                        "ProcessVariantId " + " from WFInstrumentTable " + WFSUtil.getTableLockHintStr(dbType)
                        + " where ProcessInstanceId = ? and WorkitemId = ? and Q_Userid = ? and RoutingStatus = ?");
                WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                pstmt.setInt(2, workItemID);
					pstmt.setInt(3, userID);
					pstmt.setString(4, "N");
                tableStr = "Update WFInstrumentTable Set ";
                if (debugFlag) {
                    printOut(engine, "[WFSUtil] setAttributeExt() participant.gettype() is U and tableNameStr >> WorkListTable ");
                }
			}
            else if (participant.gettype() == 'P') {
                userID = 0;
                username = "System";
				//Process Variant Support Changes
            	pstmt = con.prepareStatement(
                        " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, " +
                        "ProcessVariantId " + " from WFInstrumentTable " + WFSUtil.getTableLockHintStr(dbType)
                        + " where ProcessInstanceId = ? and WorkitemId = ? and RoutingStatus = ?");
                String st = " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, ProcessVariantId " + " from " + tableNameStr + " " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = "+workItemID+" ";            
                pstmt = con.prepareStatement(
                        " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, ProcessVariantId " + " from " + tableNameStr + " " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = ? ");
                WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                pstmt.setInt(2, workItemID);
                pstmt.setInt(3, workItemID);
                tableStr = "Update " + tableNameStr + " Set ";
                if (debugFlag) {
                    printOut(engine,"[WFSUtil] setAttributeExt() participant.gettype() is P and tableNameStr >> " + tableNameStr);
                }
            } else {
			//Process Variant Support Changes
                pstmt = con.prepareStatement(
                        " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, ProcessVariantId " + " from WorkinProcessTable " 
                        + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = ? and Q_Userid = ?  and RoutingStatus = ? " +
                        "and LockedStatus = " """);
                WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                pstmt.setInt(2, workItemID);
                pstmt.setInt(3, userID);
                pstmt.setString(4, "N");
                pstmt.setString(5, "Y");
                tableStr = "Update WorkinProcessTable Set ";
                if (debugFlag) {
                    printOut(engine,"[WFSUtil] setAttributeExt() participant.gettype() is U and tableNameStr >> WorkinProcessTable ");
                }
            }*/
             query= " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, ProcessVariantId,SecondaryDBFlag , Q_UserId,ActivityType from WFInstrumentTable "
             + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = ? "+ filterString;
			 pstmt = con.prepareStatement(query);
             WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
             pstmt.setInt(2, workItemID);
             parameters.add(pinstId);
             parameters.add(workItemID);
            //Thread.sleep(1000*40);
             WFSUtil.jdbcExecute(pinstId, sessionId, userID, query, pstmt, parameters, debugFlag, engine);
            /*pstmt.execute();*/
             parameters.clear();
            rs = pstmt.getResultSet();
            if (!rs.next()) {
            	   if (participant.gettype() == 'P' || upload || internalServerFlag) {
                       //if (participant.gettype() == 'U' || upload) {
/*                           if (debugFlag) {
                               printOut(engine,"[WFSUtil] setAttributeExt() NO DATA in tableNameStr >> " + tableNameStr);
                           }
*/                          if (participant.gettype() == 'P') {
                                userID = 0;
                                username = "System";
                            }
            		   rs.close();
                           rs = null;
                           pstmt.close();
                           pstmt = null;
                           query=" Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID," +
                               " ProcessVariantId,SecondaryDBFlag,ActivityType from WFInstrumentTable " +
                               "" + WFSUtil.getTableLockHintStr(dbType) + " where " +
                               "ProcessInstanceId = ? and WorkitemId = ? and LockStatus = ? ";
       //Process Variant Support Changes
                           pstmt = con.prepareStatement(query);
                           WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                           pstmt.setInt(2, workItemID);
                           pstmt.setString(3, "N");
                           parameters.add(pinstId);
                           parameters.add(workItemID);
                           parameters.add("N");
                           WFSUtil.jdbcExecute(pinstId, sessionId, userID, query, pstmt, parameters, debugFlag, engine)  ;
                           parameters.clear();
                           rs = pstmt.getResultSet();
                           if (!rs.next()) {
                        	   if(rs!=null){
                        		   rs.close();
                        		   rs = null;
                        	   }
          	                 pstmt.close();
          	                 pstmt = null;
                              mainCode = WFSError.WM_INVALID_WORK_ITEM;
                              subCode = WFSError.WM_NOT_LOCKED;
                              subject = WFSErrorMsg.getMessage(mainCode);
                              descr = WFSErrorMsg.getMessage(subCode);
                              errType = WFSError.WF_TMP;
                           }
            	/*
                *//** 10/11/2008, Bugzilla Bug 6924, API setAttributes should set attributes of locked workitems only - Ruhi Hira *//*
                if (participant.gettype() == 'P' || upload) {
                //if (participant.gettype() == 'U' || upload) {
                    if (debugFlag) {
                        printOut(engine,"[WFSUtil] setAttributeExt() NO DATA in tableNameStr >> " + tableNameStr);
                    }
                    rs.close();
                    rs = null;
                    pstmt.close();
                    pstmt = null;
//Process Variant Support Changes
                    pstmt = con.prepareStatement(
                            " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID," +
                            " ProcessVariantId " + " from WorklistTable " +
                            "" + WFSUtil.getTableLockHintStr(dbType) + " where " +
                            "ProcessInstanceId = ? and WorkitemId = ?");
                    WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                    pstmt.setInt(2, workItemID);
                    *//** 15/07/2008, Bugzilla Bug 5515, priorityLevel not set, querying wrong table - Ruhi Hira *//*
                    tableNameStr = " WorklistTable ";
                    tableStr = "Update WorklistTable Set ";
                    pstmt.execute();
                    rs = pstmt.getResultSet();
                    if (!rs.next()) {
                        if (debugFlag) {
                            printOut(engine,"[WFSUtil] setAttributeExt() NO DATA in WorklistTable");
                        }
                        rs.close();
                        rs = null;
                        pstmt.close();
                        pstmt = null;
//Process Variant Support Changes
                        pstmt = con.prepareStatement(
                                " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, ProcessVariantId " + " from PendingWorklistTable " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = ?");
                        WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                        pstmt.setInt(2, workItemID);
                        tableNameStr = " PendingWorklistTable ";
                        tableStr = "Update PendingWorklistTable Set ";
                        pstmt.execute();
                        rs = pstmt.getResultSet();
                        if (!rs.next()) {
                            if (debugFlag) {
                                printOut(engine,"[WFSUtil] setAttributeExt() NO DATA in PendingWorklistTable");
                            }
                            //WFS_6.1.2_056
                            rs.close();
                            rs = null;
                            pstmt.close();
                            pstmt = null;

                            if (participant.gettype() == 'P'|| upload) {
                                *//** 04/07/2008, Bugzilla Bug 5537, TableNameStr to WorkDoneTable - Ruhi Hira *//*
								//Process Variant Support Changes
                                pstmt = con.prepareStatement(
                                        " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID , ProcessVariantId from " +
                                        "WorkDoneTable " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? " +
                                        "and WorkitemId = ?");
                                WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                                pstmt.setInt(2, workItemID);
                                tableNameStr = " WorkDoneTable ";
                                tableStr = "Update WorkDoneTable Set ";
                                pstmt.execute();
                                rs = pstmt.getResultSet();
                                if (!rs.next()) {
                                    if (debugFlag) {
                                        printOut(engine,"[WFSUtil] setAttributeExt() NO DATA in WorkDoneTable");
                                    }
                                    rs.close();
                                    rs = null;
                                    pstmt.close();
                                    pstmt = null;

                                    mainCode = WFSError.WM_INVALID_WORK_ITEM;
                                    subCode = 0;
                                    subject = WFSErrorMsg.getMessage(mainCode);
                                    descr = WFSErrorMsg.getMessage(subCode);
                                    errType = WFSError.WF_TMP;
                                }
                            } else {
                                mainCode = WFSError.WM_INVALID_WORK_ITEM;
                                subCode = 0;
                                subject = WFSErrorMsg.getMessage(mainCode);
                                descr = WFSErrorMsg.getMessage(subCode);
                                errType = WFSError.WF_TMP;
                            }
                        }
                    }
                } else {*/
            	   }  else {
	            	 rs.close();
	                 rs = null;
	                 pstmt.close();
	                 pstmt = null;
	                 
	                 
	                 query= " Select ProcessDefId , ActivityID , ActivityName , ParentWorkItemID, ProcessVariantId,SecondaryDBFlag , ActivityType from QueueHistoryTable "
	                         + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = ? "+ filterString;
	            	 pstmt = con.prepareStatement(query);
	                 WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
	                 pstmt.setInt(2, workItemID);
	                 parameters.add(pinstId);
	                 parameters.add(workItemID);
	                 WFSUtil.jdbcExecute(pinstId, sessionId, userID, query, pstmt, parameters, debugFlag, engine);
	                 parameters.clear();
	                 rs = pstmt.getResultSet();
	                 if(!rs.next()){
	                	 rs.close();
		                 rs = null;
		                 pstmt.close();
		                 pstmt = null;
	                	 mainCode = WFSError.WM_INVALID_WORK_ITEM;
	                	 subCode = WFSError.WM_NOT_LOCKED;
	                	 subject = WFSErrorMsg.getMessage(mainCode);
	                	 descr = WFSErrorMsg.getMessage(subCode);
	                	 errType = WFSError.WF_TMP;
	                 }else{
	                	 tableNameStr = " QueueHistoryTable ";
	                	 queuehistorydata=true;
	                 }
       /*         }*/
            }
            	   }
            else {
            	int assignedUser=rs.getInt("Q_UserId");
            	int activityType = rs.getInt("ActivityType");
            	if(( assignedUser!=userID)&&(activityType!=WFSConstant.ACT_CASE)&&(!(internalServerFlag && participant.gettype() == 'P'))&&!upload &&!byPassWorkitemLock) {
            		rs.close();
            		rs = null;
            		pstmt.close();
            		pstmt = null;
            		mainCode = WFSError.WM_INVALID_WORK_ITEM;
            		subCode = WFSError.WM_NOT_LOCKED;
            		subject = WFSErrorMsg.getMessage(mainCode);
            		descr = WFSErrorMsg.getMessage(subCode);
            		errType = WFSError.WF_TMP;
					printOut(engine,"[WFSUtil] setAttributeExt()assignedUser!=userID mainCode >> " + mainCode);
					printOut(engine,"[WFSUtil] setAttributeExt()assignedUser!=userID assignedUserId >> " + assignedUser);
					printOut(engine,"[WFSUtil] setAttributeExt()assignedUser!=userID userID >> " + userID);

            	}
            }
            printOut(engine,"[WFSUtil] setAttributeExt() mainCode >> " + mainCode);
			if (mainCode == 0 && rs!=null) {
                 procDefID = rs.getInt(1);
                 activityId = rs.getInt(2);
                String actName = rs.getString(3);
                int parentWI = rs.getInt(4);
                int processVariantId = rs.getInt(5);//Process Variant Support Changes
                String secondaryDBStr = rs.getString(6);
                int activitytype=rs.getInt("ActivityType");
                int queryActivityId=0;
                if(activitytype==WFSConstant.ACT_EXT){
                	queryActivityId=getQueryActivityID(con,dbType,procDefID,userID,WFSConstant.ACT_QUERY);
                	if(queryActivityId>0){
                		activityId=queryActivityId;
                	}
                }
                boolean secondaryDBFlag="Y".equalsIgnoreCase(secondaryDBStr)||"D".equalsIgnoreCase(secondaryDBStr);
                int referby = 0;
                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
                String workitemids = "";
                if(secondaryDBFlag) {
                	String secondaryCabinetName=null;
                	Connection secondaryConn=null;
                	pstmt=con.prepareStatement("Select PropertyValue from WFSYSTEMPROPERTIESTABLE where PropertyKey = ?");
                    pstmt.setString(1,"SECONDARYCABINETNAME");
                    rs= pstmt.executeQuery();
                    if(rs.next()){
                    	secondaryCabinetName=WFSUtil.getFormattedString(rs.getString("PropertyValue"))	;
                    }else {
                        rs.close();
                        pstmt.close();
                        mainCode = WFSError.WF_SECONDARY_CABINET_NOT_SET;
                        subCode = 0;
                        subject = WFSErrorMsg.getMessage(mainCode);
                        descr = WFSErrorMsg.getMessage(subCode);
                        errType = WFSError.WF_TMP;
        			
                    	throw new WFSException(mainCode, subCode, errType, subject, descr);
                   
                    }
                    secondaryConn=WFSUtil.createConnectionToTargetCabinet(secondaryCabinetName,"FetchAttributesExt",engine);
                    if(secondaryConn!=null) {
                    	WFSUtil.printOut(engine,"Connection with Secondary Cabinet "+secondaryCabinetName+" is established.");
                    }
                    if(rs!=null) {
                    	rs.close();
                    	rs=null;
                    }
                    if(pstmt!=null) {
                    	pstmt.close();
                    	pstmt=null;
                    }
                     WFSSecondaryDBUtil.setAttributesExt(con,secondaryConn, participant, attribList,
                    		engine, pinstId, workItemID, gen, targetActivity,
                    		internalServerFlag, debugFlag, upload,sessionId,timeElapsedInfoMap, checkSQLExcFlag,hashIdInsertionIdMap);
                     return ;
                }
                if (parentWI != 0) {
                    int newWorkitemID = workItemID;

                    //workitemids += parentWI;
                    /*pstmt = con.prepareStatement(
                            " Select ParentWorkItemID, ReferredBy from QueueDataTable " + WFSUtil.getTableLockHintStr(dbType) 
                            + " where " + " ProcessInstanceId = ? and WorkitemId = ? ");*/
                    query = "Select ParentWorkItemID, ReferredBy from WFInstrumentTable " + WFSUtil.getTableLockHintStr(dbType) 
                            + " where " + " ProcessInstanceId = ? and WorkitemId = ? ";
                    pstmt = con.prepareStatement(query);
                    /** When a user refer a workitem to another user, there are two copies of workitems
                     * in database with different workitemIds, say user A referred workitem to user B,
                     * then user A will have workitem with Id 1 in his/ her my queue, and user B will have
                     * the one with Id 2, workitem with Id 2 will have parentWorkitemId 1 and workitem with Id 1
                     * will have parentWorkitemId 0, new values if set in attrbutes on workitem with Id 2
                     * should also be updated in workitem with Id 1.
                     */
                    while (true) {
                        WFSUtil.DB_SetString(1, pinstId, pstmt, dbType);
                        pstmt.setInt(2, newWorkitemID);
                        parameters.add(pinstId);
                        parameters.add(newWorkitemID);
                        rs = jdbcExecuteQuery(pinstId, sessionId, userID, query, pstmt, parameters, debugFlag, engine);
                        parameters.clear();
//                        pstmt.execute();
//                        rs = pstmt.getResultSet();
                        if (rs.next()) {
                            parentWI = rs.getInt(1);
                            referby = rs.getInt(2);
                            rs.close();
                            rs = null;
                        } else {
                            rs.close();
                            rs = null;
                            break;
                        }
                        if (referby != 0) {
                            workitemids += workitemids.equals("") ? "" + parentWI : "," + parentWI;
                        }
                        newWorkitemID = parentWI;
						if(parentWI == 1){
							break;
						}
                    }
                    pstmt.close();
                    pstmt = null;
                }

                int noOfAtt = attribList.size();

                if (debugFlag) {
                    WFSUtil.printOut(engine, " [WFSUtil] setAttributesExt() noOfAtt >> " + noOfAtt);
                    WFSUtil.printOut(engine, " [WFSUtil] setAttributesExt() attribList >> " + attribList);
                }
                //process variant change
                
                if (noOfAtt > 0) {
				//Process Variant Support Changes
                    startTime = System.currentTimeMillis();
                    
                    WFVariabledef attribs;
                    if(queuehistorydata){
                    	attribs = (WFVariabledef) CachedObjectCollection.getReference().getCacheObject(con, engine, procDefID, WFSConstant.CACHE_CONST_VARIABLE_HISTORY, 
                            "" + (participant.gettype() == 'P' ? -1 : activityId) + string21 + processVariantId ).getData();
                    }
                    else{
                    	attribs = (WFVariabledef) CachedObjectCollection.getReference().getCacheObject(con, engine, procDefID, WFSConstant.CACHE_CONST_Variable, 
                                "" + (participant.gettype() == 'P' ? (participant.getPSFlag() ? -1 : 0) : activityId) + string21 + processVariantId ).getData();
                    }
                    endTime = System.currentTimeMillis();
                    if(debugFlag)
                        writeLog("setAttributesExt", "[setAttributesExt]_variable_cache", startTime, endTime, 0, "", "", engine,(endTime-startTime),0, userID);  /*Bug 38914 */
                    if (debugFlag) {
                        WFSUtil.printOut(engine, " [WFSUtil] setAttributesExt() attribs >> " + attribs);
                    }
                    HashMap attribMap = attribs.getAttribMap();
                    if (con.getAutoCommit()) {
                        con.setAutoCommit(false);
                        commit = true;
                    }
                    String auditLogStr =null;
                    // Change for bug 40365 starts
                    try {
                        startTime = System.currentTimeMillis();
                        if(isDeleteInsertFlag){
                        	auditLogStr = updateData_old(con, engine, dbType, pinstId, workItemID, procDefID, true, attribList, attribMap, null, null, null, debugFlag, null, tableNameStr, "", workitemids, null, false,sessionId,userID,timeElapsedInfoMap);
                        }else{
                        auditLogStr = updateData(con, engine, dbType, pinstId, workItemID, procDefID, true, attribList, attribMap, null, null, null, debugFlag, null, tableNameStr, "", workitemids, null, false,sessionId,userID,timeElapsedInfoMap,hashIdInsertionIdMap,queuehistorydata,validationRequired);
                        }
                        endTime = System.currentTimeMillis();
                        if(debugFlag)
                            writeLog("setAttributesExt", "[setAttributesExt]_updateData", startTime, endTime, 0, "", "", engine,(endTime-startTime),0, userID);  /*Bug 38914 */
                        }
                        catch(WFSException wfe){
                        	mainCode= wfe.getMainErrorCode();
                        	subCode = wfe.getSubErrorCode();
                            subject = WFSErrorMsg.getMessage(mainCode);
                            if(wfe.getErrorDescription()==null && wfe.getErrorDescription().isEmpty()) {
                            descr = WFSErrorMsg.getMessage(subCode);
                            }
                            else {
                            	descr=wfe.getErrorDescription();
                            }
                            errType = WFSError.WF_TMP;
                        
                        }
                    // Change for bug 40365 ends
                    if (auditLogStr != null && !auditLogStr.equals("")) {
                        actName = participant.gettype() == 'P' && targetActivity != null &&
                                !targetActivity.equals("") ? targetActivity : actName;
                        auditLogStr = "<Attributes>" + auditLogStr + "</Attributes>";

                        startTime = System.currentTimeMillis();
                        WFSUtil.generateLog(engine, con, WFSConstant.WFL_Attribute_Set, pinstId, workItemID,
                                procDefID, activityId, actName, 0, userID, username, 0, auditLogStr,
                                null, null, null, null);
                        endTime = System.currentTimeMillis();
                        if(debugFlag)
                            writeLog("setAttributesExt", "[setAttributesExt]_generateLog", startTime, endTime, 0, "", "", engine,(endTime-startTime),0, userID);  /*Bug 38914 */
                        
                        /*Getting list of Variable whose values are updated...check in pre-condition of Task*/
                        String val="";
                        for(int i=0;i<attribList.size();i++){
                        	String val1=(String) ((Map) attribList.get(i)).keySet().toArray()[0];
                        	val=val+val1+"','";              	
                        }
                        /*Updating it to 'Y' so that pre-condition gets checked*/
                    	if(WFSUtil.checkTaskAndVariableinPreCondition(con,procDefID,activityId,0,val,"V",1)){//checing for Task
                    		WFSUtil.updateWFTaskPreCheckTable( con,  pinstId,  workItemID,activityId,"Y");
                    		callTaskListThread=true;
                    	}

                    }
                    if (!con.getAutoCommit() && commit) {
                        con.commit();
                        con.setAutoCommit(true);
                        commit = false;	//Bugzilla Bug 1671

                    }
                /** @todo logging - genLog ???? */
                }
            }
        } catch (SQLException e) {
        	
        	if (checkSQLExcFlag && (e.getErrorCode() == 8152 || e.getErrorCode() == 12899 || e.getErrorCode()==0 )) {
                throw e;
            }
//        	if (checkSQLExcFlag) {
//                mainCode = 0;
//                throw e;
//            }
            if (e.getErrorCode() == 220) {
            printErr(engine, "", e);
                mainCode = WFSError.WF_ERROR_INVALID_ATTRIBUTE_DATA;
                subCode = WFSError.WF_ERROR_INVALID_ATTRIBUTE_DATA;
                subject = WFSErrorMsg.getMessage(mainCode);
                errType = WFSError.WF_FAT;
                descr = e.getMessage();
            }
            else{
            printErr(engine, "", e);
            mainCode = WFSError.WM_INVALID_FILTER;
            subCode = WFSError.WFS_SQL;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_FAT;
            if (e.getErrorCode() == 0) {
                if (e.getSQLState().equalsIgnoreCase("08S01")) {
                    descr = (new JTSSQLError(e.getSQLState())).getMessage() + "(SQL State : " +
                            e.getSQLState() + ")";
                }
            } else {
                descr = e.getMessage();
            }
        }
        }catch (NumberFormatException e) {
            printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_ILP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch (NullPointerException e) {
            printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_SYS;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch (JTSException e) {
            printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = e.getErrorCode();
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.getMessage();
        } catch (Exception e) {
            printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch (Error e) {
            printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } finally {
            try {
                if (!con.getAutoCommit() && commit) {			//WFS_6.1.2_054

                    try {
                        /** 07/04/2008, Bugzilla Bug 5589, Rollback will throw error when auto commit is false
                         * and no query is yet executed. [The COMMIT TRANSACTION request has no corresponding BEGIN TRANSACTION.] - Ruhi Hira */
                        con.rollback();
                    } catch (Exception innerEx) {
                    }
                    con.setAutoCommit(true);
                }
            } catch (Exception e) {
            }
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (SQLException sqle) {
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
            } catch (SQLException sqle) {
            }
            if(callTaskListThread){
            	WFSUtil.printOut(engine,"Calling TaskList thread starts");
            	ExecutorService executor = Executors.newFixedThreadPool(1);
            	Runnable worker = new WorkerThread(engine,"setAttributesExt", pinstId, workItemID, activityId, sessionId,procDefID );
            	executor.execute(worker);
            	WFSUtil.printOut(engine,"Calling TaskList thread ends");
            }
            
        }
        if (mainCode != 0) {
            throw new WFSException(mainCode, subCode, errType, subject, descr);
        }
    }

    public static void updateWFTaskPreCheckTable(Connection con, String pId, int wId,int activityId,String value) throws SQLException {
    	
    	  String updateQuery="UPDATE WFTaskPreCheckTable set checkPreCondition=? where ProcessInstanceId=? and WorkItemId=? and ActivityId=? ";
    	   PreparedStatement pstmt=con.prepareStatement(updateQuery);
    	   pstmt.setString(1, value);
    	   pstmt.setString(2, pId);
    	   pstmt.setInt(3, wId);
    	   pstmt.setInt(4, activityId);
    	  
    	   pstmt.executeUpdate();
    	  
    		   pstmt.close();
    	   
    }
	protected static String deleteDataForNullArrays(Connection con, String engineName, int dbType, String processInstanceId, int workitemId,
            int processDefId, boolean rootFlag, ArrayList values, HashMap cacheAttribMap, WFFieldInfo wfFieldInfo,
            HashMap parentValueMap, String parentFilterStr, boolean debugFlag, HashMap parentRelationValueMap, String wiTableName,
            String parentAttribName, String workitemIds, WFFieldInfo parentFieldInfo, HashMap eRelationMap) throws Exception {

        HashMap tempRelationMap = wfFieldInfo.getRelationMap();
        WFRelationInfo relationInfo = null;
//        PreparedStatement pstmt = null;
//        ResultSet rs = null;
        StringBuffer auditLogStrBuff = new StringBuffer(100);

//        StringBuffer fetchParentRelationQuery = new StringBuffer(100);
        StringBuffer eFilterStrBuff = new StringBuffer(100);
//        String parentTableName = null;
//        fetchParentRelationQuery.append("Select ");
//        fetchParentRelationQuery.append(getFetchPrefixStr(dbType, 1));
        int counter = 0;
        Exception exceptionToBeThrown = null;

//        for(Iterator itrRel = tempRelationMap.entrySet().iterator(); itrRel.hasNext(); ){
//            counter++;
//            relationInfo = (WFRelationInfo) ((Map.Entry) itrRel.next()).getValue();
//            parentTableName = relationInfo.getParentObject();
//
//            if (counter > 1){
//                fetchParentRelationQuery.append(", ");
//            }
//            fetchParentRelationQuery.append(relationInfo.getForeignKey());
//        }
//        fetchParentRelationQuery.append(" FROM ");
//        fetchParentRelationQuery.append(parentTableName);
//        fetchParentRelationQuery.append(getTableLockHintStr(dbType));
//        fetchParentRelationQuery.append(" WHERE ");
//        fetchParentRelationQuery.append(parentFilterStr);

        try {
//            pstmt = con.prepareStatement(fetchParentRelationQuery.toString());
//            rs = pstmt.executeQuery();
//            if (rs != null && rs.next()){
                for(Iterator itrRel = tempRelationMap.entrySet().iterator(); itrRel.hasNext(); ){
                    counter++;
                    relationInfo = (WFRelationInfo) ((Map.Entry) itrRel.next()).getValue();
                    if (counter == 1) {
                        eFilterStrBuff.append(" WHERE ");
                    } else {
                        eFilterStrBuff.append(" AND ");
                    }	
                    eFilterStrBuff.append(relationInfo.getRefKey());
                    eFilterStrBuff.append(" = ");
                    //eFilterStrBuff.append(TO_SQL((String)parentRelationValueMap.get(relationInfo.getForeignKey()), relationInfo.getColType(), dbType, true));
					eFilterStrBuff.append(TO_SQL((String)parentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase()), relationInfo.getColType(), dbType, true));
                }
//            }

//            rs.close();
//            rs = null;
//            pstmt.close();
//            pstmt = null;
        } catch (Exception ex) {
            exceptionToBeThrown = ex;
//        } finally {
//            try {
//                if (rs != null) {
//                    rs.close();
//                    rs = null;
//                }
//            } catch (Exception ignored) {
//            }
//            try {
//                if (pstmt != null) {
//                    pstmt.close();
//                    pstmt = null;
//                }
//            } catch (Exception ignored) {
//            }
        }

		auditLogStrBuff.append("<Attribute><Name>");
		auditLogStrBuff.append(parentAttribName + wfFieldInfo.getName());
		auditLogStrBuff.append("</Name><Value>");
		auditLogStrBuff.append("</Value></Attribute>");
		deleteArray(con, dbType, wfFieldInfo, debugFlag, eFilterStrBuff.toString(), engineName, processDefId, eRelationMap);
//            PreparedStatement pstmt1 = null;
//            Statement stmt = null;
//            String extTableName = null;
//            String processExtTableName = null;
//            HashMap qRelationMap = null;
//            HashMap eRelationMap = null;
//            boolean updateQ = false;
//            boolean updateE = false;
//            StringBuffer updateParentQuery = null;
//            ArrayList updateParentValList = null;
//            String tempColumnStr = null;
//            String tempValueStr = null;
//            String newValueStr = null;
//            Map.Entry entry = null;
//            StringBuffer queryStr = null;
//            StringBuffer qFilterStrBuff = null;
//            ArrayList eFilterValueList = null;
//            StringBuffer eParentFilterStrBuffArray = null;
//            ArrayList eParentFilterValueList = null;
//            String qdtTableName = "QueueDataTable";
//            String wfParentFieldNameForRelationColumn = null;
//            String wfChildFieldNameForRelationColumn = null;
//            StringBuffer eDeleteArrayStrBuff = null; /*need to track this, as suggested by ruhi- shilpi*/   //check
//
//            StringBuffer auditLogStrBuff = new StringBuffer(200);
//            ResultSetMetaData rsmd = null;
//            boolean presentInParentRelationMap = false;
//            boolean presentInParentMap = false;
//            boolean presentInThisMap = false;
//            boolean parentQueryInitialized = false;
//            boolean insertFlag = false;
//
//            if (debugFlag) {
//                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() engineName >> " + engineName);
//                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() dbType >> " + dbType);
//                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() processInstanceId >> " + processInstanceId);
//                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() workitemId >> " + workitemId);
//                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() processDefId >> " + processDefId);
//                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() rootFlag >> " + rootFlag);
//                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() values >> " + values);
//                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() cacheAttribMap >> " + cacheAttribMap);
//                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() wfFieldInfo >> " + wfFieldInfo);
//                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() parentValueMap >> " + parentValueMap);
//                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() parentFilterStr >> " + parentFilterStr);
//                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() debugFlag >> " + debugFlag);
//                if (wfFieldInfo != null) {
//                    printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() wfFieldInfo.getName() >> " + wfFieldInfo.getName());
//                }
//                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() parentRelationValueMap >> " + parentRelationValueMap);
//                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() parentAttribName >> " + parentAttribName);
//                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() workitemIds >> " + workitemIds);
//                if (parentFieldInfo != null) {
//                    printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() parentFieldInfo.getName() >> " + parentFieldInfo.getName());
//                }
//                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() create delete query for this and update query for its parent , copy code from what is already written...");
//            }
//            try {
//                try {
//                    processExtTableName = WFSExtDB.getTableName(engineName, processDefId, 1);
//                /** ExtObjId is 1 for process external table */
//                } catch (Exception ignored) {
//                }
//                qFilterStrBuff = new StringBuffer(200);
//                qFilterStrBuff.append(" Where (");
//                qFilterStrBuff.append(TO_STRING("ProcessInstanceId", false, dbType));
//                qFilterStrBuff.append(" = ");
//                qFilterStrBuff.append(TO_STRING(TO_STRING(processInstanceId, true, dbType), false, dbType));
//                qFilterStrBuff.append(" AND WorkitemId = ");
//                qFilterStrBuff.append(workitemId);
//                qFilterStrBuff.append(" ) ");
//                /** 29/12/2008, Bugzilla Bug 7273, setAttributeExt does not set data in refered WIs - Ruhi Hira */
//                if (workitemIds != null && !workitemIds.equals("")) {
//                    qFilterStrBuff.append(" OR ( ");
//                    qFilterStrBuff.append(TO_STRING("ProcessInstanceId", false, dbType));
//                    qFilterStrBuff.append(" = ");
//                    qFilterStrBuff.append(TO_STRING(TO_STRING(processInstanceId, true, dbType), false, dbType));
//                    qFilterStrBuff.append(" AND WorkitemId in (");
//                    qFilterStrBuff.append(workitemIds);
//                    qFilterStrBuff.append("))");
//                }
//
//                /** 09/07/2008, Bugzilla Bug 5503, Array Support, Delete first, then insert all, then update parent - Ruhi Hira */
//                /*Instead of this for loop there will be just one flow of sequence here - shilpi*/
//                //  for (int valueCounter = 0; valueCounter < values.size(); valueCounter++) { /*for outer most values.size() is one*/
//                qRelationMap = null; /*may be q is for queuedatatable -  shilpi */
//                eRelationMap = null; /*may be e is for external table - shilpi*/
//                updateQ = false;
//                updateE = false;
//                updateParentQuery = null;
//                tempColumnStr = null;
//                tempValueStr = null;
//                newValueStr = null;
//                entry = null;
//                relationInfo = null;
//                queryStr = null;
//                eFilterStrBuff = null;
//                eParentFilterStrBuffArray = null;
//                wfParentFieldNameForRelationColumn = null;
//                wfChildFieldNameForRelationColumn = null;
//                eDeleteArrayStrBuff = null;
//                rsmd = null;
//                presentInParentRelationMap = false;
//                presentInParentMap = false;
//                presentInThisMap = false;
//                parentQueryInitialized = false;
//                insertFlag = false;
//
//                /*Need to check whats in here- shilpi*/
//                /*rootFlag is always flag no need to have this check also - shilpi*/
//                /**All these valueMaps will be null so no need to calculate simplifiedValueMap , this if else woudl get commenetd - shilpi*/
//                counter = 1;
//                /** Create insert/ update queries for primitive types at this level */
//                //WFSUtil.printOut("[WFSUtil] deleteDataForNullArrays(), {for shilpi} , wfFieldInfo.getName() = " + wfFieldInfo.getName());
//                if (wfFieldInfo.isPrimitive()) { /* in case of primitive array - shilpi*/
//                    //  WFSUtil.printOut("[WFSUtil] deleteDataForNullArrays(), {for shilpi} , fieldInfo is primitive");
//                    // WFSUtil.printOut("[WFSUtil] deleteDataForNullArrays(), {for shilpi} , extobjid >>" + wfFieldInfo.getExtObjId());
//                    //  WFSUtil.printOut("[WFSUtil] deleteDataForNullArrays(), {for shilpi} , scope >>" + wfFieldInfo.getScope());
//                    if (wfFieldInfo.getExtObjId() == 0) { /*queue data variable*/ /* this would not be the case  -shilpi*/
//                        if (wfFieldInfo.getScope() == 'Q' || wfFieldInfo.getScope() == 'U') {
//                            updateQ = true;
//                        } else if (wfFieldInfo.getScope() == 'M') {
//                            /** 03/04/3008, Bugzilla Bug 5515, unable to set system defined columns like PriorityLevel - Ruhi Hira */
//                        } else {
//    //                                printErr("[WFSUtil] updateData() Check Check Check scope is none of Q/ U/ M but >> " + fieldValuePrimitive.fieldInfo.getScope());
//                        }
//                    } else if (wfFieldInfo.getExtObjId() == 1) {
//                        //  WFSUtil.printOut("[WFSUtil] deleteDataForNullArrays(), {for shilpi} ,extobjid is 1 ");
//                        if (!updateE) {
//                            //     WFSUtil.printOut("[WFSUtil] deleteDataForNullArrays(), {for shilpi} ,updateE is false");
//                            updateE = true;
//                            parentFilterStr = qFilterStrBuff.toString();
//                            extTableName = wfFieldInfo.getMappedTable();
//                        //     WFSUtil.printOut("[WFSUtil] deleteDataForNullArrays(), {for shilpi} , updateE is false and parentFilterStr>>" + parentFilterStr);
//                        }
//                    //   WFSUtil.printOut("[WFSUtil] deleteDataForNullArrays(), {for shilpi} , parentFilterStr>>" + parentFilterStr);
//                    } else {
//                        /*Why is this not considered , discuss this with ruhi - shilpi*/
//                        //     printErr("[WFSUtil] deleteDataForNullArrays() rootFlag true and extObjId >> ");
//                        extTableName = wfFieldInfo.getMappedTable();
//                        parentFilterStr = qFilterStrBuff.toString();
//                    //   WFSUtil.printOut("[WFSUtil] deleteDataForNullArrays(), exttableName >> " + extTableName);
//                    //     WFSUtil.printOut("[WFSUtil] deleteDataForNullArrays(), parentFilterStr >> " + parentFilterStr);
//                    }
//                } else {
//                    extTableName = wfFieldInfo.getMappedTable();
//                //parentFilterStr = qFilterStrBuff.toString(); /*Need to check this - shilpi, 6th May 2009 1:03 PM*/
//                //   WFSUtil.printOut("[WFSUtil] deleteDataForNullArrays(), {for shilpi} ,its not primitive lets see what it is>>  wfFieldInfo.getName() = " + wfFieldInfo.getName());
//                }
//                //  WFSUtil.printOut("[WFSUtil] deleteDataForNullArrays(), {for shilpi} , After all this if-else for variable type," +
//                //         "qFilterStrBuff = " + qFilterStrBuff.toString());
//                //  WFSUtil.printOut("[WFSUtil] deleteDataForNullArrays(), {for shilpi} , After all this if-else for variable type," +
//                //     "parentFilterStr = " + parentFilterStr);
//                /* need to check this- shilpi*/
//                auditLogStrBuff.append("<Attribute><Name>");
//                auditLogStrBuff.append(parentAttribName + wfFieldInfo.getName());
//                auditLogStrBuff.append("</Name><Value>");
//                //auditLogStrBuff.append(null);
//                auditLogStrBuff.append("</Value></Attribute>");
//                //}
//
//                if (debugFlag) {
//                    printOut(Level.DEBUG, "[WFSUtil] deleteDataForNullArrays() before checking relation map rootFlag >> " + rootFlag);
//                }
//                stmt = con.createStatement();
//                /** Create condition string from relation map by querying parent table, override values if present in
//                 * parent map ... */
//                if (extTableName != null && processExtTableName != null && extTableName.equalsIgnoreCase(processExtTableName)) {
//                    // make query on RecordMappingTable for creating relation map
//                    queryStr = new StringBuffer();
//                    queryStr.append(" Select ");
//                    if (debugFlag) {
//                        printOut(Level.DEBUG, "[WFSUtil] deleteDataForNullArrays() ) Query RecordMappingTable >> SELECT DISTINCT Rec1, Rec2, Rec3, Rec4, Rec5 FROM RecordMappingTable where ProcessDefId = ? ");
//                    }
//                    pstmt = con.prepareStatement("SELECT DISTINCT Rec1, Rec2, Rec3, Rec4, Rec5 FROM RecordMappingTable where ProcessDefId = ? ");
//                    pstmt.setInt(1, processDefId);
//                    rs = pstmt.executeQuery();
//                    if (rs != null && rs.next()) { // This loop will run just once ..
//
//                        eRelationMap = new HashMap();
//                        WFRelationInfo extRelationInfo = null;
//                        for (int i = 1; i <= 5; i++) {
//                            tempColumnStr = rs.getString(i);
//                            if (!rs.wasNull() && !tempColumnStr.equals("")) {
//                                if (debugFlag) {
//                                    printOut(Level.DEBUG, "[WFSUtil] deleteDataForNullArrays() updateE Adding to RelationMap tempColumnStr >> " + tempColumnStr);
//                                }
//                                if (i > 1) {
//                                    queryStr.append(", ");
//                                }
//                                queryStr.append("Var_Rec_" + i);
//                                extRelationInfo = new WFRelationInfo(0, i, qdtTableName, extTableName, ("Var_Rec_" + i), 'N', tempColumnStr, 'N', WFSConstant.WF_STR);
//                                eRelationMap.put(String.valueOf(i), extRelationInfo);
//    //								extRelationInfo.setMappedParentField();
//                                /** 14/07/2008, Bugzilla Bug 5768, Mapped child not set for external table fields - Ruhi Hira */
//                                extRelationInfo.setMappedChildField((WFFieldInfo) cacheAttribMap.get(tempColumnStr.toUpperCase()));
//                            }
//                        }
//                        queryStr.append(" From ");
//                        queryStr.append(qdtTableName);
//                        queryStr.append(qFilterStrBuff.toString());
//                        if (rs != null) {
//                            rs.close();
//                            rs = null;
//                        }
//                        rs = stmt.executeQuery(queryStr.toString());
//                        rsmd = rs.getMetaData();
//                        if (parentRelationValueMap == null) {
//                            parentRelationValueMap = new HashMap();
//                        }
//                        if (rs != null && rs.next()) { // This loop will run just once ..
//
//                            for (int i = 1; i <= rsmd.getColumnCount(); i++) {
//                                tempColumnStr = rs.getString(i);
//                                if (debugFlag) {
//                                    printOut(Level.DEBUG, "[WFSUtil] deleteDataForNullArrays() adding to parentRelationValueMap ... Column " + rsmd.getColumnName(i) + " Value >> " + tempColumnStr);
//                                }
//                                parentRelationValueMap.put(rsmd.getColumnName(i).toUpperCase(), tempColumnStr);
//                            }
//                        }
//                    } else {
//                        printErr("[WFSUtil] deleteDataForNullArrays() Check this case No data returned from RecordMappingTable... ");
//                    }
//                    if (debugFlag) {
//                        printOut(Level.DEBUG, "[WFSUtil] deleteDataForNullArrays() updateE is true q relation map populated ... " + qRelationMap);
//                        printOut(Level.DEBUG, "[WFSUtil] deleteDataForNullArrays() updateE is true e relation map populated ... " + eRelationMap);
//                    }
//                    if (rs != null) {
//                        rs.close();
//                        rs = null;
//                    }
//                    pstmt.close();
//                    pstmt = null;
//                } else {
//                    eRelationMap = wfFieldInfo.getRelationMap();
//                }
//
//
//                if (debugFlag) {
//                    printOut(Level.DEBUG, "[WFSUtil] deleteDataForNullArrays() eRelationMap >> " + eRelationMap + " updateE >> " + updateE);
//                }
//                // if (!wfFieldInfo.isPrimitive()) {
//                extTableName = wfFieldInfo.getMappedTable();
//                updateE = true;
//                //}
//
//                if (updateE) {
//                    if (eRelationMap != null && eRelationMap.size() > 0) {
//                        eFilterStrBuff = new StringBuffer(200);
//                        eFilterValueList = new ArrayList();
//                        eParentFilterStrBuffArray = new StringBuffer(100);
//                        eParentFilterValueList = new ArrayList();
//                        eFilterStrBuff.append(" Where ");
//                        counter = 1;
//                        /** relation fields should never come for update, but for insert ... */
//                        for (Iterator relItr = eRelationMap.entrySet().iterator(); relItr.hasNext(); ++counter) {
//                            entry = (Map.Entry) relItr.next();
//                            relationInfo = (WFRelationInfo) entry.getValue();
//                            /** 02/12/2008, Bugzilla Bug 7084, tempValueStr was not initialized - Ruhi Hira */
//                            tempValueStr = null;
//                            if (debugFlag) {
//                                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() tempValueStr reset !! ");
//                            }
//                            /** 31/12/2008, Bugzilla Bug 7241, Array in array was not working. - Ruhi Hira */
//                            if (parentRelationValueMap != null) {
//                                if (debugFlag) {
//    //                                    printErr("[WSFUtil] updateData() fetching data from parentRelationValueMap for >> " + relationInfo.getForeignKey().toUpperCase());
//                                }
//                                if (parentFieldInfo != null && parentFieldInfo.isArray()) {
//                                    printErr("[WSFUtil] deleteDataForNullArrays() Dint check in parent map ");
//                                } else {
//                                    printErr("[WSFUtil] deleteDataForNullArrays() Trying to lookup in parent relation map .. ");
//                                    tempValueStr = (String) parentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase());
//                                }
//                                if (debugFlag) {
//                                    printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() relationInfo.getForeignKey() >> " + relationInfo.getForeignKey());
//                                    printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() tempValueStr >> " + tempValueStr);
//                                }
//                            } else {
//                                if (debugFlag) {
//    //                                    printErr("[WSFUtil] updateData() parentRelationValueMap is NULL !!! ");
//                                }
//                            }
//                            /** @todo for composite key in relation, what if one column is not null and one is null :( */
//                            wfParentFieldNameForRelationColumn = (relationInfo.getMappedParentField() == null) ? "" : relationInfo.getMappedParentField().getName();
//                            wfChildFieldNameForRelationColumn = (relationInfo.getMappedChildField() == null) ? "" : relationInfo.getMappedChildField().getName();
//                            presentInParentMap = false;
//                            presentInThisMap = false;
//                            presentInParentRelationMap = false;
//                            if (parentValueMap.containsKey(wfParentFieldNameForRelationColumn.toUpperCase())) {
//                                presentInParentMap = true;
//                            }
//                            //if (simplifiedValueMap.primitiveValueMap.containsKey(wfChildFieldNameForRelationColumn.toUpperCase())) {
//                            if (wfFieldInfo.getName().equalsIgnoreCase(wfChildFieldNameForRelationColumn)) {
//                                presentInThisMap = true;
//                            }
//                            if (!(parentFieldInfo != null && parentFieldInfo.isArray())) {
//                                printErr("[WSFUtil] deleteDataForNullArrays() Dint check in parent map ");
//                                if (tempValueStr != null && !tempValueStr.equals("")) {
//                                    presentInParentRelationMap = true;
//                                }
//                            }
//                            if (debugFlag) {
//                                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() wfParentFieldNameForRelationColumn >> " + wfParentFieldNameForRelationColumn);
//                                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() wfChildFieldNameForRelationColumn >> " + wfChildFieldNameForRelationColumn);
//                                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() presentInParentMap >> " + presentInParentMap);
//                                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() presentInThisMap >> " + presentInThisMap);
//                                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() presentInParentRelationMap >> " + presentInParentRelationMap);
//                                printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() tempValueStr >> " + tempValueStr + " IS THIS NULL ? " + (tempValueStr == null));
//                            }
//                            if (tempValueStr != null && !tempValueStr.equals("")) {
//                                if (debugFlag) {
//                                    printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() relation column found NOT NULL in parentRelationValueMap value >> " + tempValueStr + " KEY >> " + relationInfo.getRefKey());
//                                }
//                                if (updateParentQuery == null) {
//                                    updateParentQuery = new StringBuffer(200);
//                                    updateParentValList = new ArrayList();
//                                    updateParentQuery.append("Update ");
//                                    updateParentQuery.append(relationInfo.getParentObject());
//                                    updateParentQuery.append(" Set ");
//                                }
//                                if (counter > 1) {
//                                    eFilterStrBuff.append(" AND ");
//                                    updateParentQuery.append(", ");
//                                }
//                                eFilterStrBuff.append(relationInfo.getRefKey());
//                                eFilterStrBuff.append(" = ");
//                                eParentFilterStrBuffArray.append(" AND ");
//                                eParentFilterStrBuffArray.append(relationInfo.getForeignKey());
//                                eParentFilterStrBuffArray.append(" = ");
//                                if (!relationInfo.getParentObject().equalsIgnoreCase(relationInfo.getChildObject())) {
//                                    if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {
//                                        eFilterValueList.add(tempValueStr);
//                                        eFilterStrBuff.append(" ? ");
//                                        eParentFilterValueList.add(tempValueStr);
//                                        eParentFilterStrBuffArray.append(" ? ");
//                                    } else {
//                                        eFilterStrBuff.append(TO_SQL(tempValueStr, relationInfo.getColType(), dbType, true));
//                                        eParentFilterStrBuffArray.append(TO_SQL(tempValueStr, relationInfo.getColType(), dbType, true));
//                                    }
//                                }
//                                /** filterStrBuff should always have the old value, tempValueStr
//                                 * override value for update parent, insert child & update child query buffer */
//                                newValueStr = null;
//                                /** @todo We should not update parent in this case, as it may result in rebuiling
//                                 * primary index */
//                                newValueStr = (!parentValueMap.containsKey(wfParentFieldNameForRelationColumn.toUpperCase())) ? null : ((WFFieldValuePrimitive) parentValueMap.get(wfParentFieldNameForRelationColumn.toUpperCase())).value;
//                                if (newValueStr == null || newValueStr.equals("")) {
//                                    /** @todo check for null to avoid NullPointerException */
//                                    //newValueStr = (!presentInThisMap) ? null : ((WFFieldValuePrimitive) simplifiedValueMap.primitiveValueMap.get(wfChildFieldNameForRelationColumn.toUpperCase())).value;
//                                    newValueStr = null;
//                                }
//                                if (newValueStr == null || newValueStr.equals("")) {
//                                    newValueStr = tempValueStr;
//                                }
//                                if (debugFlag) {
//                                    printOut("[WFSUtil] deleteDataForNullArrays() presentInThisMap >> " + presentInThisMap);
//                                }
//                                /** 10/11/2008, Bugzilla Bug 6855,
//                                 * Case : External table is associated with the process. No row in external table.
//                                 *        When ItemIndex and ItemType is passed in setAttributeXML (from initiator web service code)
//                                 *        presentInThisMap is true as it is in inputXML but extObjId is 0
//                                 *        ItemIndex/ ItemType should be updated in both QDT as well as ExternalTable.
//                                 *        Hence ItemIndex ans ItemType were not appended in query. To be check only relationMap loop.
//                                 *        - Ruhi Hira */
//                                if (!presentInThisMap || (presentInThisMap && wfFieldInfo.getExtObjId() == 0)) {
//                                    if (!updateE) {
//                                        updateE = true;
//                                        if (rootFlag) {
//                                            parentFilterStr = qFilterStrBuff.toString();
//                                        }
//                                    }
//    //                                if (eUpdateQuery == null) {
//    //                                   // eInsertValQuery = new StringBuffer(200);
//    //                                   // eInsertValQuery.append(" values (");
//    //                                    eUpdateQuery = new StringBuffer(200);
//    //                                    eUpdateQuery.append("Update ");
//    //                                    eUpdateQuery.append(extTableName);
//    //                                    eUpdateQuery.append(" Set ");
//    //                                } else {
//    //                                   // eInsertValQuery.append(", ");
//    //                                    eUpdateQuery.append(", ");
//    //                                }
//                                    // eInsertValQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
//                                    /** Need to check parentValueMap as well as value map for new relation field values */
//                                    /** First update in this field' table if result is 0 then insert .. */
//                                    //          eUpdateQuery.append(relationInfo.getRefKey());
//    //                                eUpdateQuery.append(" = ");
//    //                                eUpdateQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
//                                    /** Bugzilla Bug 5486, Case : Var_Int1 (QPersonId) is mapped to
//                                     * Person' personId which is mapped to Address personId
//                                     * Data is coming in QPersonId only, which is the key field of next 2 level structures
//                                     * NPE in setting multi level complex structures and key is in top level only */
//                                    if (relationInfo.getMappedChildField() != null) {
//                                        if (debugFlag) {
//                                            printOut("[WFSUtil] deleteDataForNullArrays() update case... Putting in simplifiedValueMap for child mapped field name >> " + relationInfo.getMappedChildField().getName().toUpperCase() + " value >> " + newValueStr);
//                                        }
//                                        printOut("[WFSUtil] deleteDataForNullArrays() update case... Putting in simplifiedValueMap, dont know what to do here 1");
//                                    // simplifiedValueMap.primitiveValueMap.put(relationInfo.getMappedChildField().getName().toUpperCase(), new WFFieldValuePrimitive(relationInfo.getMappedChildField(), newValueStr));
//                                    } else {
//                                        if (debugFlag) {
//                                            printOut("[WFSUtil] deleteDataForNullArrays()update case... Putting in simplifiedValueMap for ref key >> " + relationInfo.getRefKey().toUpperCase() + " value >> " + newValueStr);
//                                        }
//                                        printOut("[WFSUtil] deleteDataForNullArrays() update case... Putting in simplifiedValueMap, dont know what to do here 2");
//                                    //simplifiedValueMap.primitiveValueMap.put(relationInfo.getRefKey().toUpperCase(), new WFFieldValuePrimitive(relationInfo.getMappedChildField(), newValueStr));
//                                    }
//                                }
//                                if (relationInfo.getParentObject().equalsIgnoreCase(relationInfo.getChildObject())) {
//                                    if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {
//                                        eFilterValueList.add(newValueStr);
//                                        eFilterStrBuff.append(" ? ");
//                                        eParentFilterValueList.add(newValueStr);
//                                        eParentFilterStrBuffArray.append(" ? ");
//                                    } else {
//                                        eFilterStrBuff.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
//                                        eParentFilterStrBuffArray.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
//                                    }
//                                }
//                                if (!presentInParentMap) {
//                                    parentQueryInitialized = true;
//                                    updateParentQuery.append(relationInfo.getForeignKey());
//                                    updateParentQuery.append(" = ");
//                                    if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {
//                                        updateParentValList.add(newValueStr);
//                                        updateParentQuery.append(" ? ");
//                                    } else {
//                                        updateParentQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
//                                    }
//    //                                updateParentQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
//                                }
//                            } else {
//                                insertFlag = true;
//                                if (debugFlag) {
//                                    printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() relation column found NULL in parentRelationValueMap value, hence insertFlag KEY >> " + relationInfo.getRefKey());
//                                }
//                                /** Relation columns are null in parent, hense insert.
//                                 * Relation field values must be coming in this field' value map, hence parent
//                                 * need to be updated .. OR in parentValueMap hence this need to be updated
//                                 * OR will be autogen ....
//                                 * But need to initialize eFilterStrBuff (parentFilterStr for next iteration), as this is passed to
//                                 * updateData (recursion) to fetch parent' row while updating child... */
//                                if (updateParentQuery == null) {
//                                    updateParentQuery = new StringBuffer(200);
//                                    updateParentQuery.append("Update ");
//                                    updateParentQuery.append(relationInfo.getParentObject());
//                                    updateParentQuery.append(" Set ");
//                                }
//                                if (counter > 1) {
//                                    updateParentQuery.append(", ");
//                                }
//                                newValueStr = null;
//                                newValueStr = (!presentInParentMap) ? null : ((WFFieldValuePrimitive) parentValueMap.get(wfParentFieldNameForRelationColumn.toUpperCase())).value;
//                                if (debugFlag) {
//                                    printOut(Level.DEBUG, "[WFSUtil] deleteDataForNullArrays() newValueStr in parent >> " + newValueStr);
//                                }
//                                if (newValueStr == null || newValueStr.equals("")) {
//                                    // newValueStr = (!presentInThisMap) ? null : ((WFFieldValuePrimitive) simplifiedValueMap.primitiveValueMap.get(wfChildFieldNameForRelationColumn.toUpperCase())).value;
//                                    newValueStr = null;
//                                    if (debugFlag) {
//                                        printOut(Level.DEBUG, "[WFSUtil] deleteDataForNullArrays() newValueStr in this >> " + newValueStr);
//                                    }
//                                }
//    //                            if (newValueStr == null || newValueStr.equals("")) {
//    //                                /** @todo It can be a case when no data in process external table .... */
//    //                                if (debugFlag) {
//    //                                    printOut(Level.DEBUG, "[WFSUtil] deleteDataForNullArrays() This is a case of AutoGen hence returning !! ");
//    //                                }
//    //                                if (eRelationMap.size() > 1) {
//    //                                    printErr("[WFSUtil] deleteDataForNullArrays() This should never be the case, AUTOGEN & relation map size is greater than one ?? " + eRelationMap.size());
//    //                                    return "";
//    //                                } else {
//    //                                    int currentSeqNo = 0;
//    //                                    int incrementBy = 0;
//    //                                    int seed = 0;
//    //                                    String autogenTableName = null;
//    //                                    String autogenColumnName = null;
//    //                                    /* New Table WFAutoGenInfoTable introduced in system for AutoGen functionality */
//    //                                    /* Transaction is not opened here as this method is already called in transaction */
//    //                                    queryStr = new StringBuffer(250);
//    //                                    queryStr.append("SELECT currentSeqNo, seed, IncrementBy FROM WFAutoGenInfoTable");
//    //                                    queryStr.append(getLockPrefixStr(dbType));
//    //                                    queryStr.append(" WHERE ");
//    //                                   queryStr.append(TO_STRING("TableName", false, dbType));
//    //                                    queryStr.append(" = ");
//    //                                    queryStr.append(TO_STRING("?", false, dbType));
//    //                                    queryStr.append(" AND ");
//    //                                    queryStr.append(TO_STRING("ColumnName", false, dbType));
//    //                                    queryStr.append(" = ");
//    //                                    queryStr.append(TO_STRING("?", false, dbType));
//    //                                    queryStr.append(getLockSuffixStr(dbType));
//    //
//    //
//    //                                    pstmt = con.prepareStatement(queryStr.toString());
//    //
//    //                                    if (relationInfo.isRAutoGenerated()) {
//    //                                        autogenTableName = relationInfo.getChildObject();
//    //                                        autogenColumnName = relationInfo.getRefKey();
//    //                                    } else if (relationInfo.isFAutoGenerated()) {
//    //                                        autogenTableName = relationInfo.getParentObject();
//    //                                        autogenColumnName = relationInfo.getForeignKey();
//    //                                    } else {
//    //                                        printErr("[WFSUtil] deleteDataForNullArrays()This should never be the case, relation value is NULL ..... parent object >> " + relationInfo.getParentObject() + " child object >> " + relationInfo.getChildObject());
//    //                                        return "";
//    //                                    }
//    //
//    //                                    WFSUtil.DB_SetString(1, autogenTableName, pstmt, dbType);
//    //                                    WFSUtil.DB_SetString(2, autogenColumnName, pstmt, dbType);
//    //
//    //                                    printOut("[WFSUtil] deleteDataForNullArrays() Executing Autogen Query ... ");
//    //                                    rs = pstmt.executeQuery();
//    //                                    if (rs != null && rs.next()) {
//    //                                        currentSeqNo = rs.getInt("currentSeqNo");
//    //                                        incrementBy = rs.getInt("IncrementBy");
//    //                                        seed = rs.getInt("seed");
//    //                                        currentSeqNo = (currentSeqNo == 0 ? seed : currentSeqNo + incrementBy);
//    //                                        newValueStr = String.valueOf(currentSeqNo);
//    //                                    }
//    //                                    if (rs != null) {
//    //                                        rs.close();
//    //                                        rs = null;
//    //                                    }
//    //                                    pstmt.close();
//    //                                    pstmt = null;
//    //
//    //                                    queryStr = new StringBuffer(250);
//    //                                    queryStr.append("UPDATE WFAutoGenInfoTable SET currentSeqNo = ? WHERE ");
//    //                                    queryStr.append(TO_STRING("TableName", false, dbType));
//    //                                    queryStr.append(" = ");
//    //                                    queryStr.append(TO_STRING("?", false, dbType));
//    //                                    queryStr.append(" AND ");
//    //                                    queryStr.append(TO_STRING("ColumnName", false, dbType));
//    //                                    queryStr.append(" = ");
//    //                                    queryStr.append(TO_STRING("?", false, dbType));
//    //
//    //                                    pstmt = con.prepareStatement(queryStr.toString());
//    //                                    pstmt.setInt(1, currentSeqNo);	//Bugzilla Bug 6790
//    //
//    //                                    WFSUtil.DB_SetString(2, autogenTableName, pstmt, dbType);
//    //                                    WFSUtil.DB_SetString(3, autogenColumnName, pstmt, dbType);
//    //
//    //                                    printOut("[WFSUtil] deleteDataForNullArrays() Executing Autogen update Query ... ");
//    //                                    pstmt.executeUpdate();
//    //
//    //                                    pstmt.close();
//    //                                    pstmt = null;
//    //
//    //                                }
//    //                            }
//
//                                if (counter > 1) {
//                                    eFilterStrBuff.append(" AND ");
//                                }
//                                eFilterStrBuff.append(" ( ");
//                                eParentFilterStrBuffArray.append(" AND ");
//                                eParentFilterStrBuffArray.append("( ");
//                                eParentFilterStrBuffArray.append(relationInfo.getForeignKey());
//                                eParentFilterStrBuffArray.append(" IS NULL ");
//                                eParentFilterStrBuffArray.append(" OR ");
//                                eParentFilterStrBuffArray.append(relationInfo.getForeignKey());
//                                eParentFilterStrBuffArray.append(" = ");
//                                eFilterStrBuff.append(relationInfo.getRefKey());
//                                eFilterStrBuff.append(" = ");
//                                if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {
//                                    eFilterValueList.add(newValueStr);
//                                    eFilterStrBuff.append(" ? ");
//                                    eParentFilterValueList.add(newValueStr);
//                                    eParentFilterStrBuffArray.append(" ? ");
//                                } else {
//                                    eFilterStrBuff.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
//                                    eParentFilterStrBuffArray.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
//                                }
//                                eFilterStrBuff.append(" ) ");
//                                eParentFilterStrBuffArray.append(" )");
//                                //Bugzilla Bug 6855 check was missing earlier-Shweta Tyagi
//                                if (!presentInThisMap || (presentInThisMap && wfFieldInfo.getExtObjId() == 0)) {
//                                    if (!updateE) {
//                                        updateE = true;
//                                        if (rootFlag) {
//                                            parentFilterStr = qFilterStrBuff.toString();
//                                        }
//                                    }
//                                    /** Always insert in this field' table */
//                                    //        eUpdateQuery.append(", ");
//                                    //eInsertValQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
//                                    /** Case : Var_Int1 (QPersonId) is mapped to Person' personId which is mapped to Address personId
//                                     * Data is coming in QPersonId only, which is the key field of next 2 level structures */
//                                    if (relationInfo.getMappedChildField() != null) {
//                                        if (debugFlag) {
//                                            printOut("[WFSUtil] deleteDataForNullArrays() insert case... Putting in simplifiedValueMap for child mapped field name >> " + relationInfo.getMappedChildField().getName().toUpperCase() + " value >> " + newValueStr);
//                                        }
//                                        printOut("[WFSUtil] deleteDataForNullArrays() insert case..., dont know what to do here 3 ");
//                                    //  simplifiedValueMap.primitiveValueMap.put(relationInfo.getMappedChildField().getName().toUpperCase(), new WFFieldValuePrimitive(relationInfo.getMappedChildField(), newValueStr));
//                                    } else {
//                                        if (debugFlag) {
//                                            printOut("[WFSUtil] deleteDataForNullArrays() insert case... Putting in simplifiedValueMap for ref key >> " + relationInfo.getRefKey().toUpperCase() + " value >> " + newValueStr);
//                                        }
//                                        printOut("[WFSUtil] deleteDataForNullArrays() insert case..., dont know what to do here 4");
//                                    //simplifiedValueMap.primitiveValueMap.put(relationInfo.getRefKey().toUpperCase(), new WFFieldValuePrimitive(relationInfo.getMappedChildField(), newValueStr));
//                                    }
//                                }
//                                if (!presentInParentMap) {
//                                    if (presentInParentRelationMap) {
//                                        String str1 = (String) parentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase());
//                                        if (!str1.equalsIgnoreCase(newValueStr)) {
//                                            parentQueryInitialized = true;
//                                            updateParentQuery.append(relationInfo.getForeignKey());
//                                            updateParentQuery.append(" = ");
//                                            if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {
//                                                updateParentValList.add(newValueStr);
//                                                updateParentQuery.append(" ? ");
//                                            } else {
//                                                updateParentQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
//                                            }
//    //                                        updateParentQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
//                                        }
//                                    } else {
//                                        parentQueryInitialized = true;
//                                        updateParentQuery.append(relationInfo.getForeignKey());
//                                        updateParentQuery.append(" = ");
//                                        if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {
//                                            updateParentValList.add(newValueStr);
//                                            updateParentQuery.append(" ? ");
//                                        } else {
//                                            updateParentQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
//                                        }
//    //                                    updateParentQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
//                                    }
//                                }
//                                if (!presentInParentRelationMap) {
//                                    parentRelationValueMap.put(relationInfo.getForeignKey().toUpperCase(), newValueStr);
//                                }
//                            }
//                            if (debugFlag) {
//                                WFSUtil.printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() relationMap loop relationInfo.getRefKey() >> " + relationInfo.getRefKey());
//                                WFSUtil.printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() relationMap loop relationInfo.getForeignKey() >> " + relationInfo.getForeignKey());
//                                WFSUtil.printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() relationMap loop newValueStr >> " + newValueStr);
//                            }
//                        }
//                    /** If value in parent relation field is null then insert else update ... */
//                    } else {
//                        printErr("[WFSUtil] deleteDataForNullArrays() Check Check Check relationMap size is ZERO !! " + wfFieldInfo);
//                        if (debugFlag && wfFieldInfo != null) {
//                            WFSUtil.printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() RelationMap NULL wfFieldInfo.getName() >> " + wfFieldInfo.getName());
//                        }
//                    }
//                }
//
//                if (debugFlag) {
//                    WFSUtil.printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() updateQ >> " + updateQ + " rootFlag >> " + rootFlag);
//                }
//                if (debugFlag) {
//                    WFSUtil.printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() updateE >> " + updateE);
//                    WFSUtil.printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() insertFlag >> " + insertFlag);
//                    WFSUtil.printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() insertFlag >> " + insertFlag);
//                    //WFSUtil.printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() eUpdateQuery >> " + eUpdateQuery);
//                    WFSUtil.printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() eFilterStrBuff >> " + eFilterStrBuff);
//                    WFSUtil.printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() eParentFilterStrBuffArray >> " + eParentFilterStrBuffArray);
//                // WFSUtil.printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() eInsertValQuery >> " + eInsertValQuery);
//    //                if (eUpdateQuery != null) {
//    //                    WFSUtil.printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() EXT update query >> " + (eUpdateQuery.toString() + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString())));
//    //                }
//                }
//                if (wfFieldInfo != null && wfFieldInfo.isArray()) {
//                    if (eFilterStrBuff == null) {
//                        printErr("[WFSUtil] deleteDataForNullArrays() Check Check Check how come filter for deletion is NULL ... " + wfFieldInfo.getName());
//                    }
//                    /** @todo Ideally we should first delete upto the last leaf of node for arrays - Ruhi Hira */
//                    eDeleteArrayStrBuff = new StringBuffer(200);
//                    eDeleteArrayStrBuff.append("Delete From ");
//                    eDeleteArrayStrBuff.append(extTableName);
//                    eDeleteArrayStrBuff.append(" ");
//                    if (debugFlag) {
//                        printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() Array Delete query >> " + eDeleteArrayStrBuff.toString() + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString()));
//                    }
//                    //Changed for nText support Bug Id WFS_8.0_014
//                    pstmt1 = con.prepareStatement(eDeleteArrayStrBuff.toString() + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString()));
//                    Iterator it = eFilterValueList.iterator();
//                    int iListCount = 1;
//                    while (it.hasNext()) {
//                        String strListElement = (String) it.next();
//                        pstmt1.setCharacterStream(iListCount, new StringReader(strListElement), strListElement.length());
//                        iListCount++;
//                    }
//                    pstmt1.executeUpdate();
//                    pstmt1.close();
//                    pstmt1 = null;
//
//    //                stmt.executeUpdate(eDeleteArrayStrBuff.toString() + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString()));
//
//                    insertFlag = true;
//                /** Always insert if it is an array - Ruhi Hira */
//                }
//                if (debugFlag) {
//                    printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() parentQueryInitialized >> " + parentQueryInitialized);
//                    printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() updateParentQuery >> " + updateParentQuery);
//                }
//                if (updateParentQuery != null && parentQueryInitialized) {
//                    if (debugFlag) {
//                        printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() Parent Query >> " + updateParentQuery.toString() + ((parentFilterStr == null) ? " " : parentFilterStr) + ((eParentFilterStrBuffArray != null && parentFieldInfo != null && parentFieldInfo.isArray()) ? eParentFilterStrBuffArray.toString() : " "));
//                    }
//                    if (wfFieldInfo != null && (wfFieldInfo.isArray())) {
//                        printOut(Level.DEBUG, " [WFSUtil] deleteDataForNullArrays() Parent Query >> Executing parent query");
//    //                    stmt.executeUpdate(updateParentQuery.toString() + ((parentFilterStr == null) ? " " : parentFilterStr) + ((eParentFilterStrBuffArray != null && parentFieldInfo != null && parentFieldInfo.isArray()) ? eParentFilterStrBuffArray.toString() : " "));
//                        printOut("[WFSUtil] updateData() going to call deleteArray : eFilterStrBuff.toString() >> " + eFilterStrBuff.toString());
//                        deleteArray(con, dbType, wfFieldInfo, debugFlag, eFilterStrBuff.toString());	//WFS_8.0_041
//    //					arrayAlreadyDeleted = true;
//                        printOut("[WFSUtil] updateData() After calling deleteArray");
//                    }
//                }
//
//
//                if (rs != null) {
//                    rs.close();
//                    rs = null;
//                }
//                if (stmt != null) {
//                    stmt.close();
//                    stmt = null;
//                }
//                if (pstmt != null) {
//                    pstmt.close();
//                    pstmt = null;
//                }
//            //}
//            } catch (Exception ex) {
//                exceptionToBeThrown = ex;
//            } finally {
//                try {
//                    if (rs != null) {
//                        rs.close();
//                        rs = null;
//                    }
//                } catch (Exception ignored) {
//                }
//                try {
//                    if (stmt != null) {
//                        stmt.close();
//                        stmt = null;
//                    }
//                } catch (Exception ignored) {
//                }
//                try {
//                    if (pstmt != null) {
//                        pstmt.close();
//                        pstmt = null;
//                    }
//                } catch (Exception ignored) {
//                }
//                try {
//                    if (pstmt1 != null) {
//                        pstmt1.close();
//                        pstmt1 = null;
//                    }
//                } catch (Exception ignored) {
//                }
//            }
        if (exceptionToBeThrown != null) {
            throw exceptionToBeThrown;
        }
        return auditLogStrBuff.toString();
    }

    /** wfFieldInfo will be null for root (While updating QueueDataTable & ExternalTable)
     * parentValueMap will have only primitiveValueMap that of parent ..
     * parentRelationValueMap has key columnName.
     */
	
	private static String updateData(Connection con, String engineName, int dbType, String processInstanceId, int workitemId,
            int processDefId, boolean rootFlag, ArrayList values, HashMap cacheAttribMap, WFFieldInfo wfFieldInfo,
            HashMap parentValueMap, String parentFilterStr, boolean debugFlag, HashMap parentRelationValueMap, String wiTableName,
            String parentAttribName, String workitemIds, WFFieldInfo parentFieldInfo, boolean arrayAlreadyDeleted, int sessionId, int userId,HashMap timeElapsedInfoMap,HashMap HashIdInsertionIdMap) throws Exception {
		return updateData( con,  engineName,  dbType,  processInstanceId,  workitemId,
	             processDefId,  rootFlag,  values,  cacheAttribMap,  wfFieldInfo,
	             parentValueMap,  parentFilterStr,  debugFlag,  parentRelationValueMap,  wiTableName,
	             parentAttribName,  workitemIds,  parentFieldInfo,  arrayAlreadyDeleted,  sessionId,  userId, timeElapsedInfoMap, HashIdInsertionIdMap,false);
	}
	
	
	private static String updateData(Connection con, String engineName, int dbType, String processInstanceId, int workitemId,
            int processDefId, boolean rootFlag, ArrayList values, HashMap cacheAttribMap, WFFieldInfo wfFieldInfo,
            HashMap parentValueMap, String parentFilterStr, boolean debugFlag, HashMap parentRelationValueMap, String wiTableName,
            String parentAttribName, String workitemIds, WFFieldInfo parentFieldInfo, boolean arrayAlreadyDeleted, int sessionId, int userId,HashMap timeElapsedInfoMap,HashMap HashIdInsertionIdMap,  boolean queuehistorytabledata) throws Exception {
		return  updateData(con, engineName, dbType, processInstanceId,workitemId,
            processDefId, rootFlag, values, cacheAttribMap, wfFieldInfo,
            parentValueMap, parentFilterStr, debugFlag, parentRelationValueMap, wiTableName,
            parentAttribName, workitemIds, parentFieldInfo, arrayAlreadyDeleted, sessionId, userId,timeElapsedInfoMap,HashIdInsertionIdMap,  queuehistorytabledata,false);
	}

	private static String updateData(Connection con, String engineName, int dbType, String processInstanceId, int workitemId,
            int processDefId, boolean rootFlag, ArrayList values, HashMap cacheAttribMap, WFFieldInfo wfFieldInfo,
            HashMap parentValueMap, String parentFilterStr, boolean debugFlag, HashMap parentRelationValueMap, String wiTableName,
            String parentAttribName, String workitemIds, WFFieldInfo parentFieldInfo, boolean arrayAlreadyDeleted, int sessionId, int userId,HashMap timeElapsedInfoMap,HashMap HashIdInsertionIdMap,  boolean queuehistorytabledata,boolean validationRequired) throws Exception {

        PreparedStatement pstmt1 = null;
        PreparedStatement pstmt2 = null;
        PreparedStatement pstmt = null;
        PreparedStatement pstmtNew = null;
        Statement stmt = null;
        ResultSet rs = null;
        String extTableName = null;
        String processExtTableName = null;
        String processExtTableName_history=null;
        boolean foundHistoryTable=false;
        SimplifiedValueMap simplifiedValueMap = null;
        HashMap qRelationMap = null;
        HashMap eRelationMap = null;
        WFFieldValuePrimitive fieldValuePrimitive = null;
        WFFieldValueComplex fieldValueComplex = null;
        HashMap childMap = null;
        HashMap relationValueMap = null;
        HashMap qRelationValueMap = new HashMap();
        HashMap eRelationValueMap = new HashMap();
        HashMap valueMap = null;
        boolean updateQ = false;
        boolean updateE = false;
        boolean updateM = false;
        StringBuffer updateWITableQuery = null;
        StringBuffer qUpdateQuery = null;
        StringBuffer qUpdateQuerySelect = null;
        StringBuffer qUpdateQuerySelectE = null;
        StringBuffer qDeleteArrayQuerySelectE = null;
        StringBuffer eUpdateQuery = null;
        ArrayList eUpdateValList = null;
        StringBuffer updateParentQuery = null;
        ArrayList updateParentValList = null;
        StringBuffer eInsertColQuery = null;
        StringBuffer eInsertValQuery = null;
        ArrayList eInsertValList = null;
        String tempColumnStr = null;
        String tempValueStr = null;
        String relationparenttable=null;
        boolean externalQuery=false;
        /*String previousValueStr = null;
        HashMap previousValueStrMap = null;*/
        String newValueStr = null;
        Map.Entry entry = null;
        WFRelationInfo relationInfo = null;
        StringBuffer queryStr = null;
        StringBuffer qFilterStrBuff = null;
        ArrayList eFilterValList = null;
        StringBuffer eFilterStrBuff = null;
        StringBuffer eParentFilterStrBuffArray = null;  //check
        //boolean addNullCheck = false; 
        String seqArrayName = "";
        ArrayList eParentFilterValueList = null;
        //String qdtTableName = "QueueDataTable";
        String qdtTableName = "WFInstrumentTable";//OF Optimization
        String wfParentFieldNameForRelationColumn = null;
        String wfChildFieldNameForRelationColumn = null;
        WFFieldInfo tempFieldInfo = null;
        HashMap tempRelationMap = null;
        StringBuffer qRelationValueStr = null;
        StringBuffer eRelationValueStr = null;
        StringBuffer eDeleteArrayStrBuff = null; /*need to track this, as suggested by ruhi- shilpi*/
        StringBuffer auditLogStrBuff = new StringBuffer(200);
        ResultSetMetaData rsmd = null;
        String relValueStr = null;
        char currentFieldType = '\0';
        boolean presentInParentRelationMap = false;
        boolean presentInParentMap = false;
        boolean presentInThisMap = false;
        boolean parentQueryInitialized = false;
        boolean insertFlag = false;
        Exception exceptionToBeThrown = null;
        boolean bExecuteEUpdate = false;
        StringBuilder queryStr1= null;
        StringBuilder queryStr2= null;
        String queryStr3=null;
        long startTime = 0l;
        long endTime = 0l;
        //HashMap duplicateParentRelationValueMap = new HashMap();
        ResultSet rset = null;
        HashMap<String,String> parentInsertionOrderIdMap = new HashMap<String,String>();
        int counter = 0;
        int counterQ = 0;
        int counterQSelect =0;
        int counterQSelectE = 0;
        int counterQDeleteSelectE = 0;
        ArrayList selectColumnsList = new ArrayList();
        ArrayList selectColumnsListE = new ArrayList();
        int counterM = 0;
        ArrayList parameters = new ArrayList();
        Long  timeElapsedToSetQueueData = 0L;
        Long  timeElapsedToSetExtData = 0L;
        if(queuehistorytabledata){
        	qdtTableName="QueueHistoryTable";
        }
        if (debugFlag) {
            printOut(engineName, " [WFSUtil] updateData() counter >> " + counter);
            printOut(engineName, " [WFSUtil] updateData() engineName >> " + engineName);
            printOut(engineName," [WFSUtil] updateData() dbType >> " + dbType);
            printOut(engineName," [WFSUtil] updateData() processInstanceId >> " + processInstanceId);
            printOut(engineName, " [WFSUtil] updateData() workitemId >> " + workitemId);
            printOut(engineName, " [WFSUtil] updateData() processDefId >> " + processDefId);
            printOut(engineName, " [WFSUtil] updateData() rootFlag >> " + rootFlag);
            printOut(engineName, " [WFSUtil] updateData() values >> " + values);
            printOut(engineName, " [WFSUtil] updateData() cacheAttribMap >> " + cacheAttribMap);
            printOut(engineName, " [WFSUtil] updateData() wfFieldInfo >> " + wfFieldInfo);
            printOut(engineName, " [WFSUtil] updateData() parentValueMap >> " + parentValueMap);
            printOut(engineName, " [WFSUtil] updateData() parentFilterStr >> " + parentFilterStr);
            printOut(engineName, " [WFSUtil] updateData() debugFlag >> " + debugFlag);
            if (wfFieldInfo != null) {
                printOut(engineName, " [WFSUtil] updateData() wfFieldInfo.getName() >> " + wfFieldInfo.getName());
            }
            printOut(engineName, " [WFSUtil] updateData() parentRelationValueMap >> " + parentRelationValueMap);
        }

        if (values == null || values.size() == 0) {
            /** @todo printErrshould we continue, in order to clear the values in database ? - Ruhi Hira */
            /* need to write code here
            1 a method call is needed ,
            2 this method will delete data from table for this and reset its parent -shilpi*/
            if (wfFieldInfo != null && wfFieldInfo.isArray() && !arrayAlreadyDeleted) {
				printOut(engineName," [WFSUtil] wfFieldInfo != null && wfFieldInfo.isArray() && !arrayAlreadyDeleted >> " + arrayAlreadyDeleted);
                startTime = System.currentTimeMillis();
               /* String auditLogStr = deleteDataForNullArrays(
                        con, engineName, dbType, processInstanceId, workitemId,
                        processDefId, rootFlag, values, cacheAttribMap, wfFieldInfo,
                        parentValueMap, parentFilterStr, debugFlag, parentRelationValueMap, wiTableName,
                        parentAttribName, workitemIds, parentFieldInfo);
                endTime = System.currentTimeMillis();
                if(debugFlag)
                    writeLog("setAttributesExt", "[updateData]_deleteDataForNullArrays()", startTime, endTime, 0, "", "", engineName,(endTime-startTime),0, 0);
                printOut(engineName,"[WFSUtil] updateData() Returning auditLogStr>>> !! " + auditLogStr);
                auditLogStrBuff.append(auditLogStr);
                return auditLogStrBuff.toString();*/
                return "";
            } else {
                //printOut("[WFSUtil] updateData() Returning as value is NULL !! ");
                printErr(engineName, "[WFSUtil] updateData() Returning as value is NULL !! ");
                return "";
            }
        }

        try {
            try {
                processExtTableName = WFSExtDB.getTableName(engineName, processDefId, 1);
                if(processExtTableName!=null&&processExtTableName!="" && queuehistorytabledata){
                	processExtTableName_history=processExtTableName+"_history";
                	if(dbType == JTSConstant.JTS_MSSQL)
                		queryStr3= "SELECT 1 FROM sysObjects"+WFSUtil.getTableLockHintStr(dbType)+" WHERE Upper(NAME) = Upper('"+WFSUtil.TO_SANITIZE_STRING(processExtTableName_history, false)+"')";
                    else if(dbType == JTSConstant.JTS_ORACLE)
                    	queryStr3="select 1 from user_tables where upper(table_name) = Upper('"+WFSUtil.TO_SANITIZE_STRING(processExtTableName_history, false)+"')";
                    else if(dbType == JTSConstant.JTS_POSTGRES)
                    	queryStr3="select 1 from pg_class where upper(relname)=  Upper('"+WFSUtil.TO_SANITIZE_STRING(processExtTableName_history, false)+"')";
                	
                	pstmt=con.prepareStatement(queryStr3);
                	pstmt.execute();
                	rs=pstmt.getResultSet();
                	if(rs!=null){
                		if(rs.next()){
                			foundHistoryTable=true;
                		}
                		rs.close();
                		rs=null;
                	}
                	if(pstmt!=null){
                		pstmt.close();
                		pstmt=null;
                	}
                	pstmt = con.prepareStatement(" SELECT HISTORYTABLENAME FROM EXTDBCONFTABLE " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessDefID =  ? and ExtObjId = ? ");
 					pstmt.setInt(1, processDefId);
 					pstmt.setInt(2, 1);
 					pstmt.execute();
 					rs = pstmt.getResultSet();
 					if(rs!=null && rs.next()) {
 						processExtTableName_history = rs.getString("HISTORYTABLENAME");
 					}
 					if(rs != null){
 						rs.close();
 						rs = null;
 					}
 					if(pstmt != null){
 						pstmt.close();
 						pstmt = null;
 					}
 					if(!foundHistoryTable){
 						if(dbType == JTSConstant.JTS_MSSQL)
 	                		queryStr3= "SELECT 1 FROM sysObjects"+WFSUtil.getTableLockHintStr(dbType)+" WHERE Upper(NAME) = Upper('"+WFSUtil.TO_SANITIZE_STRING(processExtTableName_history, false)+"')";
 	                    else if(dbType == JTSConstant.JTS_ORACLE)
 	                    	queryStr3="select 1 from user_tables where upper(table_name) = Upper('"+WFSUtil.TO_SANITIZE_STRING(processExtTableName_history, false)+"')";
 	                    else if(dbType == JTSConstant.JTS_POSTGRES)
 	                    	queryStr3="select 1 from pg_class where upper(relname)=  Upper('"+WFSUtil.TO_SANITIZE_STRING(processExtTableName_history, false)+"')";
 	                	
 	                	pstmt=con.prepareStatement(queryStr3);
 	                	pstmt.execute();
 	                	rs=pstmt.getResultSet();
 	                	if(rs!=null){
 	                		if(rs.next()){
 	                			foundHistoryTable=true;
 	                		}
 	                		rs.close();
 	                		rs=null;
 	                	}
 	                	if(pstmt!=null){
 	                		pstmt.close();
 	                		pstmt=null;
 	                	}
 					}
                }
            /** ExtObjId is 1 for process external table */
            } catch (Exception ignored) {
            }
            /*if(parentRelationValueMap!=null){
            	duplicateParentRelationValueMap = new HashMap();
            	for (Iterator parentRelationValueIterator = parentRelationValueMap.entrySet().iterator(); parentRelationValueIterator.hasNext();) {
                Map.Entry relationMapEntry = (Map.Entry) parentRelationValueIterator.next();
                String parentRelationKey=relationMapEntry.getKey().toString();
                String value =(String) parentRelationValueMap.get(parentRelationKey); 
                duplicateParentRelationValueMap.put(parentRelationKey, value);
                parentRelationValueMap.put(parentRelationKey,null);
            }
            }
            else{
            	duplicateParentRelationValueMap = null;
            }*/
            qFilterStrBuff = new StringBuffer(200);
            qFilterStrBuff.append(" Where (");
            //qFilterStrBuff.append(TO_STRING("ProcessInstanceId", false, dbType));
            qFilterStrBuff.append("ProcessInstanceId"); //Changes for Prdp Bug 47241
            qFilterStrBuff.append(" = ");
            //qFilterStrBuff.append(TO_STRING(TO_STRING(processInstanceId, true, dbType), false, dbType));
            qFilterStrBuff.append(TO_STRING(processInstanceId, true, dbType));//Changes for Prdp Bug 47241
            qFilterStrBuff.append(" AND WorkitemId = ");
            qFilterStrBuff.append(workitemId);
            qFilterStrBuff.append(" ) ");
            /** 29/12/2008, Bugzilla Bug 7273, setAttributeExt does not set data in refered WIs - Ruhi Hira */
            if (workitemIds != null && !workitemIds.equals("")) {
                qFilterStrBuff.append(" OR ( ");
                //qFilterStrBuff.append(TO_STRING("ProcessInstanceId", false, dbType));
                qFilterStrBuff.append("ProcessInstanceId");//Changes for Prdp Bug 47241
                qFilterStrBuff.append(" = ");
                //qFilterStrBuff.append(TO_STRING(TO_STRING(processInstanceId, true, dbType), false, dbType));
                qFilterStrBuff.append(TO_STRING(processInstanceId, true, dbType));//Changes for Prdp Bug 47241
                qFilterStrBuff.append(" AND WorkitemId in (");
                qFilterStrBuff.append(workitemIds);
                qFilterStrBuff.append("))");
            }

            if (rootFlag) {
                childMap = cacheAttribMap;
                extTableName = processExtTableName;
            } else {
                childMap = wfFieldInfo.getChildInfoMap();
            }

            /*initially for first level values will have only one element and that is a map with keys being rr and q_result, sample input string = <Attributes><q_result>shilpisrivastava</q_result><rr></rr></Attributes>*/

            if (wfFieldInfo != null && !wfFieldInfo.isArray() && values.size() > 1) {
                printErr(engineName, "[WFSUtil] updateData() CHECK CHECK CHECK !!! wfFieldInfo is not array wfFieldInfo.name >> " + wfFieldInfo.getName() + " & values size is >> " + values.size());
            }

            /** 09/07/2008, Bugzilla Bug 5503, Array Support, Delete first, then insert all, then update parent - Ruhi Hira */
			boolean arrayAlreadyDeletedLocal = arrayAlreadyDeleted;
			boolean primitiveArrayDataDeleted = false;
            for (int valueCounter = 0; valueCounter < values.size(); valueCounter++) { /*for outer most values.size() is one*/
				//arrayAlreadyDeletedLocal = arrayAlreadyDeleted;
                simplifiedValueMap = null;
                qRelationMap = null; /*may be q is for queuedatatable -  shilpi */
                eRelationMap = null; /*may be e is for external table - shilpi*/
                fieldValuePrimitive = null;
                fieldValueComplex = null;
                valueMap = null;
                updateQ = false;
                updateE = false;
                updateM = false;
                updateWITableQuery = null;
                qUpdateQuery = null;
                eUpdateQuery = null;
                updateParentQuery = null;
                eInsertColQuery = null;
                eInsertValQuery = null;
                tempColumnStr = null;
                tempValueStr = null;
                newValueStr = null;
                entry = null;
                relationInfo = null;
                queryStr = null;
                eFilterStrBuff = null;
                eParentFilterStrBuffArray = null;
                wfParentFieldNameForRelationColumn = null;
                wfChildFieldNameForRelationColumn = null;
                tempFieldInfo = null;
                tempRelationMap = null;
                qRelationValueStr = null;
                eRelationValueStr = null;
                eDeleteArrayStrBuff = null;
                rsmd = null;
                relValueStr = null;
                currentFieldType = '\0';
                presentInParentRelationMap = false;
                presentInParentMap = false;
                presentInThisMap = false;
                parentQueryInitialized = false;
                insertFlag = false;
                boolean containsInsertionOrderId = false;
                long insertionOrderIdVal = 0;
                String hashIdValue = "0";
                boolean insertNewRow = false;
                boolean dontUpdateMappingField =false; 


                /*Need to check whats in here- shilpi*/
                if (rootFlag || (wfFieldInfo != null && !(wfFieldInfo.isArray() && wfFieldInfo.isPrimitive()))) {
                    valueMap = (HashMap) values.get(valueCounter);
                    startTime = System.currentTimeMillis();
                    simplifiedValueMap = simplifyValueMap(valueMap, cacheAttribMap, debugFlag, engineName,sVarVal);
                    endTime = System.currentTimeMillis();
                    if(debugFlag)
                        writeLog("setAttributesExt", "[updateData]_simplifyValueMap()", startTime, endTime, 0, "", "", engineName,(endTime-startTime),0, 0);
                } else {
                    /** 11/07/2008, Bugzilla Bug 5744, Primitive array support - Ruhi Hira */
                    if (debugFlag) {
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() This is a case of primitive array ... ");
                    }
                    HashMap primitiveMap = new HashMap();
                    primitiveMap.put(wfFieldInfo.getName(), new WFFieldValuePrimitive(wfFieldInfo, (String) values.get(valueCounter)));
                    HashMap complexMap = new HashMap();
                    simplifiedValueMap = new SimplifiedValueMap(primitiveMap, complexMap);
                }
				WFSUtil.printOut(engineName, " [WFSUtil] updateData() simplifiedValueMap.primitiveValueMap >> " + 		simplifiedValueMap.primitiveValueMap);
				if(valueMap!=null && valueMap.containsKey("INSERTIONORDERID")){
					insertionOrderIdVal =Long.parseLong(((ArrayList)valueMap.get("INSERTIONORDERID")).get(0).toString()) ;
					insertNewRow =(insertionOrderIdVal==0);
					if((insertNewRow)&&(valueMap.containsKey("HASHID"))){
						hashIdValue=String.valueOf(((ArrayList)valueMap.get("HASHID")).get(0).toString()) ;
					}
					else if((insertionOrderIdVal>0)&&(simplifiedValueMap.primitiveValueMap.size()==0)){
						dontUpdateMappingField =true;
					}
				}
                counter = 1;
                counterQ = 1;
                counterM = 1;
                counterQSelect=1;
                counterQSelectE=1;
                counterQDeleteSelectE=1;
                if (debugFlag) {
                    WFSUtil.printOut(engineName, " [WFSUtil] updateData() simplifiedValueMap.primitiveValueMap.size() >> " + simplifiedValueMap.primitiveValueMap.size());
                }
                /** Create insert/ update queries for primitive types at this level */
                queryStr = new StringBuffer();
                queryStr.append("Select RefKey from WFVarRelationTable " + WFSUtil.getTableLockHintStr(dbType) + "  where UPPER(ParentObject)= ? and UPPER(Foreignkey)").append(WFSUtil.getOperator(WFSConstant.WF_NOTLIKE)).append(" ? and UPPER(Foreignkey) ").append(WFSUtil.getOperator(WFSConstant.WF_NOTLIKE)).append("? and ProcessDefId=?");
                pstmtNew = con.prepareStatement(queryStr.toString());
                pstmtNew.setString(1,"WFINSTRUMENTTABLE");
                //pstmtNew.setString(1,"QUEUEDATATABLE");
                pstmtNew.setString(2,"%VAR_%");
                pstmtNew.setString(3,"%VAR_REC%");
                pstmtNew.setInt(4,processDefId);
                parameters.add("WFINSTRUMENTTABLE");
                parameters.add("%VAR_%");
                parameters.add("%VAR_REC%");
                parameters.add(processDefId);
                ResultSet rsNew=jdbcExecuteQuery(processInstanceId, sessionId, userId, queryStr.toString(), pstmtNew, parameters, debugFlag, engineName);
                parameters.clear();
                //pstmtNew.execute();
                //ResultSet rsNew=pstmtNew.getResultSet();
                ArrayList<String> arrList = new ArrayList<String>();
                while(rsNew.next()){
                    String foreignKey= rsNew.getString("RefKey");
                    //System.out.println("Foreign key is" +foreignKey);
                    printOut(engineName,"Foreign key is...!!! "+foreignKey);
                    arrList.add(foreignKey.toLowerCase());
                }				
				if(rsNew != null){
                    rsNew.close();
                    rsNew = null ;
                }
                if(pstmtNew != null){
                    pstmtNew.close();
                    pstmtNew = null;
                }				
                startTime = System.currentTimeMillis();
                for (Iterator itrPrim = simplifiedValueMap.primitiveValueMap.entrySet().iterator(); itrPrim.hasNext();) {
                    entry = (Map.Entry) itrPrim.next();
                    fieldValuePrimitive = (WFFieldValuePrimitive) entry.getValue();
                    currentFieldType = '\0';
                    String isView=fieldValuePrimitive.fieldInfo.getIsView();
                    if(!("Y".equalsIgnoreCase(isView))){
                    if (rootFlag) {
                        // WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} , rootFlag is true ");
                        // WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} , fieldValuePrimitive.fieldInfo.getExtObjId() == " + fieldValuePrimitive.fieldInfo.getExtObjId());
                        if (fieldValuePrimitive.fieldInfo.getExtObjId() == 0) { /*queue data variable*/
                            if (fieldValuePrimitive.fieldInfo.getScope() == 'Q' || fieldValuePrimitive.fieldInfo.getScope() == 'U') {
                                updateQ = true;
                                currentFieldType = 'Q';
                            } else if (fieldValuePrimitive.fieldInfo.getScope() == 'M') {
                                /** 03/04/3008, Bugzilla Bug 5515, unable to set system defined columns like PriorityLevel - Ruhi Hira */
                                updateM = true;
                                currentFieldType = 'M';
                            } else {
//                                printErr("[WFSUtil] updateData() Check Check Check scope is none of Q/ U/ M but >> " + fieldValuePrimitive.fieldInfo.getScope());
                                }
                        } else if (fieldValuePrimitive.fieldInfo.getExtObjId() == 1) {
                        	externalQuery=true;
                            //  WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} ,extobjid is 1 ");
                            if (!updateE) {
                                //  WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} ,updateE is false");
                                updateE = true;
                                parentFilterStr = qFilterStrBuff.toString();
                            //   WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} , updateE is false and parentFilterStr>>"+ parentFilterStr);
                            }
                            //  WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} , parentFilterStr>>"+ parentFilterStr);
                            currentFieldType = 'E';
                        } else {
                            printErr(engineName, "[WFSUtil] updateData() rootFlag true and extObjId >> " + fieldValuePrimitive.fieldInfo.getExtObjId());
                        }
                    } else {
                        // WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} , in else ");
                        //  WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} , in else , updateE = " + updateE);
                        if (!updateE) {
                            extTableName = wfFieldInfo.getMappedTable();
                            updateE = true;
                        //    WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} , in else , extTableName = " + extTableName);
                        }
                        currentFieldType = 'E';
                    }
                    // WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} , After all this if-else for variable type," +
                    //    "qFilterStrBuff = " + qFilterStrBuff.toString());
                    //  WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} , After all this if-else for variable type," +
                    //    "parentFilterStr = " + parentFilterStr);
                    if (currentFieldType == 'Q') {
                        if (qUpdateQuery == null || qUpdateQuerySelect == null) {
                            qUpdateQuery = new StringBuffer(200);
                            qUpdateQuerySelect = new StringBuffer(200);
                            qUpdateQuery.append("Update ");
                            qUpdateQuerySelect.append("Select ");
                            qUpdateQuery.append(qdtTableName);
                            qUpdateQuery.append(" Set ");
                        }
                        if (counterQ > 1) {
                            qUpdateQuery.append(", ");
                            qUpdateQuerySelect.append(", ");
                        }
                        boolean isDataValid = true;
                    	if(fieldValuePrimitive.value!=null&&!fieldValuePrimitive.value.isEmpty()&&validationRequired) {
                    		isDataValid= isFieldValueValid(fieldValuePrimitive.fieldInfo,fieldValuePrimitive.value);
                    	}
                    	if(!isDataValid) {
                    		int mainCode = WFSError.WF_OPERATION_FAILED;
                    		int subCode = WFSError.WFS_ILP;	//Invalid parameter
                    		String subject = WFSErrorMsg.getMessage(mainCode);
                    		String errType = WFSError.WF_TMP;
                    		String descr = WFSErrorMsg.getMessage(subCode) +" "+ fieldValuePrimitive.fieldInfo.getName();
                    		throw new WFSException(mainCode, subCode, errType, subject, descr);

                    	}
                        qUpdateQuery.append(fieldValuePrimitive.fieldInfo.getMappedColumn());
                        qUpdateQuerySelect.append(fieldValuePrimitive.fieldInfo.getMappedColumn());
                        selectColumnsList.add(fieldValuePrimitive.fieldInfo.getMappedColumn());
                        qUpdateQuery.append(" = ");
                        qUpdateQuery.append(TO_SQL(fieldValuePrimitive.value, fieldValuePrimitive.fieldInfo.getWfType(), dbType, true));
                        ++counterQ;
                        counterQSelect++;
                    } else if (currentFieldType == 'E') {
                        if (eInsertColQuery == null) {
                            eInsertColQuery = new StringBuffer(200);
                            eInsertColQuery.append("Insert into ");
                            eInsertColQuery.append(extTableName);
                            eInsertColQuery.append("(");
                            eInsertValQuery = new StringBuffer(200);
                            eInsertValList = new ArrayList();
                            eInsertValQuery.append(" values (");
                            eUpdateQuery = new StringBuffer(200);
                            qUpdateQuerySelectE = new StringBuffer(200);
                            qUpdateQuerySelectE.append("Select ");
                            eUpdateValList = new ArrayList();
                            eUpdateQuery.append("Update ");
                            eUpdateQuery.append(extTableName);
                            eUpdateQuery.append(" Set ");
                        }
                        if (counter > 1) {
                            eInsertValQuery.append(", ");
                            eInsertColQuery.append(", ");
                            eUpdateQuery.append(", ");
                            qUpdateQuerySelectE.append(", ");
                        }
                        // Change for bug 40365 starts
						if(arrList.contains(fieldValuePrimitive.fieldInfo.getMappedColumn().toLowerCase())&&fieldValuePrimitive.fieldInfo.getExtObjId()!=1){
							printOut(engineName,"Set operation restricted on SystemDefinedFields...!!");
                                                        printOut(engineName,"Seems field >"+fieldValuePrimitive.fieldInfo.getMappedColumn()+ " is used to define relation and same is being set, need to remove the field from mapping if relation is defined on the same");
		                    throw new WFSException(WFSError.WF_OPERATION_FAILED, WFSError.WM_ATTRIBUTE_ASSIGNMENT_FAILED, WFSError.WF_TMP, WFSErrorMsg.getMessage(WFSError.WF_OPERATION_FAILED), WFSErrorMsg.getMessage(WFSError.WM_ATTRIBUTE_ASSIGNMENT_FAILED));
						}
						// Change for bug 40365 ends
                        eInsertColQuery.append(fieldValuePrimitive.fieldInfo.getMappedColumn());
                        qUpdateQuerySelectE.append(fieldValuePrimitive.fieldInfo.getMappedColumn());
                        selectColumnsListE.add(fieldValuePrimitive.fieldInfo.getMappedColumn());
                      //Changes for Prdp Bug 47241
                        if(!(fieldValuePrimitive.fieldInfo.getMappedColumn().equalsIgnoreCase("ITEMINDEX") || fieldValuePrimitive.fieldInfo.getMappedColumn().equalsIgnoreCase("ITEMTYPE"))) {
                        bExecuteEUpdate = true;
                        eUpdateQuery.append(fieldValuePrimitive.fieldInfo.getMappedColumn());
                        eUpdateQuery.append(" = ");
                        }
                        if (fieldValuePrimitive.fieldInfo.getWfType() == WFSConstant.WF_NTEXT) {
                            eInsertValList.add(fieldValuePrimitive.value);     //Changed for nText support Bug Id WFS_8.0_014

                            eInsertValQuery.append(" ? ");
                            if(!(fieldValuePrimitive.fieldInfo.getMappedColumn().equalsIgnoreCase("ITEMINDEX") || fieldValuePrimitive.fieldInfo.getMappedColumn().equalsIgnoreCase("ITEMTYPE")))
                            {  	
                              eUpdateValList.add(fieldValuePrimitive.value);
                          //Changes for Prdp Bug 47241
                            eUpdateQuery.append(" ? ");
                            }
                        } else {
                        	boolean isDataValid = true;
                        	if(fieldValuePrimitive.value!=null&&!fieldValuePrimitive.value.isEmpty()&&validationRequired) {
                        		isDataValid = isFieldValueValid(fieldValuePrimitive.fieldInfo,fieldValuePrimitive.value);
                        	}
                        	if(!isDataValid) {
                        		int mainCode = WFSError.WF_OPERATION_FAILED;
                        		int subCode = WFSError.WFS_ILP;	//Invalid parameter
                        		String subject = WFSErrorMsg.getMessage(mainCode);
                        		String errType = WFSError.WF_TMP;
                        		String descr = WFSErrorMsg.getMessage(subCode) +" "+ fieldValuePrimitive.fieldInfo.getName();
                        		throw new WFSException(mainCode, subCode, errType, subject, descr);

                        	}
                        	eInsertValQuery.append(TO_SQL(fieldValuePrimitive.value, fieldValuePrimitive.fieldInfo.getWfType(), dbType, true));
                        	//Changes for Prdp Bug 47241
                        	if(!(fieldValuePrimitive.fieldInfo.getMappedColumn().equalsIgnoreCase("ITEMINDEX") || fieldValuePrimitive.fieldInfo.getMappedColumn().equalsIgnoreCase("ITEMTYPE")))
                        	{
                        		eUpdateQuery.append(TO_SQL(fieldValuePrimitive.value, fieldValuePrimitive.fieldInfo.getWfType(), dbType, true));
                        	}
                        }

                        ++counter;
                        counterQSelectE++;
                    } else if (currentFieldType == 'M') {
                    	if (("PRIORITYLEVEL").equalsIgnoreCase(fieldValuePrimitive.fieldInfo.getName()) || ("DBExErrDesc").equalsIgnoreCase(fieldValuePrimitive.fieldInfo.getName()) || ("DBExErrCode").equalsIgnoreCase(fieldValuePrimitive.fieldInfo.getName())) {
                            if (updateWITableQuery == null) {
                                updateWITableQuery = new StringBuffer(200);
                                updateWITableQuery.append("Update ");
                                updateWITableQuery.append(wiTableName);
                                updateWITableQuery.append(" Set ");
                            }
                            if (counterM > 1) {
                                updateWITableQuery.append(", ");
                            }
                            updateWITableQuery.append(fieldValuePrimitive.fieldInfo.getMappedColumn());
                            updateWITableQuery.append(" = ");
                            updateWITableQuery.append(TO_STRING(fieldValuePrimitive.value, true, dbType));
                            ++counterM;
                    	}else if(("Locale").equalsIgnoreCase(fieldValuePrimitive.fieldInfo.getName())) {
                            if (updateWITableQuery == null) {
                                updateWITableQuery = new StringBuffer(200);
                                updateWITableQuery.append("Update ");
                                updateWITableQuery.append(wiTableName);
                                updateWITableQuery.append(" Set ");
                            }
                            if (counterM > 1) {
                                updateWITableQuery.append(", ");
                            }
                            updateWITableQuery.append(fieldValuePrimitive.fieldInfo.getMappedColumn());
                            updateWITableQuery.append(" = ");
                            updateWITableQuery.append(TO_STRING(fieldValuePrimitive.value, true, dbType));
                            ++counterM;
                        }else if(("ManualProcessingFlag").equalsIgnoreCase(fieldValuePrimitive.fieldInfo.getName())&&((fieldValuePrimitive.value.equalsIgnoreCase("Y"))||(fieldValuePrimitive.value.equalsIgnoreCase("N")))) {
                            if (updateWITableQuery == null) {
                                updateWITableQuery = new StringBuffer(200);
                                updateWITableQuery.append("Update ");
                                updateWITableQuery.append(wiTableName);
                                updateWITableQuery.append(" Set ");
                            }
                            if (counterM > 1) {
                                updateWITableQuery.append(", ");
                            }
                            updateWITableQuery.append(fieldValuePrimitive.fieldInfo.getMappedColumn());
                            updateWITableQuery.append(" = ");
                            updateWITableQuery.append(TO_STRING(fieldValuePrimitive.value, true, dbType));
                            ++counterM;
                        }else if(("SecondaryDBFlag").equalsIgnoreCase(fieldValuePrimitive.fieldInfo.getName())&&((fieldValuePrimitive.value.equalsIgnoreCase("U"))||(fieldValuePrimitive.value.equalsIgnoreCase("D")))&&workitemId==1) {
                            if (updateWITableQuery == null) {
                                updateWITableQuery = new StringBuffer(200);
                                updateWITableQuery.append("Update ");
                                updateWITableQuery.append(wiTableName);
                                updateWITableQuery.append(" Set ");
                            }
                            if (counterM > 1) {
                                updateWITableQuery.append(", ");
                            }
                            updateWITableQuery.append(fieldValuePrimitive.fieldInfo.getMappedColumn());
                            updateWITableQuery.append(" = ");
                            updateWITableQuery.append(TO_STRING(fieldValuePrimitive.value, true, dbType));
                            ++counterM;
                        }else if(("SecondaryDBFlag").equalsIgnoreCase(fieldValuePrimitive.fieldInfo.getName())) {
                        	throw new WFSException(WFSError.WF_OPERATION_FAILED, WFSError.WM_ATTRIBUTE_ASSIGNMENT_FAILED, WFSError.WF_TMP, WFSErrorMsg.getMessage(WFSError.WF_OPERATION_FAILED), WFSErrorMsg.getMessage(WFSError.WM_ATTRIBUTE_ASSIGNMENT_FAILED));                        
                        }
                        else {
                            /** This code will never excute */
                            if (qUpdateQuery == null) {
                                qUpdateQuery = new StringBuffer(200);
                                qUpdateQuery.append("Update ");
                                qUpdateQuery.append(qdtTableName);
                                qUpdateQuery.append(" Set ");
                            }
                            if (counterQ > 1) {
                                qUpdateQuery.append(", ");
                            }
                            qUpdateQuery.append(fieldValuePrimitive.fieldInfo.getMappedColumn());
                            qUpdateQuery.append(" = ");
                            qUpdateQuery.append(TO_SQL(fieldValuePrimitive.value, fieldValuePrimitive.fieldInfo.getWfType(), dbType, true));
                            ++counterQ;
                        }
                    }
                    if (debugFlag) {
                        printOut(engineName, "[WFSUtil] updateData() primitiveValueMap loop fieldValuePrimitive.value >> " + fieldValuePrimitive.value);
                    }
                    //if(fieldValuePrimitive.value!=null && !("".equals(fieldValuePrimitive.value))){
                    auditLogStrBuff.append("<Attribute><Name>");
                    auditLogStrBuff.append(parentAttribName + fieldValuePrimitive.fieldInfo.getName());
                    auditLogStrBuff.append("</Name>");
                    auditLogStrBuff.append("<PreviousValue>");
                    auditLogStrBuff.append(fieldValuePrimitive.fieldInfo.getMappedColumn()+"_old");
                    auditLogStrBuff.append("</PreviousValue>");
                    auditLogStrBuff.append("");
                    auditLogStrBuff.append("<Value>");
                    auditLogStrBuff.append(fieldValuePrimitive.value);
                    auditLogStrBuff.append("</Value>");
                    auditLogStrBuff.append("<Type>");
                    auditLogStrBuff.append(fieldValuePrimitive.fieldInfo.getWfType());
                    auditLogStrBuff.append("</Type>");
                    if(wfFieldInfo!=null && wfFieldInfo.isArray() ){
                    	auditLogStrBuff.append("<InsertionOrderId>dummy</InsertionOrderId>");	
                    }
                    auditLogStrBuff.append("</Attribute>");
                //}
                }
                }
                
                if(currentFieldType == 'E' || qUpdateQuerySelectE != null){
                    qUpdateQuerySelectE.append(" from ");
                    qUpdateQuerySelectE.append(extTableName);
                    }
                endTime = System.currentTimeMillis();
                if(debugFlag)
                    writeLog("setAttributesExt", "[updateData]_primitive_value_Map", startTime, endTime, 0, "", "", engineName,(endTime-startTime),0, 0);

                if (debugFlag) {
                    printOut(engineName, "[WFSUtil] updateData() before checking relation map rootFlag >> " + rootFlag);
                }
                stmt = con.createStatement();
                if (rootFlag) {
                    /** Need to fetch value from relationMap .. */
                    parentValueMap = simplifiedValueMap.primitiveValueMap;
                }
                if (rootFlag && updateQ) {
                    /** @todo here relaionMap is not required */
                    qRelationMap = new HashMap();
                    qRelationMap.put("1", new WFRelationInfo(0, 1, qdtTableName, qdtTableName, "ProcessInstanceId", 'N', "ProcessInstanceId", 'N', WFSConstant.WF_STR));
                    qRelationMap.put("2", new WFRelationInfo(0, 2, qdtTableName, qdtTableName, "WorkitemId", 'N', "WorkitemId", 'N', WFSConstant.WF_INT));
                    if (debugFlag) {
                        printOut(engineName, "[WFSUtil] updateData() updateQ is true relation map populated ... " + qRelationMap);
                    }
                }
                startTime = System.currentTimeMillis();
                if ((rootFlag && updateE) ||
                        (rootFlag && (simplifiedValueMap.complexValueMap != null && simplifiedValueMap.complexValueMap.size() > 0 && processExtTableName != null && !processExtTableName.equals(""))) ||
                        (extTableName != null && processExtTableName != null && extTableName.equalsIgnoreCase(processExtTableName))) {
                    // make query on RecordMappingTable for creating relation map
                    queryStr = new StringBuffer();
                    queryStr.append(" Select ");
                    if (debugFlag) {
                        printOut(engineName, "[WFSUtil] updateData() Query RecordMappingTable >> SELECT DISTINCT Rec1, Rec2, Rec3, Rec4, Rec5 FROM RecordMappingTable where ProcessDefId = ? ");
                    }
                    queryStr1 = new StringBuilder();
                    queryStr1.append("SELECT DISTINCT Rec1, Rec2, Rec3, Rec4, Rec5 FROM RecordMappingTable " + WFSUtil.getTableLockHintStr(dbType) + "  where ProcessDefId = ? ");
                    pstmt = con.prepareStatement(queryStr1.toString());
                    pstmt.setInt(1, processDefId);
                    parameters.clear();
                    parameters.add(processDefId);
                    rs = jdbcExecuteQuery(null, sessionId, userId, queryStr1.toString(), pstmt, parameters, debugFlag, engineName);
                    parameters.clear();
                    //rs = pstmt.executeQuery();
                    if (rs != null && rs.next()) { // This loop will run just once ..

                        eRelationMap = new HashMap();
                        WFRelationInfo extRelationInfo = null;
                        for (int i = 1; i <= 5; i++) {
                            tempColumnStr = rs.getString(i);
                            if (!rs.wasNull() && !tempColumnStr.equals("")) {
                                if (debugFlag) {
                                    printOut(engineName, "[WFSUtil] updateData() updateE Adding to RelationMap tempColumnStr >> " + tempColumnStr);
                                }
                                if (i > 1) {
                                    queryStr.append(", ");
                                }
                                queryStr.append("Var_Rec_" + i);
                                extRelationInfo = new WFRelationInfo(0, i, qdtTableName, extTableName, ("Var_Rec_" + i), 'N', tempColumnStr, 'N', WFSConstant.WF_STR);
                                eRelationMap.put(String.valueOf(i), extRelationInfo);
//								extRelationInfo.setMappedParentField();
                                /** 14/07/2008, Bugzilla Bug 5768, Mapped child not set for external table fields - Ruhi Hira */
                                extRelationInfo.setMappedChildField((WFFieldInfo) cacheAttribMap.get(tempColumnStr.toUpperCase()));
                            }
                        }
                        queryStr.append(" From ");
                        queryStr.append(qdtTableName);
                        queryStr.append(qFilterStrBuff.toString());
                        if (rs != null) {
                            rs.close();
                            rs = null;
                        }
                        //OF Optimization
                        rs = jdbcExecuteQuery(processInstanceId, sessionId, userId, queryStr.toString(), stmt, null, debugFlag, engineName);
//                        rs = stmt.executeQuery(queryStr.toString());
                        rsmd = rs.getMetaData();
                        if (parentRelationValueMap == null) {
                            parentRelationValueMap = new HashMap();
                        }
                        if (rs != null && rs.next()) { // This loop will run just once ..

                            for (int i = 1; i <= rsmd.getColumnCount(); i++) {
                                tempColumnStr = rs.getString(i);
                                if (debugFlag) {
                                    printOut(engineName, "[WFSUtil] updateData() adding to parentRelationValueMap ... Column " + rsmd.getColumnName(i) + " Value >> " + tempColumnStr);
                                }
                                parentRelationValueMap.put(rsmd.getColumnName(i).toUpperCase(), tempColumnStr);
                            }
                        }
                    } else {
                        printErr(engineName, "[WFSUtil] updateData() Check this case No data returned from RecordMappingTable... ");
						//Changes for Bug 66857 -  All the columns in external table data is updated with the same values while performing Checkin process simultaneously
                        if((extTableName != null && processExtTableName != null && extTableName.equalsIgnoreCase(processExtTableName))){
		                    throw new WFSException(WFSError.WF_OPERATION_FAILED, WFSError.WM_ATTRIBUTE_ASSIGNMENT_FAILED, WFSError.WF_TMP, WFSErrorMsg.getMessage(WFSError.WF_OPERATION_FAILED), WFSErrorMsg.getMessage(WFSError.WM_ATTRIBUTE_ASSIGNMENT_FAILED));	
                        }
                    }
                    if (debugFlag) {
                        printOut(engineName,"[WFSUtil] updateData() updateE is true q relation map populated ... " + qRelationMap);
                        printOut(engineName, "[WFSUtil] updateData() updateE is true e relation map populated ... " + eRelationMap);
                    }
                    if (rs != null) {
                        rs.close();
                        rs = null;
                    }
                    pstmt.close();
                    pstmt = null;
                } else if (!rootFlag) {
                    eRelationMap = wfFieldInfo.getRelationMap();
                }
                endTime = System.currentTimeMillis();
                if(debugFlag)
                    writeLog("setAttributesExt", "[updateData]_external_table_relation", startTime, endTime, 0, "", "", engineName,(endTime-startTime),0, 0);

                /** Create condition string from relation map by querying parent table, override values if present in
                 * parent map ... */
                if (debugFlag) {
                    printOut(engineName, "[WFSUtil] updateData() eRelationMap >> " + eRelationMap + " updateE >> " + updateE);
                }

                if (!rootFlag && simplifiedValueMap.complexValueMap.size() > 0) {
                    extTableName = wfFieldInfo.getMappedTable();
                    updateE = true;
                }
                
                startTime = System.currentTimeMillis();
                if (updateE || (simplifiedValueMap.complexValueMap.size() > 0 && processExtTableName != null && !processExtTableName.equals(""))) {
                    if (eRelationMap != null && eRelationMap.size() > 0) {
                        eFilterStrBuff = new StringBuffer(200);
                        eFilterValList = new ArrayList();
                        eParentFilterStrBuffArray = new StringBuffer(100);
                        eParentFilterValueList = new ArrayList();
                        eFilterStrBuff.append(" Where ");
                        counter = 1;
                        /** relation fields should never come for update, but for insert ... */
                        for (Iterator relItr = eRelationMap.entrySet().iterator(); relItr.hasNext(); ++counter) {
                            entry = (Map.Entry) relItr.next();
                            relationInfo = (WFRelationInfo) entry.getValue();
                            /** 02/12/2008, Bugzilla Bug 7084, tempValueStr was not initialized - Ruhi Hira */
                            tempValueStr = null;
                            if (debugFlag) {
                                printOut(engineName, " [WFSUtil] updateData() tempValueStr reset !! ");
                            }
                            /** 31/12/2008, Bugzilla Bug 7241, Array in array was not working. - Ruhi Hira */
                            presentInParentRelationMap = false;
                            if (parentRelationValueMap != null) {
                                if (debugFlag) {
//                                    printErr("[WSFUtil] updateData() fetching data from parentRelationValueMap for >> " + relationInfo.getForeignKey().toUpperCase());
                                    }
                                if (parentFieldInfo != null && parentFieldInfo.isArray() && valueCounter == 0) {
                                    /*if(debugFlag)*/
                                        //printErr(engineName, "[WSFUtil] updateData() Dint check in parent map ");
									tempValueStr = (String) parentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase());
									if (tempValueStr != null && !tempValueStr.equals("")) {
										presentInParentRelationMap = true;
									}
                                } else {
                                    /*if(debugFlag)*/
                                        //printErr(engineName, "[WSFUtil] updateData() Trying to lookup in parent relation map .. ");
                                    tempValueStr = (String) parentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase());
									if (tempValueStr != null && !tempValueStr.equals("")) {
										presentInParentRelationMap = true;
									}
                                }
                                /*if(((duplicateParentRelationValueMap!=null)&&duplicateParentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase())!=null)&&((relationInfo.getParentObject().equalsIgnoreCase(qdtTableName))||relationInfo.getParentObject().equalsIgnoreCase(processExtTableName))){
                                    tempValueStr = (String) duplicateParentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase());
									if (tempValueStr != null && !tempValueStr.equals("")) {
										presentInParentRelationMap = true;
									}
									if(parentRelationValueMap!=null){
										parentRelationValueMap.put(relationInfo.getForeignKey().toUpperCase(), tempValueStr);
									}

                                }
                                
                                if((duplicateParentRelationValueMap!=null)&&(duplicateParentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase())!=null)){
                                	previousValueStr = (String) duplicateParentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase());
                                	previousValueStrMap = new HashMap();
                                	previousValueStrMap.put(relationInfo.getRefKey(),previousValueStr);
								 }*/
                                if (debugFlag) {
                                    printOut(engineName, " [WFSUtil] updateData() relationInfo.getForeignKey() >> " + relationInfo.getForeignKey());
                                    printOut(engineName, " [WFSUtil] updateData() tempValueStr >> " + tempValueStr);
                                }
                            } else {
                                if (debugFlag) {
//                                    printErr("[WSFUtil] updateData() parentRelationValueMap is NULL !!! ");
                                }
                            }
                            /** @todo for composite key in relation, what if one column is not null and one is null :( */
                            wfParentFieldNameForRelationColumn = (relationInfo.getMappedParentField() == null) ? "" : relationInfo.getMappedParentField().getName();
                            wfChildFieldNameForRelationColumn = (relationInfo.getMappedChildField() == null) ? "" : relationInfo.getMappedChildField().getName();
                            presentInParentMap = false;
                            presentInThisMap = false;
//                            presentInParentRelationMap = false;
                            if (parentValueMap.containsKey(wfParentFieldNameForRelationColumn.toUpperCase())) {
                                presentInParentMap = true;
                            }
                            if (simplifiedValueMap.primitiveValueMap.containsKey(wfChildFieldNameForRelationColumn.toUpperCase())) {
                                presentInThisMap = true;
                            }
//                            if (!(parentFieldInfo != null && parentFieldInfo.isArray() && valueCounter == 0)) {
//                                printErr("[WSFUtil] updateData() Dint check in parent map ");
//                                if (tempValueStr != null && !tempValueStr.equals("")) {
//                                    presentInParentRelationMap = true;
//                                }
//                            }
                            if (debugFlag) {
                                printOut(engineName, " [WFSUtil] updateData() wfParentFieldNameForRelationColumn >> " + wfParentFieldNameForRelationColumn);
                                printOut(engineName, " [WFSUtil] updateData() wfChildFieldNameForRelationColumn >> " + wfChildFieldNameForRelationColumn);
                                printOut(engineName," [WFSUtil] updateData() presentInParentMap >> " + presentInParentMap);
                                printOut(engineName, " [WFSUtil] updateData() presentInThisMap >> " + presentInThisMap);
                                printOut(engineName, " [WFSUtil] updateData() presentInParentRelationMap >> " + presentInParentRelationMap);
                                printOut(engineName, " [WFSUtil] updateData() tempValueStr >> " + tempValueStr + " IS THIS NULL ? " + (tempValueStr == null));
                            }
                            if (tempValueStr != null && !tempValueStr.equals("")) {
                                if (debugFlag) {
                                    printOut(engineName, " [WFSUtil] updateData() relation column found NOT NULL in parentRelationValueMap value >> " + tempValueStr + " KEY >> " + relationInfo.getRefKey());
                                }
                                if (updateParentQuery == null) {
                                    updateParentQuery = new StringBuffer(200);
                                    updateParentValList = new ArrayList();
                                    updateParentQuery.append("Update ");
                                    updateParentQuery.append(relationInfo.getParentObject());
                                    updateParentQuery.append(" Set ");
                                }
                                if (counter > 1) {
                                    eFilterStrBuff.append(" AND ");
//                                    updateParentQuery.append(", ");
                                }
                                //eFilterStrBuff.append("(");
                                eFilterStrBuff.append(relationInfo.getRefKey());
                                eFilterStrBuff.append(" = ");
                                eParentFilterStrBuffArray.append(" AND ");
                                //eParentFilterStrBuffArray.append("(");
                                eParentFilterStrBuffArray.append(relationInfo.getForeignKey());
                                eParentFilterStrBuffArray.append(" = ");
                                if (!relationInfo.getParentObject().equalsIgnoreCase(relationInfo.getChildObject())) {
                                    if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                        eFilterStrBuff.append(" ? ");
                                        eFilterValList.add(tempValueStr);
                                        eParentFilterStrBuffArray.append(" ? ");
                                        eParentFilterValueList.add(tempValueStr);
                                    } else {
                                        eFilterStrBuff.append(TO_SQL(tempValueStr, relationInfo.getColType(), dbType, true));
                                        eParentFilterStrBuffArray.append(TO_SQL(tempValueStr, relationInfo.getColType(), dbType, true));
                                    }
                                }
                                /*if(previousValueStrMap!=null&&previousValueStrMap.get(relationInfo.getRefKey())!=null&&previousValueStrMap.get(relationInfo.getRefKey()).toString()!=tempValueStr){
                                	eFilterStrBuff.append(" OR ");
                                	eFilterStrBuff.append(relationInfo.getRefKey());
                                	eFilterStrBuff.append(" = ");
                                	eFilterStrBuff.append(TO_SQL(previousValueStrMap.get(relationInfo.getRefKey()).toString(),relationInfo.getColType(), dbType, true));
                                	previousValueStrMap.clear();
                                }
                                eFilterStrBuff.append(")");
                                eParentFilterStrBuffArray.append(")");*/
                                /** filterStrBuff should always have the old value, tempValueStr
                                 * override value for update parent, insert child & update child query buffer */
                                newValueStr = null;
                                /** @todo We should not update parent in this case, as it may result in rebuiling
                                 * primary index */
                                newValueStr = (!parentValueMap.containsKey(wfParentFieldNameForRelationColumn.toUpperCase())) ? null : ((WFFieldValuePrimitive) parentValueMap.get(wfParentFieldNameForRelationColumn.toUpperCase())).value;
                                if (newValueStr == null || newValueStr.equals("")) {
                                    /** @todo check for null to avoid NullPointerException */
                                    newValueStr = (!presentInThisMap) ? null : ((WFFieldValuePrimitive) simplifiedValueMap.primitiveValueMap.get(wfChildFieldNameForRelationColumn.toUpperCase())).value;
                                }
                                if (newValueStr == null || newValueStr.equals("")) {
                                    newValueStr = tempValueStr;
                                }
                                if (debugFlag) {
                                    printOut(engineName,"[WFSUtil] updateData() presentInThisMap >> " + presentInThisMap);
                                }
                                /** 10/11/2008, Bugzilla Bug 6855,
                                 * Case : External table is associated with the process. No row in external table.
                                 *        When ItemIndex and ItemType is passed in setAttributeXML (from initiator web service code)
                                 *        presentInThisMap is true as it is in inputXML but extObjId is 0
                                 *        ItemIndex/ ItemType should be updated in both QDT as well as ExternalTable.
                                 *        Hence ItemIndex ans ItemType were not appended in query. To be check only relationMap loop.
                                 *        - Ruhi Hira */
                                if (!presentInThisMap ||
                                        (presentInThisMap &&
                                        ((WFFieldValuePrimitive) simplifiedValueMap.primitiveValueMap.get(wfChildFieldNameForRelationColumn.toUpperCase())).fieldInfo.getExtObjId() == 0)) {
                                    if (!updateE) {
                                        updateE = true;
                                        if (rootFlag) {
                                            parentFilterStr = qFilterStrBuff.toString();
                                        }
                                    }
                                    if (eInsertColQuery == null) {
                                        eInsertColQuery = new StringBuffer(200);
                                        eInsertColQuery.append("Insert into ");
                                        eInsertColQuery.append(extTableName);
                                        eInsertColQuery.append("(");
                                        eInsertValQuery = new StringBuffer(200);
                                        eInsertValList = new ArrayList();
                                        eInsertValQuery.append(" values (");
                                        eUpdateQuery = new StringBuffer(200);
                                        eUpdateValList = new ArrayList();
                                        eUpdateQuery.append("Update ");
                                        eUpdateQuery.append(extTableName);
                                        eUpdateQuery.append(" Set ");
                                    } else {
                                        eInsertColQuery.append(", ");
                                        eInsertValQuery.append(", "); 
                                        if(!(relationInfo.getRefKey().equalsIgnoreCase("ITEMINDEX") || relationInfo.getRefKey().equalsIgnoreCase("ITEMTYPE"))||extTableName!=processExtTableName)
                                        {
                                            eUpdateQuery.append(", ");
                                        } 	
                                    }
									eInsertColQuery.append(relationInfo.getRefKey());
                                    WFSUtil.printOut(engineName,"Relation table data type..." + newValueStr + relationInfo.getColType());

                                    /** Need to check parentValueMap as well as value map for new relation field values */
                                    /** First update in this field' table if result is 0 then insert .. */
                                    if(!(relationInfo.getRefKey().equalsIgnoreCase("ITEMINDEX") || relationInfo.getRefKey().equalsIgnoreCase("ITEMTYPE"))||extTableName!=processExtTableName)
                                    {
                                       bExecuteEUpdate = true;
                                       eUpdateQuery.append(relationInfo.getRefKey());
                                       eUpdateQuery.append(" = ");
                                    }
                                    if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                        eInsertValList.add(newValueStr);
                                        eInsertValQuery.append(" ? ");
                                        if(!(relationInfo.getRefKey().equalsIgnoreCase("ITEMINDEX") || relationInfo.getRefKey().equalsIgnoreCase("ITEMTYPE"))||extTableName!=processExtTableName)
                                        {
                                           eUpdateValList.add(newValueStr);
                                           eUpdateQuery.append(" ? ");
                                        }  
                                    } else {
                                        eInsertValQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                        if(!(relationInfo.getRefKey().equalsIgnoreCase("ITEMINDEX") || relationInfo.getRefKey().equalsIgnoreCase("ITEMTYPE"))||extTableName!=processExtTableName)
                                        {
                                        eUpdateQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                        }
                                    }

                                    /** Bugzilla Bug 5486, Case : Var_Int1 (QPersonId) is mapped to
                                     * Person' personId which is mapped to Address personId
                                     * Data is coming in QPersonId only, which is the key field of next 2 level structures
                                     * NPE in setting multi level complex structures and key is in top level only */
                                    if (relationInfo.getMappedChildField() != null) {
                                        if (debugFlag) {
                                            printOut(engineName,"[WFSUtil] updateData() update case... Putting in simplifiedValueMap for child mapped field name >> " + relationInfo.getMappedChildField().getName().toUpperCase() + " value >> " + newValueStr);
                                        }
                                        simplifiedValueMap.primitiveValueMap.put(relationInfo.getMappedChildField().getName().toUpperCase(), new WFFieldValuePrimitive(relationInfo.getMappedChildField(), newValueStr));
                                    } else {
                                        if (debugFlag) {
                                            printOut(engineName,"[WFSUtil] updateData() update case... Putting in simplifiedValueMap for ref key >> " + relationInfo.getRefKey().toUpperCase() + " value >> " + newValueStr);
                                        }
                                        simplifiedValueMap.primitiveValueMap.put(relationInfo.getRefKey().toUpperCase(), new WFFieldValuePrimitive(relationInfo.getMappedChildField(), newValueStr));
                                    }
                                    if (debugFlag) {
                                        printOut(engineName,"[WFSUtil] updateData() !presentInThisMap eInsertColQuery >> " + eInsertColQuery);
                                        printOut(engineName,"[WFSUtil] updateData() !presentInThisMap eInsertValQuery >> " + eInsertValQuery);
										printOut(engineName,"[WFSUtil] updateData() !presentInThisMap eUpdateQuery >> " + eUpdateQuery);
										printOut(engineName,"[WFSUtil] updateData() !presentInThisMap eUpdateValList >> " + eUpdateValList);
                                    }
                                }
                                if (relationInfo.getParentObject().equalsIgnoreCase(relationInfo.getChildObject())) {

                                    if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                        eFilterValList.add(newValueStr);
                                        eFilterStrBuff.append(" ? ");
                                        eParentFilterValueList.add(newValueStr);
                                        eParentFilterStrBuffArray.append(" ? ");
                                    } else {
                                        eFilterStrBuff.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                        eParentFilterStrBuffArray.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                    }
                                }
                                if (!presentInParentMap) {
//                                    if (debugFlag) {
//                                        printOut("[WFSUtil] updateData() ParentQueryInitialized as not present in parent map 1 >> " + presentInParentMap);
//                                    }
//                                    parentQueryInitialized = true;
//									if (counter > 1) {
//										updateParentQuery.append(", ");
//									}
//                                    updateParentQuery.append(relationInfo.getForeignKey());
//                                    updateParentQuery.append(" = ");
//
//                                    if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014
//
//                                        updateParentValList.add(newValueStr);
//                                        updateParentQuery.append(" ? ");
//                                    } else {
//                                        updateParentQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
//                                    }
                                    if (presentInParentRelationMap) {
                                        String str1 = (String) parentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase());
                                        /*if(((duplicateParentRelationValueMap!=null)&&duplicateParentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase())!=null)&&((relationInfo.getParentObject().equalsIgnoreCase(qdtTableName))||relationInfo.getParentObject().equalsIgnoreCase(processExtTableName))){
                                        	str1 = (String) duplicateParentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase());
                                        }	*/		            

                                        if (!str1.equalsIgnoreCase(newValueStr)) {
											if (debugFlag) {
												printOut(engineName,"[WFSUtil] updateData() ParentQueryInitialized as str1 >> " + str1 + " does not match newValueStr >> " + newValueStr);
											}
                                            parentQueryInitialized = true;
											if (counter > 1) {
												updateParentQuery.append(", ");
											}
                                            updateParentQuery.append(relationInfo.getForeignKey());
                                            updateParentQuery.append(" = ");
                                            if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                                updateParentValList.add(newValueStr);
                                                updateParentQuery.append(" ? ");
                                            } else {
                                                updateParentQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                            }
                                        }
                                        	/*else{
                                        	
                                        	if(!((relationInfo.getParentObject().equalsIgnoreCase(qdtTableName))||relationInfo.getParentObject().equalsIgnoreCase(processExtTableName))){
                                        	addNullCheck = true;
                                        	if(eParentFilterStrBuffArray.toString().charAt(eParentFilterStrBuffArray.toString().length()-1)==(')')){
                                        		eParentFilterStrBuffArray.deleteCharAt(eParentFilterStrBuffArray.toString().length()-1);
                                        	}
                                        	if(!(relationInfo.getRefKey().equalsIgnoreCase("ItemIndex")||relationInfo.getRefKey().equalsIgnoreCase("ItemType"))){
                                            eParentFilterStrBuffArray.append(" OR ");
                                            eParentFilterStrBuffArray.append(relationInfo.getForeignKey());
                                            eParentFilterStrBuffArray.append(" IS NULL ");
                                        	}
                                            eParentFilterStrBuffArray.append(")");
										    parentQueryInitialized = true;
											if (counter > 1) {
												updateParentQuery.append(", ");
											}
                                            updateParentQuery.append(relationInfo.getForeignKey());
                                            updateParentQuery.append(" = ");
                                            if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                                updateParentValList.add(newValueStr);
                                                updateParentQuery.append(" ? ");
                                            } else {
                                                updateParentQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                            }
                                        }
                                        }*/
                                    } else {
										if (debugFlag) {
											printOut(engineName,"[WFSUtil] updateData() ParentQueryInitialized as not present in presentInParentRelationMap " );
										}
                                        parentQueryInitialized = true;
										if (counter > 1) {
											updateParentQuery.append(", ");
										}
                                        updateParentQuery.append(relationInfo.getForeignKey());
                                        updateParentQuery.append(" = ");
                                        if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                            updateParentValList.add(newValueStr);
                                            updateParentQuery.append(" ? ");
                                        } else {
                                            updateParentQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                        }
                                    }
									if (debugFlag) {
										printOut(engineName,"[WFSUtil] updateData() updateParentQuery >> " + updateParentQuery.toString());
									}
								}
                            } else {
                                insertFlag = true;
                                if (debugFlag) {
                                    printOut(engineName," [WFSUtil] updateData() relation column found NULL in parentRelationValueMap value, hence insertFlag KEY >> " + relationInfo.getRefKey());
                                }
                                /** Relation columns are null in parent, hense insert.
                                 * Relation field values must be coming in this field' value map, hence parent
                                 * need to be updated .. OR in parentValueMap hence this need to be updated
                                 * OR will be autogen ....
                                 * But need to initialize eFilterStrBuff (parentFilterStr for next iteration), as this is passed to
                                 * updateData (recursion) to fetch parent' row while updating child... */
                                if (updateParentQuery == null) {
                                    updateParentQuery = new StringBuffer(200);
                                    updateParentValList = new ArrayList();
                                    updateParentQuery.append("Update ");
                                    updateParentQuery.append(relationInfo.getParentObject());
                                    updateParentQuery.append(" Set ");
                                }
//                                if (counter > 1) {
//                                    updateParentQuery.append(", ");
//                                }
                                newValueStr = null;
                                newValueStr = (!presentInParentMap) ? null : ((WFFieldValuePrimitive) parentValueMap.get(wfParentFieldNameForRelationColumn.toUpperCase())).value;
                                if (debugFlag) {
                                    printOut(engineName, "[WFSUtil] updateDate() newValueStr in parent >> " + newValueStr);
                                }
                                if (newValueStr == null || newValueStr.equals("")) {
                                    newValueStr = (!presentInThisMap) ? null : ((WFFieldValuePrimitive) simplifiedValueMap.primitiveValueMap.get(wfChildFieldNameForRelationColumn.toUpperCase())).value;
                                    if (debugFlag) {
                                        printOut(engineName, "[WFSUtil] updateDate() newValueStr in this >> " + newValueStr);
                                    }
                                }
                                if (newValueStr == null || newValueStr.equals("")) {
                                    /** @todo It can be a case when no data in process external table .... */
                                    if (debugFlag) {
                                        printOut(engineName, "[WFSUtil] updateDate() This is a case of AutoGen hence returning !! ");
                                    }
                                    if (eRelationMap.size() > 1) {
                                        printErr(engineName, "[WFSUtil] updateData This should never be the case, AUTOGEN & relation map size is greater than one ?? " + eRelationMap.size());
                                        return "";
                                    } else {
                                        int currentSeqNo = 0;
                                        int incrementBy = 0;
                                        int seed = 0;
                                        String autogenTableName = null;
                                        String autogenColumnName = null;
                                        /* New Table WFAutoGenInfoTable introduced in system for AutoGen functionality */
                                        /* Transaction is not opened here as this method is already called in transaction */
                                        queryStr = new StringBuffer(250);
                                        if(dbType == JTSConstant.JTS_ORACLE || dbType == JTSConstant.JTS_POSTGRES){
                                            String seqName = null;
                                            queryStr.append("Select SeqName from WFAutoGenInfoTable");
                                            queryStr.append(" WHERE ");
                                            queryStr.append(TO_STRING("TableName", false, dbType));
                                            queryStr.append(" = ");
                                            queryStr.append(TO_STRING("?", false, dbType));
                                            queryStr.append(" AND ");
                                            queryStr.append(TO_STRING("ColumnName", false, dbType));
                                            queryStr.append(" = ");
                                            queryStr.append(TO_STRING("?", false, dbType));
                                        

                                            pstmt = con.prepareStatement(queryStr.toString());

                                            if (relationInfo.isRAutoGenerated()) {
                                                autogenTableName = relationInfo.getChildObject();
                                                autogenColumnName = relationInfo.getRefKey();
                                            } else if (relationInfo.isFAutoGenerated()) {
                                                autogenTableName = relationInfo.getParentObject();
                                                autogenColumnName = relationInfo.getForeignKey();
                                            } else {
                                                printErr(engineName, "[WFSUtil] updateData This should never be the case, relation value is NULL ..... parent object >> " + relationInfo.getParentObject() + " child object >> " + relationInfo.getChildObject());
                                                return "";
                                            }


                                            WFSUtil.DB_SetString(1, autogenTableName, pstmt, dbType);
                                            WFSUtil.DB_SetString(2, autogenColumnName, pstmt, dbType);
                                            //OF Optimization
                                            parameters.add(autogenTableName);
                                            parameters.add(autogenColumnName);
                                            printOut(engineName,"[WFSUtil] updateData() Executing Autogen Query ... ");
                                            rs = jdbcExecuteQuery(processInstanceId, sessionId, userId, queryStr.toString(), pstmt, parameters, debugFlag, engineName);
                                            parameters.clear();
                                                
                                        //rs = pstmt.executeQuery();
                                            if (rs != null && rs.next()) {
//                                                currentSeqNo = rs.getInt("currentSeqNo");
//                                                incrementBy = rs.getInt("IncrementBy");
//                                                seed = rs.getInt("seed");
//                                                currentSeqNo = (currentSeqNo == 0 ? seed : currentSeqNo + incrementBy);
                                                seqName = rs.getString("SeqName");
                                                rs.close();
                                                currentSeqNo = Integer.parseInt(WFSUtil.nextVal(con, seqName, dbType));
                                                    
                                                newValueStr = String.valueOf(currentSeqNo);
                                            }
                                            if (rs != null) {
                                                rs.close();
                                                rs = null;
                                            }
                                            pstmt.close();
                                            pstmt = null;

//                                        queryStr = new StringBuffer(250);
//                                        queryStr.append("UPDATE WFAutoGenInfoTable SET currentSeqNo = ? WHERE ");
//                                        queryStr.append(TO_STRING("TableName", false, dbType));
//                                        queryStr.append(" = ");
//                                        queryStr.append(TO_STRING("?", false, dbType));
//                                        queryStr.append(" AND ");
//                                        queryStr.append(TO_STRING("ColumnName", false, dbType));
//                                        queryStr.append(" = ");
//                                        queryStr.append(TO_STRING("?", false, dbType));
//
//                                        pstmt = con.prepareStatement(queryStr.toString());
//                                        pstmt.setInt(1, currentSeqNo);	//Bugzilla Bug 6790
//
//                                        WFSUtil.DB_SetString(2, autogenTableName, pstmt, dbType);
//                                        WFSUtil.DB_SetString(3, autogenColumnName, pstmt, dbType);
//                                        //OF Optimization
//                                        parameters.add(currentSeqNo);
//                                        parameters.add(autogenTableName);
//                                        parameters.add(autogenColumnName);
//                                        printOut(engineName,"[WFSUtil] updateData() Executing Autogen update Query ... ");
//                                        jdbcExecute(processInstanceId, sessionId, userId, queryStr.toString(), pstmt, parameters, debugFlag, engineName);
//                                        parameters.clear();
//                                        //pstmt.executeUpdate();
//
//                                        pstmt.close();
//                                        pstmt = null;
                                        }
                    				
		    if(dbType == JTSConstant.JTS_MSSQL ){
                        queryStr1 = new StringBuilder();
                      queryStr1.append("Insert WFMAPPINGTABLE_"+ relationInfo.getForeignKey() + " Default Values ");
                      jdbcExecute(null, sessionId, userId, queryStr1.toString(), stmt, null, debugFlag, engineName);
                     queryStr2 = new StringBuilder();
                     queryStr2.append("Select @@IDENTITY");
                     rs = jdbcExecuteQuery(null, sessionId, userId, queryStr2.toString(), stmt, null, debugFlag, engineName);
                    if(rs != null && rs.next()) {
                        newValueStr = String.valueOf(rs.getInt(1));
                        rs.close();
                    }
                }
                                    }
                                }

                                if (counter > 1) {
                                    eFilterStrBuff.append(" AND ");
                                }
                                eFilterStrBuff.append(" ( ");
                                eParentFilterStrBuffArray.append(" AND ");
                                eParentFilterStrBuffArray.append("( ");
                                eParentFilterStrBuffArray.append(relationInfo.getForeignKey());
                                eParentFilterStrBuffArray.append(" IS NULL ");
                                eFilterStrBuff.append(relationInfo.getRefKey());
                                eFilterStrBuff.append(" = ");
                                eParentFilterStrBuffArray.append(" OR ");
                                eParentFilterStrBuffArray.append(relationInfo.getForeignKey());
                                eParentFilterStrBuffArray.append(" = ");
                                if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                    eFilterValList.add(newValueStr);
                                    eFilterStrBuff.append(" ? ");
                                    eParentFilterValueList.add(newValueStr);
                                    eParentFilterStrBuffArray.append(" ? ");
                                } else {
                                    eParentFilterStrBuffArray.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                    eFilterStrBuff.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                }
                                /*if(previousValueStrMap!=null&&previousValueStrMap.get(relationInfo.getRefKey())!=null&&previousValueStrMap.get(relationInfo.getRefKey()).toString()!=tempValueStr){
                                	eFilterStrBuff.append(" OR ");
                                	eFilterStrBuff.append(relationInfo.getRefKey());
                                	eFilterStrBuff.append(" = ");
                                	eFilterStrBuff.append(TO_SQL(previousValueStrMap.get(relationInfo.getRefKey()).toString(),relationInfo.getColType(), dbType, true));
                                    previousValueStrMap.clear();
                                }*/
                                eFilterStrBuff.append(" ) ");
                                eParentFilterStrBuffArray.append(" )");
                                //Bugzilla Bug 6855 check was missing earlier-Shweta Tyagi
                                if (!presentInThisMap || (presentInThisMap && ((WFFieldValuePrimitive) simplifiedValueMap.primitiveValueMap.get(wfChildFieldNameForRelationColumn.toUpperCase())).fieldInfo.getExtObjId() == 0)) {

                                    if (!updateE) {
                                        updateE = true;
                                        if (rootFlag) {
                                            parentFilterStr = qFilterStrBuff.toString();
                                        }
                                    }
                                    /** Always insert in this field' table */
                                    if (eInsertColQuery == null) {
                                        eInsertColQuery = new StringBuffer(200);
                                        eInsertColQuery.append("Insert into ");
                                        eInsertColQuery.append(extTableName);
                                        eInsertColQuery.append("(");
                                        eInsertValQuery = new StringBuffer(200);
                                        eInsertValList = new ArrayList();
                                        eInsertValQuery.append(" values (");
                                    } else {
                                        eInsertColQuery.append(", ");
                                        eInsertValQuery.append(", ");
                                        eUpdateQuery.append(", ");
                                        
                                    }
                                    eInsertColQuery.append(relationInfo.getRefKey());
                                    WFSUtil.printOut(engineName,"Relation table data type..." + newValueStr + relationInfo.getColType());
                                    if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                        eInsertValList.add(newValueStr);
                                        eInsertValQuery.append(" ? ");
                                    } else {
                                        eInsertValQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                    }
                                    /** Case : Var_Int1 (QPersonId) is mapped to Person' personId which is mapped to Address personId
                                     * Data is coming in QPersonId only, which is the key field of next 2 level structures */
                                    if (relationInfo.getMappedChildField() != null) {
                                        if (debugFlag) {
                                            printOut(engineName,"[WFSUtil] updateData() insert case... Putting in simplifiedValueMap for child mapped field name >> " + relationInfo.getMappedChildField().getName().toUpperCase() + " value >> " + newValueStr);
                                        }
                                        simplifiedValueMap.primitiveValueMap.put(relationInfo.getMappedChildField().getName().toUpperCase(), new WFFieldValuePrimitive(relationInfo.getMappedChildField(), newValueStr));
                                    } else {
                                        if (debugFlag) {
                                            printOut(engineName,"[WFSUtil] updateData() insert case... Putting in simplifiedValueMap for ref key >> " + relationInfo.getRefKey().toUpperCase() + " value >> " + newValueStr);
                                        }
                                        simplifiedValueMap.primitiveValueMap.put(relationInfo.getRefKey().toUpperCase(), new WFFieldValuePrimitive(relationInfo.getMappedChildField(), newValueStr));
                                    }
                                }
                                if (!presentInParentMap) {
                                    if (presentInParentRelationMap) {
                                        String str1 = (String) parentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase());
                                        if (!str1.equalsIgnoreCase(newValueStr)) {
											if (debugFlag) {
											printOut(engineName,"[WFSUtil] updateData() ParentQueryInitialized as str1 >> " + str1 + " does not match newValueStr >> " + newValueStr);
											}
                                            parentQueryInitialized = true;
											if (counter > 1) {
												updateParentQuery.append(", ");
											}
                                            updateParentQuery.append(relationInfo.getForeignKey());
                                            updateParentQuery.append(" = ");
                                            if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                                updateParentValList.add(newValueStr);
                                                updateParentQuery.append(" ? ");
                                            } else {
                                                updateParentQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                            }
                                        }
                                    } else {
										if (debugFlag) {
											printOut(engineName,"[WFSUtil] updateData() ParentQueryInitialized as not present in presentInParentRelationMap " );
										}
                                        parentQueryInitialized = true;
										if (counter > 1) {
											updateParentQuery.append(", ");
										}
                                        updateParentQuery.append(relationInfo.getForeignKey());
                                        updateParentQuery.append(" = ");
                                        if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                            updateParentValList.add(newValueStr);
                                            updateParentQuery.append(" ? ");
                                        } else {
                                            updateParentQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                        }
                                    }
                                }
                                if (!presentInParentRelationMap) {
                                    parentRelationValueMap.put(relationInfo.getForeignKey().toUpperCase(), newValueStr);
                                }
                            }
                            if (debugFlag) {
                                WFSUtil.printOut(engineName, " [WFSUtil] updateData() relationMap loop relationInfo.getRefKey() >> " + relationInfo.getRefKey());
                                WFSUtil.printOut(engineName, " [WFSUtil] updateData() relationMap loop relationInfo.getForeignKey() >> " + relationInfo.getForeignKey());
                                WFSUtil.printOut(engineName, " [WFSUtil] updateData() relationMap loop newValueStr >> " + newValueStr);
                            }
                        }
                    /** If value in parent relation field is null then insert else update ... */
                    } else {
                        printErr(engineName, "[WFSUtil] updateData() Check Check Check relationMap size is ZERO !! " + wfFieldInfo);
                        if((extTableName != null && processExtTableName != null && extTableName.equalsIgnoreCase(processExtTableName))){
		                    throw new WFSException(WFSError.WF_OPERATION_FAILED, WFSError.WM_ATTRIBUTE_ASSIGNMENT_FAILED, WFSError.WF_TMP, WFSErrorMsg.getMessage(WFSError.WF_OPERATION_FAILED), WFSErrorMsg.getMessage(WFSError.WM_ATTRIBUTE_ASSIGNMENT_FAILED));	
                        }
                    }
                }
                /** This is required, case : parent and child are both mapped to same table, and there is no row in table for filter */
                if (simplifiedValueMap.complexValueMap.size() > 0) {
                    counter = counterQ = 0;
                    HashMap tempRelMap = new HashMap();
                    HashMap tempColRelMap = new HashMap();
                    for (Iterator itrCom = simplifiedValueMap.complexValueMap.entrySet().iterator(); itrCom.hasNext();) {
                        entry = (Map.Entry) itrCom.next();
                        fieldValueComplex = (WFFieldValueComplex) entry.getValue();
                        tempFieldInfo = fieldValueComplex.fieldInfo;
                        tempRelationMap = tempFieldInfo.getRelationMap();
                        if (tempRelationMap != null && tempRelationMap.size() > 0) {
                            for (Iterator itrRel = tempRelationMap.entrySet().iterator(); itrRel.hasNext();) {
                                relationInfo = (WFRelationInfo) ((Map.Entry) itrRel.next()).getValue();
                                if (!(insertFlag && (relationInfo.isRAutoGenerated()))) {
                                    /** Case : Var_Int1 (QPersonId) is mapped to Person' personId which is mapped to Address personId
                                     * Data is coming in QPersonId only, which is the key field of next 2 level structures */
                                    if (debugFlag) {
                                        printOut(engineName,"[WFSUtil] updateData() putting in tempMap relationInfo.getForeignKey().toUpperCase() >> " + relationInfo.getForeignKey().toUpperCase());
                                        if (relationInfo.getMappedParentField() != null) {
                                            /** MappedFields can be null in relationMap, when the columns are in relation but not in attributes. AutoGen will also fall in this category.. */
                                            printOut(engineName,"[WFSUtil] updateData() putting in tempMap relationInfo.getMappedParentField().getName() >> " + relationInfo.getMappedParentField().getName());
                                        }
                                    }
                                    tempRelMap.put(relationInfo.getForeignKey().toUpperCase(), ((relationInfo.getMappedParentField() == null) ? relationInfo.getForeignKey() : relationInfo.getMappedParentField().getName()));
                                    tempColRelMap.put(relationInfo.getForeignKey().toUpperCase(), relationInfo.getRefKey());
                                    if (relationInfo.getParentObject().equalsIgnoreCase(qdtTableName)) {
                                        parentFilterStr = qFilterStrBuff.toString();
                                        if (qRelationValueStr == null) {
                                            qRelationValueStr = new StringBuffer(300);
                                            qRelationValueStr.append("Select ");
                                        }
                                        if (counterQ > 0) {
                                            qRelationValueStr.append(", ");
                                        }
                                        qRelationValueStr.append(relationInfo.getForeignKey());
                                        ++counterQ;
                                    } else {
                                        if (eRelationValueStr == null) {
                                            eRelationValueStr = new StringBuffer(300);
                                            eRelationValueStr.append("Select ");
                                        }
                                        if (counter > 0) {
                                            eRelationValueStr.append(", ");
                                        }
                                        eRelationValueStr.append(relationInfo.getForeignKey());
                                        ++counter;
                                    }
                                }
                            }
                        } else {
                            printErr(engineName, "[WFSUtil] updateData() Check Check Check child' relation map is NULL or size ZERO ... ");
                        }
                    }
                    if (debugFlag) {
                        printOut(engineName,"[WFSUtil] updateData() Creating relation str counterQ >> " + counterQ);
                        printOut(engineName,"[WFSUtil] updateData() Creating relation str counter >> " + counter);
                    }
                    if (rootFlag && counterQ > 0) {
                        qRelationValueStr.append(" FROM ");
                        qRelationValueStr.append(qdtTableName);
                        qRelationValueStr.append(qFilterStrBuff.toString());
                        /** Query QueueDataTable for  */
                        if (debugFlag) {
                            printOut(engineName,"[WFSUtil] updateData() qRelationValueStr >> " + qRelationValueStr);
                            printOut(engineName,"[WFSUtil] updateData() counterQ >> " + counterQ);
                            printOut(engineName,"[WFSUtil] updateData() Executing Q relation value Query ... ");
                        }
                        //OF Optimization
                        rs = jdbcExecuteQuery(processInstanceId, sessionId, userId, qRelationValueStr.toString(), stmt, null, debugFlag, engineName);
                        //rs = stmt.executeQuery(qRelationValueStr.toString());
                        rsmd = rs.getMetaData();
                        if (rs != null && rs.next()) {
                            for (int i = 1; i <= counterQ; i++) {
                                if (debugFlag) {
                                    printOut(engineName,"[WFSUtil] updateData() Q rsmd.getColumnName(i) >> " + rsmd.getColumnName(i).toUpperCase());
                                    printOut(engineName,"[WFSUtil] updateData() Q rs.getString(i) >> " + rs.getString(i));
                                    printOut(engineName,"[WFSUtil] updateData() Q From tempRelMap >> " + tempRelMap.get(rsmd.getColumnName(i).toUpperCase()));
                                }
                                relValueStr = rs.getString(i);
                                if (rs.wasNull()) {
                                    if (simplifiedValueMap.primitiveValueMap.containsKey(((String) tempRelMap.get(rsmd.getColumnName(i).toUpperCase())).toUpperCase())) {
                                        relValueStr = ((WFFieldValuePrimitive) simplifiedValueMap.primitiveValueMap.get(((String) tempRelMap.get(rsmd.getColumnName(i).toUpperCase())).toUpperCase())).value;
                                        if (debugFlag) {
                                            printOut(engineName,"[WFSUtil] updateData() q NEW relValueStr >> " + relValueStr);
                                        }
                                    }
                                }
                                if (debugFlag) {
                                    printOut(engineName,"[WFSUtil] updateData() Putting in eRelationValueMap VALUE >> " + relValueStr);
                                }
                                qRelationValueMap.put(rsmd.getColumnName(i).toUpperCase(), relValueStr);
                            }
                        }
                        rs.close();
                        rs = null;
                    }
                    if (counter > 0) {
                        eRelationValueStr.append(" FROM ");
                        eRelationValueStr.append(extTableName);
                        if(insertionOrderIdVal>0){
                        	eFilterStrBuff .append(" and insertionorderid ="+ insertionOrderIdVal);
                        }
                        eRelationValueStr.append(eFilterStrBuff.toString());
                        if (debugFlag) {
                            printOut(engineName,"[WFSUtil] updateData() eRelationValueStr >> " + eRelationValueStr);
                            printOut(engineName,"[WFSUtil] updateData() counter >> " + counter);
                            printOut(engineName,"[WFSUtil] updateData() Executing E relation Query ... ");
                        }
                        //Changed for nText support Bug Id WFS_8.0_014
                        pstmt1 = con.prepareStatement(eRelationValueStr.toString());
                        if(foundHistoryTable && queuehistorytabledata)
                        	pstmt2 = con.prepareStatement(eRelationValueStr.toString().replace(processExtTableName, processExtTableName_history));
                        Iterator it = eFilterValList.iterator();
                        int iListCount = 1;
                        while (it.hasNext()) {
                            String strListElement = (String) it.next();
							//	WFS_9.0_002
                            if(strListElement == null)
                                strListElement = "";
                            pstmt1.setCharacterStream(iListCount, new StringReader(strListElement), strListElement.length());
                            if(foundHistoryTable && queuehistorytabledata){
                            	pstmt2.setCharacterStream(iListCount, new StringReader(strListElement), strListElement.length());
                            }
                            iListCount++;
                        }
                        //rs = jdbcExecuteQuery(processInstanceId, sessionId, userId, eRelationValueStr.toString(), pstmt1, null, debugFlag, engineName);
                        if(rs!=null){
                        	rs.close();
                        	rs=null;
                        }
                        if(foundHistoryTable && queuehistorytabledata){
                        	 rs = jdbcExecuteQuery(processInstanceId, sessionId, userId, eRelationValueStr.toString().replace(processExtTableName, processExtTableName_history), pstmt2, null, debugFlag, engineName);
                        }
                        //rs = pstmt1.executeQuery();

//                            rs = stmt.executeQuery(eRelationValueStr.toString());
                        if(rs!=null){
                        	rsmd = rs.getMetaData();
                        }
                        if (rs != null && rs.next()) {
                            for (int i = 1; i <= counter; i++) {
                                if (debugFlag) {
                                    printOut(engineName,"[WFSUtil] updateData() E rsmd.getColumnName(i) >> " + rsmd.getColumnName(i).toUpperCase());
                                    printOut(engineName,"[WFSUtil] updateData() E rs.getString(i) >> " + rs.getString(i) + " from tempRelMap >> " + tempRelMap.get(rsmd.getColumnName(i).toUpperCase()));
                                }
                                relValueStr = rs.getString(i);
                                if (rs.wasNull()) {
                                    if (simplifiedValueMap.primitiveValueMap.containsKey(((String) tempRelMap.get(rsmd.getColumnName(i).toUpperCase())).toUpperCase())) {
                                        relValueStr = ((WFFieldValuePrimitive) simplifiedValueMap.primitiveValueMap.get(((String) tempRelMap.get(rsmd.getColumnName(i).toUpperCase())).toUpperCase())).value;
                                        if (debugFlag) {
                                            printOut(engineName,"[WFSUtil] updateData() E NEW relValueStr >> " + relValueStr);
                                        }
                                    } else {
                                        if (debugFlag) {
                                            printOut(engineName,"[WFSUtil] updateData() E VALUE NOT FOUND IN ParentRelationMap and primitiveValueMap ");
                                        }
                                    }
                                }
                                if (debugFlag) {
                                    printOut(engineName,"[WFSUtil] updateData() Putting in eRelationValueMap VALUE >> " + relValueStr);
                                }
                                if(insertNewRow){
                                	eRelationValueMap.put(rsmd.getColumnName(i).toUpperCase(),null);	
                                }
                                else{
                                	eRelationValueMap.put(rsmd.getColumnName(i).toUpperCase(), relValueStr);
                                }
                            }    
                        } else {
                        	if(rs!=null){
                        		rs.close();
                        		rs=null;
                        	}
                        	rs = jdbcExecuteQuery(processInstanceId, sessionId, userId, eRelationValueStr.toString(), pstmt1, null, debugFlag, engineName);
                        	 if(rs!=null){
                             	rsmd = rs.getMetaData();
                             };
                             if (rs != null && rs.next()) {
                                 for (int i = 1; i <= counter; i++) {
                                     if (debugFlag) {
                                         printOut(engineName,"[WFSUtil] updateData() E rsmd.getColumnName(i) >> " + rsmd.getColumnName(i).toUpperCase());
                                         printOut(engineName,"[WFSUtil] updateData() E rs.getString(i) >> " + rs.getString(i) + " from tempRelMap >> " + tempRelMap.get(rsmd.getColumnName(i).toUpperCase()));
                                     }
                                     relValueStr = rs.getString(i);
                                     if (rs.wasNull()) {
                                         if (simplifiedValueMap.primitiveValueMap.containsKey(((String) tempRelMap.get(rsmd.getColumnName(i).toUpperCase())).toUpperCase())) {
                                             relValueStr = ((WFFieldValuePrimitive) simplifiedValueMap.primitiveValueMap.get(((String) tempRelMap.get(rsmd.getColumnName(i).toUpperCase())).toUpperCase())).value;
                                             if (debugFlag) {
                                                 printOut(engineName,"[WFSUtil] updateData() E NEW relValueStr >> " + relValueStr);
                                             }
                                         } else {
                                             if (debugFlag) {
                                                 printOut(engineName,"[WFSUtil] updateData() E VALUE NOT FOUND IN ParentRelationMap and primitiveValueMap ");
                                             }
                                         }
                                     }
                                     if (debugFlag) {
                                         printOut(engineName,"[WFSUtil] updateData() Putting in eRelationValueMap VALUE >> " + relValueStr);
                                     }
                                     if(insertNewRow){
                                     	eRelationValueMap.put(rsmd.getColumnName(i).toUpperCase(),null);	
                                     }
                                     else{
                                     	eRelationValueMap.put(rsmd.getColumnName(i).toUpperCase(), relValueStr);
                                     }
                                 }    
                             }else{
	                            for (int i = 1; i <= counter; i++) {
	                                if (debugFlag) {
	                                    printOut(engineName,"[WFSUtil] updateData() NO DATA IN EXT TABLE ... ");
	                                }
	                                relValueStr = null;
	                                if (simplifiedValueMap.primitiveValueMap.containsKey(((String) tempRelMap.get(rsmd.getColumnName(i).toUpperCase())).toUpperCase())) {
	                                    relValueStr = ((WFFieldValuePrimitive) simplifiedValueMap.primitiveValueMap.get(((String) tempRelMap.get(rsmd.getColumnName(i).toUpperCase())).toUpperCase())).value;
	                                    if (debugFlag) {
	                                        printOut(engineName,"[WFSUtil] updateData() E NEW relValueStr (for no data) >> " + relValueStr);
	                                        printOut(engineName,"[WFSUtil] updateData() Putting in eRelationValueMap VALUE (for no data) >> " + relValueStr);
	                                    }
	                                } else {
	                                    if (debugFlag) {
	                                        printOut(engineName,"[WFSUtil] updateData() E (for no data) VALUE NOT FOUND IN ParentRelationMap and primitiveValueMap ");
	                                    }
	                                }
	                                eRelationValueMap.put(rsmd.getColumnName(i).toUpperCase(), relValueStr);
	                            }
                        	}
                        }
//                        rs.close();
//                        rs = null;
//                        pstmt1.close();
//                        pstmt1 = null;
                        if(rs!=null){
                        	rs.close();
                        	rs=null;
                        }
                        if(pstmt1!=null){
                        	pstmt1.close();
                        	pstmt1=null;
                        }
                        if(pstmt2!=null){
                        	pstmt2.close();
                        	pstmt2=null;
                        }
                    }
                }

                if (debugFlag) {
                   WFSUtil.printOut(engineName, " [WFSUtil] updateData() updateQ >> " + updateQ + " rootFlag >> " + rootFlag);
                }
                /** 01/07/2008, Bugzilla Bug 5470, Child first approach - Ruhi Hira */
                if (rootFlag && updateQ) {
                    if (debugFlag) {
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() qUpdateQuery >> " + qUpdateQuery);
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() qFilterStrBuff >> " + qFilterStrBuff);
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() QDT update query >> " + (qUpdateQuery.toString() + ((qFilterStrBuff == null) ? "" : qFilterStrBuff.toString())));
                    }
                    //OF Optimization
                    if(qUpdateQuerySelect != null){
                    	qUpdateQuerySelect.append(" ,Assignmenttype ");
                        qUpdateQuerySelect.append(" from ");
                        qUpdateQuerySelect.append(qdtTableName);
                        }
                        
                    
                    startTime = System.currentTimeMillis();
                    pstmt=con.prepareStatement(qUpdateQuerySelect.toString() + getTableLockHintStr(dbType)  + qFilterStrBuff);
                    rs = pstmt.executeQuery();
                    while(rs.next()){
                    	String assType = rs.getString("Assignmenttype");
                    	if(assType.equalsIgnoreCase("E"))
                    		continue;
                    	for(int ii=0; ii<counterQSelect-1;ii++){
                    		int startIndex=auditLogStrBuff.indexOf((String)selectColumnsList.get(ii)+"_old");
                    		int lenghth = ((String)selectColumnsList.get(ii)+"_old").length();
                    		int endindex=startIndex+lenghth;
                    		if(rs.getString((String) selectColumnsList.get(ii)) == null){
                    			auditLogStrBuff.replace(startIndex, endindex, "");
                    		}else{
                    		auditLogStrBuff.replace(startIndex, endindex, rs.getString((String) selectColumnsList.get(ii)));
                    		}
                    		
                    	}
                    }
                    jdbcExecuteUpdate(processInstanceId, sessionId, userId, qUpdateQuery.toString() + ((qFilterStrBuff == null) ? "" : qFilterStrBuff.toString()), stmt, null, debugFlag, engineName);
                    //stmt.executeUpdate(qUpdateQuery.toString() + ((qFilterStrBuff == null) ? "" : qFilterStrBuff.toString()));
                    endTime = System.currentTimeMillis();
                    printOut(engineName, " [WFSUtil] timeElapsedInfoMap : " + timeElapsedInfoMap);
                    if (timeElapsedInfoMap != null) {
                        timeElapsedToSetQueueData = (Long) timeElapsedInfoMap.get(WFSConstant.CONST_TIME_ELAPSED_QUEUE_DATA);
                        if (timeElapsedToSetQueueData == null) {
                            timeElapsedToSetQueueData = 0L;
                        }
                        timeElapsedToSetQueueData += (endTime - startTime);
                        timeElapsedInfoMap.put(WFSConstant.CONST_TIME_ELAPSED_QUEUE_DATA, timeElapsedToSetQueueData);
                        printOut(engineName, " [WFSUtil] updateData() for updating queue variable >> timeElapsedToSetQueueData >> " + timeElapsedToSetQueueData);
                    }
                    printOut(engineName, " [WFSUtil] updateData() for updating queue variable >> startTime : " + startTime + "endTime : " +endTime+ " total  Time taken >> " + (endTime - startTime));
                
                }
                if (rootFlag && updateM) {
                    if (debugFlag) {
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() updateWITableQuery >> " + updateWITableQuery);
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() qFilterStrBuff >> " + qFilterStrBuff);
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() WITable update query >> " + (updateWITableQuery.toString() + ((qFilterStrBuff == null) ? "" : qFilterStrBuff.toString())));
                    }
                    //OF Optimization
                    jdbcExecuteUpdate(processInstanceId, sessionId, userId, updateWITableQuery.toString() + ((qFilterStrBuff == null) ? "" : qFilterStrBuff.toString()), stmt, null, debugFlag, engineName);
                    //stmt.executeUpdate(updateWITableQuery.toString() + ((qFilterStrBuff == null) ? "" : qFilterStrBuff.toString()));
                }
                if (debugFlag) {
                    WFSUtil.printOut(engineName, " [WFSUtil] updateData() updateE >> " + updateE);
                    WFSUtil.printOut(engineName, " [WFSUtil] updateData() insertFlag >> " + insertFlag);
                    WFSUtil.printOut(engineName, " [WFSUtil] updateData() insertFlag >> " + insertFlag);
                    WFSUtil.printOut(engineName, " [WFSUtil] updateData() eUpdateQuery >> " + eUpdateQuery);
                    WFSUtil.printOut(engineName, " [WFSUtil] updateData() eFilterStrBuff >> " + eFilterStrBuff);
                    WFSUtil.printOut(engineName, " [WFSUtil] updateData() eParentFilterStrBuffArray >> " + eParentFilterStrBuffArray);
                    WFSUtil.printOut(engineName, " [WFSUtil] updateData() eInsertColQuery >> " + eInsertColQuery);
                    WFSUtil.printOut(engineName, " [WFSUtil] updateData() eInsertValQuery >> " + eInsertValQuery);
                    if (eUpdateQuery != null) {
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() EXT update query >> " + (eUpdateQuery.toString() + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString())));
                    }
                    if (eInsertColQuery != null) {
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() EXT insert query >> " + eInsertColQuery.toString() + ")" + eInsertValQuery.toString() + ")");
                    }
                }
                String seqValue = null;

                if (wfFieldInfo != null && wfFieldInfo.isArray()) {
                    /*if (eFilterStrBuff == null) {
                        printErr(engineName, "[WFSUtil] updateData() Check Check Check how come filter for deletion is NULL ... " + wfFieldInfo.getName());
                    }*/
                    if(dbType==JTSConstant.JTS_ORACLE || dbType==JTSConstant.JTS_POSTGRES)
                    {
                    	if(insertionOrderIdVal==0){
                    		String mappedTable=wfFieldInfo.getMappedTable();
                        	int length=mappedTable.length();
                        	if(length>28)
                        	{
                        		mappedTable=mappedTable.substring(0, 28);
                        	}
                    		seqArrayName = "S_"+mappedTable;
                    		seqValue = nextVal(con, seqArrayName, dbType);
                    		eInsertColQuery.append(" , INSERTIONORDERID");
                    		eInsertValQuery.append(" ,"+seqValue);
                    	}
                    	/*if(insertionOrderIdVal==0){
                    		seqArrayName = "WFSEQ_ARRAY_"+processDefId+"_"+wfFieldInfo.getExtObjId();
                    		seqValue = nextVal(con, seqArrayName, dbType);
                    		eInsertColQuery.append(" , INSERTIONORDERID");
                    		eInsertValQuery.append(" ,"+seqValue);
                    	}*/
                    }
                    if (valueCounter == 0 && !arrayAlreadyDeletedLocal) {	//WFS_8.0_041
                        /** @todo Ideally we should first delete upto the last leaf of node for arrays - Ruhi Hira */
						//printOut(engineName,"[WFSUtil] updateData() going to call deleteArray : eFilterStrBuff.toString() >> " + eFilterStrBuff.toString());
						//deleteArray(con, dbType, wfFieldInfo, debugFlag, eFilterStrBuff.toString(),engineName);	//WFS_8.0_041
						arrayAlreadyDeletedLocal = true;
						printOut(engineName,"[WFSUtil] updateData() After calling deleteArray");
						if(wfFieldInfo.isArray() && wfFieldInfo.isPrimitive()){
							deleteArray(con, dbType, wfFieldInfo, debugFlag, eFilterStrBuff.toString(),engineName, processDefId, eRelationMap);
							primitiveArrayDataDeleted = true;
						}
/*                        eDeleteArrayStrBuff = new StringBuffer(200);
                        eDeleteArrayStrBuff.append("Delete From ");
                        eDeleteArrayStrBuff.append(extTableName);
                        eDeleteArrayStrBuff.append(" ");
                        if (debugFlag) {
                            printOut(Level.DEBUG, " [WFSUtil] updateData() Array Delete query >> " + eDeleteArrayStrBuff.toString() + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString()));
                        }
                        //Changed for nText support Bug Id WFS_8.0_014
                       pstmt1 = con.prepareStatement(eDeleteArrayStrBuff.toString() + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString()));
                        WFSUtil.printOut("UpdateData eFilterValList : " + eFilterValList);
                        Iterator it = eFilterValList.iterator();
                        int iListCount = 1;
                        while (it.hasNext()) {
                            String strListElement = (String) it.next();
                            pstmt1.setCharacterStream(iListCount, new StringReader(strListElement), strListElement.length());
                            iListCount++;
                        }
                        pstmt1.executeUpdate();
                        pstmt1.close();
                        pstmt1 = null;
*/

//                            stmt.executeUpdate(eDeleteArrayStrBuff.toString() + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString()));
                    }
                	boolean deleteInsertionOrderIdData = false;
                    insertFlag = true;
                    if(insertionOrderIdVal >0){
                    	bExecuteEUpdate = true;
                    	insertFlag =false;
                    	
                    }
                    else if(insertionOrderIdVal <0){
                    	deleteInsertionOrderIdData = true;
                    	insertFlag =false;
                    	bExecuteEUpdate = false;
                    }
                    if(deleteInsertionOrderIdData){
                    	deleteInsertionOrderIdData = true;
                    	insertFlag =false;
                    	if(eFilterStrBuff!=null){
                    		eFilterStrBuff.append(" and InsertionOrderId ="+ Math.abs(insertionOrderIdVal ));
                    	}
                    	else{
                    		eFilterStrBuff =new StringBuffer(" where InsertionOrderId ="+ Math.abs(insertionOrderIdVal ) );
                    	}
                    	printOut(engineName,"[WFSUtil] updateData() going to call deleteArray : eFilterStrBuff.toString() >> " + eFilterStrBuff.toString());
                  
                    /*	String namechild=fieldValueComplex.fieldInfo.getName();
                    	String delTableName= wfFieldInfo.getMappedTable();
                    	String nameAtt = wfFieldInfo.getName();
                    	if (qDeleteArrayQuerySelectE == null ) {
                    		qDeleteArrayQuerySelectE = new StringBuffer(200);
                    	qDeleteArrayQuerySelectE.append("Select ");
                    	
                    	    }
                    	pstmt=con.prepareStatement("Select * from " + delTableName);
                        rs = pstmt.executeQuery();
                        
                        while(rs.next())
                        {
                        	
                        }
                    	
                		Map.Entry entryDel = null;
                		WFFieldInfo childInfo = null;
                		String mappedColumns = null;
                		String selectQuery = null;
                		ArrayList columnList = null;
                		ArrayList deleteConditions = null;
                    	
                    	
                    	if (!wfFieldInfo.isPrimitive()) {	//IN case of primitive no need to go to inner lev
            				for (Iterator childIter = wfFieldInfo.getChildInfoMap().entrySet().iterator(); childIter.hasNext();) {
            					entryDel = (Map.Entry) childIter.next();
            					childInfo = (WFFieldInfo) entryDel.getValue();
            					if (!childInfo.isPrimitive()) {
            						//We have to delete this as well....
            						columnList = getMappedColumnsInParent(childInfo, debugFlag, engineName);
            						mappedColumns = (String) columnList.get(0);
            						selectQuery = "SELECT " + mappedColumns + " FROM " + wfFieldInfo.getMappedTable() + eFilterStrBuff.toString();

            						deleteConditions = fetchDeleteCondition(con, dbType, selectQuery, (ArrayList) columnList.get(1), debugFlag, engineName);
            						
            					}
            					if (childInfo.isArray()) {
            						//We have to delete this as well....
            						columnList = getMappedColumnsInParent(childInfo, debugFlag, engineName);
            						mappedColumns = (String) columnList.get(0);
            						selectQuery = "SELECT " + mappedColumns + " FROM " + wfFieldInfo.getMappedTable() + eFilterStrBuff.toString();

            						deleteConditions = fetchDeleteCondition(con, dbType, selectQuery, (ArrayList) columnList.get(1), debugFlag, engineName);
            						
            					}
            				}
            			}
*/
                    	
                    	String auditLogDeleteselect = deleteArray(con, dbType, wfFieldInfo, debugFlag, eFilterStrBuff.toString(),engineName, processDefId, eRelationMap);
                    	//auditLogStrBuff.append("<Attribute>");
                        //auditLogStrBuff.append(parentAttribName.substring(0, parentAttribName.length()-1));
                       auditLogStrBuff.append(auditLogDeleteselect);
                        //auditLogStrBuff.append("<Type>");
                       // auditLogStrBuff.append(wfFieldInfo.getWfType());
                       // auditLogStrBuff.append("</Type>");
                        //if(wfFieldInfo!=null && wfFieldInfo.isArray() ){
                        	//auditLogStrBuff.append("<InsertionOrderId>").append(insertionOrderIdVal).append("</InsertionOrderId>");	
                       // }
                        //auditLogStrBuff.append("</Attribute>");
                    }
                    	
                /** Always insert if it is an array - Ruhi Hira */
                }
                if (updateE) {
                    if (insertFlag) {
                        /** Bugzilla Bug 7030, Case : QDT -> Person -> Address; mapping field is autogen.
                         *  Set data in Address field when Person is null.
                         *  Condition in code incorrect, (eUpdateQuery != null) in place of (eInsertColQuery != null)
                         *  - Ruhi Hira */
                    	if(wfFieldInfo!= null && wfFieldInfo.isArray() && wfFieldInfo.isPrimitive()&&(!primitiveArrayDataDeleted)){ 
							deleteArray(con, dbType, wfFieldInfo, debugFlag, eFilterStrBuff.toString(),engineName, processDefId, eRelationMap);
							primitiveArrayDataDeleted = true;
						}
                        if (eInsertColQuery != null) {
                        	if((arrayAlreadyDeletedLocal)&&(insertionOrderIdVal>0)){
                        		if (eRelationValueMap != null && eRelationValueMap.size() > 0) {
                        			for (Iterator itrRel = eRelationValueMap.entrySet().iterator(); itrRel.hasNext();) {
                        				entry = (Map.Entry) itrRel.next();
                        				String columnName = (String)entry.getKey();
                        				String columnValue =(String)entry.getValue();
                        				if(columnValue!=null){
                        					eInsertColQuery.append(",");
                        					eInsertColQuery.append(columnName);
                        					eInsertValQuery.append(",");
                        					eInsertValQuery.append(WFSUtil.TO_STRING(columnValue, true, dbType));
                        				}
                        			}



                        		}
                        	}
                            //Changed for nText support Bug Id WFS_8.0_014
                            pstmt1 = con.prepareStatement(eInsertColQuery.toString() + ")" + eInsertValQuery.toString() + ")");
                            Iterator it = eInsertValList.iterator();
                            int iListCount = 1;
                            while (it.hasNext()) {
                                String strListElement = (String) it.next();
								//	WFS_9.0_002
                                if(strListElement == null)
                                    strListElement = "";
                                pstmt1.setCharacterStream(iListCount, new StringReader(strListElement), strListElement.length());
                                iListCount++;
                            }
                         //   pstmt1.executeUpdate();
                            for(int ii=0; ii<counterQSelectE-1;ii++){
                        		int startIndex=auditLogStrBuff.indexOf((String)selectColumnsListE.get(ii)+"_old");
                        		int lenghth = ((String)selectColumnsListE.get(ii)+"_old").length();
                        		int endindex=startIndex+lenghth;
                        		
                        			auditLogStrBuff.replace(startIndex, endindex, "");
                        		
                        		
                        	}
                            
                            
                            startTime = System.currentTimeMillis();
                            jdbcExecuteUpdate(null, sessionId, userId, eInsertColQuery.toString() + ")" + eInsertValQuery.toString() + ")", pstmt1, null, debugFlag, engineName);
                            endTime = System.currentTimeMillis();
                            if(selectColumnsListE != null)
                            {
                            	selectColumnsListE.clear();
                            }
                            printOut(engineName, " [WFSUtil] updateData() eInsertColQuery started at "+startTime+ "ended at "+endTime +" for external table >>  time taken" + (endTime - startTime));
                            if (timeElapsedInfoMap != null) {
                                timeElapsedToSetExtData = (Long) timeElapsedInfoMap.get(WFSConstant.CONST_TIME_ELAPSED_EXT_DATA);
                                if (timeElapsedToSetExtData == null) {
                                    timeElapsedToSetExtData = 0L;
                                }
                                timeElapsedToSetExtData += (endTime - startTime);
                                timeElapsedInfoMap.put(WFSConstant.CONST_TIME_ELAPSED_EXT_DATA, timeElapsedToSetExtData);
                                printOut(engineName, " [WFSUtil] updateData() timeElapsedToSetExtData for external table >>  time taken" + timeElapsedToSetExtData);
                            }
                            printOut(engineName, " [WFSUtil] updateData() eInsertColQuery started at " + startTime + "ended at " + endTime + " for external table >>  time taken" + (endTime - startTime));
                           
                            pstmt1.close();
                            pstmt1 = null;
                            if(dbType==JTSConstant.JTS_ORACLE || dbType==JTSConstant.JTS_POSTGRES){
                            	HashIdInsertionIdMap.put(hashIdValue,seqValue);
                            	parentInsertionOrderIdMap.put("InsertionOrderId", seqValue);
                            	auditLogStrBuff= new StringBuffer(auditLogStrBuff.toString().replace("<InsertionOrderId>dummy</InsertionOrderId>","<InsertionOrderId>" +String.valueOf(seqValue)+"</InsertionOrderId>"));
                            }
                            else if(dbType==JTSConstant.JTS_MSSQL){
								pstmt = con.prepareStatement("Select @@IDENTITY");
								pstmt.execute();
								rset = pstmt.getResultSet();

								if (rset != null && rset.next()) {
									long identityValue= rset.getLong(1);
									rset.close();
									rset = null;
	                            	HashIdInsertionIdMap.put(hashIdValue,identityValue);
	                            	parentInsertionOrderIdMap.put("InsertionOrderId", String.valueOf(identityValue));
	                            	auditLogStrBuff= new StringBuffer(auditLogStrBuff.toString().replace("<InsertionOrderId>dummy</InsertionOrderId>","<InsertionOrderId>" +String.valueOf(identityValue)+"</InsertionOrderId>"));
								}
                            }

//                                stmt.executeUpdate(eInsertColQuery.toString() + ")" + eInsertValQuery.toString() + ")");
                        } else {
                            if (debugFlag) {
                                printOut(engineName, " [WFSUtil] updateData() This should never be the case, insertFlag is true but eInsertColQuery is NULL !! ");
                            }
                        }
                    } else if(bExecuteEUpdate) { 
                        /** @todo if parentRelationInfo values were null need not fire update query just insert */
//                            int res = stmt.executeUpdate(eUpdateQuery.toString() + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString()));
                        boolean bIsNotNull = false;
                        if (eFilterStrBuff != null) {
                            bIsNotNull = true;
                        }
                        if(insertionOrderIdVal>0){
                        	eFilterStrBuff.append(" and InsertionOrderId = "+ insertionOrderIdVal);
                        	auditLogStrBuff= new StringBuffer(auditLogStrBuff.toString().replace("<InsertionOrderId>dummy</InsertionOrderId>","<InsertionOrderId>" +String.valueOf(insertionOrderIdVal)+"</InsertionOrderId>"));
                        	
                        }
                        //Changed for nText support Bug Id WFS_8.0_014
                        if(!dontUpdateMappingField){
                        pstmt1 = con.prepareStatement(eUpdateQuery.toString() + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString()));
                        if(externalQuery && foundHistoryTable && queuehistorytabledata)
                            pstmt2 = con.prepareStatement(eUpdateQuery.toString().replace(processExtTableName, processExtTableName_history) + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString()));
                        
                        //Merging the two lists of values as per the conditions
                        ArrayList mergedList = new ArrayList();

                        Iterator it1 = eUpdateValList.iterator();
                        while (it1.hasNext()) {
                            String strValue = (String) it1.next();
                            mergedList.add(strValue);
                        }
                        if (bIsNotNull) {
                            Iterator it2 = eFilterValList.iterator();
                            while (it2.hasNext()) {
                                String strValue = (String) it2.next();
                                mergedList.add(strValue);
                            }
                        }
                        //  Replacing the values in the query.
                        Iterator it = mergedList.iterator();
                        int iListCount = 1;
                        while (it.hasNext()) {
                            String strListElement = (String) it.next();
							//	WFS_9.0_002
                            if(strListElement == null)
                                strListElement = "";
                            pstmt1.setCharacterStream(iListCount, new StringReader(strListElement), strListElement.length());
                            if(externalQuery && foundHistoryTable && queuehistorytabledata)
                            	pstmt2.setCharacterStream(iListCount, new StringReader(strListElement), strListElement.length());
                            iListCount++;
                        }
                        startTime = System.currentTimeMillis();
                        //int res = jdbcExecuteUpdate(processInstanceId, sessionId, userId, eUpdateQuery.toString() + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString()), pstmt1, null, debugFlag, engineName);
                        //int res = pstmt1.executeUpdate();
                        
                        if(qUpdateQuerySelectE != null){
                        
                        pstmt=con.prepareStatement(qUpdateQuerySelectE.toString() + getTableLockHintStr(dbType) + eFilterStrBuff );
                        rs = pstmt.executeQuery();
                        while(rs.next()){
                        	
                        	for(int ii=0; ii<counterQSelectE-1;ii++){
                        		int startIndex=auditLogStrBuff.indexOf((String)selectColumnsListE.get(ii)+"_old");
                        		int lenghth = ((String)selectColumnsListE.get(ii)+"_old").length();
                        		int endindex=startIndex+lenghth;
                        		if(rs.getString((String) selectColumnsListE.get(ii)) == null){
                        			auditLogStrBuff.replace(startIndex, endindex, "");
                        		}else{
                        		auditLogStrBuff.replace(startIndex, endindex, rs.getString((String) selectColumnsListE.get(ii)));
                        		}
                        		
                        	}
                        }
                        
                        }
                        
                        int res=0;
                        if(externalQuery && foundHistoryTable && queuehistorytabledata){
                        	res = jdbcExecuteUpdate(processInstanceId, sessionId, userId, eUpdateQuery.toString().replace(processExtTableName, processExtTableName_history) + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString()), pstmt2, null, debugFlag, engineName);
                        }
                        if(res<=0){
                        	res = jdbcExecuteUpdate(processInstanceId, sessionId, userId, eUpdateQuery.toString() + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString()), pstmt1, null, debugFlag, engineName);
                        }
                        endTime = System.currentTimeMillis();
                        
                        printOut(engineName,  " [WFSUtil] updateData() Insert query for externaltable started at >> " + startTime + " ended at >> " + endTime + "timeDuration : " + (endTime - startTime));
                        if (timeElapsedInfoMap != null) {
                            timeElapsedToSetExtData = (Long) timeElapsedInfoMap.get(WFSConstant.CONST_TIME_ELAPSED_EXT_DATA);
                            if (timeElapsedToSetExtData == null) {
                                timeElapsedToSetExtData = 0L;
                            }
                            timeElapsedToSetExtData += (endTime - startTime);
                            timeElapsedInfoMap.put(WFSConstant.CONST_TIME_ELAPSED_EXT_DATA, timeElapsedToSetExtData);
                            printOut(engineName, " [WFSUtil] updateData() Update query for externaltable started at >> " + startTime + " ended at >> " + endTime + "Total Time taken : " + timeElapsedToSetExtData);
                        }
                        printOut(engineName, " [WFSUtil] updateData() Update query for externaltable started at >> " + startTime + " ended at >> " + endTime + "Total Time taken : " + (endTime - startTime));
//                      
//                        pstmt1.close();
//                        pstmt1 = null;
                        if(pstmt1!=null){
                        	pstmt1.close();
                        	pstmt1 = null;
                        }
                        if(pstmt2!=null){
                        	pstmt2.close();
                        	pstmt2=null;
                        }
                        if (res <= 0) {
                            if (debugFlag) {
                                printOut(engineName, " [WFSUtil] updateData() Inserting as update result <= 0 " + res);
                            }
                            //Changed for nText support Bug Id WFS_8.0_014
                            pstmt1 = con.prepareStatement(eInsertColQuery.toString() + ")" + eInsertValQuery.toString() + ")");
                            Iterator it4 = eInsertValList.iterator();
                            iListCount = 1;
                            while (it4.hasNext()) {
                                String strListElement = (String) it4.next();
								//	WFS_9.0_002
                                if(strListElement == null)
                                    strListElement = "";
                                pstmt1.setCharacterStream(iListCount, new StringReader(strListElement), strListElement.length());
                                iListCount++;
                            }
                            
                            for(int ii=0; ii<counterQSelectE-1;ii++){
                        		int startIndex=auditLogStrBuff.indexOf((String)selectColumnsListE.get(ii)+"_old");
                        		int lenghth = ((String)selectColumnsListE.get(ii)+"_old").length();
                        		int endindex=startIndex+lenghth;
                        		
                        			auditLogStrBuff.replace(startIndex, endindex, "");
                        		
                        		
                        	}
                            
                            startTime = System.currentTimeMillis();
                            jdbcExecuteUpdate(processInstanceId, sessionId, userId, eInsertColQuery.toString() + ")" + eInsertValQuery.toString() + ")", pstmt1, null, debugFlag, engineName);
                            endTime = System.currentTimeMillis(); 
                            printOut(engineName, " [WFSUtil] updateData() Insert query for externaltable started at >> " + startTime + " ended at >> " + endTime + "timeDuration : " + (endTime - startTime));
                            if (timeElapsedInfoMap != null) {
                                timeElapsedToSetExtData = (Long) timeElapsedInfoMap.get(WFSConstant.CONST_TIME_ELAPSED_EXT_DATA);
                                if (timeElapsedToSetExtData == null) {
                                    timeElapsedToSetExtData = 0L;
                                }
                                timeElapsedToSetExtData += (endTime - startTime);
                                timeElapsedInfoMap.put(WFSConstant.CONST_TIME_ELAPSED_EXT_DATA, timeElapsedToSetExtData);
                                printOut(engineName, " [WFSUtil] updateData() Insert query for externaltable started at >> timeElapsedToSetExtData : " + timeElapsedToSetExtData);
                            }
                            //pstmt1.executeUpdate();
                            pstmt1.close();
                            pstmt1 = null;

//                                stmt.executeUpdate(eInsertColQuery.toString() + ")" + eInsertValQuery.toString() + ")");
                        }
                        
                        if(selectColumnsListE != null)
                        	selectColumnsListE.clear();
                        }
                        
                    }
                }

                if (debugFlag) {
                    printOut(engineName, " [WFSUtil] updateData() parentQueryInitialized >> " + parentQueryInitialized);
                    printOut(engineName, " [WFSUtil] updateData() updateParentQuery >> " + updateParentQuery);
                }
                if (updateParentQuery != null && parentQueryInitialized) {
                    if (debugFlag) {
                        printOut(engineName, " [WFSUtil] updateData() Parent Query >> " + updateParentQuery.toString() + ((parentFilterStr == null) ? " " : parentFilterStr) + ((eParentFilterStrBuffArray != null && parentFieldInfo != null && parentFieldInfo.isArray()) ? eParentFilterStrBuffArray.toString() : " "));
                    }
                    if (wfFieldInfo != null && ((wfFieldInfo.isArray() && (valueCounter == 0)) || (!wfFieldInfo.isArray()))) {
                        boolean bIsNotNull = false;
                        WFSUtil.printOut(engineName,"updateParentQuery :" + updateParentQuery.toString());
                        WFSUtil.printOut(engineName,"eParentFilterStrBuffArray :" + eParentFilterStrBuffArray.toString());
                        if (eParentFilterStrBuffArray != null && parentFieldInfo != null && parentFieldInfo.isArray()) {
                            bIsNotNull = true;
                        }
                        printOut(engineName, " [WFSUtil] updateData() Parent Query >> Executing parent query");
                        //Changed for nText support Bug Id WFS_8.0_014
                        if(parentRelationValueMap!=null&&parentRelationValueMap.containsKey("InsertionOrderId")){
                        	eParentFilterStrBuffArray.append(" and InsertionOrderId ="+parentRelationValueMap.get("InsertionOrderId") );
                        }
                        pstmt1 = con.prepareStatement(updateParentQuery.toString() + ((parentFilterStr == null) ? " " : parentFilterStr) + ((eParentFilterStrBuffArray != null && parentFieldInfo != null && parentFieldInfo.isArray()) ? eParentFilterStrBuffArray.toString() : " "));
                        //Merging data in two value tables
                        ArrayList mergedValueList = new ArrayList();
                        Iterator it2 = updateParentValList.iterator();
                        while (it2.hasNext()) {
                            String strNextValue = (String) it2.next();
                            mergedValueList.add(strNextValue);
                        }

                        if (bIsNotNull) {
                            Iterator it3 = eParentFilterValueList.iterator();
                            while (it3.hasNext()) {
                                String strNextValue = (String) it3.next();
                                mergedValueList.add(strNextValue);
                            }
                        }

                        //Putting values in the prepared statement.
                        Iterator it = mergedValueList.iterator();
                        int iListCount = 1;
                        while (it.hasNext()) {
                            String strListElement = (String) it.next();
							//	WFS_9.0_002
                            if(strListElement == null)
                                strListElement = "";
                            pstmt1.setCharacterStream(iListCount, new StringReader(strListElement), strListElement.length());
                            iListCount++;
                        }
                        jdbcExecuteUpdate(processInstanceId, sessionId, userId, updateParentQuery.toString() + ((parentFilterStr == null) ? " " : parentFilterStr) + ((eParentFilterStrBuffArray != null && parentFieldInfo != null && parentFieldInfo.isArray()) ? eParentFilterStrBuffArray.toString() : " "), pstmt1, parameters, debugFlag, engineName);
                        //pstmt1.executeUpdate();
                        pstmt1.close();
                        pstmt1 = null;

//                            stmt.executeUpdate(updateParentQuery.toString() + ((parentFilterStr == null) ? " " : parentFilterStr) + ((eParentFilterStrBuffArray != null && parentFieldInfo != null && parentFieldInfo.isArray()) ? eParentFilterStrBuffArray.toString() : " "));
                    }
                }


                /** parent table will be updated before child table */
                String tempFilterStr = null;
                for (Iterator itrCom = simplifiedValueMap.complexValueMap.entrySet().iterator(); itrCom.hasNext();) {
                    entry = (Map.Entry) itrCom.next();
                    fieldValueComplex = (WFFieldValueComplex) entry.getValue();
                    /** passing cacheAttribMap null, as not required when !root
                     * @todo If relationInfo has parent Table QueueDataTable then pass qFilterStrBuff
                     * Else pass eFilterStrBuff */
                    if (debugFlag) {
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() complexValueMap loop fieldValueComplex.fieldInfo.getName() >> " + fieldValueComplex.fieldInfo.getName());
                    }
                    if(parentInsertionOrderIdMap!=null&&!parentInsertionOrderIdMap.isEmpty()&&parentInsertionOrderIdMap.containsKey("InsertionOrderId")){
                    	eRelationValueMap.putAll(parentInsertionOrderIdMap);
                    }
                    if (rootFlag) {
                        if (fieldValueComplex.fieldInfo != null && fieldValueComplex.fieldInfo.getRelationMap() != null && fieldValueComplex.fieldInfo.getRelationMap().size() > 0) {
                            if (((WFRelationInfo) fieldValueComplex.fieldInfo.getRelationMap().values().toArray()[0]).getParentObject().equalsIgnoreCase(qdtTableName) ||
                                    ((WFRelationInfo) fieldValueComplex.fieldInfo.getRelationMap().values().toArray()[0]).getChildObject().equalsIgnoreCase(processExtTableName)) {
                                tempFilterStr = (qFilterStrBuff == null) ? "" : qFilterStrBuff.toString();
                                relationValueMap = qRelationValueMap;
                            } else {
                                tempFilterStr = (eFilterStrBuff == null) ? "" : eFilterStrBuff.toString();
                                relationValueMap = eRelationValueMap;
                            }
                        }
                    } else {
                        if (((WFRelationInfo) fieldValueComplex.fieldInfo.getRelationMap().values().toArray()[0]).getParentObject().equalsIgnoreCase(qdtTableName) ||
                                ((WFRelationInfo) fieldValueComplex.fieldInfo.getRelationMap().values().toArray()[0]).getChildObject().equalsIgnoreCase(processExtTableName)) {
                            tempFilterStr = (qFilterStrBuff == null) ? "" : qFilterStrBuff.toString();
                            relationValueMap = qRelationValueMap;
                        } else {
                            tempFilterStr = (eFilterStrBuff == null) ? "" : eFilterStrBuff.toString();
                            relationValueMap = eRelationValueMap;
                        }
                    }
                    
                    if (debugFlag) {
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() Calling updateData again ..... ");
						WFSUtil.printOut(engineName, " [WFSUtil] updateData() arrayAlreadyDeletedLocal ..... " + arrayAlreadyDeletedLocal);
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() eFilterStrBuff >> " + eFilterStrBuff);
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() fieldValueComplex.value >> " + fieldValueComplex.value);
                    }
                    String tempParentAttribName = (parentAttribName == null || parentAttribName.equals("")) ? fieldValueComplex.fieldInfo.getName() + "." : (parentAttribName + fieldValueComplex.fieldInfo.getName() + ".");
                    String tempAuditLogStr = updateData(con, engineName, dbType, processInstanceId, workitemId, processDefId, false, fieldValueComplex.value,
                            ((WFFieldInfo) cacheAttribMap.get(fieldValueComplex.fieldInfo.getName().toUpperCase())).getChildInfoMap(),
                            fieldValueComplex.fieldInfo, simplifiedValueMap.primitiveValueMap,
                            tempFilterStr, debugFlag, relationValueMap, wiTableName, tempParentAttribName, workitemIds, wfFieldInfo, arrayAlreadyDeletedLocal, sessionId, userId,timeElapsedInfoMap,HashIdInsertionIdMap,queuehistorytabledata);
                    auditLogStrBuff.append(tempAuditLogStr);
                }
                /** Execute query qUpdateStr if root + eUpdateStr, if result 0 then eInsertStr */
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
            }
        } catch (Exception ex) {
            exceptionToBeThrown = ex;
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (pstmt1 != null) {
                    pstmt1.close();
                    pstmt1 = null;
                }
            } catch (Exception ignored) {
            }
        }
        if (exceptionToBeThrown != null) {
            throw exceptionToBeThrown;
        }
        return auditLogStrBuff.toString();
    }	
	
	  /**
     * *************************************************************
     * Function Name    :   isFieldValueValid
     * Programmer' Name :   Mohnish Chopra
     * Date Written     :   July 9th 2020
     * Input Parameters :   WFFieldInfo and String (Metadata of field and Value passed in attibute xml)
     * Output Parameters:   NONE
     * Return Value     :   boolean-> is value passed in api correspoding to variable valid or not
     * Description      :  Api to validate data passed in attribute.
     * *************************************************************
     */
	private static boolean isFieldValueValid(WFFieldInfo fieldInfo, String value) {
		boolean isDataValid = true;
		// TODO Auto-generated method stub
		if(fieldInfo.getWfType()==WFSConstant.WF_STR) {
			int size  = fieldInfo.getLength();
			int actualLength = value!=null?value.length():0;
			if(actualLength > size ) {
				isDataValid=false;
			}
		}else if (fieldInfo.getWfType()==WFSConstant.WF_FLT) { 
			int length = fieldInfo.getLength();
			int precision = fieldInfo.getPrecison();
			BigDecimal val = new BigDecimal(value);
			int valPrecision = val.precision();
			int scale=  val.scale();

			if(valPrecision-scale>length-precision) {
				isDataValid=false;
			}
		}else if (fieldInfo.getWfType()==WFSConstant.WF_INT) { 
			try{
                int i =Integer.parseInt(value);
            } catch(NumberFormatException ne){                
            	isDataValid = false;
                
            }
		}else if (fieldInfo.getWfType()==WFSConstant.WF_LONG) { 
            	try{
            		Long l =Long.parseLong(value);
            	} catch(NumberFormatException ne){                
            		isDataValid = false;

            	}	

            }
		else if (fieldInfo.getWfType()==WFSConstant.WF_SHORT_DAT) { 
			if (value.indexOf(":") < 0) {
				value = value + " 00:00:00";
			}
			String tempDate = (value.indexOf(".") > 0 ? value.substring(0, value.indexOf(".")) : value);
			if (!checkSQLInjectionInDate(tempDate, true)) {
				isDataValid = false;

			}
		}
		else if (fieldInfo.getWfType()==WFSConstant.WF_DAT) {
			String tempDate = (value.indexOf(".") > 0 ? value.substring(0, value.indexOf(".")) : value);
			if (!checkSQLInjectionInDate(tempDate, true)) {
       		isDataValid = false;

			}
        }
		else if (fieldInfo.getWfType()==WFSConstant.WF_BOOLEAN) { 
			int length = fieldInfo.getLength();
			int actualLength = value!=null?value.length():0;
			if(actualLength >length) {
	       		isDataValid = false;


			}
		}
		return isDataValid;
	}

	private static String updateData_old(Connection con, String engineName, int dbType, String processInstanceId, int workitemId,
            int processDefId, boolean rootFlag, ArrayList values, HashMap cacheAttribMap, WFFieldInfo wfFieldInfo,
            HashMap parentValueMap, String parentFilterStr, boolean debugFlag, HashMap parentRelationValueMap, String wiTableName,
            String parentAttribName, String workitemIds, WFFieldInfo parentFieldInfo, boolean arrayAlreadyDeleted, int sessionId, int userId,HashMap timeElapsedInfoMap) throws Exception {

        PreparedStatement pstmt1 = null;
        PreparedStatement pstmt = null;
        PreparedStatement pstmtNew = null;
        Statement stmt = null;
        ResultSet rs = null;
        String extTableName = null;
        String processExtTableName = null;
        SimplifiedValueMap simplifiedValueMap = null;
        HashMap qRelationMap = null;
        HashMap eRelationMap = null;
        WFFieldValuePrimitive fieldValuePrimitive = null;
        WFFieldValueComplex fieldValueComplex = null;
        HashMap childMap = null;
        HashMap relationValueMap = null;
        HashMap qRelationValueMap = new HashMap();
        HashMap eRelationValueMap = new HashMap();
        HashMap valueMap = null;
        boolean updateQ = false;
        boolean updateE = false;
        boolean updateM = false;
        StringBuffer updateWITableQuery = null;
        StringBuffer qUpdateQuery = null;
        StringBuffer eUpdateQuery = null;
        ArrayList eUpdateValList = null;
        StringBuffer updateParentQuery = null;
        ArrayList updateParentValList = null;
        StringBuffer eInsertColQuery = null;
        StringBuffer eInsertValQuery = null;
        ArrayList eInsertValList = null;
        String tempColumnStr = null;
        String tempValueStr = null;
        /*String previousValueStr = null;
        HashMap previousValueStrMap = null;*/
        String newValueStr = null;
        Map.Entry entry = null;
        WFRelationInfo relationInfo = null;
        StringBuffer queryStr = null;
        StringBuffer qFilterStrBuff = null;
        ArrayList eFilterValList = null;
        StringBuffer eFilterStrBuff = null;
        StringBuffer eParentFilterStrBuffArray = null;  //check
        //boolean addNullCheck = false; 
        String seqArrayName = "";
        ArrayList eParentFilterValueList = null;
        //String qdtTableName = "QueueDataTable";
        String qdtTableName = "WFInstrumentTable";//OF Optimization
        String wfParentFieldNameForRelationColumn = null;
        String wfChildFieldNameForRelationColumn = null;
        WFFieldInfo tempFieldInfo = null;
        HashMap tempRelationMap = null;
        StringBuffer qRelationValueStr = null;
        StringBuffer eRelationValueStr = null;
        StringBuffer eDeleteArrayStrBuff = null; /*need to track this, as suggested by ruhi- shilpi*/
        StringBuffer auditLogStrBuff = new StringBuffer(200);
        ResultSetMetaData rsmd = null;
        String relValueStr = null;
        char currentFieldType = '\0';
        boolean presentInParentRelationMap = false;
        boolean presentInParentMap = false;
        boolean presentInThisMap = false;
        boolean parentQueryInitialized = false;
        boolean insertFlag = false;
        Exception exceptionToBeThrown = null;
        boolean bExecuteEUpdate = false;
        StringBuilder queryStr1= null;
        StringBuilder queryStr2= null;
        long startTime = 0l;
        long endTime = 0l;
        //HashMap duplicateParentRelationValueMap = new HashMap();

        int counter = 0;
        int counterQ = 0;
        int counterM = 0;
        ArrayList parameters = new ArrayList();
        Long  timeElapsedToSetQueueData = 0L;
        Long  timeElapsedToSetExtData = 0L;
        if (debugFlag) {
            printOut(engineName, " [WFSUtil] updateData() counter >> " + counter);
            printOut(engineName, " [WFSUtil] updateData() engineName >> " + engineName);
            printOut(engineName," [WFSUtil] updateData() dbType >> " + dbType);
            printOut(engineName," [WFSUtil] updateData() processInstanceId >> " + processInstanceId);
            printOut(engineName, " [WFSUtil] updateData() workitemId >> " + workitemId);
            printOut(engineName, " [WFSUtil] updateData() processDefId >> " + processDefId);
            printOut(engineName, " [WFSUtil] updateData() rootFlag >> " + rootFlag);
            printOut(engineName, " [WFSUtil] updateData() values >> " + values);
            printOut(engineName, " [WFSUtil] updateData() cacheAttribMap >> " + cacheAttribMap);
            printOut(engineName, " [WFSUtil] updateData() wfFieldInfo >> " + wfFieldInfo);
            printOut(engineName, " [WFSUtil] updateData() parentValueMap >> " + parentValueMap);
            printOut(engineName, " [WFSUtil] updateData() parentFilterStr >> " + parentFilterStr);
            printOut(engineName, " [WFSUtil] updateData() debugFlag >> " + debugFlag);
            if (wfFieldInfo != null) {
                printOut(engineName, " [WFSUtil] updateData() wfFieldInfo.getName() >> " + wfFieldInfo.getName());
            }
            printOut(engineName, " [WFSUtil] updateData() parentRelationValueMap >> " + parentRelationValueMap);
        }

        if (values == null || values.size() == 0) {
            /** @todo printErrshould we continue, in order to clear the values in database ? - Ruhi Hira */
            /* need to write code here
            1 a method call is needed ,
            2 this method will delete data from table for this and reset its parent -shilpi*/
            if (wfFieldInfo != null && wfFieldInfo.isArray() && !arrayAlreadyDeleted) {
				printOut(engineName," [WFSUtil] wfFieldInfo != null && wfFieldInfo.isArray() && !arrayAlreadyDeleted >> " + arrayAlreadyDeleted);
                startTime = System.currentTimeMillis();
                String auditLogStr = deleteDataForNullArrays(
                        con, engineName, dbType, processInstanceId, workitemId,
                        processDefId, rootFlag, values, cacheAttribMap, wfFieldInfo,
                        parentValueMap, parentFilterStr, debugFlag, parentRelationValueMap, wiTableName,
                        parentAttribName, workitemIds, parentFieldInfo, eRelationMap);
                endTime = System.currentTimeMillis();
                if(debugFlag)
                    writeLog("setAttributesExt", "[updateData]_deleteDataForNullArrays()", startTime, endTime, 0, "", "", engineName,(endTime-startTime),0, 0);
                printOut(engineName,"[WFSUtil] updateData() Returning auditLogStr>>> !! " + auditLogStr);
                auditLogStrBuff.append(auditLogStr);
                return auditLogStrBuff.toString();
            } else {
                //printOut("[WFSUtil] updateData() Returning as value is NULL !! ");
                printErr(engineName, "[WFSUtil] updateData() Returning as value is NULL !! ");
                return "";
            }
        }

        try {
            try {
                processExtTableName = WFSExtDB.getTableName(engineName, processDefId, 1);
            /** ExtObjId is 1 for process external table */
            } catch (Exception ignored) {
            }
            /*if(parentRelationValueMap!=null){
            	duplicateParentRelationValueMap = new HashMap();
            	for (Iterator parentRelationValueIterator = parentRelationValueMap.entrySet().iterator(); parentRelationValueIterator.hasNext();) {
                Map.Entry relationMapEntry = (Map.Entry) parentRelationValueIterator.next();
                String parentRelationKey=relationMapEntry.getKey().toString();
                String value =(String) parentRelationValueMap.get(parentRelationKey); 
                duplicateParentRelationValueMap.put(parentRelationKey, value);
                parentRelationValueMap.put(parentRelationKey,null);
            }
            }
            else{
            	duplicateParentRelationValueMap = null;
            }*/
            qFilterStrBuff = new StringBuffer(200);
            qFilterStrBuff.append(" Where (");
            //qFilterStrBuff.append(TO_STRING("ProcessInstanceId", false, dbType));
            qFilterStrBuff.append("ProcessInstanceId"); //Changes for Prdp Bug 47241
            qFilterStrBuff.append(" = ");
            //qFilterStrBuff.append(TO_STRING(TO_STRING(processInstanceId, true, dbType), false, dbType));
            qFilterStrBuff.append(TO_STRING(processInstanceId, true, dbType));//Changes for Prdp Bug 47241
            qFilterStrBuff.append(" AND WorkitemId = ");
            qFilterStrBuff.append(workitemId);
            qFilterStrBuff.append(" ) ");
            /** 29/12/2008, Bugzilla Bug 7273, setAttributeExt does not set data in refered WIs - Ruhi Hira */
            if (workitemIds != null && !workitemIds.equals("")) {
                qFilterStrBuff.append(" OR ( ");
                //qFilterStrBuff.append(TO_STRING("ProcessInstanceId", false, dbType));
                qFilterStrBuff.append("ProcessInstanceId");//Changes for Prdp Bug 47241
                qFilterStrBuff.append(" = ");
                //qFilterStrBuff.append(TO_STRING(TO_STRING(processInstanceId, true, dbType), false, dbType));
                qFilterStrBuff.append(TO_STRING(processInstanceId, true, dbType));//Changes for Prdp Bug 47241
                qFilterStrBuff.append(" AND WorkitemId in (");
                qFilterStrBuff.append(workitemIds);
                qFilterStrBuff.append("))");
            }

            if (rootFlag) {
                childMap = cacheAttribMap;
                extTableName = processExtTableName;
            } else {
                childMap = wfFieldInfo.getChildInfoMap();
            }

            /*initially for first level values will have only one element and that is a map with keys being rr and q_result, sample input string = <Attributes><q_result>shilpisrivastava</q_result><rr></rr></Attributes>*/

            if (wfFieldInfo != null && !wfFieldInfo.isArray() && values.size() > 1) {
                printErr(engineName, "[WFSUtil] updateData() CHECK CHECK CHECK !!! wfFieldInfo is not array wfFieldInfo.name >> " + wfFieldInfo.getName() + " & values size is >> " + values.size());
            }

            /** 09/07/2008, Bugzilla Bug 5503, Array Support, Delete first, then insert all, then update parent - Ruhi Hira */
			boolean arrayAlreadyDeletedLocal = arrayAlreadyDeleted;
            for (int valueCounter = 0; valueCounter < values.size(); valueCounter++) { /*for outer most values.size() is one*/
				//arrayAlreadyDeletedLocal = arrayAlreadyDeleted;
                simplifiedValueMap = null;
                qRelationMap = null; /*may be q is for queuedatatable -  shilpi */
                eRelationMap = null; /*may be e is for external table - shilpi*/
                fieldValuePrimitive = null;
                fieldValueComplex = null;
                valueMap = null;
                updateQ = false;
                updateE = false;
                updateM = false;
                updateWITableQuery = null;
                qUpdateQuery = null;
                eUpdateQuery = null;
                updateParentQuery = null;
                eInsertColQuery = null;
                eInsertValQuery = null;
                tempColumnStr = null;
                tempValueStr = null;
                newValueStr = null;
                entry = null;
                relationInfo = null;
                queryStr = null;
                eFilterStrBuff = null;
                eParentFilterStrBuffArray = null;
                wfParentFieldNameForRelationColumn = null;
                wfChildFieldNameForRelationColumn = null;
                tempFieldInfo = null;
                tempRelationMap = null;
                qRelationValueStr = null;
                eRelationValueStr = null;
                eDeleteArrayStrBuff = null;
                rsmd = null;
                relValueStr = null;
                currentFieldType = '\0';
                presentInParentRelationMap = false;
                presentInParentMap = false;
                presentInThisMap = false;
                parentQueryInitialized = false;
                insertFlag = false;

                /*Need to check whats in here- shilpi*/
                if (rootFlag || (wfFieldInfo != null && !(wfFieldInfo.isArray() && wfFieldInfo.isPrimitive()))) {
                    valueMap = (HashMap) values.get(valueCounter);
                    startTime = System.currentTimeMillis();
                    simplifiedValueMap = simplifyValueMap(valueMap, cacheAttribMap, debugFlag, engineName);
                    endTime = System.currentTimeMillis();
                    if(debugFlag)
                        writeLog("setAttributesExt", "[updateData]_simplifyValueMap()", startTime, endTime, 0, "", "", engineName,(endTime-startTime),0, 0);
                } else {
                    /** 11/07/2008, Bugzilla Bug 5744, Primitive array support - Ruhi Hira */
                    if (debugFlag) {
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() This is a case of primitive array ... ");
                    }
                    HashMap primitiveMap = new HashMap();
                    primitiveMap.put(wfFieldInfo.getName(), new WFFieldValuePrimitive(wfFieldInfo, (String) values.get(valueCounter)));
                    HashMap complexMap = new HashMap();
                    simplifiedValueMap = new SimplifiedValueMap(primitiveMap, complexMap);
                }
				WFSUtil.printOut(engineName, " [WFSUtil] updateData() simplifiedValueMap.primitiveValueMap >> " + 		simplifiedValueMap.primitiveValueMap);

                counter = 1;
                counterQ = 1;
                counterM = 1;
                if (debugFlag) {
                    WFSUtil.printOut(engineName, " [WFSUtil] updateData() simplifiedValueMap.primitiveValueMap.size() >> " + simplifiedValueMap.primitiveValueMap.size());
                }
                /** Create insert/ update queries for primitive types at this level */
                queryStr = new StringBuffer();
                queryStr.append("Select RefKey from WFVarRelationTable " + WFSUtil.getTableLockHintStr(dbType) + "  where UPPER(ParentObject)= ? and UPPER(Foreignkey)").append(WFSUtil.getOperator(WFSConstant.WF_NOTLIKE)).append(" ? and UPPER(Foreignkey) ").append(WFSUtil.getOperator(WFSConstant.WF_NOTLIKE)).append("? and ProcessDefId=?");
                pstmtNew = con.prepareStatement(queryStr.toString());
                pstmtNew.setString(1,"WFINSTRUMENTTABLE");
                //pstmtNew.setString(1,"QUEUEDATATABLE");
                pstmtNew.setString(2,"%VAR_%");
                pstmtNew.setString(3,"%VAR_REC%");
                pstmtNew.setInt(4,processDefId);
                parameters.add("WFINSTRUMENTTABLE");
                parameters.add("%VAR_%");
                parameters.add("%VAR_REC%");
                parameters.add(processDefId);
                ResultSet rsNew=jdbcExecuteQuery(processInstanceId, sessionId, userId, queryStr.toString(), pstmtNew, parameters, debugFlag, engineName);
                parameters.clear();
                //pstmtNew.execute();
                //ResultSet rsNew=pstmtNew.getResultSet();
                ArrayList<String> arrList = new ArrayList<String>();
                while(rsNew.next()){
                    String foreignKey= rsNew.getString("RefKey");
                    //System.out.println("Foreign key is" +foreignKey);
                    printOut(engineName,"Foreign key is...!!! "+foreignKey);
                    arrList.add(foreignKey);
                }				
				if(rsNew != null){
                    rsNew.close();
                    rsNew = null ;
                }
                if(pstmtNew != null){
                    pstmtNew.close();
                    pstmtNew = null;
                }				
                startTime = System.currentTimeMillis();
                for (Iterator itrPrim = simplifiedValueMap.primitiveValueMap.entrySet().iterator(); itrPrim.hasNext();) {
                    entry = (Map.Entry) itrPrim.next();
                    fieldValuePrimitive = (WFFieldValuePrimitive) entry.getValue();
                    currentFieldType = '\0';
                    if (rootFlag) {
                        // WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} , rootFlag is true ");
                        // WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} , fieldValuePrimitive.fieldInfo.getExtObjId() == " + fieldValuePrimitive.fieldInfo.getExtObjId());
                        if (fieldValuePrimitive.fieldInfo.getExtObjId() == 0) { /*queue data variable*/
                            if (fieldValuePrimitive.fieldInfo.getScope() == 'Q' || fieldValuePrimitive.fieldInfo.getScope() == 'U') {
                                updateQ = true;
                                currentFieldType = 'Q';
                            } else if (fieldValuePrimitive.fieldInfo.getScope() == 'M') {
                                /** 03/04/3008, Bugzilla Bug 5515, unable to set system defined columns like PriorityLevel - Ruhi Hira */
                                updateM = true;
                                currentFieldType = 'M';
                            } else {
//                                printErr("[WFSUtil] updateData() Check Check Check scope is none of Q/ U/ M but >> " + fieldValuePrimitive.fieldInfo.getScope());
                                }
                        } else if (fieldValuePrimitive.fieldInfo.getExtObjId() == 1) {
                            //  WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} ,extobjid is 1 ");
                            if (!updateE) {
                                //  WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} ,updateE is false");
                                updateE = true;
                                parentFilterStr = qFilterStrBuff.toString();
                            //   WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} , updateE is false and parentFilterStr>>"+ parentFilterStr);
                            }
                            //  WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} , parentFilterStr>>"+ parentFilterStr);
                            currentFieldType = 'E';
                        } else {
                            printErr(engineName, "[WFSUtil] updateData() rootFlag true and extObjId >> " + fieldValuePrimitive.fieldInfo.getExtObjId());
                        }
                    } else {
                        // WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} , in else ");
                        //  WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} , in else , updateE = " + updateE);
                        if (!updateE) {
                            extTableName = wfFieldInfo.getMappedTable();
                            updateE = true;
                        //    WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} , in else , extTableName = " + extTableName);
                        }
                        currentFieldType = 'E';
                    }
                    // WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} , After all this if-else for variable type," +
                    //    "qFilterStrBuff = " + qFilterStrBuff.toString());
                    //  WFSUtil.printOut("[WFSUtil] updateData(), {for shilpi} , After all this if-else for variable type," +
                    //    "parentFilterStr = " + parentFilterStr);
                    if (currentFieldType == 'Q') {
                        if (qUpdateQuery == null) {
                            qUpdateQuery = new StringBuffer(200);
                            qUpdateQuery.append("Update ");
                            qUpdateQuery.append(qdtTableName);
                            qUpdateQuery.append(" Set ");
                        }
                        if (counterQ > 1) {
                            qUpdateQuery.append(", ");
                        }
                        qUpdateQuery.append(fieldValuePrimitive.fieldInfo.getMappedColumn());
                        qUpdateQuery.append(" = ");
                        qUpdateQuery.append(TO_SQL(fieldValuePrimitive.value, fieldValuePrimitive.fieldInfo.getWfType(), dbType, true));
                        ++counterQ;
                    } else if (currentFieldType == 'E') {
                        if (eInsertColQuery == null) {
                            eInsertColQuery = new StringBuffer(200);
                            eInsertColQuery.append("Insert into ");
                            eInsertColQuery.append(extTableName);
                            eInsertColQuery.append("(");
                            eInsertValQuery = new StringBuffer(200);
                            eInsertValList = new ArrayList();
                            eInsertValQuery.append(" values (");
                            eUpdateQuery = new StringBuffer(200);
                            eUpdateValList = new ArrayList();
                            eUpdateQuery.append("Update ");
                            eUpdateQuery.append(extTableName);
                            eUpdateQuery.append(" Set ");
                        }
                        if (counter > 1) {
                            eInsertValQuery.append(", ");
                            eInsertColQuery.append(", ");
                            eUpdateQuery.append(", ");
                        }
                        // Change for bug 40365 starts
						if(arrList.contains(fieldValuePrimitive.fieldInfo.getMappedColumn())){
							printOut(engineName,"Set operation restricted on SystemDefinedFields...!!");
		                    throw new WFSException(WFSError.WF_OPERATION_FAILED, WFSError.WM_ATTRIBUTE_ASSIGNMENT_FAILED, WFSError.WF_TMP, WFSErrorMsg.getMessage(WFSError.WF_OPERATION_FAILED), WFSErrorMsg.getMessage(WFSError.WM_ATTRIBUTE_ASSIGNMENT_FAILED));
						}
						// Change for bug 40365 ends
                        eInsertColQuery.append(fieldValuePrimitive.fieldInfo.getMappedColumn());
                      //Changes for Prdp Bug 47241
                        if(!(fieldValuePrimitive.fieldInfo.getMappedColumn().equalsIgnoreCase("ITEMINDEX") || fieldValuePrimitive.fieldInfo.getMappedColumn().equalsIgnoreCase("ITEMTYPE"))) {
                        bExecuteEUpdate = true;
                        eUpdateQuery.append(fieldValuePrimitive.fieldInfo.getMappedColumn());
                        eUpdateQuery.append(" = ");
                        }
                        if (fieldValuePrimitive.fieldInfo.getWfType() == WFSConstant.WF_NTEXT) {
                            eInsertValList.add(fieldValuePrimitive.value);     //Changed for nText support Bug Id WFS_8.0_014

                            eInsertValQuery.append(" ? ");
                            if(!(fieldValuePrimitive.fieldInfo.getMappedColumn().equalsIgnoreCase("ITEMINDEX") || fieldValuePrimitive.fieldInfo.getMappedColumn().equalsIgnoreCase("ITEMTYPE")))
                            {  	
                              eUpdateValList.add(fieldValuePrimitive.value);
                          //Changes for Prdp Bug 47241
                            eUpdateQuery.append(" ? ");
                            }
                        } else {
                            eInsertValQuery.append(TO_SQL(fieldValuePrimitive.value, fieldValuePrimitive.fieldInfo.getWfType(), dbType, true));
                          //Changes for Prdp Bug 47241
                            if(!(fieldValuePrimitive.fieldInfo.getMappedColumn().equalsIgnoreCase("ITEMINDEX") || fieldValuePrimitive.fieldInfo.getMappedColumn().equalsIgnoreCase("ITEMTYPE")))
                            {
                            	eUpdateQuery.append(TO_SQL(fieldValuePrimitive.value, fieldValuePrimitive.fieldInfo.getWfType(), dbType, true));
                            }
                        }

                        ++counter;
                    } else if (currentFieldType == 'M') {
                        if (fieldValuePrimitive.fieldInfo.getName().equalsIgnoreCase("PRIORITYLEVEL")) {
                            if (updateWITableQuery == null) {
                                updateWITableQuery = new StringBuffer(200);
                                updateWITableQuery.append("Update ");
                                updateWITableQuery.append(wiTableName);
                                updateWITableQuery.append(" Set ");
                            }
                            if (counterM > 1) {
                                updateWITableQuery.append(", ");
                            }
                            updateWITableQuery.append(fieldValuePrimitive.fieldInfo.getMappedColumn());
                            updateWITableQuery.append(" = ");
                            updateWITableQuery.append(TO_STRING(fieldValuePrimitive.value, true, dbType));
                            ++counterM;
                        } else {
                            /** This code will never excute */
                            if (qUpdateQuery == null) {
                                qUpdateQuery = new StringBuffer(200);
                                qUpdateQuery.append("Update ");
                                qUpdateQuery.append(qdtTableName);
                                qUpdateQuery.append(" Set ");
                            }
                            if (counterQ > 1) {
                                qUpdateQuery.append(", ");
                            }
                            qUpdateQuery.append(fieldValuePrimitive.fieldInfo.getMappedColumn());
                            qUpdateQuery.append(" = ");
                            qUpdateQuery.append(TO_SQL(fieldValuePrimitive.value, fieldValuePrimitive.fieldInfo.getWfType(), dbType, true));
                            ++counterQ;
                        }
                    }
                    if (debugFlag) {
                        printOut(engineName, "[WFSUtil] updateData() primitiveValueMap loop fieldValuePrimitive.value >> " + fieldValuePrimitive.value);
                    }
                    if(fieldValuePrimitive.value!=null && !("".equals(fieldValuePrimitive.value))){
                    auditLogStrBuff.append("<Attribute><Name>");
                    auditLogStrBuff.append(parentAttribName + fieldValuePrimitive.fieldInfo.getName());
                    auditLogStrBuff.append("</Name><Value>");
                    auditLogStrBuff.append(fieldValuePrimitive.value);
                    auditLogStrBuff.append("</Value>");
                    auditLogStrBuff.append("<Type>");
                    auditLogStrBuff.append(fieldValuePrimitive.fieldInfo.getWfType());
                    auditLogStrBuff.append("</Type>");
                    auditLogStrBuff.append("</Attribute>");
                }
                }
                endTime = System.currentTimeMillis();
                if(debugFlag)
                    writeLog("setAttributesExt", "[updateData]_primitive_value_Map", startTime, endTime, 0, "", "", engineName,(endTime-startTime),0, 0);

                if (debugFlag) {
                    printOut(engineName, "[WFSUtil] updateData() before checking relation map rootFlag >> " + rootFlag);
                }
                stmt = con.createStatement();
                if (rootFlag) {
                    /** Need to fetch value from relationMap .. */
                    parentValueMap = simplifiedValueMap.primitiveValueMap;
                }
                if (rootFlag && updateQ) {
                    /** @todo here relaionMap is not required */
                    qRelationMap = new HashMap();
                    qRelationMap.put("1", new WFRelationInfo(0, 1, qdtTableName, qdtTableName, "ProcessInstanceId", 'N', "ProcessInstanceId", 'N', WFSConstant.WF_STR));
                    qRelationMap.put("2", new WFRelationInfo(0, 2, qdtTableName, qdtTableName, "WorkitemId", 'N', "WorkitemId", 'N', WFSConstant.WF_INT));
                    if (debugFlag) {
                        printOut(engineName, "[WFSUtil] updateData() updateQ is true relation map populated ... " + qRelationMap);
                    }
                }
                startTime = System.currentTimeMillis();
                if ((rootFlag && updateE) ||
                        (rootFlag && (simplifiedValueMap.complexValueMap != null && simplifiedValueMap.complexValueMap.size() > 0 && processExtTableName != null && !processExtTableName.equals(""))) ||
                        (extTableName != null && processExtTableName != null && extTableName.equalsIgnoreCase(processExtTableName))) {
                    // make query on RecordMappingTable for creating relation map
                    queryStr = new StringBuffer();
                    queryStr.append(" Select ");
                    if (debugFlag) {
                        printOut(engineName, "[WFSUtil] updateData() Query RecordMappingTable >> SELECT DISTINCT Rec1, Rec2, Rec3, Rec4, Rec5 FROM RecordMappingTable where ProcessDefId = ? ");
                    }
                    queryStr1 = new StringBuilder();
                    queryStr1.append("SELECT DISTINCT Rec1, Rec2, Rec3, Rec4, Rec5 FROM RecordMappingTable " + WFSUtil.getTableLockHintStr(dbType) + "  where ProcessDefId = ? ");
                    pstmt = con.prepareStatement(queryStr1.toString());
                    pstmt.setInt(1, processDefId);
                    parameters.clear();
                    parameters.add(processDefId);
                    rs = jdbcExecuteQuery(null, sessionId, userId, queryStr1.toString(), pstmt, parameters, debugFlag, engineName);
                    parameters.clear();
                    //rs = pstmt.executeQuery();
                    if (rs != null && rs.next()) { // This loop will run just once ..

                        eRelationMap = new HashMap();
                        WFRelationInfo extRelationInfo = null;
                        for (int i = 1; i <= 5; i++) {
                            tempColumnStr = rs.getString(i);
                            if (!rs.wasNull() && !tempColumnStr.equals("")) {
                                if (debugFlag) {
                                    printOut(engineName, "[WFSUtil] updateData() updateE Adding to RelationMap tempColumnStr >> " + tempColumnStr);
                                }
                                if (i > 1) {
                                    queryStr.append(", ");
                                }
                                queryStr.append("Var_Rec_" + i);
                                extRelationInfo = new WFRelationInfo(0, i, qdtTableName, extTableName, ("Var_Rec_" + i), 'N', tempColumnStr, 'N', WFSConstant.WF_STR);
                                eRelationMap.put(String.valueOf(i), extRelationInfo);
//								extRelationInfo.setMappedParentField();
                                /** 14/07/2008, Bugzilla Bug 5768, Mapped child not set for external table fields - Ruhi Hira */
                                extRelationInfo.setMappedChildField((WFFieldInfo) cacheAttribMap.get(tempColumnStr.toUpperCase()));
                            }
                        }
                        queryStr.append(" From ");
                        queryStr.append(qdtTableName);
                        queryStr.append(qFilterStrBuff.toString());
                        if (rs != null) {
                            rs.close();
                            rs = null;
                        }
                        //OF Optimization
                        rs = jdbcExecuteQuery(processInstanceId, sessionId, userId, queryStr.toString(), stmt, null, debugFlag, engineName);
//                        rs = stmt.executeQuery(queryStr.toString());
                        rsmd = rs.getMetaData();
                        if (parentRelationValueMap == null) {
                            parentRelationValueMap = new HashMap();
                        }
                        if (rs != null && rs.next()) { // This loop will run just once ..

                            for (int i = 1; i <= rsmd.getColumnCount(); i++) {
                                tempColumnStr = rs.getString(i);
                                if (debugFlag) {
                                    printOut(engineName, "[WFSUtil] updateData() adding to parentRelationValueMap ... Column " + rsmd.getColumnName(i) + " Value >> " + tempColumnStr);
                                }
                                parentRelationValueMap.put(rsmd.getColumnName(i).toUpperCase(), tempColumnStr);
                            }
                        }
                    } else {
                        printErr(engineName, "[WFSUtil] updateData() Check this case No data returned from RecordMappingTable... ");
						//Changes for Bug 66857 -  All the columns in external table data is updated with the same values while performing Checkin process simultaneously
                        if((extTableName != null && processExtTableName != null && extTableName.equalsIgnoreCase(processExtTableName))){
		                    throw new WFSException(WFSError.WF_OPERATION_FAILED, WFSError.WM_ATTRIBUTE_ASSIGNMENT_FAILED, WFSError.WF_TMP, WFSErrorMsg.getMessage(WFSError.WF_OPERATION_FAILED), WFSErrorMsg.getMessage(WFSError.WM_ATTRIBUTE_ASSIGNMENT_FAILED));	
                        }
                    }
                    if (debugFlag) {
                        printOut(engineName,"[WFSUtil] updateData() updateE is true q relation map populated ... " + qRelationMap);
                        printOut(engineName, "[WFSUtil] updateData() updateE is true e relation map populated ... " + eRelationMap);
                    }
                    if (rs != null) {
                        rs.close();
                        rs = null;
                    }
                    pstmt.close();
                    pstmt = null;
                } else if (!rootFlag) {
                    eRelationMap = wfFieldInfo.getRelationMap();
                }
                endTime = System.currentTimeMillis();
                if(debugFlag)
                    writeLog("setAttributesExt", "[updateData]_external_table_relation", startTime, endTime, 0, "", "", engineName,(endTime-startTime),0, 0);

                /** Create condition string from relation map by querying parent table, override values if present in
                 * parent map ... */
                if (debugFlag) {
                    printOut(engineName, "[WFSUtil] updateData() eRelationMap >> " + eRelationMap + " updateE >> " + updateE);
                }

                if (!rootFlag && simplifiedValueMap.complexValueMap.size() > 0) {
                    extTableName = wfFieldInfo.getMappedTable();
                    updateE = true;
                }
                
                startTime = System.currentTimeMillis();
                if (updateE || (simplifiedValueMap.complexValueMap.size() > 0 && processExtTableName != null && !processExtTableName.equals(""))) {
                    if (eRelationMap != null && eRelationMap.size() > 0) {
                        eFilterStrBuff = new StringBuffer(200);
                        eFilterValList = new ArrayList();
                        eParentFilterStrBuffArray = new StringBuffer(100);
                        eParentFilterValueList = new ArrayList();
                        eFilterStrBuff.append(" Where ");
                        counter = 1;
                        /** relation fields should never come for update, but for insert ... */
                        for (Iterator relItr = eRelationMap.entrySet().iterator(); relItr.hasNext(); ++counter) {
                            entry = (Map.Entry) relItr.next();
                            relationInfo = (WFRelationInfo) entry.getValue();
                            /** 02/12/2008, Bugzilla Bug 7084, tempValueStr was not initialized - Ruhi Hira */
                            tempValueStr = null;
                            if (debugFlag) {
                                printOut(engineName, " [WFSUtil] updateData() tempValueStr reset !! ");
                            }
                            /** 31/12/2008, Bugzilla Bug 7241, Array in array was not working. - Ruhi Hira */
                            presentInParentRelationMap = false;
                            if (parentRelationValueMap != null) {
                                if (debugFlag) {
//                                    printErr("[WSFUtil] updateData() fetching data from parentRelationValueMap for >> " + relationInfo.getForeignKey().toUpperCase());
                                    }
                                if (parentFieldInfo != null && parentFieldInfo.isArray() && valueCounter == 0) {
                                    /*if(debugFlag)*/
                                        //printErr(engineName, "[WSFUtil] updateData() Dint check in parent map ");
									tempValueStr = (String) parentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase());
									if (tempValueStr != null && !tempValueStr.equals("")) {
										presentInParentRelationMap = true;
									}
                                } else {
                                    /*if(debugFlag)*/
                                        //printErr(engineName, "[WSFUtil] updateData() Trying to lookup in parent relation map .. ");
                                    tempValueStr = (String) parentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase());
									if (tempValueStr != null && !tempValueStr.equals("")) {
										presentInParentRelationMap = true;
									}
                                }
                                /*if(((duplicateParentRelationValueMap!=null)&&duplicateParentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase())!=null)&&((relationInfo.getParentObject().equalsIgnoreCase(qdtTableName))||relationInfo.getParentObject().equalsIgnoreCase(processExtTableName))){
                                    tempValueStr = (String) duplicateParentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase());
									if (tempValueStr != null && !tempValueStr.equals("")) {
										presentInParentRelationMap = true;
									}
									if(parentRelationValueMap!=null){
										parentRelationValueMap.put(relationInfo.getForeignKey().toUpperCase(), tempValueStr);
									}

                                }
                                
                                if((duplicateParentRelationValueMap!=null)&&(duplicateParentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase())!=null)){
                                	previousValueStr = (String) duplicateParentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase());
                                	previousValueStrMap = new HashMap();
                                	previousValueStrMap.put(relationInfo.getRefKey(),previousValueStr);
								 }*/
                                if (debugFlag) {
                                    printOut(engineName, " [WFSUtil] updateData() relationInfo.getForeignKey() >> " + relationInfo.getForeignKey());
                                    printOut(engineName, " [WFSUtil] updateData() tempValueStr >> " + tempValueStr);
                                }
                            } else {
                                if (debugFlag) {
//                                    printErr("[WSFUtil] updateData() parentRelationValueMap is NULL !!! ");
                                }
                            }
                            /** @todo for composite key in relation, what if one column is not null and one is null :( */
                            wfParentFieldNameForRelationColumn = (relationInfo.getMappedParentField() == null) ? "" : relationInfo.getMappedParentField().getName();
                            wfChildFieldNameForRelationColumn = (relationInfo.getMappedChildField() == null) ? "" : relationInfo.getMappedChildField().getName();
                            presentInParentMap = false;
                            presentInThisMap = false;
//                            presentInParentRelationMap = false;
                            if (parentValueMap.containsKey(wfParentFieldNameForRelationColumn.toUpperCase())) {
                                presentInParentMap = true;
                            }
                            if (simplifiedValueMap.primitiveValueMap.containsKey(wfChildFieldNameForRelationColumn.toUpperCase())) {
                                presentInThisMap = true;
                            }
//                            if (!(parentFieldInfo != null && parentFieldInfo.isArray() && valueCounter == 0)) {
//                                printErr("[WSFUtil] updateData() Dint check in parent map ");
//                                if (tempValueStr != null && !tempValueStr.equals("")) {
//                                    presentInParentRelationMap = true;
//                                }
//                            }
                            if (debugFlag) {
                                printOut(engineName, " [WFSUtil] updateData() wfParentFieldNameForRelationColumn >> " + wfParentFieldNameForRelationColumn);
                                printOut(engineName, " [WFSUtil] updateData() wfChildFieldNameForRelationColumn >> " + wfChildFieldNameForRelationColumn);
                                printOut(engineName," [WFSUtil] updateData() presentInParentMap >> " + presentInParentMap);
                                printOut(engineName, " [WFSUtil] updateData() presentInThisMap >> " + presentInThisMap);
                                printOut(engineName, " [WFSUtil] updateData() presentInParentRelationMap >> " + presentInParentRelationMap);
                                printOut(engineName, " [WFSUtil] updateData() tempValueStr >> " + tempValueStr + " IS THIS NULL ? " + (tempValueStr == null));
                            }
                            if (tempValueStr != null && !tempValueStr.equals("")) {
                                if (debugFlag) {
                                    printOut(engineName, " [WFSUtil] updateData() relation column found NOT NULL in parentRelationValueMap value >> " + tempValueStr + " KEY >> " + relationInfo.getRefKey());
                                }
                                if (updateParentQuery == null) {
                                    updateParentQuery = new StringBuffer(200);
                                    updateParentValList = new ArrayList();
                                    updateParentQuery.append("Update ");
                                    updateParentQuery.append(relationInfo.getParentObject());
                                    updateParentQuery.append(" Set ");
                                }
                                if (counter > 1) {
                                    eFilterStrBuff.append(" AND ");
//                                    updateParentQuery.append(", ");
                                }
                                //eFilterStrBuff.append("(");
                                eFilterStrBuff.append(relationInfo.getRefKey());
                                eFilterStrBuff.append(" = ");
                                eParentFilterStrBuffArray.append(" AND ");
                                //eParentFilterStrBuffArray.append("(");
                                eParentFilterStrBuffArray.append(relationInfo.getForeignKey());
                                eParentFilterStrBuffArray.append(" = ");
                                if (!relationInfo.getParentObject().equalsIgnoreCase(relationInfo.getChildObject())) {
                                    if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                        eFilterStrBuff.append(" ? ");
                                        eFilterValList.add(tempValueStr);
                                        eParentFilterStrBuffArray.append(" ? ");
                                        eParentFilterValueList.add(tempValueStr);
                                    } else {
                                        eFilterStrBuff.append(TO_SQL(tempValueStr, relationInfo.getColType(), dbType, true));
                                        eParentFilterStrBuffArray.append(TO_SQL(tempValueStr, relationInfo.getColType(), dbType, true));
                                    }
                                }
                                /*if(previousValueStrMap!=null&&previousValueStrMap.get(relationInfo.getRefKey())!=null&&previousValueStrMap.get(relationInfo.getRefKey()).toString()!=tempValueStr){
                                	eFilterStrBuff.append(" OR ");
                                	eFilterStrBuff.append(relationInfo.getRefKey());
                                	eFilterStrBuff.append(" = ");
                                	eFilterStrBuff.append(TO_SQL(previousValueStrMap.get(relationInfo.getRefKey()).toString(),relationInfo.getColType(), dbType, true));
                                	previousValueStrMap.clear();
                                }
                                eFilterStrBuff.append(")");
                                eParentFilterStrBuffArray.append(")");*/
                                /** filterStrBuff should always have the old value, tempValueStr
                                 * override value for update parent, insert child & update child query buffer */
                                newValueStr = null;
                                /** @todo We should not update parent in this case, as it may result in rebuiling
                                 * primary index */
                                newValueStr = (!parentValueMap.containsKey(wfParentFieldNameForRelationColumn.toUpperCase())) ? null : ((WFFieldValuePrimitive) parentValueMap.get(wfParentFieldNameForRelationColumn.toUpperCase())).value;
                                if (newValueStr == null || newValueStr.equals("")) {
                                    /** @todo check for null to avoid NullPointerException */
                                    newValueStr = (!presentInThisMap) ? null : ((WFFieldValuePrimitive) simplifiedValueMap.primitiveValueMap.get(wfChildFieldNameForRelationColumn.toUpperCase())).value;
                                }
                                if (newValueStr == null || newValueStr.equals("")) {
                                    newValueStr = tempValueStr;
                                }
                                if (debugFlag) {
                                    printOut(engineName,"[WFSUtil] updateData() presentInThisMap >> " + presentInThisMap);
                                }
                                /** 10/11/2008, Bugzilla Bug 6855,
                                 * Case : External table is associated with the process. No row in external table.
                                 *        When ItemIndex and ItemType is passed in setAttributeXML (from initiator web service code)
                                 *        presentInThisMap is true as it is in inputXML but extObjId is 0
                                 *        ItemIndex/ ItemType should be updated in both QDT as well as ExternalTable.
                                 *        Hence ItemIndex ans ItemType were not appended in query. To be check only relationMap loop.
                                 *        - Ruhi Hira */
                                if (!presentInThisMap ||
                                        (presentInThisMap &&
                                        ((WFFieldValuePrimitive) simplifiedValueMap.primitiveValueMap.get(wfChildFieldNameForRelationColumn.toUpperCase())).fieldInfo.getExtObjId() == 0)) {
                                    if (!updateE) {
                                        updateE = true;
                                        if (rootFlag) {
                                            parentFilterStr = qFilterStrBuff.toString();
                                        }
                                    }
                                    if (eInsertColQuery == null) {
                                        eInsertColQuery = new StringBuffer(200);
                                        eInsertColQuery.append("Insert into ");
                                        eInsertColQuery.append(extTableName);
                                        eInsertColQuery.append("(");
                                        eInsertValQuery = new StringBuffer(200);
                                        eInsertValList = new ArrayList();
                                        eInsertValQuery.append(" values (");
                                        eUpdateQuery = new StringBuffer(200);
                                        eUpdateValList = new ArrayList();
                                        eUpdateQuery.append("Update ");
                                        eUpdateQuery.append(extTableName);
                                        eUpdateQuery.append(" Set ");
                                    } else {
                                        eInsertColQuery.append(", ");
                                        eInsertValQuery.append(", ");
                                        if(!(relationInfo.getRefKey().equalsIgnoreCase("ITEMINDEX") || relationInfo.getRefKey().equalsIgnoreCase("ITEMTYPE"))) 
                                        {
                                            eUpdateQuery.append(", ");
                                        } 	
                                    }
									eInsertColQuery.append(relationInfo.getRefKey());
                                    WFSUtil.printOut(engineName,"Relation table data type..." + newValueStr + relationInfo.getColType());

                                    /** Need to check parentValueMap as well as value map for new relation field values */
                                    /** First update in this field' table if result is 0 then insert .. */
                                    if(!(relationInfo.getRefKey().equalsIgnoreCase("ITEMINDEX") || relationInfo.getRefKey().equalsIgnoreCase("ITEMTYPE"))) 
                                    {
                                       bExecuteEUpdate = true;
                                       eUpdateQuery.append(relationInfo.getRefKey());
                                       eUpdateQuery.append(" = ");
                                    }
                                    if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                        eInsertValList.add(newValueStr);
                                        eInsertValQuery.append(" ? ");
                                        if(!(relationInfo.getRefKey().equalsIgnoreCase("ITEMINDEX") || relationInfo.getRefKey().equalsIgnoreCase("ITEMTYPE")))
                                        {
                                           eUpdateValList.add(newValueStr);
                                           eUpdateQuery.append(" ? ");
                                        }  
                                    } else {
                                        eInsertValQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                        if(!(relationInfo.getRefKey().equalsIgnoreCase("ITEMINDEX") || relationInfo.getRefKey().equalsIgnoreCase("ITEMTYPE")))
                                        {
                                        eUpdateQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                        }
                                    }

                                    /** Bugzilla Bug 5486, Case : Var_Int1 (QPersonId) is mapped to
                                     * Person' personId which is mapped to Address personId
                                     * Data is coming in QPersonId only, which is the key field of next 2 level structures
                                     * NPE in setting multi level complex structures and key is in top level only */
                                    if (relationInfo.getMappedChildField() != null) {
                                        if (debugFlag) {
                                            printOut(engineName,"[WFSUtil] updateData() update case... Putting in simplifiedValueMap for child mapped field name >> " + relationInfo.getMappedChildField().getName().toUpperCase() + " value >> " + newValueStr);
                                        }
                                        simplifiedValueMap.primitiveValueMap.put(relationInfo.getMappedChildField().getName().toUpperCase(), new WFFieldValuePrimitive(relationInfo.getMappedChildField(), newValueStr));
                                    } else {
                                        if (debugFlag) {
                                            printOut(engineName,"[WFSUtil] updateData() update case... Putting in simplifiedValueMap for ref key >> " + relationInfo.getRefKey().toUpperCase() + " value >> " + newValueStr);
                                        }
                                        simplifiedValueMap.primitiveValueMap.put(relationInfo.getRefKey().toUpperCase(), new WFFieldValuePrimitive(relationInfo.getMappedChildField(), newValueStr));
                                    }
                                    if (debugFlag) {
                                        printOut(engineName,"[WFSUtil] updateData() !presentInThisMap eInsertColQuery >> " + eInsertColQuery);
                                        printOut(engineName,"[WFSUtil] updateData() !presentInThisMap eInsertValQuery >> " + eInsertValQuery);
										printOut(engineName,"[WFSUtil] updateData() !presentInThisMap eUpdateQuery >> " + eUpdateQuery);
										printOut(engineName,"[WFSUtil] updateData() !presentInThisMap eUpdateValList >> " + eUpdateValList);
                                    }
                                }
                                if (relationInfo.getParentObject().equalsIgnoreCase(relationInfo.getChildObject())) {

                                    if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                        eFilterValList.add(newValueStr);
                                        eFilterStrBuff.append(" ? ");
                                        eParentFilterValueList.add(newValueStr);
                                        eParentFilterStrBuffArray.append(" ? ");
                                    } else {
                                        eFilterStrBuff.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                        eParentFilterStrBuffArray.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                    }
                                }
                                if (!presentInParentMap) {
//                                    if (debugFlag) {
//                                        printOut("[WFSUtil] updateData() ParentQueryInitialized as not present in parent map 1 >> " + presentInParentMap);
//                                    }
//                                    parentQueryInitialized = true;
//									if (counter > 1) {
//										updateParentQuery.append(", ");
//									}
//                                    updateParentQuery.append(relationInfo.getForeignKey());
//                                    updateParentQuery.append(" = ");
//
//                                    if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014
//
//                                        updateParentValList.add(newValueStr);
//                                        updateParentQuery.append(" ? ");
//                                    } else {
//                                        updateParentQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
//                                    }
                                    if (presentInParentRelationMap) {
                                        String str1 = (String) parentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase());
                                        /*if(((duplicateParentRelationValueMap!=null)&&duplicateParentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase())!=null)&&((relationInfo.getParentObject().equalsIgnoreCase(qdtTableName))||relationInfo.getParentObject().equalsIgnoreCase(processExtTableName))){
                                        	str1 = (String) duplicateParentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase());
                                        }	*/		            

                                        if (!str1.equalsIgnoreCase(newValueStr)) {
											if (debugFlag) {
												printOut(engineName,"[WFSUtil] updateData() ParentQueryInitialized as str1 >> " + str1 + " does not match newValueStr >> " + newValueStr);
											}
                                            parentQueryInitialized = true;
											if (counter > 1) {
												updateParentQuery.append(", ");
											}
                                            updateParentQuery.append(relationInfo.getForeignKey());
                                            updateParentQuery.append(" = ");
                                            if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                                updateParentValList.add(newValueStr);
                                                updateParentQuery.append(" ? ");
                                            } else {
                                                updateParentQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                            }
                                        }
                                        	/*else{
                                        	
                                        	if(!((relationInfo.getParentObject().equalsIgnoreCase(qdtTableName))||relationInfo.getParentObject().equalsIgnoreCase(processExtTableName))){
                                        	addNullCheck = true;
                                        	if(eParentFilterStrBuffArray.toString().charAt(eParentFilterStrBuffArray.toString().length()-1)==(')')){
                                        		eParentFilterStrBuffArray.deleteCharAt(eParentFilterStrBuffArray.toString().length()-1);
                                        	}
                                        	if(!(relationInfo.getRefKey().equalsIgnoreCase("ItemIndex")||relationInfo.getRefKey().equalsIgnoreCase("ItemType"))){
                                            eParentFilterStrBuffArray.append(" OR ");
                                            eParentFilterStrBuffArray.append(relationInfo.getForeignKey());
                                            eParentFilterStrBuffArray.append(" IS NULL ");
                                        	}
                                            eParentFilterStrBuffArray.append(")");
										    parentQueryInitialized = true;
											if (counter > 1) {
												updateParentQuery.append(", ");
											}
                                            updateParentQuery.append(relationInfo.getForeignKey());
                                            updateParentQuery.append(" = ");
                                            if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                                updateParentValList.add(newValueStr);
                                                updateParentQuery.append(" ? ");
                                            } else {
                                                updateParentQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                            }
                                        }
                                        }*/
                                    } else {
										if (debugFlag) {
											printOut(engineName,"[WFSUtil] updateData() ParentQueryInitialized as not present in presentInParentRelationMap " );
										}
                                        parentQueryInitialized = true;
										if (counter > 1) {
											updateParentQuery.append(", ");
										}
                                        updateParentQuery.append(relationInfo.getForeignKey());
                                        updateParentQuery.append(" = ");
                                        if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                            updateParentValList.add(newValueStr);
                                            updateParentQuery.append(" ? ");
                                        } else {
                                            updateParentQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                        }
                                    }
									if (debugFlag) {
										printOut(engineName,"[WFSUtil] updateData() updateParentQuery >> " + updateParentQuery.toString());
									}
								}
                            } else {
                                insertFlag = true;
                                if (debugFlag) {
                                    printOut(engineName," [WFSUtil] updateData() relation column found NULL in parentRelationValueMap value, hence insertFlag KEY >> " + relationInfo.getRefKey());
                                }
                                /** Relation columns are null in parent, hense insert.
                                 * Relation field values must be coming in this field' value map, hence parent
                                 * need to be updated .. OR in parentValueMap hence this need to be updated
                                 * OR will be autogen ....
                                 * But need to initialize eFilterStrBuff (parentFilterStr for next iteration), as this is passed to
                                 * updateData (recursion) to fetch parent' row while updating child... */
                                if (updateParentQuery == null) {
                                    updateParentQuery = new StringBuffer(200);
                                    updateParentValList = new ArrayList();
                                    updateParentQuery.append("Update ");
                                    updateParentQuery.append(relationInfo.getParentObject());
                                    updateParentQuery.append(" Set ");
                                }
//                                if (counter > 1) {
//                                    updateParentQuery.append(", ");
//                                }
                                newValueStr = null;
                                newValueStr = (!presentInParentMap) ? null : ((WFFieldValuePrimitive) parentValueMap.get(wfParentFieldNameForRelationColumn.toUpperCase())).value;
                                if (debugFlag) {
                                    printOut(engineName, "[WFSUtil] updateDate() newValueStr in parent >> " + newValueStr);
                                }
                                if (newValueStr == null || newValueStr.equals("")) {
                                    newValueStr = (!presentInThisMap) ? null : ((WFFieldValuePrimitive) simplifiedValueMap.primitiveValueMap.get(wfChildFieldNameForRelationColumn.toUpperCase())).value;
                                    if (debugFlag) {
                                        printOut(engineName, "[WFSUtil] updateDate() newValueStr in this >> " + newValueStr);
                                    }
                                }
                                if (newValueStr == null || newValueStr.equals("")) {
                                    /** @todo It can be a case when no data in process external table .... */
                                    if (debugFlag) {
                                        printOut(engineName, "[WFSUtil] updateDate() This is a case of AutoGen hence returning !! ");
                                    }
                                    if (eRelationMap.size() > 1) {
                                        printErr(engineName, "[WFSUtil] updateData This should never be the case, AUTOGEN & relation map size is greater than one ?? " + eRelationMap.size());
                                        return "";
                                    } else {
                                        int currentSeqNo = 0;
                                        int incrementBy = 0;
                                        int seed = 0;
                                        String autogenTableName = null;
                                        String autogenColumnName = null;
                                        /* New Table WFAutoGenInfoTable introduced in system for AutoGen functionality */
                                        /* Transaction is not opened here as this method is already called in transaction */
                                        queryStr = new StringBuffer(250);
                                        if(dbType == JTSConstant.JTS_ORACLE || dbType == JTSConstant.JTS_POSTGRES){
                                            String seqName = null;
                                            queryStr.append("Select SeqName from WFAutoGenInfoTable");
                                            queryStr.append(" WHERE ");
                                            queryStr.append(TO_STRING("TableName", false, dbType));
                                            queryStr.append(" = ");
                                            queryStr.append(TO_STRING("?", false, dbType));
                                            queryStr.append(" AND ");
                                            queryStr.append(TO_STRING("ColumnName", false, dbType));
                                            queryStr.append(" = ");
                                            queryStr.append(TO_STRING("?", false, dbType));
                                        

                                            pstmt = con.prepareStatement(queryStr.toString());

                                            if (relationInfo.isRAutoGenerated()) {
                                                autogenTableName = relationInfo.getChildObject();
                                                autogenColumnName = relationInfo.getRefKey();
                                            } else if (relationInfo.isFAutoGenerated()) {
                                                autogenTableName = relationInfo.getParentObject();
                                                autogenColumnName = relationInfo.getForeignKey();
                                            } else {
                                                printErr(engineName, "[WFSUtil] updateData This should never be the case, relation value is NULL ..... parent object >> " + relationInfo.getParentObject() + " child object >> " + relationInfo.getChildObject());
                                                return "";
                                            }


                                            WFSUtil.DB_SetString(1, autogenTableName, pstmt, dbType);
                                            WFSUtil.DB_SetString(2, autogenColumnName, pstmt, dbType);
                                            //OF Optimization
                                            parameters.add(autogenTableName);
                                            parameters.add(autogenColumnName);
                                            printOut(engineName,"[WFSUtil] updateData() Executing Autogen Query ... ");
                                            rs = jdbcExecuteQuery(processInstanceId, sessionId, userId, queryStr.toString(), pstmt, parameters, debugFlag, engineName);
                                            parameters.clear();
                                                
                                        //rs = pstmt.executeQuery();
                                            if (rs != null && rs.next()) {
//                                                currentSeqNo = rs.getInt("currentSeqNo");
//                                                incrementBy = rs.getInt("IncrementBy");
//                                                seed = rs.getInt("seed");
//                                                currentSeqNo = (currentSeqNo == 0 ? seed : currentSeqNo + incrementBy);
                                                seqName = rs.getString("SeqName");
                                                rs.close();
                                                currentSeqNo = Integer.parseInt(WFSUtil.nextVal(con, seqName, dbType));
                                                    
                                                newValueStr = String.valueOf(currentSeqNo);
                                            }
                                            if (rs != null) {
                                                rs.close();
                                                rs = null;
                                            }
                                            pstmt.close();
                                            pstmt = null;

//                                        queryStr = new StringBuffer(250);
//                                        queryStr.append("UPDATE WFAutoGenInfoTable SET currentSeqNo = ? WHERE ");
//                                        queryStr.append(TO_STRING("TableName", false, dbType));
//                                        queryStr.append(" = ");
//                                        queryStr.append(TO_STRING("?", false, dbType));
//                                        queryStr.append(" AND ");
//                                        queryStr.append(TO_STRING("ColumnName", false, dbType));
//                                        queryStr.append(" = ");
//                                        queryStr.append(TO_STRING("?", false, dbType));
//
//                                        pstmt = con.prepareStatement(queryStr.toString());
//                                        pstmt.setInt(1, currentSeqNo);	//Bugzilla Bug 6790
//
//                                        WFSUtil.DB_SetString(2, autogenTableName, pstmt, dbType);
//                                        WFSUtil.DB_SetString(3, autogenColumnName, pstmt, dbType);
//                                        //OF Optimization
//                                        parameters.add(currentSeqNo);
//                                        parameters.add(autogenTableName);
//                                        parameters.add(autogenColumnName);
//                                        printOut(engineName,"[WFSUtil] updateData() Executing Autogen update Query ... ");
//                                        jdbcExecute(processInstanceId, sessionId, userId, queryStr.toString(), pstmt, parameters, debugFlag, engineName);
//                                        parameters.clear();
//                                        //pstmt.executeUpdate();
//
//                                        pstmt.close();
//                                        pstmt = null;
                                        }
                    				
		    if(dbType == JTSConstant.JTS_MSSQL ){
                        queryStr1 = new StringBuilder();
                      queryStr1.append("Insert WFMAPPINGTABLE_"+ relationInfo.getForeignKey() + " Default Values ");
                      jdbcExecute(null, sessionId, userId, queryStr1.toString(), stmt, null, debugFlag, engineName);
                     queryStr2 = new StringBuilder();
                     queryStr2.append("Select @@IDENTITY");
                     rs = jdbcExecuteQuery(null, sessionId, userId, queryStr2.toString(), stmt, null, debugFlag, engineName);
                    if(rs != null && rs.next()) {
                        newValueStr = String.valueOf(rs.getInt(1));
                        rs.close();
                    }
                }
                                    }
                                }

                                if (counter > 1) {
                                    eFilterStrBuff.append(" AND ");
                                }
                                eFilterStrBuff.append(" ( ");
                                eParentFilterStrBuffArray.append(" AND ");
                                eParentFilterStrBuffArray.append("( ");
                                eParentFilterStrBuffArray.append(relationInfo.getForeignKey());
                                eParentFilterStrBuffArray.append(" IS NULL ");
                                eFilterStrBuff.append(relationInfo.getRefKey());
                                eFilterStrBuff.append(" = ");
                                eParentFilterStrBuffArray.append(" OR ");
                                eParentFilterStrBuffArray.append(relationInfo.getForeignKey());
                                eParentFilterStrBuffArray.append(" = ");
                                if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                    eFilterValList.add(newValueStr);
                                    eFilterStrBuff.append(" ? ");
                                    eParentFilterValueList.add(newValueStr);
                                    eParentFilterStrBuffArray.append(" ? ");
                                } else {
                                    eParentFilterStrBuffArray.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                    eFilterStrBuff.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                }
                                /*if(previousValueStrMap!=null&&previousValueStrMap.get(relationInfo.getRefKey())!=null&&previousValueStrMap.get(relationInfo.getRefKey()).toString()!=tempValueStr){
                                	eFilterStrBuff.append(" OR ");
                                	eFilterStrBuff.append(relationInfo.getRefKey());
                                	eFilterStrBuff.append(" = ");
                                	eFilterStrBuff.append(TO_SQL(previousValueStrMap.get(relationInfo.getRefKey()).toString(),relationInfo.getColType(), dbType, true));
                                    previousValueStrMap.clear();
                                }*/
                                eFilterStrBuff.append(" ) ");
                                eParentFilterStrBuffArray.append(" )");
                                //Bugzilla Bug 6855 check was missing earlier-Shweta Tyagi
                                if (!presentInThisMap || (presentInThisMap && ((WFFieldValuePrimitive) simplifiedValueMap.primitiveValueMap.get(wfChildFieldNameForRelationColumn.toUpperCase())).fieldInfo.getExtObjId() == 0)) {

                                    if (!updateE) {
                                        updateE = true;
                                        if (rootFlag) {
                                            parentFilterStr = qFilterStrBuff.toString();
                                        }
                                    }
                                    /** Always insert in this field' table */
                                    if (eInsertColQuery == null) {
                                        eInsertColQuery = new StringBuffer(200);
                                        eInsertColQuery.append("Insert into ");
                                        eInsertColQuery.append(extTableName);
                                        eInsertColQuery.append("(");
                                        eInsertValQuery = new StringBuffer(200);
                                        eInsertValList = new ArrayList();
                                        eInsertValQuery.append(" values (");
                                    } else {
                                        eInsertColQuery.append(", ");
                                        eInsertValQuery.append(", ");
                                        eUpdateQuery.append(", ");
                                    }
                                    eInsertColQuery.append(relationInfo.getRefKey());
                                    WFSUtil.printOut(engineName,"Relation table data type..." + newValueStr + relationInfo.getColType());
                                    if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                        eInsertValList.add(newValueStr);
                                        eInsertValQuery.append(" ? ");
                                    } else {
                                        eInsertValQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                    }
                                    /** Case : Var_Int1 (QPersonId) is mapped to Person' personId which is mapped to Address personId
                                     * Data is coming in QPersonId only, which is the key field of next 2 level structures */
                                    if (relationInfo.getMappedChildField() != null) {
                                        if (debugFlag) {
                                            printOut(engineName,"[WFSUtil] updateData() insert case... Putting in simplifiedValueMap for child mapped field name >> " + relationInfo.getMappedChildField().getName().toUpperCase() + " value >> " + newValueStr);
                                        }
                                        simplifiedValueMap.primitiveValueMap.put(relationInfo.getMappedChildField().getName().toUpperCase(), new WFFieldValuePrimitive(relationInfo.getMappedChildField(), newValueStr));
                                    } else {
                                        if (debugFlag) {
                                            printOut(engineName,"[WFSUtil] updateData() insert case... Putting in simplifiedValueMap for ref key >> " + relationInfo.getRefKey().toUpperCase() + " value >> " + newValueStr);
                                        }
                                        simplifiedValueMap.primitiveValueMap.put(relationInfo.getRefKey().toUpperCase(), new WFFieldValuePrimitive(relationInfo.getMappedChildField(), newValueStr));
                                    }
                                }
                                if (!presentInParentMap) {
                                    if (presentInParentRelationMap) {
                                        String str1 = (String) parentRelationValueMap.get(relationInfo.getForeignKey().toUpperCase());
                                        if (!str1.equalsIgnoreCase(newValueStr)) {
											if (debugFlag) {
												printOut(engineName,"[WFSUtil] updateData() ParentQueryInitialized as str1 >> " + str1 + " does not match newValueStr >> " + newValueStr);
											}
                                            parentQueryInitialized = true;
											if (counter > 1) {
												updateParentQuery.append(", ");
											}
                                            updateParentQuery.append(relationInfo.getForeignKey());
                                            updateParentQuery.append(" = ");
                                            if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                                updateParentValList.add(newValueStr);
                                                updateParentQuery.append(" ? ");
                                            } else {
                                                updateParentQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                            }
                                        }
                                    } else {
										if (debugFlag) {
											printOut(engineName,"[WFSUtil] updateData() ParentQueryInitialized as not present in presentInParentRelationMap " );
										}
                                        parentQueryInitialized = true;
										if (counter > 1) {
											updateParentQuery.append(", ");
										}
                                        updateParentQuery.append(relationInfo.getForeignKey());
                                        updateParentQuery.append(" = ");
                                        if (relationInfo.getColType() == WFSConstant.WF_NTEXT) {          //Changed for nText support Bug Id WFS_8.0_014

                                            updateParentValList.add(newValueStr);
                                            updateParentQuery.append(" ? ");
                                        } else {
                                            updateParentQuery.append(TO_SQL(newValueStr, relationInfo.getColType(), dbType, true));
                                        }
                                    }
                                }
                                if (!presentInParentRelationMap) {
                                    parentRelationValueMap.put(relationInfo.getForeignKey().toUpperCase(), newValueStr);
                                }
                            }
                            if (debugFlag) {
                                WFSUtil.printOut(engineName, " [WFSUtil] updateData() relationMap loop relationInfo.getRefKey() >> " + relationInfo.getRefKey());
                                WFSUtil.printOut(engineName, " [WFSUtil] updateData() relationMap loop relationInfo.getForeignKey() >> " + relationInfo.getForeignKey());
                                WFSUtil.printOut(engineName, " [WFSUtil] updateData() relationMap loop newValueStr >> " + newValueStr);
                            }
                        }
                    /** If value in parent relation field is null then insert else update ... */
                    } else {
                        printErr(engineName, "[WFSUtil] updateData() Check Check Check relationMap size is ZERO !! " + wfFieldInfo);
                        if (debugFlag && wfFieldInfo != null) {
                            WFSUtil.printOut(engineName, " [WFSUtil] updateData() RelationMap NULL wfFieldInfo.getName() >> " + wfFieldInfo.getName());
                        }
                    }
                }
                /** This is required, case : parent and child are both mapped to same table, and there is no row in table for filter */
                if (simplifiedValueMap.complexValueMap.size() > 0) {
                    counter = counterQ = 0;
                    HashMap tempRelMap = new HashMap();
                    HashMap tempColRelMap = new HashMap();
                    for (Iterator itrCom = simplifiedValueMap.complexValueMap.entrySet().iterator(); itrCom.hasNext();) {
                        entry = (Map.Entry) itrCom.next();
                        fieldValueComplex = (WFFieldValueComplex) entry.getValue();
                        tempFieldInfo = fieldValueComplex.fieldInfo;
                        tempRelationMap = tempFieldInfo.getRelationMap();
                        if (tempRelationMap != null && tempRelationMap.size() > 0) {
                            for (Iterator itrRel = tempRelationMap.entrySet().iterator(); itrRel.hasNext();) {
                                relationInfo = (WFRelationInfo) ((Map.Entry) itrRel.next()).getValue();
                                if (!(insertFlag && (relationInfo.isRAutoGenerated() ))) {
                                    /** Case : Var_Int1 (QPersonId) is mapped to Person' personId which is mapped to Address personId
                                     * Data is coming in QPersonId only, which is the key field of next 2 level structures */
                                    if (debugFlag) {
                                        printOut(engineName,"[WFSUtil] updateData() putting in tempMap relationInfo.getForeignKey().toUpperCase() >> " + relationInfo.getForeignKey().toUpperCase());
                                        if (relationInfo.getMappedParentField() != null) {
                                            /** MappedFields can be null in relationMap, when the columns are in relation but not in attributes. AutoGen will also fall in this category.. */
                                            printOut(engineName,"[WFSUtil] updateData() putting in tempMap relationInfo.getMappedParentField().getName() >> " + relationInfo.getMappedParentField().getName());
                                        }
                                    }
                                    tempRelMap.put(relationInfo.getForeignKey().toUpperCase(), ((relationInfo.getMappedParentField() == null) ? relationInfo.getForeignKey() : relationInfo.getMappedParentField().getName()));
                                    tempColRelMap.put(relationInfo.getForeignKey().toUpperCase(), relationInfo.getRefKey());
                                    if (relationInfo.getParentObject().equalsIgnoreCase(qdtTableName)) {
                                        parentFilterStr = qFilterStrBuff.toString();
                                        if (qRelationValueStr == null) {
                                            qRelationValueStr = new StringBuffer(300);
                                            qRelationValueStr.append("Select ");
                                        }
                                        if (counterQ > 0) {
                                            qRelationValueStr.append(", ");
                                        }
                                        qRelationValueStr.append(relationInfo.getForeignKey());
                                        ++counterQ;
                                    } else {
                                        if (eRelationValueStr == null) {
                                            eRelationValueStr = new StringBuffer(300);
                                            eRelationValueStr.append("Select ");
                                        }
                                        if (counter > 0) {
                                            eRelationValueStr.append(", ");
                                        }
                                        eRelationValueStr.append(relationInfo.getForeignKey());
                                        ++counter;
                                    }
                                }
                            }
                        } else {
                            printErr(engineName, "[WFSUtil] updateData() Check Check Check child' relation map is NULL or size ZERO ... ");
                        }
                    }
                    if (debugFlag) {
                        printOut(engineName,"[WFSUtil] updateData() Creating relation str counterQ >> " + counterQ);
                        printOut(engineName,"[WFSUtil] updateData() Creating relation str counter >> " + counter);
                    }
                    if (rootFlag && counterQ > 0) {
                        qRelationValueStr.append(" FROM ");
                        qRelationValueStr.append(qdtTableName);
                        qRelationValueStr.append(qFilterStrBuff.toString());
                        /** Query QueueDataTable for  */
                        if (debugFlag) {
                            printOut(engineName,"[WFSUtil] updateData() qRelationValueStr >> " + qRelationValueStr);
                            printOut(engineName,"[WFSUtil] updateData() counterQ >> " + counterQ);
                            printOut(engineName,"[WFSUtil] updateData() Executing Q relation value Query ... ");
                        }
                        //OF Optimization
                        rs = jdbcExecuteQuery(processInstanceId, sessionId, userId, qRelationValueStr.toString(), stmt, null, debugFlag, engineName);
                        //rs = stmt.executeQuery(qRelationValueStr.toString());
                        rsmd = rs.getMetaData();
                        if (rs != null && rs.next()) {
                            for (int i = 1; i <= counterQ; i++) {
                                if (debugFlag) {
                                    printOut(engineName,"[WFSUtil] updateData() Q rsmd.getColumnName(i) >> " + rsmd.getColumnName(i).toUpperCase());
                                    printOut(engineName,"[WFSUtil] updateData() Q rs.getString(i) >> " + rs.getString(i));
                                    printOut(engineName,"[WFSUtil] updateData() Q From tempRelMap >> " + tempRelMap.get(rsmd.getColumnName(i).toUpperCase()));
                                }
                                relValueStr = rs.getString(i);
                                if (rs.wasNull()) {
                                    if (simplifiedValueMap.primitiveValueMap.containsKey(((String) tempRelMap.get(rsmd.getColumnName(i).toUpperCase())).toUpperCase())) {
                                        relValueStr = ((WFFieldValuePrimitive) simplifiedValueMap.primitiveValueMap.get(((String) tempRelMap.get(rsmd.getColumnName(i).toUpperCase())).toUpperCase())).value;
                                        if (debugFlag) {
                                            printOut(engineName,"[WFSUtil] updateData() q NEW relValueStr >> " + relValueStr);
                                        }
                                    }
                                }
                                if (debugFlag) {
                                    printOut(engineName,"[WFSUtil] updateData() Putting in eRelationValueMap VALUE >> " + relValueStr);
                                }
                                qRelationValueMap.put(rsmd.getColumnName(i).toUpperCase(), relValueStr);
                            }
                        }
                        rs.close();
                        rs = null;
                    }
                    if (counter > 0) {
                        eRelationValueStr.append(" FROM ");
                        eRelationValueStr.append(extTableName);
                        eRelationValueStr.append(eFilterStrBuff.toString());
                        if (debugFlag) {
                            printOut(engineName,"[WFSUtil] updateData() eRelationValueStr >> " + eRelationValueStr);
                            printOut(engineName,"[WFSUtil] updateData() counter >> " + counter);
                            printOut(engineName,"[WFSUtil] updateData() Executing E relation Query ... ");
                        }
                        //Changed for nText support Bug Id WFS_8.0_014
                        pstmt1 = con.prepareStatement(eRelationValueStr.toString());
                        Iterator it = eFilterValList.iterator();
                        int iListCount = 1;
                        while (it.hasNext()) {
                            String strListElement = (String) it.next();
							//	WFS_9.0_002
                            if(strListElement == null)
                                strListElement = "";
                            pstmt1.setCharacterStream(iListCount, new StringReader(strListElement), strListElement.length());
                            iListCount++;
                        }
                        rs = jdbcExecuteQuery(processInstanceId, sessionId, userId, eRelationValueStr.toString(), pstmt1, null, debugFlag, engineName);
                        //rs = pstmt1.executeQuery();

//                            rs = stmt.executeQuery(eRelationValueStr.toString());
                        rsmd = rs.getMetaData();
                        if (rs != null && rs.next()) {
                            for (int i = 1; i <= counter; i++) {
                                if (debugFlag) {
                                    printOut(engineName,"[WFSUtil] updateData() E rsmd.getColumnName(i) >> " + rsmd.getColumnName(i).toUpperCase());
                                    printOut(engineName,"[WFSUtil] updateData() E rs.getString(i) >> " + rs.getString(i) + " from tempRelMap >> " + tempRelMap.get(rsmd.getColumnName(i).toUpperCase()));
                                }
                                relValueStr = rs.getString(i);
                                if (rs.wasNull()) {
                                    if (simplifiedValueMap.primitiveValueMap.containsKey(((String) tempRelMap.get(rsmd.getColumnName(i).toUpperCase())).toUpperCase())) {
                                        relValueStr = ((WFFieldValuePrimitive) simplifiedValueMap.primitiveValueMap.get(((String) tempRelMap.get(rsmd.getColumnName(i).toUpperCase())).toUpperCase())).value;
                                        if (debugFlag) {
                                            printOut(engineName,"[WFSUtil] updateData() E NEW relValueStr >> " + relValueStr);
                                        }
                                    } else {
                                        if (debugFlag) {
                                            printOut(engineName,"[WFSUtil] updateData() E VALUE NOT FOUND IN ParentRelationMap and primitiveValueMap ");
                                        }
                                    }
                                }
                                if (debugFlag) {
                                    printOut(engineName,"[WFSUtil] updateData() Putting in eRelationValueMap VALUE >> " + relValueStr);
                                }
                                if(wfFieldInfo!=null&&wfFieldInfo.isArray()&&wfFieldInfo.isComplex()&&arrayAlreadyDeletedLocal&&eRelationValueMap.containsKey(rsmd.getColumnName(i).toUpperCase())){
                                	eRelationValueMap.put(rsmd.getColumnName(i).toUpperCase(),null);	
                                }
                                else{
                                	eRelationValueMap.put(rsmd.getColumnName(i).toUpperCase(), relValueStr);
                                }
                            }    
                        } else {
                            for (int i = 1; i <= counter; i++) {
                                if (debugFlag) {
                                    printOut(engineName,"[WFSUtil] updateData() NO DATA IN EXT TABLE ... ");
                                }
                                relValueStr = null;
                                if (simplifiedValueMap.primitiveValueMap.containsKey(((String) tempRelMap.get(rsmd.getColumnName(i).toUpperCase())).toUpperCase())) {
                                    relValueStr = ((WFFieldValuePrimitive) simplifiedValueMap.primitiveValueMap.get(((String) tempRelMap.get(rsmd.getColumnName(i).toUpperCase())).toUpperCase())).value;
                                    if (debugFlag) {
                                        printOut(engineName,"[WFSUtil] updateData() E NEW relValueStr (for no data) >> " + relValueStr);
                                        printOut(engineName,"[WFSUtil] updateData() Putting in eRelationValueMap VALUE (for no data) >> " + relValueStr);
                                    }
                                } else {
                                    if (debugFlag) {
                                        printOut(engineName,"[WFSUtil] updateData() E (for no data) VALUE NOT FOUND IN ParentRelationMap and primitiveValueMap ");
                                    }
                                }
                                eRelationValueMap.put(rsmd.getColumnName(i).toUpperCase(), relValueStr);
                            }
                        }
                        rs.close();
                        rs = null;
                        pstmt1.close();
                        pstmt1 = null;
                    }
                }

                if (debugFlag) {
                    WFSUtil.printOut(engineName, " [WFSUtil] updateData() updateQ >> " + updateQ + " rootFlag >> " + rootFlag);
                }
                /** 01/07/2008, Bugzilla Bug 5470, Child first approach - Ruhi Hira */
                if (rootFlag && updateQ) {
                    if (debugFlag) {
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() qUpdateQuery >> " + qUpdateQuery);
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() qFilterStrBuff >> " + qFilterStrBuff);
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() QDT update query >> " + (qUpdateQuery.toString() + ((qFilterStrBuff == null) ? "" : qFilterStrBuff.toString())));
                    }
                    //OF Optimization
                    startTime = System.currentTimeMillis();
                    jdbcExecuteUpdate(processInstanceId, sessionId, userId, qUpdateQuery.toString() + ((qFilterStrBuff == null) ? "" : qFilterStrBuff.toString()), stmt, null, debugFlag, engineName);
                    //stmt.executeUpdate(qUpdateQuery.toString() + ((qFilterStrBuff == null) ? "" : qFilterStrBuff.toString()));
                    endTime = System.currentTimeMillis();
                    printOut(engineName, " [WFSUtil] timeElapsedInfoMap : " + timeElapsedInfoMap);
                    if (timeElapsedInfoMap != null) {
                        timeElapsedToSetQueueData = (Long) timeElapsedInfoMap.get(WFSConstant.CONST_TIME_ELAPSED_QUEUE_DATA);
                        if (timeElapsedToSetQueueData == null) {
                            timeElapsedToSetQueueData = 0L;
                        }
                        timeElapsedToSetQueueData += (endTime - startTime);
                        timeElapsedInfoMap.put(WFSConstant.CONST_TIME_ELAPSED_QUEUE_DATA, timeElapsedToSetQueueData);
                        printOut(engineName, " [WFSUtil] updateData() for updating queue variable >> timeElapsedToSetQueueData >> " + timeElapsedToSetQueueData);
                    }
                    printOut(engineName, " [WFSUtil] updateData() for updating queue variable >> startTime : " + startTime + "endTime : " +endTime+ " total  Time taken >> " + (endTime - startTime));
                
                }
                if (rootFlag && updateM) {
                    if (debugFlag) {
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() updateWITableQuery >> " + updateWITableQuery);
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() qFilterStrBuff >> " + qFilterStrBuff);
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() WITable update query >> " + (updateWITableQuery.toString() + ((qFilterStrBuff == null) ? "" : qFilterStrBuff.toString())));
                    }
                    //OF Optimization
                    jdbcExecuteUpdate(processInstanceId, sessionId, userId, updateWITableQuery.toString() + ((qFilterStrBuff == null) ? "" : qFilterStrBuff.toString()), stmt, null, debugFlag, engineName);
                    //stmt.executeUpdate(updateWITableQuery.toString() + ((qFilterStrBuff == null) ? "" : qFilterStrBuff.toString()));
                }
                if (debugFlag) {
                    WFSUtil.printOut(engineName, " [WFSUtil] updateData() updateE >> " + updateE);
                    WFSUtil.printOut(engineName, " [WFSUtil] updateData() insertFlag >> " + insertFlag);
                    WFSUtil.printOut(engineName, " [WFSUtil] updateData() insertFlag >> " + insertFlag);
                    WFSUtil.printOut(engineName, " [WFSUtil] updateData() eUpdateQuery >> " + eUpdateQuery);
                    WFSUtil.printOut(engineName, " [WFSUtil] updateData() eFilterStrBuff >> " + eFilterStrBuff);
                    WFSUtil.printOut(engineName, " [WFSUtil] updateData() eParentFilterStrBuffArray >> " + eParentFilterStrBuffArray);
                    WFSUtil.printOut(engineName, " [WFSUtil] updateData() eInsertColQuery >> " + eInsertColQuery);
                    WFSUtil.printOut(engineName, " [WFSUtil] updateData() eInsertValQuery >> " + eInsertValQuery);
                    if (eUpdateQuery != null) {
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() EXT update query >> " + (eUpdateQuery.toString() + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString())));
                    }
                    if (eInsertColQuery != null) {
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() EXT insert query >> " + eInsertColQuery.toString() + ")" + eInsertValQuery.toString() + ")");
                    }
                }
                if (wfFieldInfo != null && wfFieldInfo.isArray()) {
                    /*if (eFilterStrBuff == null) {
                        printErr(engineName, "[WFSUtil] updateData() Check Check Check how come filter for deletion is NULL ... " + wfFieldInfo.getName());
                    }*/
                    if(dbType==JTSConstant.JTS_ORACLE || dbType==JTSConstant.JTS_POSTGRES)
                    {
                        seqArrayName = "WFSEQ_ARRAY_"+processDefId+"_"+wfFieldInfo.getExtObjId();
                        String seqValue = nextVal(con, seqArrayName, dbType);
                        eInsertColQuery.append(" , INSERTIONORDERID");
                        eInsertValQuery.append(" ,"+seqValue);
                    }
                    if (valueCounter == 0 && !arrayAlreadyDeletedLocal) {	//WFS_8.0_041
                        /** @todo Ideally we should first delete upto the last leaf of node for arrays - Ruhi Hira */
						printOut(engineName,"[WFSUtil] updateData() going to call deleteArray : eFilterStrBuff.toString() >> " + eFilterStrBuff.toString());
						deleteArray(con, dbType, wfFieldInfo, debugFlag, eFilterStrBuff.toString(),engineName, processDefId, eRelationMap);	//WFS_8.0_041
						arrayAlreadyDeletedLocal = true;
						printOut(engineName,"[WFSUtil] updateData() After calling deleteArray");
/*                        eDeleteArrayStrBuff = new StringBuffer(200);
                        eDeleteArrayStrBuff.append("Delete From ");
                        eDeleteArrayStrBuff.append(extTableName);
                        eDeleteArrayStrBuff.append(" ");
                        if (debugFlag) {
                            printOut(Level.DEBUG, " [WFSUtil] updateData() Array Delete query >> " + eDeleteArrayStrBuff.toString() + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString()));
                        }
                        //Changed for nText support Bug Id WFS_8.0_014
                       pstmt1 = con.prepareStatement(eDeleteArrayStrBuff.toString() + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString()));
                        WFSUtil.printOut("UpdateData eFilterValList : " + eFilterValList);
                        Iterator it = eFilterValList.iterator();
                        int iListCount = 1;
                        while (it.hasNext()) {
                            String strListElement = (String) it.next();
                            pstmt1.setCharacterStream(iListCount, new StringReader(strListElement), strListElement.length());
                            iListCount++;
                        }
                        pstmt1.executeUpdate();
                        pstmt1.close();
                        pstmt1 = null;
*/

//                            stmt.executeUpdate(eDeleteArrayStrBuff.toString() + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString()));
                    }
                    insertFlag = true;
                /** Always insert if it is an array - Ruhi Hira */
                }
                if (updateE) {
                    if (insertFlag) {
                        /** Bugzilla Bug 7030, Case : QDT -> Person -> Address; mapping field is autogen.
                         *  Set data in Address field when Person is null.
                         *  Condition in code incorrect, (eUpdateQuery != null) in place of (eInsertColQuery != null)
                         *  - Ruhi Hira */
                        if (eInsertColQuery != null) {
                        	if(arrayAlreadyDeletedLocal){
                        		if (eRelationValueMap != null && eRelationValueMap.size() > 0) {
                        			for (Iterator itrRel = eRelationValueMap.entrySet().iterator(); itrRel.hasNext();) {
                        				entry = (Map.Entry) itrRel.next();
                        				String columnName = (String)entry.getKey();
                        				String columnValue =(String)entry.getValue();
                        				if(columnValue!=null){
                        					eInsertColQuery.append(",");
                        					eInsertColQuery.append(columnName);
                        					eInsertValQuery.append(",");
                        					eInsertValQuery.append(WFSUtil.TO_STRING(columnValue, true, dbType));
                        				}
                        			}



                        		}
                        	}
                            //Changed for nText support Bug Id WFS_8.0_014
                            pstmt1 = con.prepareStatement(eInsertColQuery.toString() + ")" + eInsertValQuery.toString() + ")");
                            Iterator it = eInsertValList.iterator();
                            int iListCount = 1;
                            while (it.hasNext()) {
                                String strListElement = (String) it.next();
								//	WFS_9.0_002
                                if(strListElement == null)
                                    strListElement = "";
                                pstmt1.setCharacterStream(iListCount, new StringReader(strListElement), strListElement.length());
                                iListCount++;
                            }
                         //   pstmt1.executeUpdate();
                            startTime = System.currentTimeMillis();
                            jdbcExecuteUpdate(null, sessionId, userId, eInsertColQuery.toString() + ")" + eInsertValQuery.toString() + ")", pstmt1, null, debugFlag, engineName);
                            endTime = System.currentTimeMillis();
                            printOut(engineName, " [WFSUtil] updateData() eInsertColQuery started at "+startTime+ "ended at "+endTime +" for external table >>  time taken" + (endTime - startTime));
                            if (timeElapsedInfoMap != null) {
                                timeElapsedToSetExtData = (Long) timeElapsedInfoMap.get(WFSConstant.CONST_TIME_ELAPSED_EXT_DATA);
                                if (timeElapsedToSetExtData == null) {
                                    timeElapsedToSetExtData = 0L;
                                }
                                timeElapsedToSetExtData += (endTime - startTime);
                                timeElapsedInfoMap.put(WFSConstant.CONST_TIME_ELAPSED_EXT_DATA, timeElapsedToSetExtData);
                                printOut(engineName, " [WFSUtil] updateData() timeElapsedToSetExtData for external table >>  time taken" + timeElapsedToSetExtData);
                            }
                            printOut(engineName, " [WFSUtil] updateData() eInsertColQuery started at " + startTime + "ended at " + endTime + " for external table >>  time taken" + (endTime - startTime));
                           
                            pstmt1.close();
                            pstmt1 = null;

//                                stmt.executeUpdate(eInsertColQuery.toString() + ")" + eInsertValQuery.toString() + ")");
                        } else {
                            if (debugFlag) {
                                printOut(engineName, " [WFSUtil] updateData() This should never be the case, insertFlag is true but eInsertColQuery is NULL !! ");
                            }
                        }
                    } else if(bExecuteEUpdate) { 
                        /** @todo if parentRelationInfo values were null need not fire update query just insert */
//                            int res = stmt.executeUpdate(eUpdateQuery.toString() + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString()));
                        boolean bIsNotNull = false;
                        if (eFilterStrBuff != null) {
                            bIsNotNull = true;
                        }
                        //Changed for nText support Bug Id WFS_8.0_014
                        pstmt1 = con.prepareStatement(eUpdateQuery.toString() + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString()));
                        //Merging the two lists of values as per the conditions
                        ArrayList mergedList = new ArrayList();

                        Iterator it1 = eUpdateValList.iterator();
                        while (it1.hasNext()) {
                            String strValue = (String) it1.next();
                            mergedList.add(strValue);
                        }
                        if (bIsNotNull) {
                            Iterator it2 = eFilterValList.iterator();
                            while (it2.hasNext()) {
                                String strValue = (String) it2.next();
                                mergedList.add(strValue);
                            }
                        }
                        //  Replacing the values in the query.
                        Iterator it = mergedList.iterator();
                        int iListCount = 1;
                        while (it.hasNext()) {
                            String strListElement = (String) it.next();
							//	WFS_9.0_002
                            if(strListElement == null)
                                strListElement = "";
                            pstmt1.setCharacterStream(iListCount, new StringReader(strListElement), strListElement.length());
                            iListCount++;
                        }
                        startTime = System.currentTimeMillis();
                        int res = jdbcExecuteUpdate(processInstanceId, sessionId, userId, eUpdateQuery.toString() + ((eFilterStrBuff == null) ? "" : eFilterStrBuff.toString()), pstmt1, null, debugFlag, engineName);
                        //int res = pstmt1.executeUpdate();
                        endTime = System.currentTimeMillis();
                        printOut(engineName,  " [WFSUtil] updateData() Insert query for externaltable started at >> " + startTime + " ended at >> " + endTime + "timeDuration : " + (endTime - startTime));
                        if (timeElapsedInfoMap != null) {
                            timeElapsedToSetExtData = (Long) timeElapsedInfoMap.get(WFSConstant.CONST_TIME_ELAPSED_EXT_DATA);
                            if (timeElapsedToSetExtData == null) {
                                timeElapsedToSetExtData = 0L;
                            }
                            timeElapsedToSetExtData += (endTime - startTime);
                            timeElapsedInfoMap.put(WFSConstant.CONST_TIME_ELAPSED_EXT_DATA, timeElapsedToSetExtData);
                            printOut(engineName, " [WFSUtil] updateData() Update query for externaltable started at >> " + startTime + " ended at >> " + endTime + "Total Time taken : " + timeElapsedToSetExtData);
                        }
                        printOut(engineName, " [WFSUtil] updateData() Update query for externaltable started at >> " + startTime + " ended at >> " + endTime + "Total Time taken : " + (endTime - startTime));
//                      
                        pstmt1.close();
                        pstmt1 = null;
                        if (res <= 0) {
                            if (debugFlag) {
                                printOut(engineName, " [WFSUtil] updateData() Inserting as update result <= 0 " + res);
                            }
                            //Changed for nText support Bug Id WFS_8.0_014
                            pstmt1 = con.prepareStatement(eInsertColQuery.toString() + ")" + eInsertValQuery.toString() + ")");
                            Iterator it4 = eInsertValList.iterator();
                            iListCount = 1;
                            while (it4.hasNext()) {
                                String strListElement = (String) it4.next();
								//	WFS_9.0_002
                                if(strListElement == null)
                                    strListElement = "";
                                pstmt1.setCharacterStream(iListCount, new StringReader(strListElement), strListElement.length());
                                iListCount++;
                            }
                            startTime = System.currentTimeMillis();
                            jdbcExecuteUpdate(processInstanceId, sessionId, userId, eInsertColQuery.toString() + ")" + eInsertValQuery.toString() + ")", pstmt1, null, debugFlag, engineName);
                            endTime = System.currentTimeMillis(); 
                            printOut(engineName, " [WFSUtil] updateData() Insert query for externaltable started at >> " + startTime + " ended at >> " + endTime + "timeDuration : " + (endTime - startTime));
                            if (timeElapsedInfoMap != null) {
                                timeElapsedToSetExtData = (Long) timeElapsedInfoMap.get(WFSConstant.CONST_TIME_ELAPSED_EXT_DATA);
                                if (timeElapsedToSetExtData == null) {
                                    timeElapsedToSetExtData = 0L;
                                }
                                timeElapsedToSetExtData += (endTime - startTime);
                                timeElapsedInfoMap.put(WFSConstant.CONST_TIME_ELAPSED_EXT_DATA, timeElapsedToSetExtData);
                                printOut(engineName, " [WFSUtil] updateData() Insert query for externaltable started at >> timeElapsedToSetExtData : " + timeElapsedToSetExtData);
                            }
                            //pstmt1.executeUpdate();
                            pstmt1.close();
                            pstmt1 = null;

//                                stmt.executeUpdate(eInsertColQuery.toString() + ")" + eInsertValQuery.toString() + ")");
                        }
                    }
                }

                if (debugFlag) {
                    printOut(engineName, " [WFSUtil] updateData() parentQueryInitialized >> " + parentQueryInitialized);
                    printOut(engineName, " [WFSUtil] updateData() updateParentQuery >> " + updateParentQuery);
                }
                if (updateParentQuery != null && parentQueryInitialized) {
                    if (debugFlag) {
                        printOut(engineName, " [WFSUtil] updateData() Parent Query >> " + updateParentQuery.toString() + ((parentFilterStr == null) ? " " : parentFilterStr) + ((eParentFilterStrBuffArray != null && parentFieldInfo != null && parentFieldInfo.isArray()) ? eParentFilterStrBuffArray.toString() : " "));
                    }
                    if (wfFieldInfo != null && ((wfFieldInfo.isArray() && (valueCounter == 0)) || (!wfFieldInfo.isArray()))) {
                        boolean bIsNotNull = false;
                        WFSUtil.printOut(engineName,"updateParentQuery :" + updateParentQuery.toString());
                        WFSUtil.printOut(engineName,"eParentFilterStrBuffArray :" + eParentFilterStrBuffArray.toString());
                        if (eParentFilterStrBuffArray != null && parentFieldInfo != null && parentFieldInfo.isArray()) {
                            bIsNotNull = true;
                        }
                        printOut(engineName, " [WFSUtil] updateData() Parent Query >> Executing parent query");
                        //Changed for nText support Bug Id WFS_8.0_014
                        pstmt1 = con.prepareStatement(updateParentQuery.toString() + ((parentFilterStr == null) ? " " : parentFilterStr) + ((eParentFilterStrBuffArray != null && parentFieldInfo != null && parentFieldInfo.isArray()) ? eParentFilterStrBuffArray.toString() : " "));
                        //Merging data in two value tables
                        ArrayList mergedValueList = new ArrayList();
                        Iterator it2 = updateParentValList.iterator();
                        while (it2.hasNext()) {
                            String strNextValue = (String) it2.next();
                            mergedValueList.add(strNextValue);
                        }

                        if (bIsNotNull) {
                            Iterator it3 = eParentFilterValueList.iterator();
                            while (it3.hasNext()) {
                                String strNextValue = (String) it3.next();
                                mergedValueList.add(strNextValue);
                            }
                        }

                        //Putting values in the prepared statement.
                        Iterator it = mergedValueList.iterator();
                        int iListCount = 1;
                        while (it.hasNext()) {
                            String strListElement = (String) it.next();
							//	WFS_9.0_002
                            if(strListElement == null)
                                strListElement = "";
                            pstmt1.setCharacterStream(iListCount, new StringReader(strListElement), strListElement.length());
                            iListCount++;
                        }
                        jdbcExecuteUpdate(processInstanceId, sessionId, userId, updateParentQuery.toString() + ((parentFilterStr == null) ? " " : parentFilterStr) + ((eParentFilterStrBuffArray != null && parentFieldInfo != null && parentFieldInfo.isArray()) ? eParentFilterStrBuffArray.toString() : " "), pstmt1, parameters, debugFlag, engineName);
                        //pstmt1.executeUpdate();
                        pstmt1.close();
                        pstmt1 = null;

//                            stmt.executeUpdate(updateParentQuery.toString() + ((parentFilterStr == null) ? " " : parentFilterStr) + ((eParentFilterStrBuffArray != null && parentFieldInfo != null && parentFieldInfo.isArray()) ? eParentFilterStrBuffArray.toString() : " "));
                    }
                }


                /** parent table will be updated before child table */
                String tempFilterStr = null;
                for (Iterator itrCom = simplifiedValueMap.complexValueMap.entrySet().iterator(); itrCom.hasNext();) {
                    entry = (Map.Entry) itrCom.next();
                    fieldValueComplex = (WFFieldValueComplex) entry.getValue();
                    /** passing cacheAttribMap null, as not required when !root
                     * @todo If relationInfo has parent Table QueueDataTable then pass qFilterStrBuff
                     * Else pass eFilterStrBuff */
                    if (debugFlag) {
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() complexValueMap loop fieldValueComplex.fieldInfo.getName() >> " + fieldValueComplex.fieldInfo.getName());
                    }
                    if (rootFlag) {
                        if (fieldValueComplex.fieldInfo != null && fieldValueComplex.fieldInfo.getRelationMap() != null && fieldValueComplex.fieldInfo.getRelationMap().size() > 0) {
                            if (((WFRelationInfo) fieldValueComplex.fieldInfo.getRelationMap().values().toArray()[0]).getParentObject().equalsIgnoreCase(qdtTableName) ||
                                    ((WFRelationInfo) fieldValueComplex.fieldInfo.getRelationMap().values().toArray()[0]).getChildObject().equalsIgnoreCase(processExtTableName)) {
                                tempFilterStr = (qFilterStrBuff == null) ? "" : qFilterStrBuff.toString();
                                relationValueMap = qRelationValueMap;
                            } else {
                                tempFilterStr = (eFilterStrBuff == null) ? "" : eFilterStrBuff.toString();
                                relationValueMap = eRelationValueMap;
                            }
                        }
                    } else {
                        if (((WFRelationInfo) fieldValueComplex.fieldInfo.getRelationMap().values().toArray()[0]).getParentObject().equalsIgnoreCase(qdtTableName) ||
                                ((WFRelationInfo) fieldValueComplex.fieldInfo.getRelationMap().values().toArray()[0]).getChildObject().equalsIgnoreCase(processExtTableName)) {
                            tempFilterStr = (qFilterStrBuff == null) ? "" : qFilterStrBuff.toString();
                            relationValueMap = qRelationValueMap;
                        } else {
                            tempFilterStr = (eFilterStrBuff == null) ? "" : eFilterStrBuff.toString();
                            relationValueMap = eRelationValueMap;
                        }
                    }

                    if (debugFlag) {
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() Calling updateData again ..... ");
						WFSUtil.printOut(engineName, " [WFSUtil] updateData() arrayAlreadyDeletedLocal ..... " + arrayAlreadyDeletedLocal);
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() eFilterStrBuff >> " + eFilterStrBuff);
                        WFSUtil.printOut(engineName, " [WFSUtil] updateData() fieldValueComplex.value >> " + fieldValueComplex.value);
                    }
                    String tempParentAttribName = (parentAttribName == null || parentAttribName.equals("")) ? fieldValueComplex.fieldInfo.getName() + "." : (parentAttribName + fieldValueComplex.fieldInfo.getName() + ".");
                    String tempAuditLogStr = updateData_old(con, engineName, dbType, processInstanceId, workitemId, processDefId, false, fieldValueComplex.value,
                            ((WFFieldInfo) cacheAttribMap.get(fieldValueComplex.fieldInfo.getName().toUpperCase())).getChildInfoMap(),
                            fieldValueComplex.fieldInfo, simplifiedValueMap.primitiveValueMap,
                            tempFilterStr, debugFlag, relationValueMap, wiTableName, tempParentAttribName, workitemIds, wfFieldInfo, arrayAlreadyDeletedLocal, sessionId, userId,timeElapsedInfoMap);
                    auditLogStrBuff.append(tempAuditLogStr);
                }
                /** Execute query qUpdateStr if root + eUpdateStr, if result 0 then eInsertStr */
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
            }
        } catch (Exception ex) {
            exceptionToBeThrown = ex;
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (pstmt1 != null) {
                    pstmt1.close();
                    pstmt1 = null;
                }
            } catch (Exception ignored) {
            }
        }
        if (exceptionToBeThrown != null) {
            throw exceptionToBeThrown;
        }
        return auditLogStrBuff.toString();
    }	
	
    private static String getValueForPrimitiveAttribute(ArrayList valueList) {
        String strValue = null;
        if (valueList != null && valueList.size() == 1 && valueList.get(0) instanceof String) {
            strValue = (String) valueList.get(0);
        }
        return strValue;
    }


//----------------------------------------------------------------------------------------------------
//	Function Name 				: fetchAttributes
//	Date Written (DD/MM/YYYY)	: 04/01/2006
//	Author						: Mandeep
//	Input Parameters			: Connection con, String procInstID,int workItemID,
//									String filter,String engine,int dbType,XMLGenerator gen,boolean ps
//	Output Parameters			: none
//	Return Values				: String
//	Description					: Call fetchAttributes with, procesdefId = 0,  ActivityId = 0
//----------------------------------------------------------------------------------------------------
    public static Object fetchAttributes(Connection con, String procInstID, int workItemID, String filter,
            String engine, int dbType, XMLGenerator gen, String name,
            boolean ps, boolean cuser) throws JTSException, WFSException {

        return fetchAttributes(con, 0, 0, procInstID, workItemID, filter, engine, dbType,
                gen, name, ps, cuser,0,0,false);
    }

    public static Object fetchAttributes(Connection con, int iProcDefId, int iActId, String procInstID, int workItemID,
            String filter, String engine, int dbType, XMLGenerator gen, String name,
            boolean ps, boolean cuser) throws JTSException, WFSException {
        return fetchAttributes(con, iProcDefId, iActId, procInstID, workItemID, filter, engine, dbType,
                gen, name, ps, cuser, false,0,0,false);
    }

    public static Object fetchAttributes(Connection con, String procInstID, int workItemID, String filter,
            String engine, int dbType, XMLGenerator gen, String name,
            boolean ps, boolean cuser, boolean internalServerFlag) throws JTSException, WFSException {

        return fetchAttributes(con, 0, 0, procInstID, workItemID, filter, engine, dbType,
                gen, name, ps, cuser, internalServerFlag,0,0,false);
    } 
	 public static Object fetchAttributes(Connection con, String procInstID, int workItemID, String filter,
            String engine, int dbType, XMLGenerator gen, String name,
            boolean ps, boolean cuser,int sessionId,int userId,boolean printQueryFlag)throws JTSException, WFSException {

        return fetchAttributes(con, 0, 0, procInstID, workItemID, filter, engine, dbType,
                gen, name, ps, cuser,sessionId,userId,printQueryFlag);
    }

    public static Object fetchAttributes(Connection con, int iProcDefId, int iActId, String procInstID, int workItemID,
            String filter, String engine, int dbType, XMLGenerator gen, String name,
            boolean ps, boolean cuser,int sessionId,int userId,boolean printQueryFlag) throws JTSException, WFSException {
        return fetchAttributes(con, iProcDefId, iActId, procInstID, workItemID, filter, engine, dbType,
                gen, name, ps, cuser, false,sessionId,userId,printQueryFlag);
    }

    public static Object fetchAttributes(Connection con, int iProcDefId, int iActId, String procInstID, int workItemID,
            String filter, String engine, int dbType, XMLGenerator gen, String name,
            boolean ps, boolean cuser,int internalServerFlag,int sessionId,int userId,boolean printQueryFlag)  throws JTSException, WFSException {

        return fetchAttributes(con, 0, 0, procInstID, workItemID, filter, engine, dbType,
                gen, name, ps, cuser, internalServerFlag,sessionId,userId,printQueryFlag);
    }
	public static Object fetchAttributes(Connection con, int iProcDefId, int iActId, String procInstID, int workItemID,
            String filter, String engine, int dbType, XMLGenerator gen, String name,
            boolean ps, boolean cuser, boolean internalServerFlag) throws JTSException, WFSException{
		return 	fetchAttributes(con,iProcDefId,iActId,procInstID,workItemID,filter,engine,dbType,gen,name,ps,cuser,internalServerFlag,0,0,false);
			
	}
    //----------------------------------------------------------------------------------------------------
    //	Function Name 				: fetchAttributes
    //	Date Written (DD/MM/YYYY)	: 28/06/2002
    //	Author						: Prashant
    //	Input Parameters			: Connection con, String procInstID,int workItemID,
    //								  String filter,String engine,int dbType,XMLGenerator gen,boolean ps
    //	Output Parameters			: none
    //	Return Values				: String
    //	Description					: Fetch ProcessInstance's Attributes
    //                                  SrNo-4, Synchronous routing of workitems.
    //----------------------------------------------------------------------------------------------------
    public static Object fetchAttributes(Connection con, int iProcDefId, int iActId, String procInstID, int workItemID,
            String filter, String engine, int dbType, XMLGenerator gen, String name,
            boolean ps, boolean cuser, boolean internalServerFlag,int sessionId,int userId,boolean printQueryFlag) throws JTSException, WFSException {

        StringBuffer tempXml = null;
        HashMap attributes = null;
        PreparedStatement pstmt = null;
        int mainCode = 0;
        int subCode = 0;
        String subject = null;
        String descr = null;
        String errType = WFSError.WF_TMP;
        ResultSet rs = null;
		boolean secondaryDBFlag=false;

        try {
            tempXml = new StringBuffer(1000);
            int retrCount = 0;
            int qCount = 0;
            int iCount = 0;
            int extObj = 0;

            ArrayList queattribs;
            ArrayList extattribs;
            String[] attrib = new String[7];
            String tablename = "";
            String wlisttable = "";
            StringBuffer quebuffer;
            StringBuffer extbuffer;
            String strextbuffer;
            StringBuffer keybuffer;
            String tempStr = "";
            String columnValue = "";

            int procDefId = 0;
            int activityID = 0;
			int procVarId = 0;
			
			String queryString;
			ArrayList parameters = new ArrayList();
			
            /*if (!cuser) {
			//Process Variant Support Changes
                pstmt = con.prepareStatement(" Select ProcessDefID , ActivityID, ProcessVariantId from Workinprocesstable where ProcessInstanceID = ? and WorkItemID = ? ");
                WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
                pstmt.setInt(2, workItemID);
                pstmt.execute();
                rs = pstmt.getResultSet();
                if (rs.next()) {
                    procDefId = rs.getInt(1);
                    activityID = rs.getInt(2);
					procVarId = rs.getInt(3);
                }
                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
                wlisttable = " Workinprocesstable ";
            }
            if (!cuser && procDefId == 0) {
			//Process Variant Support Changes
                pstmt = con.prepareStatement(" Select ProcessDefID , ActivityID, ProcessVariantId from Worklisttable where ProcessInstanceID = ? and WorkItemID = ? ");
                WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
                pstmt.setInt(2, workItemID);
                pstmt.execute();
                rs = pstmt.getResultSet();
                if (rs.next()) {
                    procDefId = rs.getInt(1);
                    activityID = rs.getInt(2);
					procVarId = rs.getInt(3);
                }
                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
                wlisttable = " Worklisttable ";
            }
            if (!cuser && procDefId == 0) {//Process Variant Support Changes
                pstmt = con.prepareStatement(" Select ProcessDefID , ActivityID, ProcessVariantId from Workdonetable where ProcessInstanceID = ? and WorkItemID = ? ");
                WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
                pstmt.setInt(2, workItemID);
                pstmt.execute();
                rs = pstmt.getResultSet();
                if (rs.next()) {
                    procDefId = rs.getInt(1);
                    activityID = rs.getInt(2);
					procVarId = rs.getInt(3);
                }
                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
                wlisttable = " Workdonetable ";
            }
            if (procDefId == 0) {
                // SrNo-8, Synchronous routing of workitems, removal of WorkDoneTable - Ruhi Hira
                /** 02/12/2008, Bugzilla Bug 6991, prorityLevel not set for u type user in setAttributeExt. - Ruhi Hira *-/
                if ((internalServerFlag && ps) || (!ps)) {
                    wlisttable = " WorkInProcessTable ";
                } else {
                    wlisttable = " WorkwithPStable ";
                }
				//Process Variant Support Changes
                pstmt = con.prepareStatement(" Select ProcessDefID , ActivityID, ProcessVariantId from " + wlisttable + " where ProcessInstanceID = ? and WorkItemID = ? ");
                WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
                pstmt.setInt(2, workItemID);
                pstmt.execute();
                rs = pstmt.getResultSet();
                if (rs.next()) {
                    procDefId = rs.getInt(1);
                    activityID = rs.getInt(2);
					procVarId = rs.getInt(3);
                }
                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
            }
            if (!cuser && procDefId == 0) {
			//Process Variant Support Changes
                pstmt = con.prepareStatement(" Select ProcessDefID , ActivityID, ProcessVariantId from Pendingworklisttable where ProcessInstanceID = ? and WorkItemID = ? ");
                WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
                pstmt.setInt(2, workItemID);
                pstmt.execute();
                rs = pstmt.getResultSet();
                if (rs.next()) {
                    procDefId = rs.getInt(1);
                    activityID = rs.getInt(2);
					procVarId = rs.getInt(3);
                }
                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
                wlisttable = " Pendingworklisttable ";
            }*/
			if(!cuser){
				queryString = " Select ProcessDefID , ActivityID, ProcessVariantId,SecondaryDBFlag from WFInstrumentTable " + WFSUtil.getTableLockHintStr(dbType) +" where ProcessInstanceID = ? and WorkItemID = ? ";
				pstmt = con.prepareStatement(queryString);
                WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
                pstmt.setInt(2, workItemID);
				parameters.addAll(Arrays.asList(procInstID,workItemID));
                //pstmt.execute();
				jdbcExecute(procInstID,sessionId,userId,queryString,pstmt,parameters,printQueryFlag,engine);
                rs = pstmt.getResultSet();
                if (rs.next()) {
                    procDefId = rs.getInt(1);
                    activityID = rs.getInt(2);
					procVarId = rs.getInt(3);
	                String secondaryDBStr = rs.getString(4);
	                 secondaryDBFlag="Y".equalsIgnoreCase(secondaryDBStr)||"D".equalsIgnoreCase(secondaryDBStr);

                }
                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
                wlisttable = " WFInstrumentTable ";
			}
			if(cuser){
				queryString = " Select ProcessDefID , ActivityID, ProcessVariantId,SecondaryDBFlag from WFInstrumentTable" + WFSUtil.getTableLockHintStr(dbType) +"  where ProcessInstanceID = ? and WorkItemID = ? and LockStatus = ?" ;
				pstmt = con.prepareStatement(queryString);
                WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
                pstmt.setInt(2, workItemID);
				WFSUtil.DB_SetString(3, "Y", pstmt, dbType);
				parameters = new ArrayList();
				parameters.addAll(Arrays.asList(procInstID,workItemID,"Y"));
                //pstmt.execute();
				jdbcExecute(procInstID,sessionId,userId,queryString,pstmt,parameters,printQueryFlag,engine);
                rs = pstmt.getResultSet();
                if (rs.next()) {
                    procDefId = rs.getInt(1);
                    activityID = rs.getInt(2);
					procVarId = rs.getInt(3);
	                String secondaryDBStr = rs.getString(4);
	                 secondaryDBFlag="Y".equalsIgnoreCase(secondaryDBStr)||"D".equalsIgnoreCase(secondaryDBStr);
                }
                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
                wlisttable = " WFInstrumentTable ";
			}
            if (procDefId == 0) {
			//Process Variant Support Changes
				queryString = " Select ProcessDefID , ActivityID, ProcessVariantId,SecondaryDBFlag from Queuehistorytable" + WFSUtil.getTableLockHintStr(dbType) +" where ProcessInstanceID = ? and WorkItemID = ? " ;
                pstmt = con.prepareStatement(queryString);
                WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
                pstmt.setInt(2, workItemID);
				parameters = new ArrayList();
				parameters.addAll(Arrays.asList(procInstID,workItemID));
                //pstmt.execute();
				jdbcExecute(procInstID,sessionId,userId,queryString,pstmt,parameters,printQueryFlag,engine);
                rs = pstmt.getResultSet();
                if (rs.next()) {
                    procDefId = rs.getInt(1);
                    activityID = rs.getInt(2);
					procVarId = rs.getInt(3);
					String secondaryDBStr = rs.getString(4);
	                 secondaryDBFlag="Y".equalsIgnoreCase(secondaryDBStr)||"D".equalsIgnoreCase(secondaryDBStr);
                }
                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
                wlisttable = " Queuehistorytable ";
            }

            //
            if(secondaryDBFlag) {
            	String secondaryCabinetName=null;
            	Connection secondaryConn=null;
            	pstmt=con.prepareStatement("Select PropertyValue from WFSYSTEMPROPERTIESTABLE where PropertyKey = ?");
                pstmt.setString(1,"SECONDARYCABINETNAME");
                rs= pstmt.executeQuery();
                if(rs.next()){
                	secondaryCabinetName=WFSUtil.getFormattedString(rs.getString("PropertyValue"))	;
                }else {

                    rs.close();
                    pstmt.close();
                    mainCode = WFSError.WF_SECONDARY_CABINET_NOT_SET;
                    subCode = 0;
                    subject = WFSErrorMsg.getMessage(mainCode);
                    descr = WFSErrorMsg.getMessage(subCode);
                    errType = WFSError.WF_TMP;
    			
                	throw new WFSException(mainCode, subCode, errType, subject, descr);
               
                	
                }
                secondaryConn=WFSUtil.createConnectionToTargetCabinet(secondaryCabinetName,"FetchAttributesExt",engine);
                if(secondaryConn!=null) {
                	WFSUtil.printOut(engine,"Connection with Secondary Cabinet "+secondaryCabinetName+" is established.");
                }
                rs.close();
                pstmt.close();
                return WFSSecondaryDBUtil.fetchAttributes(con,secondaryConn, iProcDefId, iActId, procInstID, workItemID,
                        filter, engine, dbType, gen, name,
                        ps, cuser, internalServerFlag,sessionId,userId,printQueryFlag);
            }
            if (iActId > 0) {
                procDefId = iProcDefId;
                activityID = iActId;
            }
            if (procDefId != 0) {
// Filter neeeds to be handled ??
                StringTokenizer st = null;
                int mapCount = 0;

                //Changed by Ashish on 16/05/2005
                WFAttributedef attribs = (WFAttributedef) CachedObjectCollection.getReference().getCacheObject(con, engine, procDefId, WFSConstant.CACHE_CONST_Attribute, "" + (ps ? 0 : activityID) + string21 + procVarId).getData();
                queattribs = attribs.getQueueVars();
                extattribs = attribs.getExtVars();
                quebuffer = attribs.getQueueString();
                HashMap cachemap = attribs.getAttribMap();
                WMAttribute allAttrib = null;
                extbuffer = new StringBuffer(attribs.getExtString());
                keybuffer = attribs.getKeyBuffer();
                qCount = queattribs.size();
                iCount = extattribs.size();
                retrCount = qCount + iCount + WFSConstant.qdmattribs.length +
                        WFSConstant.wklattribs.length + WFSConstant.prcattribs.length;

                if (retrCount > 0) {
                    tempXml.append("<Attributes>\n");

                    if (iCount > 0) {
                        st = new StringTokenizer(keybuffer.toString(), string21);
                        mapCount = st.countTokens();
                    }

                    if (ps) {
                        attributes = new HashMap(50);
                    }
                    if (name != null && name.equals("")) {
                    	pstmt = con.prepareStatement(quebuffer.toString() + WFSConstant.s_attribqdatam +  (wlisttable.equalsIgnoreCase(" Queuehistorytable ") ? "" : WFSConstant.s_attribqdatachild) + " from " +
                                (wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
                                : "WFInstrumentTable ") + WFSUtil.getTableLockHintStr(dbType) +
								//: "Queuedatatable ") +
                                " where ProcessInstanceId = ? and WorkItemId = ?");
                        WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
                        pstmt.setInt(2, workItemID);
                        pstmt.execute();
                        rs = pstmt.getResultSet();
                        if (rs.next()) {
                            int k = 0;
                            for (k = 0; qCount > k; k++) {
                                attrib = (String[]) queattribs.get(k);
                                if (ps) {
                                    if (attrib[2] == null) {
                                        attributes.put(attrib[0].toUpperCase(), new WMAttribute(attrib[0], rs.getString(k + 1), Integer.parseInt(attrib[1]), 255));
                                    } else {
                                        attributes.put(attrib[0].toUpperCase(), new WMAttribute(attrib[0], rs.getString(k + 1), Integer.parseInt(attrib[1]), Integer.parseInt(attrib[2])));
                                    }
                                } else {
                                    try {
                                        if (attrib[6] != null && attrib[6].charAt(1) == '4') {
                                            continue;
                                        } //do not return the attribs that have access attrib as NULL

                                    } catch (Exception ex) { //stringIndexOutOfBounds
                                        //do nothing

                                    }
                                    tempXml.append("<Attribute>\n");
                                    tempXml.append(gen.writeValueOf("Name", attrib[0]));
                                    tempXml.append(gen.writeValueOf("Type", attrib[6]));
                                    if (attrib[2] == null) {
                                        tempXml.append(gen.writeValueOf("Length", "255"));
                                    } else {
                                        tempXml.append(gen.writeValueOf("Length", attrib[2]));
                                    }
                                    // SrNo-1, Check for float value.. Bug rectified By PRD team ..
                                    if (attrib[1].equals(String.valueOf(WFSConstant.WF_FLT))) {
                                        columnValue = rs.getBigDecimal(k + 1) + "";
                                        if (rs.wasNull()) {
                                            columnValue = null;
                                        }
                                    } else {
                                        columnValue = rs.getString(k + 1);
                                    }
                                    tempXml.append(gen.writeValueOf("Value", handleSpecialCharInXml(columnValue)));
                                    tempXml.append("\n</Attribute>\n");
                                }
                            }

                            if (mapCount > 0) {
                                while (st.hasMoreTokens()) {
                                    tempStr = rs.getString(++k);
                                    if (rs.wasNull()) {
                                        extbuffer.append(st.nextToken()).append(" is null and ");
                                    } else {
                                        extbuffer.append(st.nextToken()).append("=").append(WFSUtil.TO_STRING(
                                                tempStr.trim(), true, dbType)).append(" and ");
                                    }
                                }
                            }

                            for (k = 0; WFSConstant.qdmattribs.length > k; k++) {
                                attrib = WFSConstant.qdmattribs[k];
                                allAttrib = (WMAttribute) (cachemap.get(attrib[0].toUpperCase()));
                                if (allAttrib != null) {
                                    if (ps) {
                                        attributes.put(attrib[0].toUpperCase(), new WMAttribute(attrib[0], rs.getString(qCount + mapCount + k + 1), Integer.parseInt(attrib[1]), allAttrib.length));
                                    } else {
                                        tempXml.append("<Attribute>\n");
                                        tempXml.append(gen.writeValueOf("Name", attrib[0]));
                                        tempXml.append(gen.writeValueOf("Type", attrib[1]));
                                        tempXml.append(gen.writeValueOf("Length", String.valueOf(allAttrib.length)));
                                        tempXml.append(gen.writeValueOf("Value",
                                                rs.getString(qCount + mapCount + k + 1)));
                                        tempXml.append("\n</Attribute>\n");
                                    }
                                }
                            }
                            rs.close();
                            rs = null;
                            pstmt.close();
                            pstmt = null;

                            pstmt = con.prepareStatement(WFSConstant.s_attribpinlst +  getTableLockHintStr(dbType)  +" where ProcessInstanceId = ?");
                            WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
                            pstmt.execute();
                            rs = pstmt.getResultSet();
                            if (rs.next()) {
                                for (k = 0; WFSConstant.prcattribs.length > k; k++) {
                                    attrib = WFSConstant.prcattribs[k];
                                    allAttrib = (WMAttribute) (cachemap.get(attrib[0].toUpperCase()));
                                    if (allAttrib != null) {
                                        if (ps) {
                                            attributes.put(attrib[0].toUpperCase(), new WMAttribute(attrib[0], rs.getString(k + 1), Integer.parseInt(attrib[1]), allAttrib.length));
                                        } else {
                                            tempXml.append("<Attribute>\n");
                                            tempXml.append(gen.writeValueOf("Name", attrib[0]));
                                            tempXml.append(gen.writeValueOf("Type", attrib[1]));
                                            tempXml.append(gen.writeValueOf("Length", String.valueOf(allAttrib.length)));
                                            tempXml.append(gen.writeValueOf("Value", rs.getString(k + 1)));
                                            tempXml.append("\n</Attribute>\n");
                                        }
                                    }
                                }
                            }
                            rs.close();
                            rs = null;
                            pstmt.close();
                            pstmt = null;

                            pstmt = con.prepareStatement((wlisttable.trim().equalsIgnoreCase("Queuehistorytable")? WFSConstant.s_attribwrklst.replaceAll("expectedWorkITemDelay","EXPECTEDWORKITEMDELAYTIME") : WFSConstant.s_attribwrklst) + WFSUtil.getDate(dbType) + ",QueueName,QueueType from " + wlisttable + WFSUtil.getTableLockHintStr(dbType)+
                                    " where ProcessInstanceId = ? and WorkitemId = ? ");//WFS_8.0_081
                            WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
                            pstmt.setInt(2, workItemID);
                            pstmt.execute();
                            rs = pstmt.getResultSet();
                            if (rs.next()) {
                                for (k = 0; WFSConstant.wklattribs.length > k; k++) {
                                    attrib = WFSConstant.wklattribs[k];
                                    allAttrib = (WMAttribute) (cachemap.get(attrib[0].toUpperCase()));
                                    if (allAttrib != null) {
                                        if (ps) {
                                            attributes.put(attrib[0].toUpperCase(), new WMAttribute(attrib[0], rs.getString(k + 1), Integer.parseInt(attrib[1]), allAttrib.length));
                                        } else {
                                            tempXml.append("<Attribute>\n");
                                            tempXml.append(gen.writeValueOf("Name", attrib[0]));
                                            tempXml.append(gen.writeValueOf("Type", attrib[1]));
                                            tempXml.append(gen.writeValueOf("Length", String.valueOf(allAttrib.length)));
                                            tempXml.append(gen.writeValueOf("Value", rs.getString(k + 1)));
                                            tempXml.append("\n</Attribute>\n");
                                        }
                                    }
                                }
                                tempXml.append("<Attribute>\n");
                                tempXml.append(gen.writeValueOf("Name", "QueueName"));
                                tempXml.append(gen.writeValueOf("Type", "3210"));
                                tempXml.append(gen.writeValueOf("Length", "255"));
                                tempXml.append(gen.writeValueOf("Value", rs.getString(++k)));
                                tempXml.append("\n</Attribute>\n");
                                tempXml.append("<Attribute>\n");
                                tempXml.append(gen.writeValueOf("Name", "QueueType"));
                                tempXml.append(gen.writeValueOf("Type", "3210"));
                                tempXml.append(gen.writeValueOf("Length", "255"));
                                tempXml.append(gen.writeValueOf("Value", rs.getString(++k)));
                                tempXml.append("\n</Attribute>\n");
                                retrCount += 2;
                            }
                            rs.close();
                            rs = null;
                            pstmt.close();
                            pstmt = null;

                            if (iCount > 0) {
                                pstmt = con.prepareStatement(extbuffer.append(" 1 = 1 ").toString());
                                pstmt.execute();
                                rs = pstmt.getResultSet();
                                if (rs.next()) {
                                    for (k = 0; iCount > k; k++) {
                                        attrib = (String[]) extattribs.get(k);
                                        if (ps) {
                                            if (attrib[2] == null) {
                                                attributes.put(attrib[0].toUpperCase(), new WMAttribute(attrib[0], rs.getString(k + 1), Integer.parseInt(attrib[1]), 1024));
                                            } else {
                                                attributes.put(attrib[0].toUpperCase(), new WMAttribute(attrib[0], rs.getString(k + 1), Integer.parseInt(attrib[1])));
                                            }
                                        } else {
                                            try {
                                                if (attrib[6] != null && attrib[6].charAt(1) == '4') {
                                                    continue;
                                                } //do not return the attribs that have access attrib as NULL

                                            } catch (Exception ex) { //stringIndexOutOfBounds
                                                //do nothing

                                            }

                                            tempXml.append("<Attribute>\n");
                                            tempXml.append(gen.writeValueOf("Name", attrib[0]));
                                            tempXml.append(gen.writeValueOf("Type", attrib[6]));
                                            if (attrib[2] == null) {
                                                tempXml.append(gen.writeValueOf("Length", "1024"));
                                            } else {
                                                tempXml.append(gen.writeValueOf("Length", attrib[2]));
                                            }
                                            // SrNo-1, Check for float value. Bug rectified By PRD team ..
                                            String tmp_value = "";
                                            if (attrib[1].equals(String.valueOf(WFSConstant.WF_FLT))) {
                                                tmp_value = rs.getBigDecimal(k + 1) + "";
                                                if (rs.wasNull()) {
                                                    tmp_value = "";
                                                }
                                            } else {
                                                tmp_value = rs.getString(k + 1);
                                            }
                                            if (attrib[1].equals(String.valueOf(WFSConstant.WF_SHORT_DAT))) {//Bugzilla Bug Id 5142

                                                if (tmp_value != null && !tmp_value.equals("")) {
                                                    tmp_value = tmp_value.substring(0, tmp_value.indexOf(" "));
                                                }
                                                tempXml.append(gen.writeValueOf("Value", tmp_value));
                                            } else if (attrib[1].equals(String.valueOf(WFSConstant.WF_TIME))) {	//Bugzilla Bug Id 5142

                                                if (tmp_value != null && !tmp_value.equals("")) {
                                                	if(tmp_value.indexOf(":")>0){
                                                		tmp_value = tmp_value.substring(tmp_value.indexOf(" ") + 1, tmp_value.lastIndexOf(":"));	
                                                	}
                                                	else{
                                                		tmp_value = tmp_value.substring(tmp_value.indexOf(" ") + 1, tmp_value.lastIndexOf("."));
                                                	}
                                                    
                                                }
                                                tempXml.append(gen.writeValueOf("Value", tmp_value));
                                            } else {
                                                tempXml.append(gen.writeValueOf("Value", tmp_value));
                                            }
                                            tempXml.append("\n</Attribute>\n");
                                        }
                                    }
                                    pstmt.close();
                                } else {
                                    for (k = 0; iCount > k; k++) {
                                        attrib = (String[]) extattribs.get(k);
                                        if (ps) {
                                            if (attrib[2] == null) {
                                                attributes.put(attrib[0].toUpperCase(), new WMAttribute(attrib[0], "", Integer.parseInt(attrib[1]), 1024));
                                            } else {
                                                attributes.put(attrib[0].toUpperCase(), new WMAttribute(attrib[0], "", Integer.parseInt(attrib[1]), Integer.parseInt(attrib[2])));
                                            }
                                        } else {
                                            tempXml.append("<Attribute>\n");
                                            tempXml.append(gen.writeValueOf("Name", attrib[0]));
                                            tempXml.append(gen.writeValueOf("Type", attrib[6]));
                                            if (attrib[2] == null) {
                                                tempXml.append(gen.writeValueOf("Length", "1024"));
                                            } else {
                                                tempXml.append(gen.writeValueOf("Length", attrib[2]));
                                            }
                                            tempXml.append(gen.writeValueOf("Value", ""));
                                            tempXml.append("\n</Attribute>\n");
                                        }
                                    }
                                }
                            }
                        } else {
                            rs.close();
                            rs = null;
                            pstmt.close();
                            pstmt = null;
                        }
//						  Changed By Varun Bhansaly On 14/03/2007 for Bugzilla Bug id 486
//                        tempXml.append("\n</Attributes>\n");
                    } else {
                        boolean success = false;
                        String queryTable = "";
                        ListIterator iter = queattribs.listIterator();
//						Added By Varun Bhansaly On 14/03/2007 for Bugzilla Bug id 486
                        retrCount = 1;
                        while (iter.hasNext()) {
                            attrib = (String[]) iter.next();
                            if (!attrib[0].equalsIgnoreCase(name)) {
                                continue;
                            }
                            success = true;
                            //queryTable = " queueDatatable ";
							queryTable = " WFInstrumentTable ";
                            queryTable = wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
                                    : queryTable;
                            queryTable = "Select " + attrib[3] + " from " + queryTable + WFSUtil.getTableLockHintStr(dbType)+ " where  ProcessInstanceId=? and " + "WorkItemId=" + workItemID;
                            break;
                        }
                        if (!success) {
                            iter = extattribs.listIterator();
                            tempStr = "";
                            while (iter.hasNext()) {
                                attrib = (String[]) iter.next();
                                if (!attrib[0].equalsIgnoreCase(name)) { //if (attrib[0].equalsIgnoreCase(name))	//Ashish modified condition (added not) WSE_5.0.1_PRDP_001

                                    continue;
                                }
                                success = true;
                                queryTable = attribs.getExt_tablename();
                                queryTable = "Select " + attrib[3] + " from " + queryTable + "," + (wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
                                       // : " QueueDataTable ") + " where ProcessInstanceId=? and WorkItemId=" +
                                		: " WFInstrumentTable ") +  WFSUtil.getTableLockHintStr(dbType)+" where ProcessInstanceId=? and WorkItemId=" +
                                        workItemID;
                                st = new StringTokenizer(keybuffer.toString(), string21, true);
                                int i = 0;
                                while (st.hasMoreTokens()) {
                                    tempStr = st.nextToken();
                                    if (!tempStr.equals("#")) {
                                        queryTable += " and VAR_REC_" + (i + 1) + "=" + tempStr;
                                    } else {
                                        i++;
                                    }
                                }
                                break;
                            }
                        }
                        if (!success) {
                            for (int i = 0; i < WFSConstant.qdmattribs.length; i++) {
                                attrib = WFSConstant.qdmattribs[i];
                                // Bugzilla Bug 896, ArrayIndexOutOfRange, 23/05/2007 - Ruhi Hira
                                if (!attrib[0].equalsIgnoreCase(name)) {
                                    continue;
                                }
                                success = true;
                                //queryTable = " queueDatatable ";
								queryTable = " WFInstrumentTable ";
                                queryTable = wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
                                        : queryTable;
                                queryTable = "Select " + attrib[0] + " from " + queryTable +  WFSUtil.getTableLockHintStr(dbType)+" where ProcessInstanceId=? and " + "WorkItemId=" + workItemID;
                                break;
                            }
                        }
                        if (!success) {
                            for (int i = 0; i < WFSConstant.prcattribs.length; i++) {
                                attrib = WFSConstant.prcattribs[i];
                                if (!attrib[0].equalsIgnoreCase(name)) {
                                    continue;
                                }
                                success = true;
                                //queryTable = " ProcessInstanceTable ";
								queryTable = " WFInstrumentTable ";
                                queryTable = wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
                                        : queryTable;
                                queryTable = "Select " + attrib[0] + " from " + queryTable + WFSUtil.getTableLockHintStr(dbType)+ " where ProcessInstanceId=?";
                                break;
                            }
                        }
                        if (!success) {
                            for (int i = 0; i < WFSConstant.wklattribs.length; i++) {
                                attrib = WFSConstant.wklattribs[i];
                                if (!attrib[0].equalsIgnoreCase(name)) {
                                    continue;
                                }
                                success = true;
                                queryTable = wlisttable;
                                queryTable = wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
                                        : queryTable;
                                queryTable = "Select " + attrib[0] + " from " + queryTable  +WFSUtil.getTableLockHintStr(dbType)+ " where ProcessInstanceId=? and " + "WorkItemId=" + workItemID;
                                break;
                            }
                        }
                        if (success) {
                            pstmt = con.prepareStatement(queryTable);
                            WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
                            pstmt.execute();
                            rs = pstmt.getResultSet();
                            ResultSetMetaData rsmd = pstmt.getMetaData();
                            if (rs.next()) {
                                //Changed for nText support Bug Id WFS_8.0_014
                                int iColumnType = rsmd.getColumnType(1);
                                String strColumnName = rsmd.getColumnName(1);
                                String strValue = "";
                                if (JDBCTYPE_TO_WFSTYPE(iColumnType) == WFSConstant.WF_NTEXT) {
                                    Object[] obj = getBIGData(con, rs, strColumnName, dbType, DatabaseTransactionServer.charSet);
                                    strValue = (String) obj[0];
                                } else {
                                    strValue = rs.getString(1);
                                }
                                if (strValue != null) {
                                    strValue = strValue.trim();
//							Added By Varun Bhansaly On 14/03/2007 for Bugzilla Bug id 486
                                }
                                tempXml.append("<Attribute>\n");
                                tempXml.append(gen.writeValueOf("Value", strValue));
                                tempXml.append(gen.writeValueOf("Name", attrib[0]));
                                // Bugzilla Bug 896, ArrayIndexOutOfRange, 23/05/2007 - Ruhi Hira
                                if (attrib.length > 2) {
                                    tempXml.append(gen.writeValueOf("Type", attrib[6]));
                                    tempXml.append(gen.writeValueOf("Length", attrib[2]));
                                } else {
                                    tempXml.append(gen.writeValueOf("Type", attrib[1]));
                                    tempXml.append(gen.writeValueOf("Length", "1024"));
                                }
//							Added By Varun Bhansaly On 14/03/2007 for Bugzilla Bug id 486
                                tempXml.append("</Attribute>\n");
                            }
                            rs.close();
                            rs = null;
                            pstmt.close();
                            pstmt = null;
                        } else {
                            mainCode = WFSError.WM_INVALID_ATTRIBUTE;
                            subCode = 0;
                            subject = WFSErrorMsg.getMessage(mainCode);
                            descr = WFSErrorMsg.getMessage(subCode);
                            errType = WFSError.WF_TMP;
                        }
                    }
//							Added By Varun Bhansaly On 14/03/2007 for Bugzilla Bug id 486
                    tempXml.append("\n</Attributes>\n");
                    tempXml.append(gen.writeValueOf("RetrievedCount", String.valueOf(retrCount)));
                    tempXml.append(gen.writeValueOf("Count", String.valueOf(retrCount)));
                }
            } else {
                mainCode = WFSError.WM_INVALID_WORKITEM;
                subCode = 0;
                subject = WFSErrorMsg.getMessage(mainCode);
                descr = WFSErrorMsg.getMessage(subCode);
                errType = WFSError.WF_TMP;
            }
        } catch (SQLException e) {
            printErr(engine, "", e);
            mainCode = WFSError.WM_INVALID_FILTER;
            subCode = WFSError.WFS_SQL;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_FAT;
            if (e.getErrorCode() == 0) {
                if (e.getSQLState().equalsIgnoreCase("08S01")) {
                    descr = (new JTSSQLError(e.getSQLState())).getMessage() + "(SQL State : " +
                            e.getSQLState() + ")";
                }
            } else {
                descr = e.getMessage();
            }
        } catch (NumberFormatException e) {
            printErr(engine, "", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_ILP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch (NullPointerException e) {
            printErr(engine, "", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_SYS;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch (Exception e) {
            printErr(engine, "", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch (Error e) {
            printErr(engine, "", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (Exception e) {
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
            } catch (Exception e) {
            }
           
        }
        if (mainCode != 0) {
            throw new WFSException(mainCode, subCode, errType, subject, descr);
        }
        if (ps) {
            return attributes;
        } else {
            return tempXml.toString();
        }

    } // End fetchAttributes

//----------------------------------------------------------------------------------------------------
//	Function Name 				: fetchAttributesExt
//	Date Written (DD/MM/YYYY)	:
//	Author						: Shweta Tyagi
//	Input Parameters			: Connection con, String procInstID,int workItemID,
//									String filter,String engine,int dbType,XMLGenerator gen,boolean ps
//	Output Parameters			: none
//	Return Values				: String
//	Description					: Call fetchAttributesExt with, procesdefId = 0,  ActivityId = 0
//----------------------------------------------------------------------------------------------------

    public static Object fetchAttributesExt(Connection con, String procInstID, int workItemID, String filter,
            String engine, int dbType, XMLGenerator gen, String name,
            boolean ps, boolean cuser) throws JTSException, WFSException {

        return fetchAttributesExt(con, 0, 0, procInstID, workItemID, filter, engine, dbType,
                gen, name, ps, cuser);
    }

    public static Object fetchAttributesExt(Connection con, int iProcDefId, int iActId, String procInstID, int workItemID,
            String filter, String engine, int dbType, XMLGenerator gen, String name,
            boolean ps, boolean cuser) throws JTSException, WFSException {
        return fetchAttributesExt(con, iProcDefId, iActId, procInstID, workItemID, filter, engine, dbType,
                gen, name, ps, cuser, false);
    }
    
	//----------------------------------------------------------------------------------------------------
//	Function Name 				: fetchAttributesExt
//	Date Written (DD/MM/YYYY)	:
//	Author						: Shweta Singhal
//	Input Parameters			: Connection con, int iProcDefId, int iActId, String procInstID, int workItemID,
//            String filter, String engine, int dbType, XMLGenerator gen, String name,
//            boolean ps, boolean cuser, int processVariantId
//	Output Parameters			: none
//	Return Values				: String
//	Description					: Call fetchAttributesExt with, procesdefId = 0,  ActivityId = 0, Processvariantid = 0
//----------------------------------------------------------------------------------------------------
//Process Variant Support Changes
    public static Object fetchAttributesExt(Connection con, int iProcDefId, int iActId, String procInstID, int workItemID,String filter, String engine, int dbType, XMLGenerator gen, String name,
    boolean ps, boolean cuser, int processVariantId) throws JTSException, WFSException {
        return fetchAttributesExt(con, iProcDefId, iActId, procInstID, workItemID, filter, engine, dbType,
                gen, name, ps, cuser, false, processVariantId,0,0,false);
    }

    public static Object fetchAttributesExt(Connection con, String procInstID, int workItemID, String filter,
    String engine, int dbType, XMLGenerator gen, String name,boolean ps, boolean cuser, boolean internalServerFlag) throws JTSException, WFSException {

        return fetchAttributesExt(con, 0, 0, procInstID, workItemID, filter, engine, dbType,
                gen, name, ps, cuser, internalServerFlag,0,0,false);
    }
	
	public static Object fetchAttributesExt(Connection con, int iProcDefId, int iActId, String procInstID, int workItemID,String filter, String engine, int dbType, XMLGenerator gen, String name,boolean ps, boolean cuser, boolean internalServerFlag) throws JTSException, WFSException {
			
		return	fetchAttributesExt(con, iProcDefId, iActId, procInstID, workItemID, filter, engine, dbType, gen, name, ps, cuser, internalServerFlag, 0,0,0,false);
	}
	public static Object fetchAttributesExt(Connection con, int iProcDefId, int iActId, String procInstID, int workItemID,String filter, String engine, int dbType, XMLGenerator gen, String name,
    boolean ps, boolean cuser, int processVariantId,int sessionId,int userId,boolean printQueryFlag) throws JTSException, WFSException {
        return fetchAttributesExt(con, iProcDefId, iActId, procInstID, workItemID, filter, engine, dbType,
                gen, name, ps, cuser, false, processVariantId);
    }

    public static Object fetchAttributesExt(Connection con, String procInstID, int workItemID, String filter,String engine, int dbType, XMLGenerator gen, String name,boolean ps, boolean cuser, boolean internalServerFlag,int sessionId,int userId,boolean printQueryFlag) throws JTSException, WFSException {

        return fetchAttributesExt(con, 0, 0, procInstID, workItemID, filter, engine, dbType,
                gen, name, ps, cuser, internalServerFlag);
    }
	
	public static Object fetchAttributesExt(Connection con, int iProcDefId, int iActId, String procInstID, int workItemID,String filter, String engine, int dbType, XMLGenerator gen, String name,boolean ps, boolean cuser, boolean internalServerFlag,int sessionId,int userId,boolean printQueryFlag) throws JTSException, WFSException {
			
		return	fetchAttributesExt(con, iProcDefId, iActId, procInstID, workItemID, filter, engine, dbType, gen, name, ps, cuser, internalServerFlag, 0);
	}
	public static Object fetchAttributesExt(Connection con, int iProcDefId, int iActId, String procInstID, int workItemID,String filter, String engine, int dbType, XMLGenerator gen, String name,
    boolean ps, boolean cuser, boolean internalServerFlag, int iProcVarId) throws JTSException, WFSException {
		return fetchAttributesExt(con,iProcDefId,iActId,procInstID,workItemID,filter,engine,dbType,gen,name,ps,cuser,internalServerFlag,iProcVarId,0,0,false);
	}
        public static Object fetchAttributesExt(Connection con, int iProcDefId, int iActId, String procInstID, int workItemID,
            String filter, String engine, int dbType, XMLGenerator gen, String name,
            boolean ps, boolean cuser, boolean internalServerFlag, int iProcVarId,int sessionId,int userId,boolean printQueryFlag) throws JTSException, WFSException {                
            return fetchAttributesExt(con, iProcDefId, iActId, procInstID, workItemID, filter, engine, dbType, gen, name, ps, cuser, internalServerFlag, 0,0,0, false, "Y");
        }
//----------------------------------------------------------------------------------------------------
//	Function Name 				: fetchAttributesExt
//	Date Written (DD/MM/YYYY)	: 12/05/2008
//	Author						: Shweta Tyagi
//	Input Parameters			: Connection con, String procInstID,int workItemID,
//									String filter,String engine,int dbType,XMLGenerator gen,boolean ps
//	Output Parameters			: none
//	Return Values				: String
//	Description					: fetches variables associated with activity
//----------------------------------------------------------------------------------------------------
        public static Object fetchAttributesExt(Connection con, int iProcDefId, int iActId, String procInstID, int workItemID,
                String filter, String engine, int dbType, XMLGenerator gen, String name,
                boolean ps, boolean cuser, boolean internalServerFlag, int iProcVarId,int sessionId,int userId,boolean printQueryFlag, String userDefVarFlag) throws JTSException, WFSException {
    	 return fetchAttributesExt(con, iProcDefId, iActId, procInstID, workItemID,
    	            filter, engine, dbType, gen, name,
    	            ps, cuser, internalServerFlag, iProcVarId,sessionId,userId,printQueryFlag, userDefVarFlag,null);
     }
    public static Object fetchAttributesExt(Connection con, int iProcDefId, int iActId, String procInstID, int workItemID,
            String filter, String engine, int dbType, XMLGenerator gen, String name,
            boolean ps, boolean cuser, boolean internalServerFlag, int iProcVarId,int sessionId,int userId,boolean printQueryFlag, String userDefVarFlag,ArrayList batchInfo) throws JTSException, WFSException {

        StringBuffer tempXml = null;
        LinkedHashMap attributes = null;
        PreparedStatement pstmt = null;
        int mainCode = 0;
        int subCode = 0;
        String subject = null;
        String descr = null;
        String errType = WFSError.WF_TMP;
        ResultSet rs = null;
        ResultSetMetaData rsmd = null;
        ArrayList<String> fragmentVariables= new ArrayList<String>();
		boolean fetchAttributeProperty = true;
        Long timeElapsedToFetchQueueData=0L;
        Long timeElapsedToFetchExtData=0L;
        Long timeElapsedToFetchCmplxQueData=0L; //shubham
        Long timeElapsedToFetchCmplxExtData=0L; //shubham
        String timeElapsedForQueueData = "0";
        String timeElapsedForExtData = "0";
        String timeElapsedForCmplxQueData = "0"; //shubham 
        String timeElapsedForCmplxExtData = "0"; //shubham
        String extTableNameHistory = "";
        boolean extTabExist_History_Explicit = false;
        String itemIndexValue = null;
        String itemTypeValue= null;
        Connection secondaryConn = null;
        try {
            tempXml = new StringBuffer(1000);
            int retrCount = 0;
            int qCount = 0;
            int iCount = 0;
            int aCount = 0;
            int cCount = 0;
            int extObj = 0;

            ArrayList queattribs;
            ArrayList extattribs;
            ArrayList cmplxattribs;
            ArrayList arrayattribs;

            String[] attrib = new String[10];
            String tablename = "";
            String wlisttable = "";
            String secondaryCabinetName = null;

            StringBuffer quebuffer;
            StringBuffer extbuffer;
            StringBuffer arraybuffer;
            StringBuffer cmplxquebuffer;
            StringBuffer cmplxextbuffer;
            String strextbuffer;
            StringBuffer keybuffer;
            String rightsInfo;

            String tempStr = "";

            int procDefId = 0;
            int activityID = 0;
			int procVarId = 0;
			boolean secondaryDBFlag = false;
			String queryString;
			ArrayList parameters = new ArrayList();
			
            /*if (!cuser) {
			//Process Variant Support Changes
                pstmt = con.prepareStatement(" Select ProcessDefID , ActivityID, ProcessVariantId from Workinprocesstable where ProcessInstanceID = ? and WorkItemID = ? ");
                WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
                pstmt.setInt(2, workItemID);
                pstmt.execute();
                rs = pstmt.getResultSet();
                if (rs.next()) {
                    procDefId = rs.getInt(1);
                    activityID = rs.getInt(2);
                    procVarId = rs.getInt(3);
                }
                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
                wlisttable = " Workinprocesstable ";
            }
            if (!cuser && procDefId == 0) {//Process Variant Support Changes
                pstmt = con.prepareStatement(" Select ProcessDefID , ActivityID, ProcessVariantId from Worklisttable where ProcessInstanceID = ? and WorkItemID = ? ");
                WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
                pstmt.setInt(2, workItemID);
                pstmt.execute();
                rs = pstmt.getResultSet();
                if (rs.next()) {
                    procDefId = rs.getInt(1);
                    activityID = rs.getInt(2);
					procVarId = rs.getInt(3);
                }
                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
                wlisttable = " Worklisttable ";
            }
            if (!cuser && procDefId == 0) {//Process Variant Support Changes
                pstmt = con.prepareStatement(" Select ProcessDefID , ActivityID, ProcessVariantId from Workdonetable where ProcessInstanceID = ? and WorkItemID = ? ");
                WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
                pstmt.setInt(2, workItemID);
                pstmt.execute();
                rs = pstmt.getResultSet();
                if (rs.next()) {
                    procDefId = rs.getInt(1);
                    activityID = rs.getInt(2);
					procVarId = rs.getInt(3);
                }
                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
                wlisttable = " Workdonetable ";
            }
            if (procDefId == 0) {
                /** SrNo-8, Synchronous routing of workitems, removal of WorkDoneTable - Ruhi Hira */
                /** 02/12/2008, Bugzilla Bug 6991, prorityLevel not set for u type user in setAttributeExt. - Ruhi Hira *-/
                if ((internalServerFlag && ps) || (!ps)) {
                    wlisttable = " WorkInProcessTable ";
                } else {
                    wlisttable = " WorkwithPStable ";
                }
				//Process Variant Support Changes
                pstmt = con.prepareStatement(" Select ProcessDefID , ActivityID, ProcessVariantId from " + wlisttable + " where ProcessInstanceID = ? and WorkItemID = ? ");
                WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
                pstmt.setInt(2, workItemID);
                pstmt.execute();
                rs = pstmt.getResultSet();
                if (rs.next()) {
                    procDefId = rs.getInt(1);
                    activityID = rs.getInt(2);
					procVarId = rs.getInt(3);
                }
                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
            }
            if (!cuser && procDefId == 0) {
			//Process Variant Support Changes
                pstmt = con.prepareStatement(" Select ProcessDefID , ActivityID, ProcessVariantId from Pendingworklisttable where ProcessInstanceID = ? and WorkItemID = ? ");
                WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
                pstmt.setInt(2, workItemID);
                pstmt.execute();
                rs = pstmt.getResultSet();
                if (rs.next()) {
                    procDefId = rs.getInt(1);
                    activityID = rs.getInt(2);
					procVarId = rs.getInt(3);
                }
                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
                wlisttable = " Pendingworklisttable ";
            }*/
			
            if(!cuser){
				queryString = " Select ProcessDefID , ActivityID, ProcessVariantId,SecondaryDBFlag from WFInstrumentTable " + getTableLockHintStr(dbType) + " where ProcessInstanceID = ? and WorkItemID = ? ";
				pstmt = con.prepareStatement(queryString);
                WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
                pstmt.setInt(2, workItemID);
				parameters.addAll(Arrays.asList(procInstID,workItemID));
                //pstmt.execute();
				jdbcExecute(procInstID,sessionId,userId,queryString,pstmt,parameters,printQueryFlag,engine);
                rs = pstmt.getResultSet();
                if (rs.next()) {
                    procDefId = rs.getInt(1);
                    activityID = rs.getInt(2);
					procVarId = rs.getInt(3);
					secondaryDBFlag = rs.getString(4).equalsIgnoreCase("Y");
                }
                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
                wlisttable = " WFInstrumentTable ";
			}
			if(cuser){
				queryString = " Select ProcessDefID , ActivityID, ProcessVariantId,SecondaryDBFlag from WFInstrumentTable " + getTableLockHintStr(dbType) + " where ProcessInstanceID = ? and WorkItemID = ? and LockStatus = ?" ;
				pstmt = con.prepareStatement(queryString);
                WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
                pstmt.setInt(2, workItemID);
				WFSUtil.DB_SetString(3, "Y", pstmt, dbType);
				parameters = new ArrayList();
				parameters.addAll(Arrays.asList(procInstID,workItemID,"Y"));
                //pstmt.execute();
				jdbcExecute(procInstID,sessionId,userId,queryString,pstmt,parameters,printQueryFlag,engine);
                rs = pstmt.getResultSet();
                if (rs.next()) {
                    procDefId = rs.getInt(1);
                    activityID = rs.getInt(2);
					procVarId = rs.getInt(3);
					secondaryDBFlag = rs.getString(4).equalsIgnoreCase("Y");
					
                }
                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
                wlisttable = " WFInstrumentTable ";
			}
            if (procDefId == 0) {
			//Process Variant Support Changes
				queryString = " Select ProcessDefID , ActivityID, ProcessVariantId,SecondaryDBFlag from Queuehistorytable " + getTableLockHintStr(dbType) + " where ProcessInstanceID = ? and WorkItemID = ? " ;
                pstmt = con.prepareStatement(queryString);
                WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
                pstmt.setInt(2, workItemID);
				parameters = new ArrayList();
				parameters.addAll(Arrays.asList(procInstID,workItemID));
                //pstmt.execute();
				jdbcExecute(procInstID,sessionId,userId,queryString,pstmt,parameters,printQueryFlag,engine);
                rs = pstmt.getResultSet();
                if (rs.next()) {
                    procDefId = rs.getInt(1);
                    activityID = rs.getInt(2);
					procVarId = rs.getInt(3);
					secondaryDBFlag = rs.getString(4).equalsIgnoreCase("Y")||rs.getString(4).equalsIgnoreCase("D");
                }
                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
                wlisttable = " Queuehistorytable ";
            }

            //
            if (iActId > 0) {
                procDefId = iProcDefId;
                activityID = iActId;
            }
            if(secondaryDBFlag) {
            	pstmt=con.prepareStatement("Select PropertyValue from WFSYSTEMPROPERTIESTABLE where PropertyKey = ?");
                pstmt.setString(1,"SECONDARYCABINETNAME");
                rs= pstmt.executeQuery();
                if(rs.next()){
                	secondaryCabinetName=WFSUtil.getFormattedString(rs.getString("PropertyValue"))	;
                }else {
                    rs.close();
                    pstmt.close();
                    mainCode = WFSError.WF_SECONDARY_CABINET_NOT_SET;
                    subCode = 0;
                    subject = WFSErrorMsg.getMessage(mainCode);
                    descr = WFSErrorMsg.getMessage(subCode);
                    errType = WFSError.WF_TMP;
    			
                	throw new WFSException(mainCode, subCode, errType, subject, descr);
                }
                secondaryConn=WFSUtil.createConnectionToTargetCabinet(secondaryCabinetName,"FetchAttributesExt",engine);
                if(secondaryConn!=null) {
                	WFSUtil.printOut(engine,"Connection with Secondary Cabinet "+secondaryCabinetName+" is established.");
                }
                rs.close();
                pstmt.close();
                return WFSSecondaryDBUtil.fetchAttributesExt(con,secondaryConn, iProcDefId, iActId, procInstID, workItemID,
        	            filter, engine, dbType, gen, name,
        	            ps, cuser, internalServerFlag, iProcVarId,sessionId,userId,printQueryFlag, userDefVarFlag,batchInfo);
            }
            if (procDefId != 0) {
// Filter neeeds to be handled ??
            	// Change for bug 40367 
            	String keyToken = wlisttable.equalsIgnoreCase(" Queuehistorytable ")?("QUEUEHISTORYTABLE" + string21)://"QUEUEDATATABLE#";
				("WFInstrumentTable" + string21);
                StringTokenizer st = null;
                int mapCount = 0;
                WFVariabledef attribs;
                // Change for bug 40367 starts
                if(wlisttable.equalsIgnoreCase(" Queuehistorytable ")){
                	printOut(engine,"VariableCacheHistory will be used..");
                	
                    attribs = (WFVariabledef) CachedObjectCollection.getReference().getCacheObject(con, engine, procDefId, WFSConstant.CACHE_CONST_VARIABLE_HISTORY, "" + (ps ? -1 : activityID) + string21 + procVarId).getData();
                }
                else{
                	printOut(engine,"VariableCache will be used..");
                attribs = (WFVariabledef) CachedObjectCollection.getReference().getCacheObject(con, engine, procDefId, WFSConstant.CACHE_CONST_Variable, "" + (ps ? -1 : activityID) + string21 + procVarId).getData();
                }
                // Change for bug 40367 ends

                queattribs = attribs.getQueueVars();
                extattribs = attribs.getExtVars();
                arrayattribs = attribs.getArrayVars();
                cmplxattribs = attribs.getCmplxVars();

                quebuffer = attribs.getQueueString();
                extbuffer = new StringBuffer(attribs.getExtString());
                //Bug Id 5431
                if (attribs.getCmplxQueString() != null) {
                    cmplxquebuffer = new StringBuffer(attribs.getCmplxQueString().toString());
                } else {
                    cmplxquebuffer = attribs.getCmplxQueString();
                }
                if (attribs.getCmplxExtString() != null) {
                    cmplxextbuffer = new StringBuffer(attribs.getCmplxExtString().toString());
                } else {
                    cmplxextbuffer = attribs.getCmplxExtString();
                }
                keybuffer = attribs.getKeyBuffer();
                WFSUtil.printOut(engine,"query for queue variables" + quebuffer);
                //WFSUtil.printOut(engine,"query for external variables" + extbuffer);
                WFSUtil.printOut(engine,"query for relation variables" + cmplxquebuffer);
                //WFSUtil.printOut(engine,"query for external relation variables" + cmplxextbuffer);
                LinkedHashMap cachemap = attribs.getAttribMap();
                LinkedHashMap valuemap = new LinkedHashMap();
                LinkedHashMap arrayQry = attribs.getArrayQry();
                LinkedHashMap cmplxQry = attribs.getCmplxQry();
				LinkedHashMap relationMap = null;
				if(attribs.getQryRelationMap() != null)
					relationMap = new LinkedHashMap(attribs.getQryRelationMap());
				else
					relationMap = new LinkedHashMap();
                LinkedHashMap memberMap = attribs.getMemberMap();
                WFFieldValue wfFieldValue = null;
                WFFieldInfo allAttrib = null;
                qCount = queattribs.size();
                iCount = extattribs.size();
                aCount = arrayattribs.size();
                cCount = cmplxattribs.size();
                
                retrCount = qCount + iCount + aCount + cCount + WFSConstant.qdmattribs.length +
                (wlisttable.equalsIgnoreCase(" Queuehistorytable ") ? 0 : WFSConstant.qdmchildattribs.length) + 
                WFSConstant.wklattribs.length + WFSConstant.prcattribs.length;
        
                String value = "";
                ArrayList values;
                tablename = attribs.getExt_tablename();

                if (retrCount > 0) {
                    Document doc = WFXMLUtil.createDocumentWithRoot("Attributes");
                    StringBuffer xml = new StringBuffer(100);

                    if (iCount > 0) {
                        st = new StringTokenizer(keybuffer.toString(), string21);
                        mapCount = st.countTokens();
                    }

                    if (ps) {
                        attributes = new LinkedHashMap(50);
                    }
                    int type;
                    String colname = "";
					//WFS_8.0_084
                    if (name != null) {
                        WFSUtil.printOut(engine,"in if");
                        pstmt = con.prepareStatement(quebuffer.toString() + WFSConstant.s_attribqdatam + (wlisttable.equalsIgnoreCase(" Queuehistorytable ") ? "" : WFSConstant.s_attribqdatachild) + " from " +
                                (wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
                                //: "Queuedatatable ") +
                                : "WFInstrumentTable ") +  getTableLockHintStr(dbType) + 
								" where ProcessInstanceId = ? and WorkItemId = ?");

                        WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
                        pstmt.setInt(2, workItemID);
                        long startTime = System.currentTimeMillis();
                        pstmt.execute();
                        long endTime = System.currentTimeMillis();
                        timeElapsedToFetchQueueData = endTime - startTime;
                        //WFSUtil.printOut(engine, "FetchAttributes() : Query to fetch attributes for queuedatatable : started at " + startTime + " Ended at : "+ endTime +" total time taken : "+ timeElapsedToFetchQueueData);
                      
                        rs = pstmt.getResultSet();
                        rsmd = pstmt.getMetaData();
                        if (rs.next()) {
                            int k = 0;
                            for (k = 0; qCount > k; k++) {
                                attrib = (String[]) queattribs.get(k);
                                allAttrib = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
                                //WFS_8.0_084
                                value = rs.getString(k + 1);
                                type = rsmd.getColumnType(k + 1);
                                colname = rsmd.getColumnName(k + 1);
                                //WFSUtil.printOut(engine,rsmd.getColumnName(k + 1) + "-->" + value);
                                //printOut(engine,"key>>"+keyToken);
                                //	 Change for bug 40367 
								if (relationMap != null && relationMap.containsKey((keyToken + colname).toUpperCase())) {
                                    //WFSUtil.printOut("line num 4299 putting value for relation" + value);
                                    values = new ArrayList();
                                    //Bug Id 5128
									String strval=value;
                                    if (strval != null) {
                                        if (JDBCTYPE_TO_WFSTYPE(type) == WFSConstant.WF_NTEXT) {
                                            Object[] obj = getBIGData(con, rs, colname, dbType, DatabaseTransactionServer.charSet);
                                            strval = (String) obj[0];
                                        } else {
                                            strval = WFSUtil.TO_SQL(value.trim(), WFSUtil.JDBCTYPE_TO_WFSTYPE(type), dbType, true);
                                        }
                                    }
                                    values.add(strval);
                                    WFSUtil.printOut(engine,values);
                                    // Change for bug 40367 
                                    relationMap.put((keyToken + colname).toUpperCase(), values);
                                }
								if (!name.equalsIgnoreCase("") && !attrib[1].equalsIgnoreCase(name))
                                {
                                    continue;
                                }
                                if (ps) {
                                    if (attrib[3] == null) {
                                        attributes.put(attrib[1].toUpperCase(), new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], value, Integer.parseInt(attrib[2]), 255, Integer.parseInt(attrib[8])));
                                    } else {
                                        attributes.put(attrib[1].toUpperCase(), new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], value, Integer.parseInt(attrib[2]), Integer.parseInt(attrib[3]), Integer.parseInt(attrib[8])));
                                    }
                                } else {
                                    try {
                                        if (attrib[7] != null && attrib[7].charAt(1) == '4') {
                                            continue;
                                        } //do not return the attribs that have access attrib as NULL



                                    } catch (Exception ex) { //stringIndexOutOfBounds
                                        //do nothing

                                    }
                                    // SrNo-1, Check for float value.. Bug rectified By PRD team ..
                                    // has been checked in getXml method--shweta tyagi
									/*if (attrib[2].equals(String.valueOf(WFSConstant.WF_FLT))) {
                                    value = gen.getfloatValue(value);
                                    }
                                     */
                                    rightsInfo = attrib[7].substring(0, 2);
                                    if (attrib[3] == null) {
                                        wfFieldValue = new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], value, allAttrib.getWfType(), allAttrib.getScope(), 255, allAttrib.getPrecison()); //just identical to cache

                                    } else {
                                        wfFieldValue = new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], value, allAttrib.getWfType(), allAttrib.getScope(), Integer.parseInt(attrib[3]), allAttrib.getPrecison());
                                    }
                                    wfFieldValue.setRightsInfo(rightsInfo);
                                    valuemap.put(Integer.parseInt(attrib[0]) + string21 + 0, wfFieldValue); //just identical to cache

                                }
                            }

                            if (mapCount > 0) {
                                while (st.hasMoreTokens()) {
                                    int y = ++k;
                                    tempStr = rs.getString(y);
                                    colname = rsmd.getColumnName(y);
                                    type = rsmd.getColumnType(y);
                                    String tmptoken = "";
                                    if (rs.wasNull()) {
                                        tmptoken = st.nextToken();	//Bug Id 5431

                                        extbuffer.append(tmptoken).append(" is null and ");
                                        if (cmplxextbuffer != null) {
                                            cmplxextbuffer.append(tmptoken).append(" is null and ");
                                        }
                                    } else {
                                        tmptoken = st.nextToken();	//Bug Id 5431
                                        if(colname.equalsIgnoreCase("VAR_REC_1")&&tmptoken.equalsIgnoreCase("ItemIndex")) {
                                            extbuffer.append(tmptoken).append("= ? ").append(" and ");
                                            itemIndexValue=tempStr;
                                        }
                                        else if(colname.equalsIgnoreCase("VAR_REC_2")&&tmptoken.equalsIgnoreCase("ItemType")) {
                                            extbuffer.append(tmptoken).append("= ? ").append(" and ");
                                            itemTypeValue=tempStr;
                                        }else {
                                        extbuffer.append(tmptoken).append("=").append(WFSUtil.TO_STRING(
                                                tempStr.trim(), true, dbType)).append(" and ");
                                        }
                                        if (cmplxextbuffer != null) {
                                            cmplxextbuffer.append(tmptoken).append("=").append(
                                                    WFSUtil.TO_STRING(tempStr.trim(), true, dbType)).append(" and ");
                                        }
                                    }
                                    // Change for bug 40367 
                                    if (relationMap != null && relationMap.containsKey((keyToken + colname).toUpperCase())) {
                                        //WFSUtil.printOut("line num 4325 putting value for relation" + tempStr);
                                        //Bug Id 5128
                                        if (tempStr != null) {
                                            if (JDBCTYPE_TO_WFSTYPE(type) == WFSConstant.WF_NTEXT) {
                                                Object[] obj = getBIGData(con, rs, colname, dbType, DatabaseTransactionServer.charSet);
                                                tempStr = (String) obj[0];
                                            } else {
                                                tempStr = WFSUtil.TO_SQL(tempStr.trim(), WFSUtil.JDBCTYPE_TO_WFSTYPE(type), dbType, true);
                                            }
                                        }
                                        values = new ArrayList();
                                        values.add(tempStr);
                                        // Change for bug 40367 
                                        relationMap.put((keyToken + colname).toUpperCase(), values);
                                    }
                                }
                            }

                            for (k = 0; WFSConstant.qdmattribs.length > k; k++) {
                                attrib = WFSConstant.qdmattribs[k];
                                allAttrib = (WFFieldInfo) (cachemap.get(attrib[0].toUpperCase()));
                                //WFS_8.0_084
								if (!name.equalsIgnoreCase("") && !attrib[0].equalsIgnoreCase(name))
                                {
                                    continue;
                                }
                                if (allAttrib != null) {
                                    value = rs.getString(qCount + mapCount + k + 1);
                                    if (ps) {
                                        attributes.put(attrib[0].toUpperCase(), new WFFieldValue(allAttrib.getVariableId(), attrib[0], value, Integer.parseInt(attrib[1]), allAttrib.getLength(), allAttrib.getPrecison()));
                                    } else {
                                        rightsInfo = attrib[1].substring(0, 2);
                                        wfFieldValue = new WFFieldValue(allAttrib.getVariableId(), attrib[0], value, allAttrib.getWfType(), allAttrib.getLength(), allAttrib.getPrecison());
                                        wfFieldValue.setRightsInfo(rightsInfo);
                                        valuemap.put((allAttrib.getVariableId() + string21 + 0), wfFieldValue);
                                    }
                                }
                            }
                            if(!wlisttable.equalsIgnoreCase(" Queuehistorytable "))
                            {
                                for (k = 0; WFSConstant.qdmchildattribs.length > k; k++) {
                                    attrib = WFSConstant.qdmchildattribs[k];
                                    if (!name.equalsIgnoreCase("") && !attrib[0].equalsIgnoreCase(name))
                                    {
                                        continue;
                                    }
                                    value = rs.getString(qCount + mapCount + WFSConstant.qdmattribs.length + k + 1);
                                    printOut(engine, " Variable : " + attrib[0] + " Value : " + value);
                                    if (ps) {
                                        attributes.put(attrib[0].toUpperCase(), new WFFieldValue(Integer.parseInt(attrib[3]), attrib[0], value, Integer.parseInt(attrib[1]), 255, 0));
                                    } else {
                                        rightsInfo = attrib[1].substring(0, 2);
                                        wfFieldValue = new WFFieldValue(Integer.parseInt(attrib[3]), attrib[0], value, Integer.parseInt(attrib[1]), 255, 0);
                                        wfFieldValue.setRightsInfo(rightsInfo);
                                        valuemap.put((attrib[3] + string21 + 0), wfFieldValue);
                                    }
                                }
                            }
                            rs.close();
                            rs = null;
                            pstmt.close();
                            pstmt = null;

                            pstmt = con.prepareStatement(WFSConstant.s_attribpinlst +  getTableLockHintStr(dbType)  +" where ProcessInstanceId = ?");
                            WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
                            pstmt.execute();
                            rs = pstmt.getResultSet();
                            if (rs.next()) {
                                for (k = 0; WFSConstant.prcattribs.length > k; k++) {
                                    attrib = WFSConstant.prcattribs[k];
                                    allAttrib = (WFFieldInfo) (cachemap.get(attrib[0].toUpperCase()));
									//WFS_8.0_084
									if (!name.equalsIgnoreCase("") && !attrib[0].equalsIgnoreCase(name))
                                    {
                                        continue;
                                    }
                                    if (allAttrib != null) {
                                        value = rs.getString(k + 1);
                                        if (ps) {
                                            attributes.put(attrib[0].toUpperCase(), new WFFieldValue(allAttrib.getVariableId(), attrib[0], value, Integer.parseInt(attrib[1]), allAttrib.getLength(), allAttrib.getPrecison()));
                                        } else {
                                            rightsInfo = attrib[1].substring(0, 2);
                                            wfFieldValue = new WFFieldValue(allAttrib.getVariableId(), attrib[0], value, allAttrib.getWfType(), allAttrib.getLength(), allAttrib.getPrecison());
                                            wfFieldValue.setRightsInfo(rightsInfo);
                                            valuemap.put(allAttrib.getVariableId() + string21 + 0, wfFieldValue);
                                        }
                                    }
                                }
                            }else{
								pstmt = con.prepareStatement(WFSConstant.s_attribqueht + " where ProcessInstanceId = ?");
								WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
								pstmt.execute();
								rs = pstmt.getResultSet();
								if (rs.next()) {
									for (k = 0; WFSConstant.prcattribs.length > k; k++) {
										attrib = WFSConstant.prcattribs[k];
										allAttrib = (WFFieldInfo) (cachemap.get(attrib[0].toUpperCase()));
									   
										//WFS_8.0_084
										if (!name.equalsIgnoreCase("") && !attrib[0].equalsIgnoreCase(name)){
											
											continue;
										}
										if (allAttrib != null) {
											value = rs.getString(k + 1);
											if (ps) {
												attributes.put(attrib[0].toUpperCase(), new WFFieldValue(allAttrib.getVariableId(), attrib[0], value, Integer.parseInt(attrib[1]), allAttrib.getLength(), allAttrib.getPrecison()));
											} else {
												rightsInfo = attrib[1].substring(0, 2);
												wfFieldValue = new WFFieldValue(allAttrib.getVariableId(), attrib[0], value, allAttrib.getWfType(), allAttrib.getLength(), allAttrib.getPrecison());
												wfFieldValue.setRightsInfo(rightsInfo);
												valuemap.put(allAttrib.getVariableId() + string21 + 0, wfFieldValue);
											}
										}
									}
								}
                            }
							
                            rs.close();
                            rs = null;
                            pstmt.close();
                            pstmt = null;

                            pstmt = con.prepareStatement((wlisttable.trim().equalsIgnoreCase("Queuehistorytable")? WFSConstant.s_attribwrklst.replaceAll("expectedWorkITemDelay","EXPECTEDWORKITEMDELAYTIME") : WFSConstant.s_attribwrklst) + WFSUtil.getDate(dbType) + ",QueueName,QueueType from " + wlisttable +WFSUtil.getTableLockHintStr(dbType)+
                                    " where ProcessInstanceId = ? and WorkitemId = ? ");//WFS_8.0_081
                            WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
                            pstmt.setInt(2, workItemID);
                            pstmt.execute();
                            rs = pstmt.getResultSet();
                            if (rs.next()) {
                                for (k = 0; WFSConstant.wklattribs.length > k; k++) {
                                    attrib = WFSConstant.wklattribs[k];
                                    allAttrib = (WFFieldInfo) (cachemap.get(attrib[0].toUpperCase()));
									//WFS_8.0_084
									if (!name.equalsIgnoreCase("") && !attrib[0].equalsIgnoreCase(name))
                                    {
                                        continue;
                                    }
                                    if (allAttrib != null) {
                                        value = rs.getString(k + 1);
                                        if (ps) {
                                            attributes.put(attrib[0].toUpperCase(), new WFFieldValue(allAttrib.getVariableId(), attrib[0], value, Integer.parseInt(attrib[1]), allAttrib.getLength(), allAttrib.getPrecison()));
                                        } else {
                                            rightsInfo = attrib[1].substring(0, 2);
                                            wfFieldValue = new WFFieldValue(allAttrib.getVariableId(), attrib[0], value, allAttrib.getWfType(), allAttrib.getLength(), allAttrib.getPrecison());
                                            wfFieldValue.setRightsInfo(rightsInfo);
                                            valuemap.put((allAttrib.getVariableId() + string21 + 0).toUpperCase(), wfFieldValue);
                                        }
                                    }
                                }
                                value = rs.getString(++k);
                                wfFieldValue = new WFFieldValue(45, "QueueName", value, WFSConstant.WF_STR, '\0', 255, 0);
                                wfFieldValue.setRightsInfo("32");
                                valuemap.put(45 + string21 + 0, wfFieldValue); //@@check

                                value = rs.getString(++k);
                                wfFieldValue = new WFFieldValue(44, "QueueType", value, WFSConstant.WF_STR, '\0', 255, 0);
                                wfFieldValue.setRightsInfo("32");
                                valuemap.put(44 + string21 + 0, wfFieldValue); //@@check

                                retrCount += 2;
                            }
                            rs.close();
                            rs = null;
                            pstmt.close();
                            pstmt = null;

                            if (iCount > 0) {
                            	WFSUtil.printOut(engine,"query for external variables:" + extbuffer);
								boolean extTabExist_History  = false;
								int idx1 = extbuffer.indexOf(" From ");
								int idx2 = extbuffer.indexOf(" where ");
								String part1 =  extbuffer.substring(0,idx1+5)+" "  ;
								String part2 = " " + extbuffer.substring(idx2);
								String tableName = extbuffer.substring(idx1 + 5,idx2).trim();
								if(wlisttable.toUpperCase().contains("QUEUEHISTORYTABLE")){
								if(dbType==JTSConstant.JTS_MSSQL){
									pstmt = con.prepareStatement("SELECT 1 FROM sysObjects WHERE NAME = ?");
								}
								else if(dbType==JTSConstant.JTS_ORACLE){
									pstmt = con.prepareStatement("SELECT 1  FROM USER_TABLES WHERE TABLE_NAME = UPPER(?)");
								}
								else if(dbType==JTSConstant.JTS_POSTGRES){
									pstmt = con.prepareStatement("select 1  from information_schema.tables where upper(table_name) =  UPPER(?)");
								}
								pstmt.setString(1,tableName+"_history");
								rs=pstmt.executeQuery();
								if(rs.next()){
									extTabExist_History=true;
										extTableNameHistory=tableName+"_history";
								}
								rs.close();
								pstmt.close();
									if(!extTabExist_History){
										try{ 
											pstmt = con.prepareStatement(" SELECT HISTORYTABLENAME FROM EXTDBCONFTABLE where ProcessDefID =  ? and ExtObjId = ? ");
											pstmt.setInt(1, iProcDefId);
											pstmt.setInt(2, 1);
											pstmt.execute();
											rs = pstmt.getResultSet();
											if(rs!=null && rs.next()) {
												extTableNameHistory = rs.getString("HISTORYTABLENAME");
												WFSUtil.printOut(engine, "[fetchAttributesExt] HISTORYTABLENAME >> " + extTableNameHistory);
											}
	                                        if(rs!=null){
	                                              rs.close();
	                                              rs = null;
	                                         }
	                                         if(pstmt!=null){
	                                               pstmt.close();
	                                               pstmt = null;
	                                          }
	                                        if(extTableNameHistory != null && !extTableNameHistory.equals("")){
		                                        if(dbType==JTSConstant.JTS_MSSQL){
		         									pstmt = con.prepareStatement("SELECT 1 FROM sysObjects WHERE NAME = ?");
		         								}
		         								else if(dbType==JTSConstant.JTS_ORACLE){
		         									pstmt = con.prepareStatement("SELECT 1  FROM USER_TABLES WHERE TABLE_NAME = UPPER(?)");
		         								}
		         								else if(dbType==JTSConstant.JTS_POSTGRES){
		         									pstmt = con.prepareStatement("select 1  from information_schema.tables where upper(table_name) =  UPPER(?)");
		         								}
		         								pstmt.setString(1,extTableNameHistory);
		         								rs=pstmt.executeQuery();
		         								if(rs.next()){
		         									extTabExist_History_Explicit = true;
													extTabExist_History =  true;
		         								}
		         								rs.close();
		        								pstmt.close();
	                                        }
	
									} catch(SQLException e){
										WFSUtil.printErr(engine, e);
									} 
									}
									StringBuffer extbuffer_history = new StringBuffer(part1 + extTableNameHistory  );
								extbuffer_history.append(getTableLockHintStr(dbType));
								extbuffer_history.append(part2); 
								WFSUtil.printOut(engine,"query for external variables from external history table:" + extbuffer_history);	
								
									pstmt = con.prepareStatement(extbuffer_history.append(" 1 = 1 ").toString());
									
								if(extTabExist_History){
		                                pstmt.setString(1, itemIndexValue);
		                                pstmt.setString(2, itemTypeValue);
									rs = pstmt.executeQuery();
									if (rs != null && rs.next()) {
										extTabExist_History = true;
									rs = pstmt.executeQuery();
									rsmd = pstmt.getMetaData();
										}else{
											extTabExist_History = false;
											rs.close();
											pstmt.close();
								}
									}
								}
								if(!extTabExist_History){ 
								extbuffer.replace(idx1+5, idx2, " "  +tableName +getTableLockHintStr(dbType));
	                            pstmt = con.prepareStatement(extbuffer.append(" 1 = 1 ").toString());
	                                pstmt.setString(1, itemIndexValue);
	                                pstmt.setString(2, itemTypeValue);
                                startTime = System.currentTimeMillis();
                                pstmt.execute();
                                endTime = System.currentTimeMillis();
                                timeElapsedToFetchExtData = endTime - startTime;
                                //WFSUtil.printOut(engine,"WFFetchAttributes : query to fetch external table data started at : "+startTime +" ended at : "+endTime +" total time taken : "+timeElapsedToFetchExtData);
								
                                rs = pstmt.getResultSet();
                                rsmd = pstmt.getMetaData();
								}
                                if (rs.next()) {
                                    for (k = 0; iCount > k; k++) {
                                        attrib = (String[]) extattribs.get(k);
                                        allAttrib = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
										//WFS_8.0_084
										colname = rsmd.getColumnName(k + 1);
                                        value = rs.getString(k + 1);
                                        type = rsmd.getColumnType(k + 1);

                                         //IF clause included for - Bug 42322
                                        if(value !=null && (type == WFSConstant.WF_FLT || type == WFSConstant.WF_DAT)){
                                            BigDecimal valNum = new BigDecimal(value);
                                            value = valNum.toString();
                                        }

                                        //WFSUtil.printOut(engine,"value:::=> "+value+", Column Name:"+rsmd.getColumnName(k+1) +", Type:"+type+", relationMap::"+relationMap);

										if (relationMap != null && relationMap.containsKey((tablename + string21 + colname).toUpperCase())) {
                                            //WFSUtil.printOut("line 4455 putting value for relation" + value);
                                            values = new ArrayList();
                                            //Bug Id 5128
											String strval=value;
                                            if (strval != null) {
                                                if (JDBCTYPE_TO_WFSTYPE(type) == WFSConstant.WF_NTEXT) {
                                                    Object[] obj = getBIGData(con, rs, colname, dbType, DatabaseTransactionServer.charSet);
                                                    strval = (String) obj[0];
                                                } else {
                                                    strval = WFSUtil.TO_SQL(value.trim(), WFSUtil.JDBCTYPE_TO_WFSTYPE(type), dbType, true);
                                                }
                                            }
                                            values.add(strval);
                                            //WFSUtil.printOut(values);
                                            relationMap.put((tablename + string21 + colname).toUpperCase(), values);
                                        }
										if (!name.equalsIgnoreCase("") && !attrib[1].equalsIgnoreCase(name))
                                        {
                                            continue;
                                        }
                                        if (ps) {
                                            if (attrib[3] == null) {
                                                attributes.put(attrib[1].toUpperCase(), new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], value, Integer.parseInt(attrib[2]), 1024, Integer.parseInt(attrib[8])));
                                            } else {
                                                attributes.put(attrib[1].toUpperCase(), new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], value, Integer.parseInt(attrib[2]), Integer.parseInt(attrib[3]), Integer.parseInt(attrib[8])));
                                            } //checkout

                                        } else {
                                            try {
                                                if (attrib[7] != null && attrib[7].charAt(1) == '4') {
                                                    continue;
                                                } //do not return the attribs that have access attrib as NULL

                                            } catch (Exception ex) { //stringIndexOutOfBounds
                                                //do nothing

                                            }
                                            if (allAttrib != null) {
                                                // SrNo-1, Check for float value. Bug rectified By PRD team ..
                                                // has been checked in getXml method--shweta tyagi
													/*if (attrib[2].equals(String.valueOf(WFSConstant.WF_FLT))) {
                                                value = gen.getfloatValue(value);
                                                }*/
                                                rightsInfo = attrib[7].substring(0, 2);
                                                if (attrib[3] == null) {
                                                    wfFieldValue = new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], value, allAttrib.getWfType(), 1024, allAttrib.getPrecison());
                                                } else {
                                                    wfFieldValue = new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], value, allAttrib.getWfType(), Integer.parseInt(attrib[3]), allAttrib.getPrecison());
                                                }
                                                wfFieldValue.setRightsInfo(rightsInfo);
                                                valuemap.put(allAttrib.getVariableId() + string21 + 0, wfFieldValue);
                                            }
                                        }
                                        //WFSUtil.printOut("line num 4453" + (tablename + "#" + colname).toUpperCase());
                                    }
                                } else {
                                    for (k = 0; iCount > k; k++) {
                                        attrib = (String[]) extattribs.get(k);
                                        allAttrib = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
										//WFS_8.0_084
										if (!name.equalsIgnoreCase("") && !attrib[1].equalsIgnoreCase(name))
                                        {
                                            continue;
                                        }

                                        if (ps) {
                                            if (attrib[3] == null) {
                                                attributes.put(attrib[1].toUpperCase(), new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], "", Integer.parseInt(attrib[2]), 1024, Integer.parseInt(attrib[8])));
                                            } else {
                                                attributes.put(attrib[1].toUpperCase(), new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], "", Integer.parseInt(attrib[2]), Integer.parseInt(attrib[3]), Integer.parseInt(attrib[8])));
                                            }
                                        } else {
                                            if (allAttrib != null) {
                                                // SrNo-1, Check for float value. Bug rectified By PRD team ..
                                                // has been checked in getXml method--shweta tyagi
													/*if (attrib[2].equals(String.valueOf(WFSConstant.WF_FLT))) {
                                                value = gen.getfloatValue(value);
                                                }*/
                                                rightsInfo = attrib[7].substring(0, 2);
                                                if (attrib[3] == null) {
                                                    wfFieldValue = new WFFieldValue(allAttrib.getVariableId(), attrib[1], "", allAttrib.getWfType(), 1024, allAttrib.getPrecison());
                                                } else {
                                                    wfFieldValue = new WFFieldValue(allAttrib.getVariableId(), attrib[1], "", allAttrib.getWfType(), Integer.parseInt(attrib[3]), allAttrib.getPrecison());
                                                }
                                                wfFieldValue.setRightsInfo(rightsInfo);
                                                valuemap.put(allAttrib.getVariableId() + string21 + 0, wfFieldValue);
                                            }
                                        }
                                    }
                                }
                            }
                            for (k = 0; WFSConstant.s_timeattribs.length-2 > k; k++) {
                                attrib = WFSConstant.s_timeattribs[k];
                                int length = WFSConstant.s_timeattribs.length;
                                if (attrib[3].equals("-3")) {
                                    value = String.valueOf(timeElapsedToFetchQueueData);
                                } else if (attrib[3].equals("-4")) {
                                    value = String.valueOf(timeElapsedToFetchExtData);
                                }
                                if (ps) {
                                    attributes.put(attrib[0].toUpperCase(), new WFFieldValue(Integer.parseInt(attrib[3]), attrib[0], value,  WFSConstant.WF_STR, '\0', 255, 0));
                                } else {
                                    rightsInfo = attrib[1].substring(0, 2);
                                    wfFieldValue = new WFFieldValue(Integer.parseInt(attrib[3]), attrib[0], value, WFSConstant.WF_STR, 255, 0);
                                    wfFieldValue.setRightsInfo(rightsInfo);
                                    valuemap.put((attrib[3] +string21 + 0), wfFieldValue); 
                                }
                            }
                       

                        } else {
                            rs.close();
                            rs = null;
                            pstmt.close();
                            pstmt = null;
                        }
                        /*added to ensure that relation columns have been selected before querying
                        for arrays and complex - shweta tyagi*/
                        if (aCount > 0 || cCount > 0) {
                            String tmptable = "";
                            String tmpcol = "";
                            String tmpcmplx = "";

                            if (cmplxquebuffer != null) {
                                pstmt = con.prepareStatement(cmplxquebuffer.toString() + "null from " +
                                        (wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
                                        //: "Queuedatatable ") + " where ProcessInstanceId = ? and WorkItemId = ?");
										: "WFInstrumentTable ") + getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkItemId = ?");
                                WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
                                pstmt.setInt(2, workItemID);
                                startTime = System.currentTimeMillis();
                                pstmt.execute();
                                endTime = System.currentTimeMillis();
                                timeElapsedToFetchCmplxQueData = endTime - startTime;
                                //WFSUtil.printOut(engine,"WFFetchAttributes : query to fetch Complex table data started at : "+startTime +" ended at : "+endTime +" total time taken : "+timeElapsedToFetchCmplxQueData);
                                rs = pstmt.getResultSet();
                                rsmd = pstmt.getMetaData();
                                int ctr = rsmd.getColumnCount();
                                int i = 1;

                                if (rs != null && rs.next()) {
                                    while (ctr > 0) {
                                        type = rsmd.getColumnType(i);
                                        value = rs.getString(i);
                                        String strColumnName = rsmd.getColumnName(i);
                                        //Bug Id 5128
										String strval=value;
                                        if (strval != null) {
                                            if (JDBCTYPE_TO_WFSTYPE(type) == WFSConstant.WF_NTEXT) {
                                                Object[] obj = getBIGData(con, rs, strColumnName, dbType, DatabaseTransactionServer.charSet);
                                                strval = (String) obj[0];
                                            } else {
                                                strval =WFSUtil.TO_SQL(value.trim(), WFSUtil.JDBCTYPE_TO_WFSTYPE(type), dbType, true);
                                            }
                                        }
                                        values = new ArrayList();
                                        values.add(strval);
                                        tmpcol = rsmd.getColumnName(i);
                                        if (!tmpcol.equals("")) {
                                        	// Change for bug 40367 
                                       		relationMap.put((keyToken + tmpcol).toUpperCase(), values);
                                        }

                                        i++;
                                        ctr--;
                                    }
                                }
                                rs.close();
                                rs = null;
                                pstmt.close();
                                pstmt = null;
                            }
                            if (cmplxextbuffer != null) {

                                pstmt = con.prepareStatement(cmplxextbuffer.append("1=1").toString());
                                startTime = System.currentTimeMillis();
                                pstmt.execute();
                                endTime = System.currentTimeMillis();
                                timeElapsedToFetchCmplxExtData = endTime - startTime;
                                //WFSUtil.printOut(engine,"WFFetchAttributes : query to fetch complex EXT table data started at : "+startTime +" ended at : "+endTime +" total time taken : "+timeElapsedToFetchCmplxExtData);
                                rs = pstmt.getResultSet();
                                rsmd = pstmt.getMetaData();
                                int ctr = rsmd.getColumnCount();
                                int i = 1;

                                if (rs != null && rs.next()) {
                                    while (ctr > 0) {
                                        type = rsmd.getColumnType(i);
                                        String strColumnName = rsmd.getColumnName(i);
                                        value = rs.getString(i);//Bug was introduced while fixing Bug 5128
                                        //Bug Id 5128
										String strval=value;
                                        if (strval != null) {
                                            if (JDBCTYPE_TO_WFSTYPE(type) == WFSConstant.WF_NTEXT) {
                                                Object[] obj = getBIGData(con, rs, strColumnName, dbType, DatabaseTransactionServer.charSet);
                                                strval = (String) obj[0];
                                            } else {
                                                strval = WFSUtil.TO_SQL(value.trim(), WFSUtil.JDBCTYPE_TO_WFSTYPE(type), dbType, true);
                                            }
                                        }
                                        values = new ArrayList();
                                        values.add(strval);
                                        //tmptable = rsmd.getTableName(i); //Bugzilla Bug 5580
                                        tmptable = tablename;
                                        tmpcol = rsmd.getColumnName(i);
                                        relationMap.put((tmptable + string21 + tmpcol).toUpperCase(), values);
                                        i++;
                                        ctr--;
                                    }
                                }
                                rs.close();
                                rs = null;
                                pstmt.close();
                                pstmt = null;
                            }
                            
                            for (int k = 2; WFSConstant.s_timeattribs.length > k; k++) {
                                attrib = WFSConstant.s_timeattribs[k];
                                int length = WFSConstant.s_timeattribs.length;
                                if (attrib[3].equals("-5")) {
                                    value = String.valueOf(timeElapsedToFetchCmplxQueData);
                                }else if (attrib[3].equals("-6")) {
                                    value = String.valueOf(timeElapsedToFetchCmplxExtData);
                                }
                                if (ps) {
                                    attributes.put(attrib[0].toUpperCase(), new WFFieldValue(Integer.parseInt(attrib[3]), attrib[0], value,  WFSConstant.WF_STR, '\0', 255, 0));
                                } else {
                                    rightsInfo = attrib[1].substring(0, 2);
                                    wfFieldValue = new WFFieldValue(Integer.parseInt(attrib[3]), attrib[0], value, WFSConstant.WF_STR, 255, 0);
                                    wfFieldValue.setRightsInfo(rightsInfo);
                                    valuemap.put((attrib[3] +string21 + 0), wfFieldValue); 
                                }
                            }
                        }
                        WFSUtil.printOut(engine,"array count was " + aCount);
                        if (aCount > 0) {
                            if (arrayQry != null) {
                                int k;
								String ignoreSuffix = getFetchSuffixStr(dbType,1,WFSConstant.QUERY_STR_AND).toUpperCase();
								int iPosSuffix = 0;
								
                                for (k = 0; aCount > k; k++) {
                                    attrib = (String[]) arrayattribs.get(k);
                                    allAttrib = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
									//WFS_8.0_084
                                    if (!name.equalsIgnoreCase("") && !attrib[1].equalsIgnoreCase(name))
                                    {
                                        continue;
                                    }
                                    StringBuffer str = new StringBuffer((String) arrayQry.get(attrib[1].toUpperCase()));
                                    String qry = str.toString();
                                    ArrayList relationstr = new ArrayList();
                                    ArrayList relationval = new ArrayList();

									if (!ignoreSuffix.equalsIgnoreCase("")){
										iPosSuffix = qry.indexOf(ignoreSuffix);
										if (iPosSuffix != -1){	//Bugzilla Bug 13084
											qry = qry.substring(0, iPosSuffix);
										}
									}
                                    while (qry.indexOf("=") != -1) {
                                        if (qry.indexOf(" AND ") != -1) {	//WFS_8.0_004

                                            relationstr.add((qry.substring(qry.indexOf("=") + 1, qry.indexOf(" AND "))).trim());//Bugzilla Bug 7227,7357

                                            qry = qry.substring(qry.indexOf(" AND ") + 1);
                                        } else {
                                            relationstr.add((qry.substring(qry.indexOf("=") + 1)).trim());//Bugzilla Bug 7227,7357

                                            qry = qry.substring(qry.indexOf("=") + 1);
                                        }
                                    }

                                    ListIterator itr = relationstr.listIterator();
                                    ArrayList relvalues = new ArrayList();
                                    String val = "";
                                    boolean flag = false;
                                    while (itr.hasNext()) {
                                        String tmpstr = (String) itr.next();
                                        StringBuffer tmp = new StringBuffer();
                                        //if (tmpstr.indexOf("QUEUEDATATABLE") == -1 && tmpstr.indexOf(
										if (tmpstr.indexOf("WFINSTRUMENTTABLE") == -1 && tmpstr.indexOf(
										"QUEUEHISTORYTABLE") == -1 && tmpstr.indexOf(tablename.toUpperCase()) == -1) {
                                            tmp.append(attrib[1] + ":");
                                        }
                                        if (!tmpstr.equals("1")) {
                                            tmp.append(tmpstr.replace(".", string21)); //structurename:tablename#columname

                                            WFSUtil.printOut(engine,"key to get the relation value" + tmp.toString());
                                            WFSUtil.printOut(engine,"relationMap for array case" + relationMap);
                                            relvalues = (ArrayList) relationMap.get((tmp.toString()).trim().toUpperCase());
                                            if (relvalues != null) {
                                                if (relvalues.size() > 1) {
                                                    WFSUtil.printOut(engine,"this cannot happen error");
                                                }
                                                val = (String) relvalues.get(0);
                                                if (val != null) {
                                                    str = str.replace(str.indexOf(tmpstr), str.indexOf(tmpstr) + tmpstr.length(), val);
                                                } else {
                                                    //flag = true;
                                                    str = str.replace(str.indexOf("=" + tmpstr), str.indexOf("=" + tmpstr) + tmpstr.length() + 1, " IS NULL ");
                                                }
                                            } else {
                                                //flag = true;
                                                str = str.replace(str.indexOf("=" + tmpstr), str.indexOf("=" + tmpstr) + tmpstr.length() + 1, " IS NULL ");
                                            }
                                        }

                                    }
                                    /*join of parent table with array table removed-shweta tyagi*/
                                    /*if (flag) {

                                    str = str.replace(str.indexOf("FROM "), str.indexOf("FROM ") + 5, "FROM " + ((String) relationstr.get(0)).substring(0, ((String) relationstr.get(0)).indexOf(".")) + ",");

                                    }*/
                                    str.append(" ORDER BY INSERTIONORDERID ");
                                    WFSUtil.printOut(engine,"array query1  " + str.toString());
                                    pstmt = con.prepareStatement(str.toString());
                                    pstmt.execute();
                                    rs = pstmt.getResultSet();
                                    rsmd = rs.getMetaData();
                                    values = new ArrayList();
                                    while (rs != null && rs.next()) {
                                        values.add(rs.getString(1));
                                        type = rsmd.getColumnType(1);
                                        colname = rsmd.getColumnName(1);
                                    }
                                    //WFSUtil.printOut("4568" + values);
                                    //***array to be put in relation map***//
                                    String key = (allAttrib.getName() + ":" + allAttrib.getMappedTable() + string21 + colname).toUpperCase();
                                    if (relationMap.containsKey(key)) {
                                        relationMap.put(key, values);
                                        WFSUtil.printOut(engine,"putting in relation map value for root level array");
                                    }
									if (values.size() > 0) {		//primitive array returning blank tag in case empty
										if (ps) {
											if (attrib[3] == null) {
												attributes.put(attrib[1].toUpperCase(), new WFFieldValue(allAttrib.getVariableId(), allAttrib.getVarFieldId(), attrib[1], values, Integer.parseInt(attrib[2]), allAttrib.getScope(), 1024, allAttrib.getPrecison(), allAttrib.getParentInfo()));
											} else {
												attributes.put(attrib[1].toUpperCase(), new WFFieldValue(allAttrib.getVariableId(), allAttrib.getVarFieldId(), attrib[1], values, Integer.parseInt(attrib[2]), allAttrib.getScope(), Integer.parseInt(attrib[3]), allAttrib.getPrecison(), allAttrib.getParentInfo()));
											}
										} else {
											if (allAttrib != null) {
												rightsInfo = allAttrib.getRightsInfo();
												if (attrib[3] == null) {
													wfFieldValue = new WFFieldValue(allAttrib.getVariableId(), allAttrib.getVarFieldId(), attrib[1], values, allAttrib.getWfType(), allAttrib.getScope(), allAttrib.getLength(), allAttrib.getPrecison(), allAttrib.getParentInfo());
												} else {
													wfFieldValue = new WFFieldValue(allAttrib.getVariableId(), allAttrib.getVarFieldId(), attrib[1], values, allAttrib.getWfType(), allAttrib.getScope(), allAttrib.getLength(), allAttrib.getPrecison(), allAttrib.getParentInfo());
												}
												wfFieldValue.setRightsInfo(rightsInfo);
												valuemap.put((allAttrib.getVariableId() + string21 + allAttrib.getVarFieldId()).toUpperCase(), wfFieldValue);
											}
										}
									}
                                    rs.close();
                                    rs = null;
                                    pstmt.close();
                                    pstmt = null;
                                }
                            }
                        }
						//WFS_8.0_084
                        Iterator itrvarval = valuemap.entrySet().iterator();
                        HashMap qvalmap=new HashMap();
                        while (itrvarval.hasNext()) {
                            ArrayList objlist=new ArrayList();
                            Object obruleid=itrvarval.next();
                            Map.Entry entries = (Map.Entry) obruleid;
                            WFFieldValue fieldValue = (WFFieldValue) entries.getValue();
                            String key=obruleid.toString();
                           
                            key=key.substring(0, key.lastIndexOf(string21));
                    
                            objlist=fieldValue.getValues();
                            int iOperandType=fieldValue.getWfType();
                            qvalmap.put(key, String.valueOf(objlist.toArray()[0])+string21+iOperandType);
                        }
                        LinkedHashMap FragmentOperationVarMap = new LinkedHashMap(500);
                        FragmentOperationVarMap=attribs.getFragmentOperationVarMap();
                        LinkedHashMap FragmentConditionVarMap = new LinkedHashMap(500);
                        FragmentConditionVarMap=attribs.getFragmentConditionVarMap();
                        LinkedHashMap CmplxMap = new LinkedHashMap(500);
                        //Iterator itr = FragmentOperationVarMap.keySet();//entrySet().iterator();
                        Iterator itr =FragmentOperationVarMap.keySet().iterator();
                        int iRuleID=0;
                        ResultSet rsopr=null;
                        Statement stmt=null;
                        String strCmplxName="";
                        boolean finalconditionresult=false;
                        boolean conditionresult=false;
                        String fragcondition="";
                        while (itr.hasNext())
                        {








                             String param []=new String[10];
                             String type1="";
                             int variableid1=0;
                             String type2="";
                             int variableid2=0;
                             int Operator=0;
                             int LogicalOperator=0;
                             int extCount=0;

                             fragcondition="";
                             Object obruleid=itr.next();
                             iRuleID=Integer.parseInt(obruleid.toString());
                             ArrayList ruleList = null;
                             WFRuleInfo wfRuleInfo = null;
                             try
                             {








                                 ruleList = (ArrayList)CachedObjectCollection.getReference().getCacheObject(con, engine, procDefId, WFSConstant.CACHE_CONST_RuleCache, String.valueOf(iRuleID)).getData();
                                 if(ruleList != null){
                                     for(int i = 0; i < ruleList.size(); i++){
                                        wfRuleInfo = (WFRuleInfo) ruleList.get(i);
                                        param [0]=wfRuleInfo.getParam1();
                                        type1=wfRuleInfo.getType1();
                                        variableid1=wfRuleInfo.getVariableid_1();
                                        param [1] =wfRuleInfo.getParam2();
                                        type2=wfRuleInfo.getType2();
                                        variableid2=wfRuleInfo.getVariableid_2();
                                        LogicalOperator=wfRuleInfo.getLogicalOp();
                                        Operator=wfRuleInfo.getOperator();
                                        //Changes for Bug 39661 .

                                        fragmentVariables.add(String.valueOf(FragmentOperationVarMap.get(iRuleID)));
                                        if(type1.equalsIgnoreCase("S"))
                                        {
                                            strCmplxName=String.valueOf(FragmentOperationVarMap.get(iRuleID));
                                            CmplxMap.put(FragmentOperationVarMap.get(iRuleID),"");
                                        }
                                        else
                                        {
                                            if(type2.equalsIgnoreCase("C"))
                                            {
                                                String Mapvarval1=qvalmap.get(String.valueOf(variableid1)).toString();
                                                String varval1=Mapvarval1.substring(0,Mapvarval1.lastIndexOf(string21));
                                                int OperandType=Integer.parseInt(Mapvarval1.substring(Mapvarval1.lastIndexOf(string21)+1));
                                                conditionresult=Utility.compareObject(varval1, param[1], OperandType, Operator);
                                            }
                                            if(!type2.equalsIgnoreCase("C") && !type2.equalsIgnoreCase("S"))
                                            {
                                                String Mapvarval1=qvalmap.get(String.valueOf(variableid1)).toString();
                                                String varval1=Mapvarval1.substring(0,Mapvarval1.lastIndexOf(string21));
                                                String Mapvarval2=qvalmap.get(String.valueOf(variableid2)).toString();
                                                String varval2=Mapvarval1.substring(0,Mapvarval2.lastIndexOf(string21));
                                                int OperandType=Integer.parseInt(Mapvarval1.substring(Mapvarval1.lastIndexOf(string21)+1));
                                                conditionresult=Utility.compareObject(varval1, varval1, OperandType, Operator);
                                            }
                                        }
                                        if(LogicalOperator==1)
                                            fragcondition+=" "+conditionresult+" AND ";
                                        if(LogicalOperator==2)
                                            fragcondition+=" "+conditionresult+" OR";
                                        else if(LogicalOperator!=4 || LogicalOperator!=3)
                                            fragcondition+=""+conditionresult;
                                        }
                                 }                                
                             }
                             catch(Exception e)
                             {
                                 //printErr(engine, "", e);
                             }
                             if(fragcondition.contains("AND")&& fragcondition.contains("false"))
                                 finalconditionresult=false;
                             if(fragcondition.contains("OR")&& fragcondition.contains("true"))
                                 finalconditionresult=true;
                             else if(!fragcondition.contains("AND")&& !fragcondition.contains("OR"))
                             {
                                 if(fragcondition.equalsIgnoreCase("true")||fragcondition.equalsIgnoreCase("TRUE"))
                                    finalconditionresult=true;
                                 else
                                    finalconditionresult=false;
                             }
                             if(finalconditionresult)
                             {
                                 CmplxMap.put(String.valueOf(FragmentOperationVarMap.get(iRuleID)),"");
                             }
                        }
                        if (cCount > 0) {
                            LinkedHashMap valmap = new LinkedHashMap();
                            ArrayList mapvalues;
                            for (int k = 0; cCount > k; k++)
                            {
                                attrib = (String[]) cmplxattribs.get(k);
                                allAttrib = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
								//WFS_8.0_084
								if (!name.equalsIgnoreCase("") && !attrib[1].equalsIgnoreCase(name))
                                {
                                    continue;
                                }
                                if(name.equalsIgnoreCase("") && (CmplxMap.size()>0) && !CmplxMap.containsKey(attrib[1]))
                                    continue;
                                //Check added for Bug 39661 .
                                if(name.equalsIgnoreCase("") && (CmplxMap.size()==0) && fragmentVariables.contains(attrib[1])){
                                	continue;
                                }
                                LinkedHashMap qryRelationMap = new LinkedHashMap(relationMap);
                              //  WFSUtil.printOut(engine,"new relation map" + qryRelationMap);
                                LinkedHashMap qryMemberMap = new LinkedHashMap((LinkedHashMap) memberMap.get((allAttrib.getName()).toUpperCase()));
                              //  WFSUtil.printOut(engine,"new member map" + qryMemberMap);
                                valmap.put((allAttrib.getName()).toUpperCase(), qryMemberMap);
                             //   WFSUtil.printOut(engine,"map before method " + valmap);
                                setValueInMap(con, dbType, cmplxQry, allAttrib, allAttrib.getName(), valmap, qryRelationMap, tablename, engine,batchInfo);
                             //   WFSUtil.printOut(engine,"map after method" + valmap);
                                WFFieldValue wffieldvalue = new WFFieldValue(allAttrib.getVariableId(), allAttrib.getVarFieldId(), allAttrib.getName(), "", allAttrib.getWfType(), allAttrib.getScope(), allAttrib.getLength(), allAttrib.getPrecison(), allAttrib.getParentInfo(),allAttrib.getIsView());
                                wffieldvalue.setRightsInfo(allAttrib.getRightsInfo());
                                setValue(allAttrib, wffieldvalue, valmap);
                                if (ps) {
                                    attributes.put(attrib[1].toUpperCase(), wffieldvalue);
                                } else {
                                    valuemap.put(allAttrib.getVariableId() + string21 + allAttrib.getVarFieldId(), wffieldvalue);
                                }
                             //   WFSUtil.printOut(engine,"final map is" + valuemap);
                            }
                        }

                        Iterator itr3 = valuemap.entrySet().iterator();
                        fetchAttributeProperty = !userDefVarFlag.equalsIgnoreCase("X");
                        while (itr3.hasNext()) {
                            Map.Entry entries = (Map.Entry) itr3.next();
                            WFFieldValue fieldValue = (WFFieldValue) entries.getValue();
                            String fieldName = fieldValue.getName();                 
                            if (fieldName.equals("TimeElapsedToFetchQueueData") || fieldName.equals("TimeElapsedToFetchExtData") || fieldName.equals("TimeElapsedToFetchCmplxQueData") || fieldName.equals("TimeElapsedToFetchCmplxExtData")) {
                                if (fieldName.equals("TimeElapsedToFetchQueueData")) {
                                    timeElapsedForQueueData = (String) fieldValue.getValues().get(0);
                                }
                                if (fieldName.equals("TimeElapsedToFetchExtData")) {
                                    timeElapsedForExtData = (String) fieldValue.getValues().get(0);
                                }
                                if (fieldName.equals("TimeElapsedToFetchCmplxQueData")) {
                                    timeElapsedForCmplxQueData = (String) fieldValue.getValues().get(0);
                                }
                                if (fieldName.equals("TimeElapsedToFetchCmplxExtData")) {
                                    timeElapsedForCmplxExtData = (String) fieldValue.getValues().get(0);
                                }
                            } else {
                            fieldValue.serializeAsXML(doc, doc.getDocumentElement(),engine, fetchAttributeProperty);
                            }
                        }
                        xml.append(WFXMLUtil.removeXMLHeader(doc, engine));
                    } /*else {
                        boolean success = false;
                        boolean complexflag = false;
                        String queryTable = "";

                        ListIterator iter = queattribs.listIterator();

                        retrCount = 1;
                        while (iter.hasNext()) {
                            attrib = (String[]) iter.next();
                            allAttrib = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
                            if (!attrib[1].equalsIgnoreCase(name)) {
                                continue;
                            }
                            success = true;
                            queryTable = " queueDatatable ";
                            queryTable = wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
                                    : queryTable;
                            queryTable = "Select " + attrib[4] + " from " + queryTable + " where ProcessInstanceId=? and " + "WorkItemId=" + workItemID;
                            break;
                        }
                        WFSUtil.printOut("[in else][queue variable] " + queryTable);
                        if (!success) {
                            iter = extattribs.listIterator();
                            tempStr = "";
                            while (iter.hasNext()) {
                                attrib = (String[]) iter.next();
                                allAttrib = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
                                if (!attrib[1].equalsIgnoreCase(name)) { //if (attrib[0].equalsIgnoreCase(name))	//Ashish modified condition (added not) WSE_5.0.1_PRDP_001

                                    continue;
                                }
                                success = true;
                                queryTable = tablename;
                                queryTable = "Select " + attrib[4] + " from " + queryTable + "," + (wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
                                        : " QueueDataTable ") + " where ProcessInstanceId=? and WorkItemId=" +
                                        workItemID;

                                st = new StringTokenizer(keybuffer.toString(), "#", true);
                                int i = 0;
                                while (st.hasMoreTokens()) {
                                    tempStr = st.nextToken();
                                    if (!tempStr.equals("#")) {
                                        queryTable += " and VAR_REC_" + (i + 1) + "=" + tempStr;
                                    } else {
                                        i++;
                                    }
                                }
                                break;
                            }
                            WFSUtil.printOut("[in else][external variable] " + queryTable);
                        }
                        if (!success) {
                            for (int i = 0; i < WFSConstant.qdmattribs.length; i++) {
                                attrib = WFSConstant.qdmattribs[i];
                                allAttrib = (WFFieldInfo) cachemap.get(attrib[0].toUpperCase());
                                /* Bugzilla Bug 896, ArrayIndexOutOfRange, 23/05/2007 - Ruhi Hira 
                                if (!attrib[0].equalsIgnoreCase(name)) {
                                    continue;
                                }
                                success = true;
                                queryTable = " queueDatatable ";
                                queryTable = wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
                                        : queryTable;
                                queryTable = "Select " + attrib[0] + " from " + queryTable + " where ProcessInstanceId=? and " + "WorkItemId=" + workItemID;
                                break;
                            }
                            WFSUtil.printOut("[in else][qdmattribs] " + queryTable);
                        }
                        if (!success) {
                            for (int i = 0; i < WFSConstant.prcattribs.length; i++) {
                                attrib = WFSConstant.prcattribs[i];
                                allAttrib = (WFFieldInfo) cachemap.get(attrib[0].toUpperCase());
                                if (!attrib[0].equalsIgnoreCase(name)) {
                                    continue;
                                }
                                success = true;
                                queryTable = " ProcessInstanceTable ";
                                queryTable = wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
                                        : queryTable;
                                queryTable = "Select " + attrib[0] + " from " + queryTable + " where ProcessInstanceId=?";
                                break;
                            }
                            WFSUtil.printOut("[in else][prcattribs] " + queryTable);
                        }
                        if (!success) {
                            for (int i = 0; i < WFSConstant.wklattribs.length; i++) {
                                attrib = WFSConstant.wklattribs[i];
                                allAttrib = (WFFieldInfo) cachemap.get(attrib[0].toUpperCase());
                                if (!attrib[0].equalsIgnoreCase(name)) {
                                    continue;
                                }
                                success = true;
                                queryTable = wlisttable;
                                queryTable = wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
                                        : queryTable;
                                queryTable = "Select " + attrib[0] + " from " + queryTable + " where ProcessInstanceId=? and " + "WorkItemId=" + workItemID;
                                break;
                            }
                            WFSUtil.printOut("[in else][wklattribs] " + queryTable);
                        }
                        //change for arrays and complex variables//
                        if (!success) {
                            iter = arrayattribs.listIterator();
							String ignoreSuffix = getFetchSuffixStr(dbType,1,WFSConstant.QUERY_STR_AND).toUpperCase();
							int iPosSuffix = 0;
                            while (iter.hasNext()) {
                                attrib = (String[]) iter.next();
                                allAttrib = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
                                if (!attrib[1].equalsIgnoreCase(name)) { //if (attrib[0].equalsIgnoreCase(name))	//Ashish modified condition (added not) WSE_5.0.1_PRDP_001

                                    continue;
                                }
                                success = true;
                                StringBuffer str = new StringBuffer((String) arrayQry.get(attrib[1].toUpperCase()));
                                String qry = str.toString();
                                ArrayList relationstr = new ArrayList();
                                ArrayList relationval = new ArrayList();
								if (!ignoreSuffix.equalsIgnoreCase("")){
									iPosSuffix = qry.indexOf(ignoreSuffix);
									if (iPosSuffix != -1){	//Bugzilla Bug 13084
										qry = qry.substring(0, iPosSuffix);
									}
								}
                                while (qry.indexOf("=") != -1) {
                                    if (qry.indexOf(" AND ") != -1) {
                                        relationstr.add(qry.substring(qry.indexOf("=") + 1, qry.indexOf(" AND ")));
                                        qry = qry.substring(qry.indexOf(" AND ") + 1);
                                    } else {
                                        relationstr.add(qry.substring(qry.indexOf("=") + 1));
                                        qry = qry.substring(qry.indexOf("=") + 1);
                                    }
                                }

                                ListIterator itr = relationstr.listIterator();
                                String val = "";
                                boolean flag = false;
                                while (itr.hasNext()) {
                                    String tmpstr = (String) itr.next();
                                    StringBuffer tmp = new StringBuffer(attrib[1] + ":");
                                    if (!tmpstr.equals("1")) {

                                        tmp.append(tmpstr.replace('.', '#')); //structurename:tablename#columname

                                        WFSUtil.printOut("key to get the relation value" + tmp.toString());
                                        val = (String) relationMap.get(tmp.toString().toUpperCase());
                                        if (val != null) {
                                            str = str.replace(str.indexOf(tmpstr), tmpstr.length(), val);
                                        } else {
                                            flag = true;
                                        }
                                    }

                                }
                                if (flag) {
                                    str = str.replace(str.indexOf("FROM "), str.indexOf("FROM ") + 5, "FROM " + ((String) relationstr.get(0)).substring(0, ((String) relationstr.get(0)).indexOf(".")) + ",");

                                }
                                WFSUtil.printOut("[in else][array attrib] " + str.toString());
                                queryTable = str.toString();
                                break;
                            }
                        }
                        //@@ complex structure fetch to be supported in next phase as per discussion with ashish sir- shweta tyagi
						/*if (!success) {
                        iter = cmplxattribs.listIterator();
                        while (iter.hasNext()) {
                        attrib = (String[]) iter.next();
                        allAttrib = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
                        if (!attrib[1].equalsIgnoreCase(name)) { //if (attrib[0].equalsIgnoreCase(name))	//Ashish modified condition (added not) WSE_5.0.1_PRDP_001
                        continue;
                        }
                        success = true;
                        LinkedHashMap valmap = new LinkedHashMap();
                        allAttrib  = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
                        LinkedHashMap qryRelationMap = new LinkedHashMap(relationMap);
                        WFSUtil.printOut("[in else] new relation map"+qryRelationMap);
                        LinkedHashMap qryMemberMap = new LinkedHashMap((LinkedHashMap) memberMap.get(allAttrib.getVariableId()+"#"+allAttrib.getVarFieldId()));
                        WFSUtil.printOut("[in else] new member map"+qryMemberMap);
                        valmap.put(allAttrib.getVariableId()+"#"+allAttrib.getVarFieldId(),qryMemberMap);
                        WFSUtil.printOut("[in else] map before method "+valmap);
                        setValueInMap(con, dbType, cmplxQry, allAttrib, allAttrib.getName(), valmap, qryRelationMap, tablename);
                        WFSUtil.printOut("[in else] map after method"+valmap);
                        WFFieldValue wffieldvalue = new WFFieldValue(allAttrib.getVariableId(), allAttrib.getVarFieldId(), allAttrib.getName(),"" , allAttrib.getWfType(), allAttrib.getScope(), allAttrib.getLength(), allAttrib.getPrecison(), allAttrib.getParentInfo());
                        setValue(allAttrib, wffieldvalue, valmap);
                        WFSUtil.printOut("[in else] list of maps"+wffieldvalue.getListOfMaps());
                        xml = xml+wffieldvalue.getXml();
                        xml = xml+"</Attributes>";
                        WFSUtil.printOut("output xml in else"+xml);
                        complexflag = true;
                        break;
                        }
                        }
                        if (success && !complexflag) {
                            values = new ArrayList();
                            pstmt = con.prepareStatement(queryTable);
                            WFSUtil.printOut(procInstID);
                            //WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
                            pstmt.execute();
                            rs = pstmt.getResultSet();
                            ResultSetMetaData rsmd1 = pstmt.getMetaData();

                            while (rs != null && rs.next()) {
                                //Changed for nText support Bug Id WFS_8.0_014
                                int iColumnType = rsmd1.getColumnType(1);
                                String strColumnName = rsmd1.getColumnName(1);
                                String strValue = "";
                                if (JDBCTYPE_TO_WFSTYPE(iColumnType) == WFSConstant.WF_NTEXT) {
                                    Object[] obj = getBIGData(con, rs, strColumnName, dbType, DatabaseTransactionServer.charSet);
                                    strValue = (String) obj[0];
                                } else {
                                    strValue = rs.getString(1);
                                }
                                if (strValue != null) {
                                    strValue = strValue.trim();
                                }
                                values.add(strValue);
                            }
                            WFSUtil.printOut("[in else printing values]" + values);

                            WFFieldValue wffieldvalue = null;
                            wffieldvalue = new WFFieldValue(allAttrib.getVariableId(), allAttrib.getVarFieldId(), allAttrib.getName(), values, allAttrib.getWfType(), allAttrib.getScope(), allAttrib.getLength(), allAttrib.getPrecison(), "");
                            wffieldvalue.serializeAsXML(doc, doc.getDocumentElement());
                            xml.append(WFXMLUtil.removeXMLHeader(doc));
                            rs.close();
                            rs = null;
                            pstmt.close();
                            pstmt = null;
                        } else {
                            mainCode = WFSError.WM_INVALID_ATTRIBUTE;
                            subCode = 0;
                            subject = WFSErrorMsg.getMessage(mainCode);
                            descr = WFSErrorMsg.getMessage(subCode);
                            errType = WFSError.WF_TMP;
                        }
                    }*/
                    tempXml.append(xml.toString());
                    tempXml.append(gen.writeValueOf("TimeElapsedToFetchQueueData", timeElapsedForQueueData));
                    tempXml.append(gen.writeValueOf("TimeElapsedToFetchExternalData", timeElapsedForExtData));
                    tempXml.append(gen.writeValueOf("TimeElapsedToFetchCmplxExtData", timeElapsedForCmplxExtData));
                    tempXml.append(gen.writeValueOf("TimeElapsedToFetchCmplxQueData", timeElapsedForCmplxQueData));
                   
                    tempXml.append(gen.writeValueOf("RetrievedCount", String.valueOf(retrCount)));
                    tempXml.append(gen.writeValueOf("Count", String.valueOf(retrCount)));
                }
            } else {
                printOut(engine,"[fectAttributesExt] ProcessInstanceId 9612 >>"+ procInstID);
                mainCode = WFSError.WM_INVALID_WORKITEM;
                subCode = 0;
                subject = WFSErrorMsg.getMessage(mainCode);
                descr = WFSErrorMsg.getMessage(subCode);
                errType = WFSError.WF_TMP;
            }
        } catch (SQLException e) {
            printErr(engine, "", e);
            mainCode = WFSError.WM_INVALID_FILTER;
            subCode = WFSError.WFS_SQL;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_FAT;
            if (e.getErrorCode() == 0) {
                if (e.getSQLState().equalsIgnoreCase("08S01")) {
                    descr = (new JTSSQLError(e.getSQLState())).getMessage() + "(SQL State : " +
                            e.getSQLState() + ")";
                }
            } else {
                descr = e.getMessage();
            }
        } catch (NumberFormatException e) {
            printErr(engine, "", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_ILP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch (NullPointerException e) {
            printErr(engine, "", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_SYS;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch (Exception e) {
            printErr(engine, "", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch (Error e) {
            printErr(engine, "", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }

            } catch (Exception e) {
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }

            } catch (Exception e) {
            }
            

        }
            if (mainCode != 0) {
                throw new WFSException(mainCode, subCode, errType, subject, descr);
            }
        if (ps) {
            return attributes;
        } else {
            return tempXml.toString();
        }
    }
	    public static Object fetchAttributesExt(Connection con, int iProcDefId, int iActId, String procInstID, int workItemID,
	            String filter, String engine, int dbType, String name,
	            boolean ps, boolean cuser, boolean internalServerFlag, int iProcVarId,int sessionId,int userId,boolean printQueryFlag) throws JTSException, WFSException {

	        StringBuffer tempXml = null;
	        LinkedHashMap attributes = null;
	        PreparedStatement pstmt = null;
	        int mainCode = 0;
	        int subCode = 0;
	        String subject = null;
	        String descr = null;
	        String errType = WFSError.WF_TMP;
	        ResultSet rs = null;
	        ResultSetMetaData rsmd = null;

	        try {
	            tempXml = new StringBuffer(1000);
	            int retrCount = 0;
	            int qCount = 0;
	            int iCount = 0;
	            int aCount = 0;
	            int cCount = 0;
	            int extObj = 0;

	            ArrayList queattribs;
	            ArrayList extattribs;
	            ArrayList cmplxattribs;
	            ArrayList arrayattribs;

	            String[] attrib = new String[10];
	            String tablename = "";
	            String wlisttable = "";

	            StringBuffer quebuffer;
	            StringBuffer extbuffer;
	            StringBuffer arraybuffer;
	            StringBuffer cmplxquebuffer;
	            StringBuffer cmplxextbuffer;
	            String strextbuffer;
	            StringBuffer keybuffer;
	            String rightsInfo;

	            String tempStr = "";

	            int procDefId = 0;
	            int activityID = 0;
				int procVarId = 0;
				
				String queryString;
				ArrayList parameters = new ArrayList();
				
	            /*if (!cuser) {
				//Process Variant Support Changes
	                pstmt = con.prepareStatement(" Select ProcessDefID , ActivityID, ProcessVariantId from Workinprocesstable where ProcessInstanceID = ? and WorkItemID = ? ");
	                WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
	                pstmt.setInt(2, workItemID);
	                pstmt.execute();
	                rs = pstmt.getResultSet();
	                if (rs.next()) {
	                    procDefId = rs.getInt(1);
	                    activityID = rs.getInt(2);
	                    procVarId = rs.getInt(3);
	                }
	                rs.close();
	                rs = null;
	                pstmt.close();
	                pstmt = null;
	                wlisttable = " Workinprocesstable ";
	            }
	            if (!cuser && procDefId == 0) {//Process Variant Support Changes
	                pstmt = con.prepareStatement(" Select ProcessDefID , ActivityID, ProcessVariantId from Worklisttable where ProcessInstanceID = ? and WorkItemID = ? ");
	                WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
	                pstmt.setInt(2, workItemID);
	                pstmt.execute();
	                rs = pstmt.getResultSet();
	                if (rs.next()) {
	                    procDefId = rs.getInt(1);
	                    activityID = rs.getInt(2);
						procVarId = rs.getInt(3);
	                }
	                rs.close();
	                rs = null;
	                pstmt.close();
	                pstmt = null;
	                wlisttable = " Worklisttable ";
	            }
	            if (!cuser && procDefId == 0) {//Process Variant Support Changes
	                pstmt = con.prepareStatement(" Select ProcessDefID , ActivityID, ProcessVariantId from Workdonetable where ProcessInstanceID = ? and WorkItemID = ? ");
	                WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
	                pstmt.setInt(2, workItemID);
	                pstmt.execute();
	                rs = pstmt.getResultSet();
	                if (rs.next()) {
	                    procDefId = rs.getInt(1);
	                    activityID = rs.getInt(2);
						procVarId = rs.getInt(3);
	                }
	                rs.close();
	                rs = null;
	                pstmt.close();
	                pstmt = null;
	                wlisttable = " Workdonetable ";
	            }
	            if (procDefId == 0) {
	                /** SrNo-8, Synchronous routing of workitems, removal of WorkDoneTable - Ruhi Hira */
	                /** 02/12/2008, Bugzilla Bug 6991, prorityLevel not set for u type user in setAttributeExt. - Ruhi Hira *-/
	                if ((internalServerFlag && ps) || (!ps)) {
	                    wlisttable = " WorkInProcessTable ";
	                } else {
	                    wlisttable = " WorkwithPStable ";
	                }
					//Process Variant Support Changes
	                pstmt = con.prepareStatement(" Select ProcessDefID , ActivityID, ProcessVariantId from " + wlisttable + " where ProcessInstanceID = ? and WorkItemID = ? ");
	                WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
	                pstmt.setInt(2, workItemID);
	                pstmt.execute();
	                rs = pstmt.getResultSet();
	                if (rs.next()) {
	                    procDefId = rs.getInt(1);
	                    activityID = rs.getInt(2);
						procVarId = rs.getInt(3);
	                }
	                rs.close();
	                rs = null;
	                pstmt.close();
	                pstmt = null;
	            }
	            if (!cuser && procDefId == 0) {
				//Process Variant Support Changes
	                pstmt = con.prepareStatement(" Select ProcessDefID , ActivityID, ProcessVariantId from Pendingworklisttable where ProcessInstanceID = ? and WorkItemID = ? ");
	                WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
	                pstmt.setInt(2, workItemID);
	                pstmt.execute();
	                rs = pstmt.getResultSet();
	                if (rs.next()) {
	                    procDefId = rs.getInt(1);
	                    activityID = rs.getInt(2);
						procVarId = rs.getInt(3);
	                }
	                rs.close();
	                rs = null;
	                pstmt.close();
	                pstmt = null;
	                wlisttable = " Pendingworklisttable ";
	            }*/
				
	            if(!cuser){
					queryString = " Select ProcessDefID , ActivityID, ProcessVariantId from WFInstrumentTable "+ WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceID = ? and WorkItemID = ? ";
					pstmt = con.prepareStatement(queryString);
	                WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
	                pstmt.setInt(2, workItemID);
					parameters.addAll(Arrays.asList(procInstID,workItemID));
	                //pstmt.execute();
					jdbcExecute(procInstID,sessionId,userId,queryString,pstmt,parameters,printQueryFlag,engine);
	                rs = pstmt.getResultSet();
	                if (rs.next()) {
	                    procDefId = rs.getInt(1);
	                    activityID = rs.getInt(2);
						procVarId = rs.getInt(3);
	                }
	                rs.close();
	                rs = null;
	                pstmt.close();
	                pstmt = null;
	                wlisttable = " WFInstrumentTable ";
				}
				if(cuser){
					queryString = " Select ProcessDefID , ActivityID, ProcessVariantId from WFInstrumentTable " + WFSUtil.getTableLockHintStr(dbType) + "  where ProcessInstanceID = ? and WorkItemID = ? and LockStatus = ?" ;
					pstmt = con.prepareStatement(queryString);
	                WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
	                pstmt.setInt(2, workItemID);
					WFSUtil.DB_SetString(3, "Y", pstmt, dbType);
					parameters = new ArrayList();
					parameters.addAll(Arrays.asList(procInstID,workItemID,"Y"));
	                //pstmt.execute();
					jdbcExecute(procInstID,sessionId,userId,queryString,pstmt,parameters,printQueryFlag,engine);
	                rs = pstmt.getResultSet();
	                if (rs.next()) {
	                    procDefId = rs.getInt(1);
	                    activityID = rs.getInt(2);
						procVarId = rs.getInt(3);
	                }
	                rs.close();
	                rs = null;
	                pstmt.close();
	                pstmt = null;
	                wlisttable = " WFInstrumentTable ";
				}
	            if (procDefId == 0) {
				//Process Variant Support Changes
					queryString = " Select ProcessDefID , ActivityID, ProcessVariantId from Queuehistorytable " + WFSUtil.getTableLockHintStr(dbType) + "  where ProcessInstanceID = ? and WorkItemID = ? " ;
	                pstmt = con.prepareStatement(queryString);
	                WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
	                pstmt.setInt(2, workItemID);
					parameters = new ArrayList();
					parameters.addAll(Arrays.asList(procInstID,workItemID));
	                //pstmt.execute();
					jdbcExecute(procInstID,sessionId,userId,queryString,pstmt,parameters,printQueryFlag,engine);
	                rs = pstmt.getResultSet();
	                if (rs.next()) {
	                    procDefId = rs.getInt(1);
	                    activityID = rs.getInt(2);
						procVarId = rs.getInt(3);
	                }
	                rs.close();
	                rs = null;
	                pstmt.close();
	                pstmt = null;
	                wlisttable = " Queuehistorytable ";
	            }

	            //
	            if (iActId > 0) {
	                procDefId = iProcDefId;
	                activityID = iActId;
	            }

	            if (procDefId != 0) {
	// Filter neeeds to be handled ??
	            	// Change for bug 40367 
	            	String keyToken = wlisttable.equalsIgnoreCase(" Queuehistorytable ")? ("QUEUEHISTORYTABLE"+string21)://"QUEUEDATATABLE#";
					("WFInstrumentTable"+string21);
	                StringTokenizer st = null;
	                int mapCount = 0;
	                WFVariabledef attribs;
	                // Change for bug 40367 starts
	                if(wlisttable.equalsIgnoreCase(" Queuehistorytable ")){
	                	printOut(engine,"VariableCacheHistory will be used..");
	                	
	                    attribs = (WFVariabledef) CachedObjectCollection.getReference().getCacheObject(con, engine, procDefId, WFSConstant.CACHE_CONST_VARIABLE_HISTORY, "" + (ps ? -1 : activityID) + string21 +procVarId).getData();
	                }
	                else{
	                	printOut(engine,"VariableCache will be used..");
	                attribs = (WFVariabledef) CachedObjectCollection.getReference().getCacheObject(con, engine, procDefId, WFSConstant.CACHE_CONST_Variable, "" + (ps ? -1 : activityID) + string21 + procVarId).getData();
	                }
	                // Change for bug 40367 ends

	                queattribs = attribs.getQueueVars();
	                extattribs = attribs.getExtVars();
	                arrayattribs = attribs.getArrayVars();
	                cmplxattribs = attribs.getCmplxVars();

	                quebuffer = attribs.getQueueString();
	                extbuffer = new StringBuffer(attribs.getExtString());
	                //Bug Id 5431
	                if (attribs.getCmplxQueString() != null) {
	                    cmplxquebuffer = new StringBuffer(attribs.getCmplxQueString().toString());
	                } else {
	                    cmplxquebuffer = attribs.getCmplxQueString();
	                }
	                if (attribs.getCmplxExtString() != null) {
	                    cmplxextbuffer = new StringBuffer(attribs.getCmplxExtString().toString());
	                } else {
	                    cmplxextbuffer = attribs.getCmplxExtString();
	                }
	                keybuffer = attribs.getKeyBuffer();
	                WFSUtil.printOut(engine,"query for queue variables" + quebuffer);
	                //WFSUtil.printOut(engine,"query for external variables" + extbuffer);
	                WFSUtil.printOut(engine,"query for relation variables" + cmplxquebuffer);
	                //WFSUtil.printOut(engine,"query for external relation variables" + cmplxextbuffer);
	                LinkedHashMap cachemap = attribs.getAttribMap();
	                LinkedHashMap valuemap = new LinkedHashMap();
	                LinkedHashMap arrayQry = attribs.getArrayQry();
	                LinkedHashMap cmplxQry = attribs.getCmplxQry();
					LinkedHashMap relationMap = null;
					if(attribs.getQryRelationMap() != null)
						relationMap = new LinkedHashMap(attribs.getQryRelationMap());
					else
						relationMap = new LinkedHashMap();
	                LinkedHashMap memberMap = attribs.getMemberMap();
	                WFFieldValue wfFieldValue = null;
	                WFFieldInfo allAttrib = null;
	                qCount = queattribs.size();
	                iCount = extattribs.size();
	                aCount = arrayattribs.size();
	                cCount = cmplxattribs.size();
	                retrCount = qCount + iCount + aCount + cCount + WFSConstant.qdmattribs.length +
                    (wlisttable.equalsIgnoreCase(" Queuehistorytable ") ? 0 : WFSConstant.qdmchildattribs.length) + 
                    WFSConstant.wklattribs.length + WFSConstant.prcattribs.length;
                    String value = "";
	                ArrayList values;
	                tablename = attribs.getExt_tablename();

	                if (retrCount > 0) {
	                    Document doc = WFXMLUtil.createDocumentWithRoot("Attributes");
	                    StringBuffer xml = new StringBuffer(100);

	                    if (iCount > 0) {
	                        st = new StringTokenizer(keybuffer.toString(), string21);
	                        mapCount = st.countTokens();
	                    }

	                    if (ps) {
	                        attributes = new LinkedHashMap(50);
	                    }
	                    int type;
	                    String colname = "";
						//WFS_8.0_084
	                    if (name != null) {
	                        WFSUtil.printOut(engine,"in if");

	                        pstmt = con.prepareStatement(quebuffer.toString() + WFSConstant.s_attribqdatam + (wlisttable.equalsIgnoreCase(" Queuehistorytable ") ? "" : WFSConstant.s_attribqdatachild) + " from " +
	                                (wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
	                                //: "Queuedatatable ") +
	                                : "WFInstrumentTable ") + WFSUtil.getTableLockHintStr(dbType) +
									" where ProcessInstanceId = ? and WorkItemId = ?");

	                        WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
	                        pstmt.setInt(2, workItemID);
	                        pstmt.execute();
	                        rs = pstmt.getResultSet();
	                        rsmd = pstmt.getMetaData();
	                        if (rs.next()) {
	                            int k = 0;
	                            for (k = 0; qCount > k; k++) {
	                                attrib = (String[]) queattribs.get(k);
	                                allAttrib = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
	                                //WFS_8.0_084
	                                value = rs.getString(k + 1);
	                                type = rsmd.getColumnType(k + 1);
	                                colname = rsmd.getColumnName(k + 1);
	                                //WFSUtil.printOut(engine,rsmd.getColumnName(k + 1) + "-->" + value);
	                                //printOut(engine,"key>>"+keyToken);
	                                //	 Change for bug 40367 
									if (relationMap != null && relationMap.containsKey((keyToken + colname).toUpperCase())) {
	                                    //WFSUtil.printOut("line num 4299 putting value for relation" + value);
	                                    values = new ArrayList();
	                                    //Bug Id 5128
										String strval=value;
	                                    if (strval != null) {
	                                        if (JDBCTYPE_TO_WFSTYPE(type) == WFSConstant.WF_NTEXT) {
	                                            Object[] obj = getBIGData(con, rs, colname, dbType, DatabaseTransactionServer.charSet);
	                                            strval = (String) obj[0];
	                                        } else {
	                                            strval = WFSUtil.TO_SQL(value.trim(), WFSUtil.JDBCTYPE_TO_WFSTYPE(type), dbType, true);
	                                        }
	                                    }
	                                    values.add(strval);
	                                    WFSUtil.printOut(engine,values);
	                                    // Change for bug 40367 
	                                    relationMap.put((keyToken + colname).toUpperCase(), values);
	                                }
									if (!name.equalsIgnoreCase("") && !attrib[1].equalsIgnoreCase(name))
	                                {
	                                    continue;
	                                }
	                                if (ps) {
	                                    if (attrib[3] == null) {
	                                        attributes.put(attrib[1].toUpperCase(), new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], value, Integer.parseInt(attrib[2]), 255, Integer.parseInt(attrib[8])));
	                                    } else {
	                                        attributes.put(attrib[1].toUpperCase(), new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], value, Integer.parseInt(attrib[2]), Integer.parseInt(attrib[3]), Integer.parseInt(attrib[8])));
	                                    }
	                                } else {
	                                    try {
	                                        if (attrib[7] != null && attrib[7].charAt(1) == '4') {
	                                            continue;
	                                        } //do not return the attribs that have access attrib as NULL



	                                    } catch (Exception ex) { //stringIndexOutOfBounds
	                                        //do nothing

	                                    }
	                                    // SrNo-1, Check for float value.. Bug rectified By PRD team ..
	                                    // has been checked in getXml method--shweta tyagi
										/*if (attrib[2].equals(String.valueOf(WFSConstant.WF_FLT))) {
	                                    value = gen.getfloatValue(value);
	                                    }
	                                     */
	                                    rightsInfo = attrib[7].substring(0, 2);
	                                    if (attrib[3] == null) {
	                                        wfFieldValue = new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], value, allAttrib.getWfType(), allAttrib.getScope(), 255, allAttrib.getPrecison()); //just identical to cache

	                                    } else {
	                                        wfFieldValue = new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], value, allAttrib.getWfType(), allAttrib.getScope(), Integer.parseInt(attrib[3]), allAttrib.getPrecison());
	                                    }
	                                    wfFieldValue.setRightsInfo(rightsInfo);
	                                    valuemap.put(Integer.parseInt(attrib[0]) + string21 + 0, wfFieldValue); //just identical to cache

	                                }
	                            }

	                            if (mapCount > 0) {
	                                while (st.hasMoreTokens()) {
	                                    int y = ++k;
	                                    tempStr = rs.getString(y);
	                                    colname = rsmd.getColumnName(y);
	                                    type = rsmd.getColumnType(y);

	                                    String tmptoken = "";
	                                    if (rs.wasNull()) {
	                                        tmptoken = st.nextToken();	//Bug Id 5431

	                                        extbuffer.append(tmptoken).append(" is null and ");
	                                        if (cmplxextbuffer != null) {
	                                            cmplxextbuffer.append(tmptoken).append(" is null and ");
	                                        }
	                                    } else {
	                                        tmptoken = st.nextToken();	//Bug Id 5431

	                                        extbuffer.append(tmptoken).append("=").append(WFSUtil.TO_STRING(
	                                                tempStr.trim(), true, dbType)).append(" and ");

	                                        if (cmplxextbuffer != null) {
	                                            cmplxextbuffer.append(tmptoken).append("=").append(
	                                                    WFSUtil.TO_STRING(tempStr.trim(), true, dbType)).append(" and ");
	                                        }
	                                    }
	                                    // Change for bug 40367 
	                                    if (relationMap != null && relationMap.containsKey((keyToken + colname).toUpperCase())) {
	                                        //WFSUtil.printOut("line num 4325 putting value for relation" + tempStr);
	                                        //Bug Id 5128
	                                        if (tempStr != null) {
	                                            if (JDBCTYPE_TO_WFSTYPE(type) == WFSConstant.WF_NTEXT) {
	                                                Object[] obj = getBIGData(con, rs, colname, dbType, DatabaseTransactionServer.charSet);
	                                                tempStr = (String) obj[0];
	                                            } else {
	                                                tempStr = WFSUtil.TO_SQL(tempStr.trim(), WFSUtil.JDBCTYPE_TO_WFSTYPE(type), dbType, true);
	                                            }
	                                        }
	                                        values = new ArrayList();
	                                        values.add(tempStr);
	                                        // Change for bug 40367 
	                                        relationMap.put((keyToken + colname).toUpperCase(), values);
	                                    }
	                                }
	                            }

	                            for (k = 0; WFSConstant.qdmattribs.length > k; k++) {
	                                attrib = WFSConstant.qdmattribs[k];
	                                allAttrib = (WFFieldInfo) (cachemap.get(attrib[0].toUpperCase()));
	                                //WFS_8.0_084
									if (!name.equalsIgnoreCase("") && !attrib[0].equalsIgnoreCase(name))
	                                {
	                                    continue;
	                                }
	                                if (allAttrib != null) {
	                                    value = rs.getString(qCount + mapCount + k + 1);
	                                    if (ps) {
	                                        attributes.put(attrib[0].toUpperCase(), new WFFieldValue(allAttrib.getVariableId(), attrib[0], value, Integer.parseInt(attrib[1]), allAttrib.getLength(), allAttrib.getPrecison()));
	                                    } else {
	                                        rightsInfo = attrib[1].substring(0, 2);
	                                        wfFieldValue = new WFFieldValue(allAttrib.getVariableId(), attrib[0], value, allAttrib.getWfType(), allAttrib.getLength(), allAttrib.getPrecison());
	                                        wfFieldValue.setRightsInfo(rightsInfo);
	                                        valuemap.put((allAttrib.getVariableId() + string21 + 0), wfFieldValue);
	                                    }
	                                }
	                            }
	                            if(!wlisttable.equalsIgnoreCase(" Queuehistorytable "))
	                            {
	                                for (k = 0; WFSConstant.qdmchildattribs.length > k; k++) {
	                                    attrib = WFSConstant.qdmchildattribs[k];
	                                    if (!name.equalsIgnoreCase("") && !attrib[0].equalsIgnoreCase(name))
	                                    {
	                                        continue;
	                                    }
	                                    value = rs.getString(qCount + mapCount + WFSConstant.qdmattribs.length + k + 1);
	                                    printOut(engine, "Sweta---> Variable : " + attrib[0] + " Value : " + value);
	                                    if (ps) {
	                                        attributes.put(attrib[0].toUpperCase(), new WFFieldValue(Integer.parseInt(attrib[3]), attrib[0], value, Integer.parseInt(attrib[1]), 255, 0));
	                                    } else {
	                                        rightsInfo = attrib[1].substring(0, 2);
	                                        wfFieldValue = new WFFieldValue(Integer.parseInt(attrib[3]), attrib[0], value, Integer.parseInt(attrib[1]), 255, 0);
	                                        wfFieldValue.setRightsInfo(rightsInfo);
	                                        valuemap.put((attrib[3] + string21 + 0), wfFieldValue);
	                                    }
	                                }
	                            }

	                            rs.close();
	                            rs = null;
	                            pstmt.close();
	                            pstmt = null;

	                            pstmt = con.prepareStatement(WFSConstant.s_attribpinlst +  getTableLockHintStr(dbType) + " where ProcessInstanceId = ?");
	                            WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
	                            pstmt.execute();
	                            rs = pstmt.getResultSet();
	                            if (rs.next()) {
	                                for (k = 0; WFSConstant.prcattribs.length > k; k++) {
	                                    attrib = WFSConstant.prcattribs[k];
	                                    allAttrib = (WFFieldInfo) (cachemap.get(attrib[0].toUpperCase()));
										//WFS_8.0_084
										if (!name.equalsIgnoreCase("") && !attrib[0].equalsIgnoreCase(name))
	                                    {
	                                        continue;
	                                    }
	                                    if (allAttrib != null) {
	                                        value = rs.getString(k + 1);
	                                        if (ps) {
	                                            attributes.put(attrib[0].toUpperCase(), new WFFieldValue(allAttrib.getVariableId(), attrib[0], value, Integer.parseInt(attrib[1]), allAttrib.getLength(), allAttrib.getPrecison()));
	                                        } else {
	                                            rightsInfo = attrib[1].substring(0, 2);
	                                            wfFieldValue = new WFFieldValue(allAttrib.getVariableId(), attrib[0], value, allAttrib.getWfType(), allAttrib.getLength(), allAttrib.getPrecison());
	                                            wfFieldValue.setRightsInfo(rightsInfo);
	                                            valuemap.put(allAttrib.getVariableId() + string21 + 0, wfFieldValue);
	                                        }
	                                    }
	                                }
	                            }else{
									pstmt = con.prepareStatement(WFSConstant.s_attribqueht + " where ProcessInstanceId = ?");
									WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
									pstmt.execute();
									rs = pstmt.getResultSet();
									if (rs.next()) {
										for (k = 0; WFSConstant.prcattribs.length > k; k++) {
											attrib = WFSConstant.prcattribs[k];
											allAttrib = (WFFieldInfo) (cachemap.get(attrib[0].toUpperCase()));
										   
											//WFS_8.0_084
											if (!name.equalsIgnoreCase("") && !attrib[0].equalsIgnoreCase(name)){
												
												continue;
											}
											if (allAttrib != null) {
												value = rs.getString(k + 1);
												if (ps) {
													attributes.put(attrib[0].toUpperCase(), new WFFieldValue(allAttrib.getVariableId(), attrib[0], value, Integer.parseInt(attrib[1]), allAttrib.getLength(), allAttrib.getPrecison()));
												} else {
													rightsInfo = attrib[1].substring(0, 2);
													wfFieldValue = new WFFieldValue(allAttrib.getVariableId(), attrib[0], value, allAttrib.getWfType(), allAttrib.getLength(), allAttrib.getPrecison());
													wfFieldValue.setRightsInfo(rightsInfo);
													valuemap.put(allAttrib.getVariableId() + string21 + 0, wfFieldValue);
												}
											}
										}
									}
	                            }
								
	                            rs.close();
	                            rs = null;
	                            pstmt.close();
	                            pstmt = null;

	                            pstmt = con.prepareStatement((wlisttable.trim().equalsIgnoreCase("Queuehistorytable")? WFSConstant.s_attribwrklst.replaceAll("expectedWorkITemDelay","EXPECTEDWORKITEMDELAYTIME") : WFSConstant.s_attribwrklst) + WFSUtil.getDate(dbType) + ",QueueName,QueueType from " + wlisttable +WFSUtil.getTableLockHintStr(dbType)+
	                                    " where ProcessInstanceId = ? and WorkitemId = ? ");//WFS_8.0_081
	                            WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
	                            pstmt.setInt(2, workItemID);
	                            pstmt.execute();
	                            rs = pstmt.getResultSet();
	                            if (rs.next()) {
	                                for (k = 0; WFSConstant.wklattribs.length > k; k++) {
	                                    attrib = WFSConstant.wklattribs[k];
	                                    allAttrib = (WFFieldInfo) (cachemap.get(attrib[0].toUpperCase()));
										//WFS_8.0_084
										if (!name.equalsIgnoreCase("") && !attrib[0].equalsIgnoreCase(name))
	                                    {
	                                        continue;
	                                    }
	                                    if (allAttrib != null) {
	                                        value = rs.getString(k + 1);
	                                        if (ps) {
	                                            attributes.put(attrib[0].toUpperCase(), new WFFieldValue(allAttrib.getVariableId(), attrib[0], value, Integer.parseInt(attrib[1]), allAttrib.getLength(), allAttrib.getPrecison()));
	                                        } else {
	                                            rightsInfo = attrib[1].substring(0, 2);
	                                            wfFieldValue = new WFFieldValue(allAttrib.getVariableId(), attrib[0], value, allAttrib.getWfType(), allAttrib.getLength(), allAttrib.getPrecison());
	                                            wfFieldValue.setRightsInfo(rightsInfo);
	                                            valuemap.put((allAttrib.getVariableId() + string21 + 0).toUpperCase(), wfFieldValue);
	                                        }
	                                    }
	                                }
	                                value = rs.getString(++k);
	                                wfFieldValue = new WFFieldValue(45, "QueueName", value, WFSConstant.WF_STR, '\0', 255, 0);
	                                wfFieldValue.setRightsInfo("32");
	                                valuemap.put(45 + string21 + 0, wfFieldValue); //@@check

	                                value = rs.getString(++k);
	                                wfFieldValue = new WFFieldValue(44, "QueueType", value, WFSConstant.WF_STR, '\0', 255, 0);
	                                wfFieldValue.setRightsInfo("32");
	                                valuemap.put(44 + string21 + 0, wfFieldValue); //@@check

	                                retrCount += 2;
	                            }
	                            rs.close();
	                            rs = null;
	                            pstmt.close();
	                            pstmt = null;

	                            if (iCount > 0) {
	                                pstmt = con.prepareStatement(extbuffer.append(" 1 = 1 ").toString());
	                                pstmt.execute();
	                                rs = pstmt.getResultSet();
	                                rsmd = pstmt.getMetaData();
	                                if (rs.next()) {
	                                    for (k = 0; iCount > k; k++) {
	                                        attrib = (String[]) extattribs.get(k);
	                                        allAttrib = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
											//WFS_8.0_084
											colname = rsmd.getColumnName(k + 1);
	                                        value = rs.getString(k + 1);
	                                        type = rsmd.getColumnType(k + 1);

											if (relationMap != null && relationMap.containsKey((tablename + string21 + colname).toUpperCase())) {
	                                            //WFSUtil.printOut("line 4455 putting value for relation" + value);
	                                            values = new ArrayList();
	                                            //Bug Id 5128
												String strval=value;
	                                            if (strval != null) {
	                                                if (JDBCTYPE_TO_WFSTYPE(type) == WFSConstant.WF_NTEXT) {
	                                                    Object[] obj = getBIGData(con, rs, colname, dbType, DatabaseTransactionServer.charSet);
	                                                    strval = (String) obj[0];
	                                                } else {
	                                                    strval = WFSUtil.TO_SQL(value.trim(), WFSUtil.JDBCTYPE_TO_WFSTYPE(type), dbType, true);
	                                                }
	                                            }
	                                            values.add(strval);
	                                            //WFSUtil.printOut(values);
	                                            relationMap.put((tablename + string21 + colname).toUpperCase(), values);
	                                        }
											if (!name.equalsIgnoreCase("") && !attrib[1].equalsIgnoreCase(name))
	                                        {
	                                            continue;
	                                        }
	                                        if (ps) {
	                                            if (attrib[3] == null) {
	                                                attributes.put(attrib[1].toUpperCase(), new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], value, Integer.parseInt(attrib[2]), 1024, Integer.parseInt(attrib[8])));
	                                            } else {
	                                                attributes.put(attrib[1].toUpperCase(), new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], value, Integer.parseInt(attrib[2]), Integer.parseInt(attrib[3]), Integer.parseInt(attrib[8])));
	                                            } //checkout

	                                        } else {
	                                            try {
	                                                if (attrib[7] != null && attrib[7].charAt(1) == '4') {
	                                                    continue;
	                                                } //do not return the attribs that have access attrib as NULL

	                                            } catch (Exception ex) { //stringIndexOutOfBounds
	                                                //do nothing

	                                            }
	                                            if (allAttrib != null) {
	                                                // SrNo-1, Check for float value. Bug rectified By PRD team ..
	                                                // has been checked in getXml method--shweta tyagi
														/*if (attrib[2].equals(String.valueOf(WFSConstant.WF_FLT))) {
	                                                value = gen.getfloatValue(value);
	                                                }*/
	                                                rightsInfo = attrib[7].substring(0, 2);
	                                                if (attrib[3] == null) {
	                                                    wfFieldValue = new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], value, allAttrib.getWfType(), 1024, allAttrib.getPrecison());
	                                                } else {
	                                                    wfFieldValue = new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], value, allAttrib.getWfType(), Integer.parseInt(attrib[3]), allAttrib.getPrecison());
	                                                }
	                                                wfFieldValue.setRightsInfo(rightsInfo);
	                                                valuemap.put(allAttrib.getVariableId() + string21 + 0, wfFieldValue);
	                                            }
	                                        }
	                                        //WFSUtil.printOut("line num 4453" + (tablename + "#" + colname).toUpperCase());
	                                    }
	                                } else {
	                                    for (k = 0; iCount > k; k++) {
	                                        attrib = (String[]) extattribs.get(k);
	                                        allAttrib = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
											//WFS_8.0_084
											if (!name.equalsIgnoreCase("") && !attrib[1].equalsIgnoreCase(name))
	                                        {
	                                            continue;
	                                        }

	                                        if (ps) {
	                                            if (attrib[3] == null) {
	                                                attributes.put(attrib[1].toUpperCase(), new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], "", Integer.parseInt(attrib[2]), 1024, Integer.parseInt(attrib[8])));
	                                            } else {
	                                                attributes.put(attrib[1].toUpperCase(), new WFFieldValue(Integer.parseInt(attrib[0]), attrib[1], "", Integer.parseInt(attrib[2]), Integer.parseInt(attrib[3]), Integer.parseInt(attrib[8])));
	                                            }
	                                        } else {
	                                            if (allAttrib != null) {
	                                                // SrNo-1, Check for float value. Bug rectified By PRD team ..
	                                                // has been checked in getXml method--shweta tyagi
														/*if (attrib[2].equals(String.valueOf(WFSConstant.WF_FLT))) {
	                                                value = gen.getfloatValue(value);
	                                                }*/
	                                                rightsInfo = attrib[7].substring(0, 2);
	                                                if (attrib[3] == null) {
	                                                    wfFieldValue = new WFFieldValue(allAttrib.getVariableId(), attrib[1], "", allAttrib.getWfType(), 1024, allAttrib.getPrecison());
	                                                } else {
	                                                    wfFieldValue = new WFFieldValue(allAttrib.getVariableId(), attrib[1], "", allAttrib.getWfType(), Integer.parseInt(attrib[3]), allAttrib.getPrecison());
	                                                }
	                                                wfFieldValue.setRightsInfo(rightsInfo);
	                                                valuemap.put(allAttrib.getVariableId() + string21 + 0, wfFieldValue);
	                                            }
	                                        }
	                                    }
	                                }
	                            }

	                        } else {
	                            rs.close();
	                            rs = null;
	                            pstmt.close();
	                            pstmt = null;
	                        }
	                        /*added to ensure that relation columns have been selected before querying
	                        for arrays and complex - shweta tyagi*/
	                        if (aCount > 0 || cCount > 0) {
	                            String tmptable = "";
	                            String tmpcol = "";
	                            String tmpcmplx = "";

	                            if (cmplxquebuffer != null) {
	                                pstmt = con.prepareStatement(cmplxquebuffer.toString() + "null from " +
	                                        (wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
	                                        //: "Queuedatatable ") + " where ProcessInstanceId = ? and WorkItemId = ?");
											: "WFInstrumentTable ") + " where ProcessInstanceId = ? and WorkItemId = ?");
	                                WFSUtil.DB_SetString(1, procInstID.trim(), pstmt, dbType);
	                                pstmt.setInt(2, workItemID);
	                                pstmt.execute();
	                                rs = pstmt.getResultSet();
	                                rsmd = pstmt.getMetaData();
	                                int ctr = rsmd.getColumnCount();
	                                int i = 1;

	                                if (rs != null && rs.next()) {
	                                    while (ctr > 0) {
	                                        type = rsmd.getColumnType(i);
	                                        value = rs.getString(i);
	                                        String strColumnName = rsmd.getColumnName(i);
	                                        //Bug Id 5128
											String strval=value;
	                                        if (strval != null) {
	                                            if (JDBCTYPE_TO_WFSTYPE(type) == WFSConstant.WF_NTEXT) {
	                                                Object[] obj = getBIGData(con, rs, strColumnName, dbType, DatabaseTransactionServer.charSet);
	                                                strval = (String) obj[0];
	                                            } else {
	                                                strval =WFSUtil.TO_SQL(value.trim(), WFSUtil.JDBCTYPE_TO_WFSTYPE(type), dbType, true);
	                                            }
	                                        }
	                                        values = new ArrayList();
	                                        values.add(strval);
	                                        tmpcol = rsmd.getColumnName(i);
	                                        if (!tmpcol.equals("")) {
	                                        	// Change for bug 40367 
	                                       		relationMap.put((keyToken + tmpcol).toUpperCase(), values);
	                                        }

	                                        i++;
	                                        ctr--;
	                                    }
	                                }
	                                rs.close();
	                                rs = null;
	                                pstmt.close();
	                                pstmt = null;
	                            }
	                            if (cmplxextbuffer != null) {

	                                pstmt = con.prepareStatement(cmplxextbuffer.append("1=1").toString());
	                                pstmt.execute();
	                                rs = pstmt.getResultSet();
	                                rsmd = pstmt.getMetaData();
	                                int ctr = rsmd.getColumnCount();
	                                int i = 1;

	                                if (rs != null && rs.next()) {
	                                    while (ctr > 0) {
	                                        type = rsmd.getColumnType(i);
	                                        String strColumnName = rsmd.getColumnName(i);
	                                        value = rs.getString(i);//Bug was introduced while fixing Bug 5128
	                                        //Bug Id 5128
											String strval=value;
	                                        if (strval != null) {
	                                            if (JDBCTYPE_TO_WFSTYPE(type) == WFSConstant.WF_NTEXT) {
	                                                Object[] obj = getBIGData(con, rs, strColumnName, dbType, DatabaseTransactionServer.charSet);
	                                                strval = (String) obj[0];
	                                            } else {
	                                                strval = WFSUtil.TO_SQL(value.trim(), WFSUtil.JDBCTYPE_TO_WFSTYPE(type), dbType, true);
	                                            }
	                                        }
	                                        values = new ArrayList();
	                                        values.add(strval);
	                                        //tmptable = rsmd.getTableName(i); //Bugzilla Bug 5580
	                                        tmptable = tablename;
	                                        tmpcol = rsmd.getColumnName(i);
	                                        relationMap.put((tmptable + string21 + tmpcol).toUpperCase(), values);
	                                        i++;
	                                        ctr--;
	                                    }
	                                }
	                                rs.close();
	                                rs = null;
	                                pstmt.close();
	                                pstmt = null;
	                            }
	                        }
	                        WFSUtil.printOut(engine,"array count was " + aCount);
	                        if (aCount > 0) {
	                            if (arrayQry != null) {
	                                int k;
									String ignoreSuffix = getFetchSuffixStr(dbType,1,WFSConstant.QUERY_STR_AND).toUpperCase();
									int iPosSuffix = 0;
									
	                                for (k = 0; aCount > k; k++) {
	                                    attrib = (String[]) arrayattribs.get(k);
	                                    allAttrib = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
										//WFS_8.0_084
	                                    if (!name.equalsIgnoreCase("") && !attrib[1].equalsIgnoreCase(name))
	                                    {
	                                        continue;
	                                    }
	                                    StringBuffer str = new StringBuffer((String) arrayQry.get(attrib[1].toUpperCase()));
	                                    String qry = str.toString();
	                                    ArrayList relationstr = new ArrayList();
	                                    ArrayList relationval = new ArrayList();

										if (!ignoreSuffix.equalsIgnoreCase("")){
											iPosSuffix = qry.indexOf(ignoreSuffix);
											if (iPosSuffix != -1){	//Bugzilla Bug 13084
												qry = qry.substring(0, iPosSuffix);
											}
										}
	                                    while (qry.indexOf("=") != -1) {
	                                        if (qry.indexOf(" AND ") != -1) {	//WFS_8.0_004

	                                            relationstr.add((qry.substring(qry.indexOf("=") + 1, qry.indexOf(" AND "))).trim());//Bugzilla Bug 7227,7357

	                                            qry = qry.substring(qry.indexOf(" AND ") + 1);
	                                        } else {
	                                            relationstr.add((qry.substring(qry.indexOf("=") + 1)).trim());//Bugzilla Bug 7227,7357

	                                            qry = qry.substring(qry.indexOf("=") + 1);
	                                        }
	                                    }

	                                    ListIterator itr = relationstr.listIterator();
	                                    ArrayList relvalues = new ArrayList();
	                                    String val = "";
	                                    boolean flag = false;
	                                    while (itr.hasNext()) {
	                                        String tmpstr = (String) itr.next();
	                                        StringBuffer tmp = new StringBuffer();
	                                        //if (tmpstr.indexOf("QUEUEDATATABLE") == -1 && tmpstr.indexOf(
											if (tmpstr.indexOf("WFINSTRUMENTTABLE") == -1 && tmpstr.indexOf(
											"QUEUEHISTORYTABLE") == -1 && tmpstr.indexOf(tablename.toUpperCase()) == -1) {
	                                            tmp.append(attrib[1] + ":");
	                                        }
	                                        if (!tmpstr.equals("1")) {
	                                            tmp.append(tmpstr.replace(".", string21)); //structurename:tablename#columname

	                                            WFSUtil.printOut(engine,"key to get the relation value" + tmp.toString());
	                                            WFSUtil.printOut(engine,"relationMap for array case" + relationMap);
	                                            relvalues = (ArrayList) relationMap.get((tmp.toString()).trim().toUpperCase());
	                                            if (relvalues != null) {
	                                                if (relvalues.size() > 1) {
	                                                    WFSUtil.printOut(engine,"this cannot happen error");
	                                                }
	                                                val = (String) relvalues.get(0);
	                                                if (val != null) {
	                                                    str = str.replace(str.indexOf(tmpstr), str.indexOf(tmpstr) + tmpstr.length(), val);
	                                                } else {
	                                                    //flag = true;
	                                                    str = str.replace(str.indexOf("=" + tmpstr), str.indexOf("=" + tmpstr) + tmpstr.length() + 1, " IS NULL ");
	                                                }
	                                            } else {
	                                                //flag = true;
	                                                str = str.replace(str.indexOf("=" + tmpstr), str.indexOf("=" + tmpstr) + tmpstr.length() + 1, " IS NULL ");
	                                            }
	                                        }

	                                    }
	                                    /*join of parent table with array table removed-shweta tyagi*/
	                                    /*if (flag) {

	                                    str = str.replace(str.indexOf("FROM "), str.indexOf("FROM ") + 5, "FROM " + ((String) relationstr.get(0)).substring(0, ((String) relationstr.get(0)).indexOf(".")) + ",");

	                                    }*/
	                                    str.append(" ORDER BY INSERTIONORDERID ");
	                                    WFSUtil.printOut(engine,"array query1  " + str.toString());
	                                    pstmt = con.prepareStatement(str.toString());
	                                    pstmt.execute();
	                                    rs = pstmt.getResultSet();
	                                    rsmd = rs.getMetaData();
	                                    values = new ArrayList();
	                                    while (rs != null && rs.next()) {
	                                        values.add(rs.getString(1));
	                                        type = rsmd.getColumnType(1);
	                                        colname = rsmd.getColumnName(1);
	                                    }
	                                    //WFSUtil.printOut("4568" + values);
	                                    //***array to be put in relation map***//
	                                    String key = (allAttrib.getName() + ":" + allAttrib.getMappedTable() + string21 + colname).toUpperCase();
	                                    if (relationMap.containsKey(key)) {
	                                        relationMap.put(key, values);
	                                        WFSUtil.printOut(engine,"putting in relation map value for root level array");
	                                    }
										if (values.size() > 0) {		//primitive array returning blank tag in case empty
											if (ps) {
												if (attrib[3] == null) {
													attributes.put(attrib[1].toUpperCase(), new WFFieldValue(allAttrib.getVariableId(), allAttrib.getVarFieldId(), attrib[1], values, Integer.parseInt(attrib[2]), allAttrib.getScope(), 1024, allAttrib.getPrecison(), allAttrib.getParentInfo()));
												} else {
													attributes.put(attrib[1].toUpperCase(), new WFFieldValue(allAttrib.getVariableId(), allAttrib.getVarFieldId(), attrib[1], values, Integer.parseInt(attrib[2]), allAttrib.getScope(), Integer.parseInt(attrib[3]), allAttrib.getPrecison(), allAttrib.getParentInfo()));
												}
											} else {
												if (allAttrib != null) {
													rightsInfo = allAttrib.getRightsInfo();
													if (attrib[3] == null) {
														wfFieldValue = new WFFieldValue(allAttrib.getVariableId(), allAttrib.getVarFieldId(), attrib[1], values, allAttrib.getWfType(), allAttrib.getScope(), allAttrib.getLength(), allAttrib.getPrecison(), allAttrib.getParentInfo());
													} else {
														wfFieldValue = new WFFieldValue(allAttrib.getVariableId(), allAttrib.getVarFieldId(), attrib[1], values, allAttrib.getWfType(), allAttrib.getScope(), allAttrib.getLength(), allAttrib.getPrecison(), allAttrib.getParentInfo());
													}
													wfFieldValue.setRightsInfo(rightsInfo);
													valuemap.put((allAttrib.getVariableId() + string21 + allAttrib.getVarFieldId()).toUpperCase(), wfFieldValue);
												}
											}
										}
	                                    rs.close();
	                                    rs = null;
	                                    pstmt.close();
	                                    pstmt = null;
	                                }
	                            }
	                        }
							//WFS_8.0_084
	                        Iterator itrvarval = valuemap.entrySet().iterator();
	                        HashMap qvalmap=new HashMap();
	                        while (itrvarval.hasNext()) {
	                            ArrayList objlist=new ArrayList();
	                            Object obruleid=itrvarval.next();
	                            Map.Entry entries = (Map.Entry) obruleid;
	                            WFFieldValue fieldValue = (WFFieldValue) entries.getValue();
	                            String key=obruleid.toString();
	                            key=key.substring(0, key.lastIndexOf(string21));
	                            objlist=fieldValue.getValues();
	                            int iOperandType=fieldValue.getWfType();
	                            qvalmap.put(key, String.valueOf(objlist.toArray()[0])+string21+iOperandType);
	                        }
	                        LinkedHashMap FragmentOperationVarMap = new LinkedHashMap(500);
	                        FragmentOperationVarMap=attribs.getFragmentOperationVarMap();
	                        LinkedHashMap FragmentConditionVarMap = new LinkedHashMap(500);
	                        FragmentConditionVarMap=attribs.getFragmentConditionVarMap();
	                        LinkedHashMap CmplxMap = new LinkedHashMap(500);
	                        //Iterator itr = FragmentOperationVarMap.keySet();//entrySet().iterator();
	                        Iterator itr =FragmentOperationVarMap.keySet().iterator();
	                        int iRuleID=0;
	                        ResultSet rsopr=null;
	                        Statement stmt=null;
	                        String strCmplxName="";
	                        boolean finalconditionresult=false;
	                        boolean conditionresult=false;
	                        String fragcondition="";
	                        while (itr.hasNext())
	                        {








	                             String param []=new String[10];
	                             String type1="";
	                             int variableid1=0;
	                             String type2="";
	                             int variableid2=0;
	                             int Operator=0;
	                             int LogicalOperator=0;
	                             int extCount=0;

	                             fragcondition="";
	                             Object obruleid=itr.next();
	                             iRuleID=Integer.parseInt(obruleid.toString());
	                             ArrayList ruleList = null;
	                             WFRuleInfo wfRuleInfo = null;
	                             try
	                             {








	                                 ruleList = (ArrayList)CachedObjectCollection.getReference().getCacheObject(con, engine, procDefId, WFSConstant.CACHE_CONST_RuleCache, String.valueOf(iRuleID)).getData();
	                                 if(ruleList != null){
	                                     for(int i = 0; i < ruleList.size(); i++){
	                                        wfRuleInfo = (WFRuleInfo) ruleList.get(i);
	                                        param [0]=wfRuleInfo.getParam1();
	                                        type1=wfRuleInfo.getType1();
	                                        variableid1=wfRuleInfo.getVariableid_1();
	                                        param [1] =wfRuleInfo.getParam2();
	                                        type2=wfRuleInfo.getType2();
	                                        variableid2=wfRuleInfo.getVariableid_2();
	                                        LogicalOperator=wfRuleInfo.getLogicalOp();
	                                        Operator=wfRuleInfo.getOperator();
	                                        if(type1.equalsIgnoreCase("S"))
	                                        {
	                                            strCmplxName=String.valueOf(FragmentOperationVarMap.get(iRuleID));
	                                            CmplxMap.put(FragmentOperationVarMap.get(iRuleID),"");
	                                        }
	                                        else
	                                        {
	                                            if(type2.equalsIgnoreCase("C"))
	                                            {
	                                                String Mapvarval1=qvalmap.get(String.valueOf(variableid1)).toString();
	                                                String varval1=Mapvarval1.substring(0,Mapvarval1.lastIndexOf(string21));
	                                                int OperandType=Integer.parseInt(Mapvarval1.substring(Mapvarval1.lastIndexOf(string21)+1));
	                                                conditionresult=Utility.compareObject(varval1, param[1], OperandType, Operator);
	                                            }
	                                            if(!type2.equalsIgnoreCase("C") && !type2.equalsIgnoreCase("S"))
	                                            {
	                                                String Mapvarval1=qvalmap.get(String.valueOf(variableid1)).toString();
	                                                String varval1=Mapvarval1.substring(0,Mapvarval1.lastIndexOf(string21));
	                                                String Mapvarval2=qvalmap.get(String.valueOf(variableid2)).toString();
	                                                String varval2=Mapvarval1.substring(0,Mapvarval2.lastIndexOf(string21));
	                                                int OperandType=Integer.parseInt(Mapvarval1.substring(Mapvarval1.lastIndexOf(string21)+1));
	                                                conditionresult=Utility.compareObject(varval1, varval1, OperandType, Operator);
	                                            }
	                                        }
	                                        if(LogicalOperator==1)
	                                            fragcondition+=" "+conditionresult+" AND ";
	                                        if(LogicalOperator==2)
	                                            fragcondition+=" "+conditionresult+" OR";
	                                        else if(LogicalOperator!=4 || LogicalOperator!=3)
	                                            fragcondition+=""+conditionresult;
	                                        }
	                                 }                                
	                             }
	                             catch(Exception e)
	                             {
	                                 printErr(engine, "", e);
	                             }
	                             if(fragcondition.contains("AND")&& fragcondition.contains("false"))
	                                 finalconditionresult=false;
	                             if(fragcondition.contains("OR")&& fragcondition.contains("true"))
	                                 finalconditionresult=true;
	                             else if(!fragcondition.contains("AND")&& !fragcondition.contains("OR"))
	                             {
	                                 if(fragcondition.equalsIgnoreCase("true")||fragcondition.equalsIgnoreCase("TRUE"))
	                                    finalconditionresult=true;
	                                 else
	                                    finalconditionresult=false;
	                             }
	                             if(finalconditionresult)
	                             {
	                                 CmplxMap.put(String.valueOf(FragmentOperationVarMap.get(iRuleID)),"");
	                             }
	                        }
	                        if (cCount > 0) {
	                            LinkedHashMap valmap = new LinkedHashMap();
	                            ArrayList mapvalues;
	                            for (int k = 0; cCount > k; k++)
	                            {
	                                attrib = (String[]) cmplxattribs.get(k);
	                                allAttrib = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
									//WFS_8.0_084
									if (!name.equalsIgnoreCase("") && !attrib[1].equalsIgnoreCase(name))
	                                {
	                                    continue;
	                                }
	                                if(name.equalsIgnoreCase("") && (CmplxMap.size()>0) && !CmplxMap.containsKey(attrib[1]))
	                                    continue;
	                                LinkedHashMap qryRelationMap = new LinkedHashMap(relationMap);
	                           //     WFSUtil.printOut(engine,"new relation map" + qryRelationMap);
	                                LinkedHashMap qryMemberMap = new LinkedHashMap((LinkedHashMap) memberMap.get((allAttrib.getName()).toUpperCase()));
	                            //    WFSUtil.printOut(engine,"new member map" + qryMemberMap);
	                                valmap.put((allAttrib.getName()).toUpperCase(), qryMemberMap);
	                            //    WFSUtil.printOut(engine,"map before method " + valmap);
	                                setValueInMap(con, dbType, cmplxQry, allAttrib, allAttrib.getName(), valmap, qryRelationMap, tablename, engine);
	                                //WFSUtil.printOut(engine,"map after method" + valmap);
	                                WFFieldValue wffieldvalue = new WFFieldValue(allAttrib.getVariableId(), allAttrib.getVarFieldId(), allAttrib.getName(), "", allAttrib.getWfType(), allAttrib.getScope(), allAttrib.getLength(), allAttrib.getPrecison(), allAttrib.getParentInfo());
	                                wffieldvalue.setRightsInfo(allAttrib.getRightsInfo());
	                                setValue(allAttrib, wffieldvalue, valmap);
	                                if (ps) {
	                                    attributes.put(attrib[1].toUpperCase(), wffieldvalue);
	                                } else {
	                                    valuemap.put(allAttrib.getVariableId() + string21 + allAttrib.getVarFieldId(), wffieldvalue);
	                                }
	                               // WFSUtil.printOut(engine,"final map is" + valuemap);
	                            }
	                        }

	                        Iterator itr3 = valuemap.entrySet().iterator();

	                        while (itr3.hasNext()) {
	                            Map.Entry entries = (Map.Entry) itr3.next();
	                            WFFieldValue fieldValue = (WFFieldValue) entries.getValue();
	                            //fieldValue.serializeAsXML(doc, doc.getDocumentElement(),engine);
	                        }
//	                        xml.append(WFXMLUtil.removeXMLHeader(doc, engine));
	                    } /*else {
	                        boolean success = false;
	                        boolean complexflag = false;
	                        String queryTable = "";

	                        ListIterator iter = queattribs.listIterator();

	                        retrCount = 1;
	                        while (iter.hasNext()) {
	                            attrib = (String[]) iter.next();
	                            allAttrib = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
	                            if (!attrib[1].equalsIgnoreCase(name)) {
	                                continue;
	                            }
	                            success = true;
	                            queryTable = " queueDatatable ";
	                            queryTable = wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
	                                    : queryTable;
	                            queryTable = "Select " + attrib[4] + " from " + queryTable + " where ProcessInstanceId=? and " + "WorkItemId=" + workItemID;
	                            break;
	                        }
	                        WFSUtil.printOut("[in else][queue variable] " + queryTable);
	                        if (!success) {
	                            iter = extattribs.listIterator();
	                            tempStr = "";
	                            while (iter.hasNext()) {
	                                attrib = (String[]) iter.next();
	                                allAttrib = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
	                                if (!attrib[1].equalsIgnoreCase(name)) { //if (attrib[0].equalsIgnoreCase(name))	//Ashish modified condition (added not) WSE_5.0.1_PRDP_001

	                                    continue;
	                                }
	                                success = true;
	                                queryTable = tablename;
	                                queryTable = "Select " + attrib[4] + " from " + queryTable + "," + (wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
	                                        : " QueueDataTable ") + " where ProcessInstanceId=? and WorkItemId=" +
	                                        workItemID;

	                                st = new StringTokenizer(keybuffer.toString(), "#", true);
	                                int i = 0;
	                                while (st.hasMoreTokens()) {
	                                    tempStr = st.nextToken();
	                                    if (!tempStr.equals("#")) {
	                                        queryTable += " and VAR_REC_" + (i + 1) + "=" + tempStr;
	                                    } else {
	                                        i++;
	                                    }
	                                }
	                                break;
	                            }
	                            WFSUtil.printOut("[in else][external variable] " + queryTable);
	                        }
	                        if (!success) {
	                            for (int i = 0; i < WFSConstant.qdmattribs.length; i++) {
	                                attrib = WFSConstant.qdmattribs[i];
	                                allAttrib = (WFFieldInfo) cachemap.get(attrib[0].toUpperCase());
	                                /* Bugzilla Bug 896, ArrayIndexOutOfRange, 23/05/2007 - Ruhi Hira 
	                                if (!attrib[0].equalsIgnoreCase(name)) {
	                                    continue;
	                                }
	                                success = true;
	                                queryTable = " queueDatatable ";
	                                queryTable = wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
	                                        : queryTable;
	                                queryTable = "Select " + attrib[0] + " from " + queryTable + " where ProcessInstanceId=? and " + "WorkItemId=" + workItemID;
	                                break;
	                            }
	                            WFSUtil.printOut("[in else][qdmattribs] " + queryTable);
	                        }
	                        if (!success) {
	                            for (int i = 0; i < WFSConstant.prcattribs.length; i++) {
	                                attrib = WFSConstant.prcattribs[i];
	                                allAttrib = (WFFieldInfo) cachemap.get(attrib[0].toUpperCase());
	                                if (!attrib[0].equalsIgnoreCase(name)) {
	                                    continue;
	                                }
	                                success = true;
	                                queryTable = " ProcessInstanceTable ";
	                                queryTable = wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
	                                        : queryTable;
	                                queryTable = "Select " + attrib[0] + " from " + queryTable + " where ProcessInstanceId=?";
	                                break;
	                            }
	                            WFSUtil.printOut("[in else][prcattribs] " + queryTable);
	                        }
	                        if (!success) {
	                            for (int i = 0; i < WFSConstant.wklattribs.length; i++) {
	                                attrib = WFSConstant.wklattribs[i];
	                                allAttrib = (WFFieldInfo) cachemap.get(attrib[0].toUpperCase());
	                                if (!attrib[0].equalsIgnoreCase(name)) {
	                                    continue;
	                                }
	                                success = true;
	                                queryTable = wlisttable;
	                                queryTable = wlisttable.equals(" Queuehistorytable ") ? " Queuehistorytable "
	                                        : queryTable;
	                                queryTable = "Select " + attrib[0] + " from " + queryTable + " where ProcessInstanceId=? and " + "WorkItemId=" + workItemID;
	                                break;
	                            }
	                            WFSUtil.printOut("[in else][wklattribs] " + queryTable);
	                        }
	                        //change for arrays and complex variables//
	                        if (!success) {
	                            iter = arrayattribs.listIterator();
								String ignoreSuffix = getFetchSuffixStr(dbType,1,WFSConstant.QUERY_STR_AND).toUpperCase();
								int iPosSuffix = 0;
	                            while (iter.hasNext()) {
	                                attrib = (String[]) iter.next();
	                                allAttrib = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
	                                if (!attrib[1].equalsIgnoreCase(name)) { //if (attrib[0].equalsIgnoreCase(name))	//Ashish modified condition (added not) WSE_5.0.1_PRDP_001

	                                    continue;
	                                }
	                                success = true;
	                                StringBuffer str = new StringBuffer((String) arrayQry.get(attrib[1].toUpperCase()));
	                                String qry = str.toString();
	                                ArrayList relationstr = new ArrayList();
	                                ArrayList relationval = new ArrayList();
									if (!ignoreSuffix.equalsIgnoreCase("")){
										iPosSuffix = qry.indexOf(ignoreSuffix);
										if (iPosSuffix != -1){	//Bugzilla Bug 13084
											qry = qry.substring(0, iPosSuffix);
										}
									}
	                                while (qry.indexOf("=") != -1) {
	                                    if (qry.indexOf(" AND ") != -1) {
	                                        relationstr.add(qry.substring(qry.indexOf("=") + 1, qry.indexOf(" AND ")));
	                                        qry = qry.substring(qry.indexOf(" AND ") + 1);
	                                    } else {
	                                        relationstr.add(qry.substring(qry.indexOf("=") + 1));
	                                        qry = qry.substring(qry.indexOf("=") + 1);
	                                    }
	                                }

	                                ListIterator itr = relationstr.listIterator();
	                                String val = "";
	                                boolean flag = false;
	                                while (itr.hasNext()) {
	                                    String tmpstr = (String) itr.next();
	                                    StringBuffer tmp = new StringBuffer(attrib[1] + ":");
	                                    if (!tmpstr.equals("1")) {

	                                        tmp.append(tmpstr.replace('.', '#')); //structurename:tablename#columname

	                                        WFSUtil.printOut("key to get the relation value" + tmp.toString());
	                                        val = (String) relationMap.get(tmp.toString().toUpperCase());
	                                        if (val != null) {
	                                            str = str.replace(str.indexOf(tmpstr), tmpstr.length(), val);
	                                        } else {
	                                            flag = true;
	                                        }
	                                    }

	                                }
	                                if (flag) {
	                                    str = str.replace(str.indexOf("FROM "), str.indexOf("FROM ") + 5, "FROM " + ((String) relationstr.get(0)).substring(0, ((String) relationstr.get(0)).indexOf(".")) + ",");

	                                }
	                                WFSUtil.printOut("[in else][array attrib] " + str.toString());
	                                queryTable = str.toString();
	                                break;
	                            }
	                        }
	                        //@@ complex structure fetch to be supported in next phase as per discussion with ashish sir- shweta tyagi
							/*if (!success) {
	                        iter = cmplxattribs.listIterator();
	                        while (iter.hasNext()) {
	                        attrib = (String[]) iter.next();
	                        allAttrib = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
	                        if (!attrib[1].equalsIgnoreCase(name)) { //if (attrib[0].equalsIgnoreCase(name))	//Ashish modified condition (added not) WSE_5.0.1_PRDP_001
	                        continue;
	                        }
	                        success = true;
	                        LinkedHashMap valmap = new LinkedHashMap();
	                        allAttrib  = (WFFieldInfo) cachemap.get(attrib[1].toUpperCase());
	                        LinkedHashMap qryRelationMap = new LinkedHashMap(relationMap);
	                        WFSUtil.printOut("[in else] new relation map"+qryRelationMap);
	                        LinkedHashMap qryMemberMap = new LinkedHashMap((LinkedHashMap) memberMap.get(allAttrib.getVariableId()+"#"+allAttrib.getVarFieldId()));
	                        WFSUtil.printOut("[in else] new member map"+qryMemberMap);
	                        valmap.put(allAttrib.getVariableId()+"#"+allAttrib.getVarFieldId(),qryMemberMap);
	                        WFSUtil.printOut("[in else] map before method "+valmap);
	                        setValueInMap(con, dbType, cmplxQry, allAttrib, allAttrib.getName(), valmap, qryRelationMap, tablename);
	                        WFSUtil.printOut("[in else] map after method"+valmap);
	                        WFFieldValue wffieldvalue = new WFFieldValue(allAttrib.getVariableId(), allAttrib.getVarFieldId(), allAttrib.getName(),"" , allAttrib.getWfType(), allAttrib.getScope(), allAttrib.getLength(), allAttrib.getPrecison(), allAttrib.getParentInfo());
	                        setValue(allAttrib, wffieldvalue, valmap);
	                        WFSUtil.printOut("[in else] list of maps"+wffieldvalue.getListOfMaps());
	                        xml = xml+wffieldvalue.getXml();
	                        xml = xml+"</Attributes>";
	                        WFSUtil.printOut("output xml in else"+xml);
	                        complexflag = true;
	                        break;
	                        }
	                        }
	                        if (success && !complexflag) {
	                            values = new ArrayList();
	                            pstmt = con.prepareStatement(queryTable);
	                            WFSUtil.printOut(procInstID);
	                            //WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
	                            pstmt.execute();
	                            rs = pstmt.getResultSet();
	                            ResultSetMetaData rsmd1 = pstmt.getMetaData();

	                            while (rs != null && rs.next()) {
	                                //Changed for nText support Bug Id WFS_8.0_014
	                                int iColumnType = rsmd1.getColumnType(1);
	                                String strColumnName = rsmd1.getColumnName(1);
	                                String strValue = "";
	                                if (JDBCTYPE_TO_WFSTYPE(iColumnType) == WFSConstant.WF_NTEXT) {
	                                    Object[] obj = getBIGData(con, rs, strColumnName, dbType, DatabaseTransactionServer.charSet);
	                                    strValue = (String) obj[0];
	                                } else {
	                                    strValue = rs.getString(1);
	                                }
	                                if (strValue != null) {
	                                    strValue = strValue.trim();
	                                }
	                                values.add(strValue);
	                            }
	                            WFSUtil.printOut("[in else printing values]" + values);

	                            WFFieldValue wffieldvalue = null;
	                            wffieldvalue = new WFFieldValue(allAttrib.getVariableId(), allAttrib.getVarFieldId(), allAttrib.getName(), values, allAttrib.getWfType(), allAttrib.getScope(), allAttrib.getLength(), allAttrib.getPrecison(), "");
	                            wffieldvalue.serializeAsXML(doc, doc.getDocumentElement());
	                            xml.append(WFXMLUtil.removeXMLHeader(doc));
	                            rs.close();
	                            rs = null;
	                            pstmt.close();
	                            pstmt = null;
	                        } else {
	                            mainCode = WFSError.WM_INVALID_ATTRIBUTE;
	                            subCode = 0;
	                            subject = WFSErrorMsg.getMessage(mainCode);
	                            descr = WFSErrorMsg.getMessage(subCode);
	                            errType = WFSError.WF_TMP;
	                        }
	                    }*/
//	                    tempXml.append(xml.toString());
	                //    tempXml.append(gen.writeValueOf("RetrievedCount", String.valueOf(retrCount)));
	                 //   tempXml.append(gen.writeValueOf("Count", String.valueOf(retrCount)));
	                }
	            } else {
	                mainCode = WFSError.WM_INVALID_WORKITEM;
	                subCode = 0;
	                subject = WFSErrorMsg.getMessage(mainCode);
	                descr = WFSErrorMsg.getMessage(subCode);
	                errType = WFSError.WF_TMP;
	            }
	        } catch (SQLException e) {
	            printErr(engine, "", e);
	            mainCode = WFSError.WM_INVALID_FILTER;
	            subCode = WFSError.WFS_SQL;
	            subject = WFSErrorMsg.getMessage(mainCode);
	            errType = WFSError.WF_FAT;
	            if (e.getErrorCode() == 0) {
	                if (e.getSQLState().equalsIgnoreCase("08S01")) {
	                    descr = (new JTSSQLError(e.getSQLState())).getMessage() + "(SQL State : " +
	                            e.getSQLState() + ")";
	                }
	            } else {
	                descr = e.getMessage();
	            }
	        } catch (NumberFormatException e) {
	            printErr(engine, "", e);
	            mainCode = WFSError.WF_OPERATION_FAILED;
	            subCode = WFSError.WFS_ILP;
	            subject = WFSErrorMsg.getMessage(mainCode);
	            errType = WFSError.WF_TMP;
	            descr = e.toString();
	        } catch (NullPointerException e) {
	            printErr(engine, "", e);
	            mainCode = WFSError.WF_OPERATION_FAILED;
	            subCode = WFSError.WFS_SYS;
	            subject = WFSErrorMsg.getMessage(mainCode);
	            errType = WFSError.WF_TMP;
	            descr = e.toString();
	        } catch (Exception e) {
	            printErr(engine, "", e);
	            mainCode = WFSError.WF_OPERATION_FAILED;
	            subCode = WFSError.WFS_EXP;
	            subject = WFSErrorMsg.getMessage(mainCode);
	            errType = WFSError.WF_TMP;
	            descr = e.toString();
	        } catch (Error e) {
	            printErr(engine, "", e);
	            mainCode = WFSError.WF_OPERATION_FAILED;
	            subCode = WFSError.WFS_EXP;
	            subject = WFSErrorMsg.getMessage(mainCode);
	            errType = WFSError.WF_TMP;
	            descr = e.toString();
	        } finally {
	            try {
	                if (rs != null) {
	                    rs.close();
	                    rs = null;
	                }

	            } catch (Exception e) {
	            }
	            try {
	                if (pstmt != null) {
	                    pstmt.close();
	                    pstmt = null;
	                }

	            } catch (Exception e) {
	            }
	            

	        }
	        if (mainCode != 0) {
                throw new WFSException(mainCode, subCode, errType, subject, descr);
            }
	        if (ps) {
	            return attributes;
	        } else {
	            return tempXml.toString();
	        }


	    }
//----------------------------------------------------------------------------------------------------
//	Function Name 				: setValue
//	Date Written (DD/MM/YYYY)	: 14/05/2008
//	Author						: Shweta Tyagi
//	Input Parameters			: WFFieldInfo wffieldinfo, WFFieldValue wffieldvalue, LinkedHashMap valmap
//	Output Parameters			: none
//	Return Values				: void
//	Description					: sets value in value map
//----------------------------------------------------------------------------------------------------

    public static void setValue(WFFieldInfo wffieldinfo, WFFieldValue wffieldvalue, LinkedHashMap valmap) {

        LinkedHashMap[] maps;
        String value = "";
        ArrayList values;
        ArrayList insertionOrderIdValues =null; 
        ArrayList mapvalues = new ArrayList();
        ArrayList listOfMaps = new ArrayList();
        LinkedHashMap childValueMap = null;
        LinkedHashMap childInfoMap = null;
        mapvalues = (ArrayList) valmap.get((wffieldinfo.getName()).toUpperCase());
        WFFieldValue wfFieldValue = null;
        //Bugzilla Bug Id 5138
        //SrNo.11
			/*if (mapvalues.size()==0) {
        childInfoMap = wffieldinfo.getChildInfoMap();
        Iterator iter = childInfoMap.entrySet().iterator();
        childValueMap = new LinkedHashMap();
        while(iter.hasNext()) {
        Map.Entry entry = (Map.Entry) iter.next();
        WFFieldInfo childInfo = (WFFieldInfo) entry.getValue();
        if (childInfo.getWfType()!=11) {
        childValueMap.put(entry.getKey(), new WFFieldValue(childInfo.getVariableId(), childInfo.getVarFieldId(), childInfo.getName(),"" , childInfo.getWfType(), childInfo.getScope(), childInfo.getLength(), childInfo.getPrecison(), childInfo.getParentInfo()))	;
        } else {
        WFFieldValue childFieldValue =  new WFFieldValue(childInfo.getVariableId(), childInfo.getVarFieldId(), childInfo.getName(),"" , childInfo.getWfType(), childInfo.getScope(), childInfo.getLength(), childInfo.getPrecison(), childInfo.getParentInfo());
        childValueMap.put(entry.getKey(), childFieldValue)	;
        //setValue(childInfo, childFieldValue, memberMap);
        }
        }
        listOfMaps.add(childValueMap);
        WFSUtil.printOut("line num 5112"+listOfMaps);
        wffieldvalue.setListOfMaps(listOfMaps);
        }*/
        ListIterator itr = mapvalues.listIterator();
        while (itr.hasNext()) {
            maps = (LinkedHashMap[]) itr.next();
            childInfoMap = wffieldinfo.getChildInfoMap();
            Iterator iter = childInfoMap.entrySet().iterator();
            childValueMap = new LinkedHashMap();
            while (iter.hasNext()) {
                Map.Entry entry = (Map.Entry) iter.next();
                WFFieldInfo childInfo = (WFFieldInfo) entry.getValue();
                if (childInfo.getWfType() != 11) {
                	if( maps[0].get((childInfo.getName()).toUpperCase()) instanceof ArrayList){
                		values = (ArrayList) maps[0].get((childInfo.getName()).toUpperCase());
                		insertionOrderIdValues =(ArrayList) maps[2].get((childInfo.getName()).toUpperCase());
                	}
                	else{
                		values = new ArrayList();
                	}
					wfFieldValue = new WFFieldValue(childInfo.getVariableId(), childInfo.getVarFieldId(), childInfo.getName(), values, childInfo.getWfType(), childInfo.getScope(), childInfo.getLength(), childInfo.getPrecison(), childInfo.getParentInfo(),insertionOrderIdValues,childInfo.getIsView());
                    wfFieldValue.setRightsInfo(childInfo.getRightsInfo());
                    childValueMap.put(entry.getKey(), wfFieldValue);
                } else {

                    WFFieldValue childFieldValue = new WFFieldValue(childInfo.getVariableId(), childInfo.getVarFieldId(), childInfo.getName(), "", childInfo.getWfType(), childInfo.getScope(), childInfo.getLength(), childInfo.getPrecison(), childInfo.getParentInfo(),childInfo.getIsView());
                    childFieldValue.setRightsInfo(childInfo.getRightsInfo());
                    childValueMap.put(entry.getKey(), childFieldValue);
                    setValue(childInfo, childFieldValue, maps[0]);
                }
            }
            listOfMaps.add(childValueMap);
            //WFSUtil.printOut("List of Maps" + listOfMaps);
            wffieldvalue.setListOfMaps(listOfMaps);
        }

    }
//----------------------------------------------------------------------------------------------------
//	Function Name 				: setValueInMap
//	Date Written (DD/MM/YYYY)	: 14/05/2008
//	Author						: Shweta Tyagi
//	Input Parameters			: Connection con, int dbType,LinkedHashMap qryMap, WFFieldInfo wffieldinfo, String name,LinkedHashMap valmap, LinkedHashMap qryRelationMap, String tablename
//	Output Parameters			: none
//	Return Values				: void
//	Description					: executes queries to get values
//----------------------------------------------------------------------------------------------------

    public static void setValueInMap(Connection con, int dbType, LinkedHashMap qryMap, WFFieldInfo wffieldinfo, String name, LinkedHashMap valmap, LinkedHashMap qryRelationMap, String tablename, String engine) throws WFSException{
    	setValueInMap(con, dbType, qryMap, wffieldinfo, name, valmap, qryRelationMap, tablename, engine,null);	
    }
    

    public static void setValueInMap(Connection con, int dbType, LinkedHashMap qryMap, WFFieldInfo wffieldinfo, String name, LinkedHashMap valmap, LinkedHashMap qryRelationMap, String tablename, String engine,ArrayList batchInfo) throws WFSException{

        LinkedHashMap childValueMap = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        ResultSetMetaData rsmd = null;
        try {
        	HashMap batchInfoForCurrentComplex = new HashMap() ;
            String lastValue;
            String sLastInsertionOrderIdValue;
            String sSortingFieldName;
        	String sortOrderValue = "";
        	int batchSizeValue =0;
			String ignoreSuffix = getFetchSuffixStr(dbType,1,WFSConstant.QUERY_STR_AND).toUpperCase();
			int iPosSuffix = 0;
			
			WFConfigLocator configlocator = null;
			configLocator = WFConfigLocator.getInstance();
            String strConfigFileName = configLocator.getPath(Location.IBPS_CONFIG) + File.separator + WFSConstant.CONST_DIRECTORY_CONFIG + File.separator + WFSConstant.CONST_FILE_WFAPPCONFIGPARAM;
            XMLParser parserTemp = new XMLParser(WFSUtil.readFile(strConfigFileName));
			String complexDefaultBatchSize = parserTemp.getValueOf("ComplexDefaultBatchSize");
			
			if(complexDefaultBatchSize==null || complexDefaultBatchSize=="") {
				complexDefaultBatchSize="10";
				}

            String mainqry = (String) qryMap.get(name.toUpperCase());
            WFSUtil.printOut(engine,"query from cmplx qry map" + mainqry);
            int size = 0;
            ArrayList queries = new ArrayList();
            if (mainqry.indexOf(string21) != -1) {
                StringTokenizer st = new StringTokenizer(mainqry, string21);
                size = st.countTokens();
                while (st.hasMoreTokens()) {
                    queries.add(st.nextToken());
                }
            } else {
                queries.add(mainqry);
            }
            size = queries.size();
            for (int k = 0; k < size; k++) {
                WFSUtil.printOut(engine,"k is this time" + k);
              //  WFSUtil.printOut(engine,"iterating thru queries");
                String qry = (String) queries.get(k);
                StringBuffer str = new StringBuffer(qry);
                ArrayList relationstr = new ArrayList();
				if (!ignoreSuffix.equalsIgnoreCase("")){
					iPosSuffix = qry.indexOf(ignoreSuffix);
					if (iPosSuffix != -1){	//Bugzilla Bug 13084
						qry = qry.substring(0, iPosSuffix);
					}
				}				
                while (qry.indexOf("=") != -1) {
                    if (qry.indexOf(" AND ") != -1) {	//WFS_8.0_004

                        relationstr.add((qry.substring(qry.indexOf("=") + 1, qry.indexOf(" AND "))).trim());//Bugzilla Bug 7227,7357

                        qry = qry.substring(qry.indexOf(" AND ") + 1);
                    } else {
                        relationstr.add((qry.substring(qry.indexOf("=") + 1)).trim());//Bugzilla Bug 7227,7357

                        qry = qry.substring(qry.indexOf("=") + 1);
                    }
                }
                String val = "";
                boolean flag = false;
                ArrayList qrylist = new ArrayList();//chek this out
                ArrayList isQryMappedWithNull = new ArrayList();	//Ashish Mangla added on 03/03/2013

                ArrayList vallist = new ArrayList(); //relation arraylist

                ArrayList mapvalues = new ArrayList();
                if (k > 0) {
                    WFSUtil.printOut(engine,"sub query case");
                    mapvalues = (ArrayList) valmap.get((wffieldinfo.getName()).toUpperCase());
                    int arr_size = mapvalues.size();
                    for (int x = 0; x < arr_size; x++) {
                        LinkedHashMap[] maps = (LinkedHashMap[]) mapvalues.get(x);
                        //WFSUtil.printOut("old" + qryRelationMap);
                        qryRelationMap = new LinkedHashMap(maps[1]);
                        WFSUtil.printOut(engine,"new" + qryRelationMap);
                        if (x == 0) {
                            qrylist = new ArrayList();//check-shweta
                            isQryMappedWithNull = new ArrayList();

                            WFSUtil.printOut(engine,"****initial empty qry list*** " + qrylist);
                        }
                        int qrylistsize = qrylist.size();
                        qrylist.add(str.toString());
                        isQryMappedWithNull.add("FALSE");
                        ListIterator listitr = relationstr.listIterator();
                        while (listitr.hasNext()) {
                            String tmpstr = ((String) listitr.next()).trim().toUpperCase();
                            StringBuffer tmp = new StringBuffer();

                            //Bug 5762
                            /*if (!tablename.equals("")) {
                                if (tmpstr.indexOf("QUEUEDATATABLE") == -1 && tmpstr.indexOf("QUEUEHISTORYTABLE") == -1 && tmpstr.indexOf(tablename.toUpperCase()) == -1) {
                                    tmp.append(name + ":");
                                }
                            } else {
                                if (tmpstr.indexOf("QUEUEDATATABLE") == -1 && tmpstr.indexOf("QUEUEHISTORYTABLE") == -1) {
                                    tmp.append(name + ":");
                                }
                            }*/

							if (!tablename.equals("")) {
                                if (tmpstr.indexOf("WFInstrumentTable") == -1 && tmpstr.indexOf("QUEUEHISTORYTABLE") == -1 && tmpstr.indexOf(tablename.toUpperCase()) == -1) {
                                    tmp.append(name + ":");
                                }
                            } else {
                                if (tmpstr.indexOf("WFInstrumentTable") == -1 && tmpstr.indexOf("QUEUEHISTORYTABLE") == -1) {
                                    tmp.append(name + ":");
                                }
                            }
                            if (!tmpstr.equals("1")) {
                                tmp.append(tmpstr.replace(".", string21)); //structurename:tablename#columname

                                WFSUtil.printOut(engine,"key to get value from qryrelationmap" + string25 + tmp.toString());//added as case of arrays within complex arrays relation column was not getting appended-shweta tyagi

                                WFSUtil.printOut(engine,"flag val" + qryRelationMap.containsKey(string25 + ((tmp.toString()).trim()).toUpperCase()));

                                vallist = (ArrayList) qryRelationMap.get(string25 + ((tmp.toString()).trim()).toUpperCase());
                                int val_size = 0;

                                int y = 0;
                                if (vallist != null) {
                                    val_size = vallist.size();
                                    for (y = 0; y < val_size; y++) {
                                        if (y >= 1) {
                                            qrylist.add(str.toString());
                                            isQryMappedWithNull.add("FALSE");
                                        }
                                        val = (String) vallist.get(y);
                                        if (val != null) {
                                            //qrylist.add(str.toString());
                                            StringBuffer tempBuffer = new StringBuffer((String) qrylist.get(qrylistsize + y));
                                            tempBuffer = tempBuffer.replace(tempBuffer.indexOf(tmpstr), tempBuffer.indexOf(tmpstr) + tmpstr.length(), val);
                                            qrylist.set(qrylistsize + y, tempBuffer.toString());

                                        } else {
                                            flag = true;
                                            WFSUtil.printOut(engine,"relation value was null");
                                            StringBuffer tempBuffer = new StringBuffer((String) qrylist.get(qrylistsize + y));
                                            tempBuffer = tempBuffer.replace(tempBuffer.indexOf("=" + tmpstr), tempBuffer.indexOf("=" + tmpstr) + tmpstr.length() + 1, " IS NULL ");	//Bugzilla Bug Id 5138

                                            qrylist.set(qrylistsize + y, tempBuffer.toString());
                                            isQryMappedWithNull.set(qrylistsize + y, "TRUE");

                                        }
                                    }
                                } else {
                                    flag = true;
                                    WFSUtil.printOut(engine,"relation arraylist was null");
                                    StringBuffer tempBuffer = new StringBuffer((String) qrylist.get(qrylistsize + y));
                                    tempBuffer = tempBuffer.replace(tempBuffer.indexOf("=" + tmpstr), tempBuffer.indexOf("=" + tmpstr) + tmpstr.length() + 1, " IS NULL ");		//Bugzilla Bug Id 5138

                                    qrylist.set(qrylistsize + y, tempBuffer.toString());
                                    isQryMappedWithNull.set(qrylistsize + y, "TRUE");    
                                }
                            }
                        }
                    }
                } else {
                    int qrylistsize = qrylist.size();
                    //WFSUtil.printOut("initial empty qry list " + qrylist);
                    qrylist.add(str.toString());
                    isQryMappedWithNull.add("FALSE");
                    ListIterator listitr = relationstr.listIterator();
                    while (listitr.hasNext()) {
                        String tmpstr = ((String) listitr.next()).trim().toUpperCase();
                        StringBuffer tmp = new StringBuffer();
                        //Bug 5762
                        /*if (tablename != "") {
                            if (tmpstr.indexOf("QUEUEDATATABLE") == -1 && tmpstr.indexOf("QUEUEHISTORYTABLE") == -1 && tmpstr.indexOf(tablename.toUpperCase()) == -1) {
                                tmp.append(name + ":");
                            }
                        } else {
                            if (tmpstr.indexOf("QUEUEDATATABLE") == -1 && tmpstr.indexOf("QUEUEHISTORYTABLE") == -1) {
                                tmp.append(name + ":");
                            }
                        }*/
						if (tablename != "") {
                            if (tmpstr.indexOf("WFINSTRUMENTTABLE") == -1 && tmpstr.indexOf("QUEUEHISTORYTABLE") == -1 && tmpstr.indexOf(tablename.toUpperCase()) == -1) {
                                tmp.append(name + ":");
                            }
                        } else {
                            if (tmpstr.indexOf("WFINSTRUMENTTABLE") == -1 && tmpstr.indexOf("QUEUEHISTORYTABLE") == -1) {
                                tmp.append(name + ":");
                            }
                        }
                        if (!tmpstr.equals("1")) {
                            tmp.append(tmpstr.replace(".", string21)); //structurename:tablename#columname

                            WFSUtil.printOut(engine,"key to get value from qryrelationmap" + tmp.toString());
                            WFSUtil.printOut(engine,"flag val" + qryRelationMap.containsKey(((tmp.toString()).trim()).toUpperCase()));
                            //WFSUtil.printOut(qryRelationMap.get(((tmp.toString()).trim()).toUpperCase()));
                            vallist = (ArrayList) qryRelationMap.get(((tmp.toString()).trim()).toUpperCase());
                            int y = 0;
                            if (vallist != null) {
                                int val_size = vallist.size();


                                for (y = 0; y < val_size; y++) {
                                    if (y >= 1) {
                                        qrylist.add(str.toString());
                                        isQryMappedWithNull.add("FALSE");
                                    }
                                    val = (String) vallist.get(y);
                                    if (val != null) {
                                        StringBuffer tempBuffer = new StringBuffer((String) qrylist.get(qrylistsize + y));
                                        tempBuffer = tempBuffer.replace(tempBuffer.indexOf(tmpstr), tempBuffer.indexOf(tmpstr) + tmpstr.length(), val);
                                        qrylist.set(qrylistsize + y, tempBuffer.toString());
                                    } else {
                                        flag = true;

                                        StringBuffer tempBuffer = new StringBuffer((String) qrylist.get(qrylistsize + y));
                                        tempBuffer = tempBuffer.replace(tempBuffer.indexOf("=" + tmpstr), tempBuffer.indexOf("=" + tmpstr) + tmpstr.length() + 1, " IS NULL ");
                                        qrylist.set(qrylistsize + y, tempBuffer.toString());
                                        isQryMappedWithNull.set(qrylistsize + y, "TRUE");

                                    }
                                }
                            } else {
                                flag = true;

                                StringBuffer tempBuffer = new StringBuffer((String) qrylist.get(qrylistsize + y));
                                tempBuffer = tempBuffer.replace(tempBuffer.indexOf("=" + tmpstr), tempBuffer.indexOf("=" + tmpstr) + tmpstr.length() + 1, " IS NULL ");
                                qrylist.set(qrylistsize + y, tempBuffer.toString());
                                isQryMappedWithNull.set(qrylistsize + y, "TRUE");

                            }
                        }
                    }
                }

                WFSUtil.printOut(engine,"line num 5021" + qrylist + "for k = " + k);
                int asize = qrylist.size();// size shud be >0

                if (asize > 0) {

                    boolean mainflag = false;
                    ArrayList arrayValue = new ArrayList();
                    ArrayList insertionValueList = null;
                    ArrayList values = new ArrayList();
                    boolean memberflag = false;
                    boolean relationflag = false;
                    String mymapval = "";	//Bugzilla Bug Id 5130

                    String mymapkey = "";	//Bugzilla Bug Id 5130
                    StringBuffer filterConditionStr =null;
                    for (int m = 0; m < asize; m++) {
                        lastValue = null;
                        sLastInsertionOrderIdValue = null;
                        sSortingFieldName = null;
                        String query = (String) qrylist.get(m);
                        String executeQuery = (String) isQryMappedWithNull.get(m);
						if (!executeQuery.equalsIgnoreCase("true")) {
							//String cmplxtablename = query.substring(query.indexOf(" FROM ") + 6, query.indexOf(" WHERE "));
							String queryTableName = query.substring(query.indexOf(" FROM ") + 6, query.indexOf(" WHERE "));
							queryTableName = queryTableName.replace(" WITH (NOLOCK)", "").trim();
							String whereCondition = query.substring(query.indexOf(" WHERE ") );
							String cmplxtablename = wffieldinfo.getMappedTable();
							String cmplxMappedViewName=wffieldinfo.getMappedViewName();
							String complexName= wffieldinfo.getName();
                                                    if (wffieldinfo.isArray() && batchInfo != null && !batchInfo.isEmpty()) {
                                                        Iterator batchInfoIterator = batchInfo.iterator();
                                                        if (batchInfoIterator.hasNext()) {
                                                            HashMap batchMap = (HashMap) batchInfoIterator.next();
                                                            ArrayList batchingInfo = (ArrayList) batchMap.get(complexName.toUpperCase());
                                                            if (batchingInfo == null || batchInfo.isEmpty()) {
                                                                batchInfoForCurrentComplex = batchMap;
                                                                if (batchMap.containsKey("NoOfRecordsToFetch")) {
                                                                    batchSizeValue = (Integer) batchMap.get("NoOfRecordsToFetch");
                                                                } else {
                                                                    batchSizeValue = Integer.parseInt(complexDefaultBatchSize);
                                                                }
                                                            } else {
                                                                batchInfoForCurrentComplex = (HashMap) batchingInfo.get(0);
                                                                ArrayList batchSizeList = (ArrayList) batchInfoForCurrentComplex.get("NOOFRECORDSTOFETCH");
                                                                if (batchSizeList != null) {
                                                                    batchSizeValue = (Integer.parseInt((String) batchSizeList.get(0)));
                                                                } else {
                                                                    batchSizeValue = Integer.parseInt(complexDefaultBatchSize);
                                                                }
                                                                ArrayList aOrderByList = (ArrayList) batchInfoForCurrentComplex.get("ORDERBY");
                                                                if (aOrderByList != null && !aOrderByList.isEmpty()) {
                                                                    sSortingFieldName = String.valueOf(aOrderByList.get(0));
                                                                } else {
                                                                    sSortingFieldName = wffieldinfo.getDefaultSortingFieldname();
                                                                }
                                                                ArrayList sortOrderList = (ArrayList) batchInfoForCurrentComplex.get("SORTORDER");
                                                                if (sortOrderList != null && !sortOrderList.isEmpty()) {
                                                                    sortOrderValue = ((String) sortOrderList.get(0));
                                                                } else {
                                                                    sortOrderValue = "A";
                                                                }
                                                                ArrayList lastValueList = (ArrayList) batchInfoForCurrentComplex.get("LASTVALUE");
                                                                if (lastValueList != null && !lastValueList.isEmpty()) {
                                                                    lastValue = String.valueOf(lastValueList.get(0));
                                                                }
                                                                ArrayList LastInsertionOrderIdValueList = (ArrayList) batchInfoForCurrentComplex.get("LASTINSERTIONORDERIDVALUE");
                                                                if (LastInsertionOrderIdValueList != null && !LastInsertionOrderIdValueList.isEmpty()) {
                                                                    sLastInsertionOrderIdValue = String.valueOf(LastInsertionOrderIdValueList.get(0));
                                                                }
                                                                ArrayList filterXMLList = (ArrayList) batchInfoForCurrentComplex.get("FILTERXML");
                                                                if (filterXMLList != null) {
                                                                    filterConditionStr = new StringBuffer();
                                                                    String op = "0";
                                                                    String logicalOp = "0";
                                                                    String varName = "";
                                                                    String varValue = "";
                                                                    String mappedColumn = "";
                                                                    WFFieldInfo childInfo = null;
                                                                    HashMap filerMap = new HashMap();
                                                                    filerMap = (HashMap) filterXMLList.get(0);
                                                                    if (filerMap != null) {

                                                                        ArrayList filterList = (ArrayList) filerMap.get("FILTER");
                                                                        int filterListIndex = 0;
                                                                        if (filterList != null) {
                                                                            filterConditionStr.append(" AND ( ");
                                                                            while (filterListIndex < filterList.size()) {
                                                                                filerMap = (HashMap) filterList.get(filterListIndex);
                                                                                if (filerMap != null) {
                                                                                    op = (String) ((ArrayList) filerMap.get("OPERATOR")).get(0);
                                                                                    try {
                                                                                        logicalOp = (String) ((ArrayList) filerMap.get("LOGICALOPERATOR")).get(0);
                                                                                    } catch (NullPointerException nex) {
                                                                                        //If the current filter is the last one then if logical operator is missing then take it as 0
                                                                                        if ((filterListIndex + 1) == filterList.size()) {
                                                                                            logicalOp = "0";
                                                                                        }
                                                                                    }
                                                                                    varName = (String) ((ArrayList) filerMap.get("VARNAME")).get(0);
                                                                                    if (filerMap.get("VARVALUE") != null || "".equalsIgnoreCase((String) filerMap.get("VARVALUE"))) {
                                                                                        varValue = (String) ((ArrayList) filerMap.get("VARVALUE")).get(0);
                                                                                        childInfo = (WFFieldInfo) wffieldinfo.getChildInfoMap().get(varName.toUpperCase());
                                                                                        mappedColumn = childInfo.getMappedColumn();
                                                                                        filterConditionStr.append(getAttributesFilterCondition(childInfo, dbType, logicalOp, op, varValue));
                                                                                    }
                                                                                }
                                                                                filterListIndex++;
                                                                            }
                                                                            filterConditionStr.append(" ) ");
                                                                        }
                                                                        if (filterConditionStr.length() == 5) {//As all the filter contains null or blank values
                                                                            filterConditionStr.delete(0, filterConditionStr.length());
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
							String mapval = "";
							String mapkey = "";
							String maxminQueryForInsertionOrderId= null;
							String maxValue =null;
							String minValue =null;
							String relmapkey = "";
							if (k == 0) {
								mainflag = true;
                            WFSUtil.printOut(engine,"wffieldinfo.isArray()---"+wffieldinfo.isArray());
                            if(wffieldinfo.isArray()){
                                String sSortingFieldColumn = null, sSortingOrder = " ASC ";
                                /*inner complex array is not yet supported*/
                                if (wffieldinfo.getParentVarFieldId() > 0) {
                                    batchSizeValue = -1;
                                }
                                if (batchSizeValue > 1) {
                                    if (dbType == JTSConstant.JTS_MSSQL) {
                                        query = query.replace("SELECT ", "SELECT TOP " + (batchSizeValue + 1) + " ");
                                    }
                                    if (sSortingFieldName != null && !sSortingFieldName.trim().isEmpty()
                                            && sortOrderValue != null && !sortOrderValue.trim().isEmpty()) {
                                        WFFieldInfo oSortingFieldInfo = getSortingFieldInfo(sSortingFieldName, wffieldinfo);
                                        if (oSortingFieldInfo == null) {
                                            sSortingFieldColumn = sSortingFieldName;
                                        } else {
                                            sSortingFieldColumn = oSortingFieldInfo.getMappedColumn();
                                        }
                                        sSortingOrder = sortOrderValue.equals("D") ? " DESC " : " ASC ";
                                        if (lastValue != null && !lastValue.trim().isEmpty()
                                                && sLastInsertionOrderIdValue != null && !sLastInsertionOrderIdValue.trim().isEmpty()) {
                                            if (!"insertionorderid".equalsIgnoreCase(sSortingFieldName)) {
                                                lastValue = ((oSortingFieldInfo == null) ? lastValue : TO_SQL(lastValue, oSortingFieldInfo.getWfType(), dbType, true));
                                                query += " and ("
                                                        + sSortingFieldColumn + (sortOrderValue.equalsIgnoreCase("D") ? " < " : " > ") + lastValue
                                                        + " or ("
                                                        + sSortingFieldColumn + " = " + lastValue
                                                        + " and insertionorderid" + (sortOrderValue.equalsIgnoreCase("D") ? " < " : " > ") + sLastInsertionOrderIdValue
                                                        + "))";
                                            } else {
                                                query += " and " + sSortingFieldColumn + (sortOrderValue.equalsIgnoreCase("D") ? " < " : " > ") + lastValue;
                                            }
                                        }
                                    }
                                }
                                if (sSortingFieldColumn == null) {
                                    String sDefaultSortingFieldname = wffieldinfo.getDefaultSortingFieldname();
                                    if (sDefaultSortingFieldname != null && !sDefaultSortingFieldname.trim().isEmpty()) {
                                        WFFieldInfo oSortingFieldInfo = getSortingFieldInfo(sDefaultSortingFieldname, wffieldinfo);
                                        if (oSortingFieldInfo == null) {
                                            sSortingFieldColumn = sDefaultSortingFieldname;
                                        } else {
                                            sSortingFieldColumn = oSortingFieldInfo.getMappedColumn();
                                        }
                                    } else {
                                        sSortingFieldColumn = "insertionorderid";
                                    }
                                    sSortingOrder = (wffieldinfo.getDefaultSortingOrder() == 0) ? " ASC " : " DESC ";
                                }
                                
                                if(filterConditionStr!= null && filterConditionStr.length()>0){
                                    query+=filterConditionStr.toString();
                                }
                        
                            	maxminQueryForInsertionOrderId= "Select max(insertionOrderId) as maxInsertionOrderId, min(InsertionOrderid) as minInsertionOrderId from ";
                            	if(cmplxMappedViewName!=null&&cmplxMappedViewName!=""){
                            		maxminQueryForInsertionOrderId+=cmplxMappedViewName;
                            	}
                            	else
                            	{
                            		maxminQueryForInsertionOrderId+=cmplxtablename;
                            	}
                            	maxminQueryForInsertionOrderId+=" " + getTableLockHintStr(dbType) + " "+whereCondition;
                            	if(filterConditionStr!= null && filterConditionStr.length()>0){
                            		maxminQueryForInsertionOrderId+=filterConditionStr.toString();
                                }
                                query += " ORDER BY " + sSortingFieldColumn + sSortingOrder;
                                if (!"insertionorderid".equalsIgnoreCase(sSortingFieldColumn)) {
                                    query += ", insertionorderid " + sSortingOrder;
                                }
                            	if((dbType==JTSConstant.JTS_POSTGRES)&&(batchSizeValue>1)){
                                    query += " Limit " + (batchSizeValue + 1);
                            	} 
                            	else if (dbType==JTSConstant.JTS_ORACLE){ 
                            		StringBuffer queryBuffer = new StringBuffer();
                            		queryBuffer.append("Select * from ( ").append(query).append(")");
                            		if(batchSizeValue>1){
                                            queryBuffer.append(" where rownum<= ").append((batchSizeValue + 1));
                            		}
                    				query = queryBuffer.toString();
                    				queryBuffer= null;
                    			}
                            	pstmt =con.prepareStatement(maxminQueryForInsertionOrderId);
                            	
                            	pstmt.execute();
                            	rs = pstmt.getResultSet();
                            	if(rs!=null&&rs.next()){
                            	
                            	maxValue =rs.getString("maxInsertionOrderId");
                            	minValue =rs.getString("minInsertionOrderId");
                            	}
                            	pstmt.close();
                            	rs.close();
                            	pstmt =null;
                            	rs =null;
                            }
                            WFSUtil.printOut(engine,"executing main query  " + query);
								pstmt = con.prepareStatement(query);
								pstmt.execute();
								rs = pstmt.getResultSet();
								rsmd = rs.getMetaData();
								int type;
								int j = 0;
								LinkedHashMap myQryInsertionOrderIdMap =null;
			                    insertionValueList = new ArrayList();

								if (rs != null) {
                                                                    int iRetrievedCount = 0, iTotalCount = 0;
									while (rs.next()) {
                                                                            if (wffieldinfo.isArray() && batchSizeValue > 0) {
                                                                                iTotalCount++;
                                                                                if (iTotalCount > batchSizeValue) {
                                                                                    break;
                                                                                }
                                                                                iRetrievedCount++;
                                                                            }
								        myQryInsertionOrderIdMap = new LinkedHashMap();
										insertionValueList=new ArrayList();
										int ctr = rsmd.getColumnCount();
										int i = 1;
										WFSUtil.printOut(engine,"in loop for the " + j + 1 + "time");
                                        WFSUtil.printOut(engine,"ctr for the" + j + 1 + "time");
										LinkedHashMap myQryMemberMap = new LinkedHashMap((LinkedHashMap) valmap.get((wffieldinfo.getName()).toUpperCase()));
										LinkedHashMap myQryRelationMap = new LinkedHashMap(qryRelationMap);

										//WFSUtil.printOut("myQryRelationMap" + myQryRelationMap);
										//WFSUtil.printOut("myQryMemberMap" + myQryMemberMap);
										Iterator itr3 = myQryMemberMap.entrySet().iterator();

										while (ctr > 0) {   //Changed for nText support Bug Id WFS_8.0_014

											int iColumnType = rsmd.getColumnType(i);
											String strColumnName = rsmd.getColumnName(i);
											String insertionOrderIdValue = "";

											//Work to do for InsertionOrder Order id . Outer most structure is array ...Mohnish
											String strValue = "";

											try {
												if (JDBCTYPE_TO_WFSTYPE(iColumnType) == WFSConstant.WF_NTEXT) {
													Object[] obj = getBIGData(con, rs, strColumnName, dbType, DatabaseTransactionServer.charSet);
													strValue = (String) obj[0];
												} else {
													strValue = rs.getString(i);
													if((iColumnType==8)&&(dbType==JTSConstant.JTS_MSSQL)){
														try{
														BigDecimal d = new BigDecimal(strValue);
														strValue=d.toPlainString();
														}
														catch(Exception ignored){
															
														}
														
													}
												}
												
											} catch (Exception e) {
												printErr(engine, "", e);
											}
											try {
												if((i==1)&&(wffieldinfo.isArray())){
													insertionOrderIdValue = rs.getString("InsertionOrderId");
												}
												
											} catch (Exception e) {
												printErr(engine,"", e);
											}
											memberflag = false;
											relationflag = false;
											String newMapKey = "";
											String key = (name + ":" + cmplxtablename + string21 + rsmd.getColumnName(i)).toUpperCase();
											String key2 = (name + ":" + queryTableName + string21 + rsmd.getColumnName(i)).toUpperCase();
											//WFSUtil.printOut("my key  " + key);
											while (itr3.hasNext()) { 	//chek whether containsValue cud be used
												mapval="";              //change for Bug Id-92653
												Map.Entry entry = (Map.Entry) itr3.next();
												if (!((((Object) entry.getValue()) instanceof LinkedHashMap))) {
													mapval = ((Object) entry.getValue()).toString();
												}
												mapkey = (String) entry.getKey();
												if ((key.equalsIgnoreCase(mapval))||(key2.equalsIgnoreCase(mapval))) {
													memberflag = true;
													WFSUtil.printOut(engine,"member flag" + memberflag);
													break;
												}

											}
											if((i==1)&&wffieldinfo.isArray()){
												if(insertionValueList==null){
													insertionValueList=new ArrayList();
												}
												insertionValueList.add(insertionOrderIdValue);
												insertionValueList.add(maxValue);
												insertionValueList.add(minValue);
											}
											if (memberflag) {
												WFSUtil.printOut(engine,mapkey + "  " + strValue);
												values = new ArrayList();
												values.add(strValue);
												myQryMemberMap.put(mapkey, values);
												myQryInsertionOrderIdMap.put(mapkey, insertionValueList);

											}
											if (myQryRelationMap.containsKey(key)) {
												// this case occurs for only arrays inside the strctr(wierd case)
												relationflag = true;
												newMapKey = key;
												WFSUtil.printOut(engine,mapkey + "  " + strValue);
												WFSUtil.printOut(engine,"array case relationflag" + relationflag);
												WFSUtil.printOut(engine,"PUTTING VALUE IN RELATION MAP" + newMapKey + "  " + strValue);
												type = rsmd.getColumnType(i);
												values = new ArrayList();
												//Bug 5128,5785
												if (strValue != null) {
													values.add(WFSUtil.TO_SQL((rs.getString(i)).trim(), type, dbType, true));
												} else {
													values.add(strValue);
												}
												myQryRelationMap.put(newMapKey, values);

											}
											//Bugzilla Bug Id 5130
											Iterator itr4 = myQryRelationMap.entrySet().iterator();
											while (itr4.hasNext()) {
												Map.Entry entry = (Map.Entry) itr4.next();
												mapkey = (String) entry.getKey();
												relmapkey = "";
												//WFSUtil.printOut("relation map keys-->" + mapkey);
												if (mapkey.indexOf(string25) != -1) {
													relmapkey = mapkey.substring(mapkey.indexOf(string25) + 1);
												//WFSUtil.printOut("modified map key-->" + relmapkey);
												}
											//	WFSUtil.printOut(engine,"key from loop is-->" + key);
												if (!relmapkey.equals("") && relmapkey.equals(key)) {
													relationflag = true;
													newMapKey = mapkey;
													WFSUtil.printOut(engine,"relationflag" + relationflag);
													WFSUtil.printOut(engine,"PUTTING VALUE IN RELATION MAP" + newMapKey + "  " + strValue);
													type = rsmd.getColumnType(i);
													//Bugzilla Bug 7241
													values = (ArrayList) myQryRelationMap.get(newMapKey);
													if (values == null) {
														values = new ArrayList();
													}
													//Bug 5128,5785
													if (strValue != null) {
														values.add(WFSUtil.TO_SQL((rs.getString(i)).trim(), type, dbType, true));
													} else {
														values.add(strValue);
													}
													myQryRelationMap.put(newMapKey, values);
												}
											}

											/*if(relationflag){
											WFSUtil.printOut("PUTTING VALUE IN RELATION MAP"+newMapKey+"  "+rs.getString(i));
											type = rsmd.getColumnType(i);
											values = new ArrayList();
											values.add(WFSUtil.TO_SQL((rs.getString(i)).trim(), type, dbType, true));
											myQryRelationMap.put(newMapKey,values);
											}*/

											i++;
											ctr--;
										}
										j++;
										//WFSUtil.printOut(engine,"5066 member map" + myQryMemberMap);
										//WFSUtil.printOut(engine,"5067 relation map" + myQryRelationMap);
										LinkedHashMap insertionOrderIdMap = new LinkedHashMap();
										if(myQryInsertionOrderIdMap.size()>0){
											insertionOrderIdMap =myQryInsertionOrderIdMap; 
										}
										LinkedHashMap[] maps = new LinkedHashMap[3];
										maps[0] = myQryMemberMap;
										maps[1] = myQryRelationMap;
										maps[2] = insertionOrderIdMap;

										mapvalues.add(maps);
										WFSUtil.printOut(engine,mapvalues);
									//valmap.put(wffieldinfo.getVariableId()+"#"+wffieldinfo.getVarFieldId(),values);

									}

                                                                    if (wffieldinfo.isArray() && batchSizeValue > 0) {
                                                                        Iterator itr = mapvalues.iterator();
                                                                        while (itr.hasNext()) {
                                                                            Object maps = itr.next();
                                                                            if (maps instanceof LinkedHashMap[]) {
                                                                                Object insertionOrderIdMap = ((LinkedHashMap[]) maps)[2];
                                                                                if (insertionOrderIdMap instanceof LinkedHashMap) {
                                                                                    for (Object oInsertionValueList : ((LinkedHashMap) insertionOrderIdMap).values()) {
                                                                                        if (oInsertionValueList instanceof ArrayList) {
                                                                                            ((ArrayList) oInsertionValueList).add(iTotalCount);
                                                                                            ((ArrayList) oInsertionValueList).add(iRetrievedCount);
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
								}
								//WFSUtil.printOut(engine,"no of times loop exec " + j + "map values" + mapvalues);
								WFSUtil.printOut(engine,"map Values size" + mapvalues.size());
								rs.close();
								rs = null;
								pstmt.close();
								pstmt = null;
							} else {
								mainflag = false;//primitive array inside complex
								WFSUtil.printOut(engine,"debug.. primitive array inside complex");
								WFSUtil.printOut(engine,query);
								pstmt = con.prepareStatement(query);
								pstmt.execute();
								rs = pstmt.getResultSet();
								rsmd = pstmt.getMetaData();
								arrayValue = null;
								insertionValueList= null;
								mapvalues = (ArrayList) valmap.get((wffieldinfo.getName()).toUpperCase());
								WFSUtil.printOut(engine,"debug.. map values size " + mapvalues.size());

								memberflag = false;
								relationflag = false;
								LinkedHashMap[] maps = (LinkedHashMap[]) mapvalues.get(m);
								LinkedHashMap myQryMemberMap = maps[0];
								LinkedHashMap myQryRelationMap = maps[1];
								LinkedHashMap myQryInsertionOrderIdMap =maps[2];
								WFSUtil.printOut(engine,"debug.. member map" + myQryMemberMap);
								WFSUtil.printOut(engine,"debug.. rel map" + myQryRelationMap);
								Iterator iter4 = myQryMemberMap.entrySet().iterator();
								String key = (name + ":" + cmplxtablename + string21 + rsmd.getColumnName(1)).toUpperCase();
								String key2 = (name + ":" + queryTableName + string21 + rsmd.getColumnName(1)).toUpperCase();
								WFSUtil.printOut(engine,"debug..  key in member map shud be " + key);
								//Bugzilla Bug Id 5130,5241
								while (iter4.hasNext()) {
									Map.Entry entry = (Map.Entry) iter4.next();
									if ((entry.getValue()!=null)&&!((((Object) entry.getValue())instanceof ArrayList))) {
										mymapval = ((Object) entry.getValue()).toString();
										mymapkey = (String) entry.getKey();
									}
									else if(entry.getValue()==null){
										mymapval="";
										mymapkey= (String) entry.getKey();
									}
									if ((key.equalsIgnoreCase(mymapval))||(key2.equalsIgnoreCase(mymapval))) {
										memberflag = true;
										WFSUtil.printOut(engine,"debug.. member flag was" + memberflag);
										WFSUtil.printOut(engine,"debug.. mapkey  was " + mymapkey);
										WFSUtil.printOut(engine,"debug.. mapval  was " + mymapval);
										break;
									}
								}

								if (rs != null) {
									while (rs.next()) {
										int iColumnType = rsmd.getColumnType(1);
										String strColumnName = rsmd.getColumnName(1);
										String strValue = "";
										String insertionOrderIdValue = "";
										//Changed for nText support Bug Id WFS_8.0_014
										try {
											if (JDBCTYPE_TO_WFSTYPE(iColumnType) == WFSConstant.WF_NTEXT) {
												Object[] obj = getBIGData(con, rs, strColumnName, dbType, DatabaseTransactionServer.charSet);
												strValue = (String) obj[0];
											} else {
												strValue = rs.getString(1);
											}
											if (strValue != null) {
												strValue = strValue.trim();
											}
										} catch (Exception e) {
											printErr(engine,"", e);
										}
										/*try {
												insertionOrderIdValue = rs.getString("InsertionOrderId");
												
										} catch (Exception e) {
											printErr(engine,"", e);
										}*/
										
										WFSUtil.printOut(engine,strValue);
										try {
											arrayValue = (ArrayList) myQryMemberMap.get(mymapkey);
										} catch (ClassCastException ex) {
											arrayValue = new ArrayList();
											myQryMemberMap.put(mymapkey, arrayValue);
										}
										arrayValue.add(strValue);//Add insertion order ids in new arrayList here.......Mohnish
										if(insertionValueList==null)
											insertionValueList=new ArrayList();
										//insertionValueList.add(insertionOrderIdValue);

									}
								}
								if (memberflag) {
									WFSUtil.printOut(engine,"debug.. array value  " + arrayValue);
									myQryMemberMap.put(mymapkey, arrayValue);//put insertion order id in new map here
									myQryInsertionOrderIdMap.put(mymapkey, insertionValueList);
									LinkedHashMap[] map1= (LinkedHashMap[])(mapvalues.get(m));
									map1[2].putAll(myQryInsertionOrderIdMap);
									
								}
								rs.close();
								rs = null;
								pstmt.close();
								pstmt = null;
							}
						} else {
							if (k == 0) {
								mainflag = true;
							}
						}
					}
                    if (mainflag) {
                        valmap.put((wffieldinfo.getName()).toUpperCase(), mapvalues);
                      //  WFSUtil.printOut(engine,"valmap is bieng modified  " + valmap);
                    } else {
                     //   WFSUtil.printOut(engine,"debug.. valmap is bieng modified  " + valmap);
                    }
                }
            }
            LinkedHashMap childInfoMap = wffieldinfo.getChildInfoMap();
          //  WFSUtil.printOut(engine,"[after one structure]" + wffieldinfo.getVariableId() + string21 + wffieldinfo.getVarFieldId());
         //   WFSUtil.printOut(engine,"checking child map" + childInfoMap);
            if (childInfoMap != null) {
                Iterator itr2 = childInfoMap.entrySet().iterator();
                while (itr2.hasNext()) {
                    Map.Entry entry = (Map.Entry) itr2.next();
                    WFFieldInfo childInfo = (WFFieldInfo ) entry.getValue();
                    if (childInfo.getWfType() == 11) { 
                        String childname = childInfo.getName() + string25 + name;
                        ArrayList batchInfoForComplexPresent = new ArrayList();
                        ArrayList values = (ArrayList) valmap.get((wffieldinfo.getName()).toUpperCase());
                        ListIterator iter2 = values.listIterator();
                        while (iter2.hasNext()) {
                            ArrayList batchInfoForChildComplex = new ArrayList();
                            batchInfoForChildComplex = (ArrayList) batchInfoForCurrentComplex.get(childInfo.getName().toUpperCase());
                        	LinkedHashMap[] maps = (LinkedHashMap[]) iter2.next();
                        	WFSUtil.printOut(engine,"calling again for child");
                        	if(batchInfoForChildComplex ==null||batchInfoForChildComplex .isEmpty()){
                        		batchInfoForChildComplex =batchInfo;	
                        	}
                        	else{
                        		HashMap batchInfoMapForChildComplex =  (HashMap)batchInfoForChildComplex.get(0);
                        		HashMap childMap = new HashMap();
                        		ArrayList batchInfoMapForChildList = new ArrayList();
                        		batchInfoMapForChildList.add(batchInfoMapForChildComplex);
                        		if(!batchInfoForComplexPresent.contains(childInfo.getName().toUpperCase())){
                        			childMap.put(childInfo.getName().toUpperCase(), batchInfoMapForChildList);
                            		batchInfoForComplexPresent.add(childInfo.getName().toUpperCase());
                            		//batchInfoForChildComplex .removeAll(batchInfoForChildComplex);
                            		batchInfoForChildComplex.clear();
                        		}
                        		batchInfoForChildComplex .add(childMap);
                        	}
                        	setValueInMap(con, dbType, qryMap, childInfo, childname, maps[0], maps[1], tablename, engine,batchInfoForChildComplex );
                        }
                    }
                }
            }
        } catch (SQLException e) {
            printErr(engine, "", e);
        //handle exception
        }
    //return valmap;
    }

    public static String getExternalData(String engine, int procDefId, String procInstID,
            int extObjId, String attrname) {
        Connection con = null;
        //<----------------------- Dinesh Parikh -------------------------------------->
        //com.newgen.omni.jts.srvr.JDBCConnectionPool.JTSConnection JTSConn = null;
        try {
            con = (Connection) NGDBConnection.getDBConnection(engine, "");
//      JTSConn = (com.newgen.omni.jts.srvr.JDBCConnectionPool.JTSConnection) NGDBConnection.
//          getDBConnection(engine, "");
//      con = JTSConn.conn;
            return (new XMLParser((String) (fetchAttributes(con, procInstID, 1, "", engine,
                    ServerProperty.getReference().getDBType(engine), new XMLGenerator(), attrname,
                    false, false)))).getValueOf("Value");
        } catch (JTSException ex) {
            return "";
        } finally {
            if (con != null) {
                try {
//          NGDBConnection.closeDBConnection(JTSConn.conn, "");
                    NGDBConnection.closeDBConnection(con, "");
                } catch (JTSException ex) {
                }
            }
        }
    }

    public static void setExternalData(String engine, int procDefId, String procInstID,
            int extObjId,
            String attrname, String attrValue, int type) {
        Connection con = null;
        //<----------------------- Dinesh Parikh -------------------------------------->
//    com.newgen.omni.jts.srvr.JDBCConnectionPool.JTSConnection JTSConn = null;
        try {
            con = (Connection) NGDBConnection.getDBConnection(engine, "");
//      JTSConn = (com.newgen.omni.jts.srvr.JDBCConnectionPool.JTSConnection) NGDBConnection.
//          getDBConnection(engine, "");
//      con = JTSConn.conn;
            HashMap ipattr = new HashMap(1, 10F);
            ipattr.put(attrname.toUpperCase(), new WMAttribute(attrname, attrValue, type));
            setAttributes(con, null, ipattr, engine, procInstID, 1, new XMLGenerator(), null);
        } catch (JTSException ex) {
        } finally {
            if (con != null) {
                try {
                    NGDBConnection.closeDBConnection(con, "");
//          NGDBConnection.closeDBConnection(JTSConn.conn, "");
                } catch (JTSException ex) {
                }
            }
        }
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 			:	genLog
//	Date Written (DD/MM/YYYY):	16/05/2002
//	Author					:	Prashant
//	Input Parameters		:	Connection , procDefId, processInst, activityId, actName, actionId , userID, fieldID ,  fieldName , comments
//	Output Parameters		:   none
//	Return Values			:	String
//	Description				:   enters Logging information of a given event .
//----------------------------------------------------------------------------------------------------
    public static void genLogTime(String engineName, Connection con, int procDefId,
            String processInst,
            int activityId, String actName, int actionId, int userID,
            int fieldID,
            int workItemId, String userName, String date) throws SQLException {
        ResultSet rs = null;
        Statement stmt = null;
        PreparedStatement pstmt = null;
        boolean commit = false;
        StringBuffer tempXml = new StringBuffer(100);
        int dbType = ServerProperty.getReference().getDBType(engineName);
        try {
            //String date1 = new java.text.SimpleDateFormat("yyyy-MM-dd H:mm:ss", Locale.US).format(new java.util.Date());
        	String date1 = dbDateTime(con, dbType); //Bug#70680 to fix the discripencies related to diference in time

        	String datediff = WFSUtil.DATEDIFF(WFSConstant.WFL_ss, date, WFSUtil.getDate(dbType), dbType);
            // Bug # WFS_6_009, causing NullPointerException if input is null....
            if (datediff != null) {
                datediff = replace(datediff, "'", "''");
            }
//			XMLGenerator gen = (XMLGenerator) generatorPool.checkOut();
            XMLGenerator gen = new XMLGenerator();
            tempXml.append("<Message>");
            tempXml.append(gen.writeValueOf("ActionId", String.valueOf(actionId)));
            tempXml.append(gen.writeValueOf("UserId", String.valueOf(userID)));
            tempXml.append(gen.writeValueOf("ProcessDefId", String.valueOf(procDefId)));
            tempXml.append(gen.writeValueOf("ActivityId", String.valueOf(activityId)));
            tempXml.append(gen.writeValueOf("QueueId", "0"));
            tempXml.append(gen.writeValueOf("UserName", userName));
            tempXml.append(gen.writeValueOf("ActivityName", actName));
            tempXml.append(gen.writeValueOf("TotalWiCount", "0"));
            tempXml.append(gen.writeValueOf("TotalDuration", "0"));
            tempXml.append(gen.writeValueOf("ActionDateTime", date1));
            tempXml.append(gen.writeValueOf("EngineName", engineName));
            tempXml.append(gen.writeValueOf("ProcessInstance", processInst));
            tempXml.append(gen.writeValueOf("FiledId", String.valueOf(fieldID)));
            tempXml.append(gen.writeValueOf("FieldName", datediff));
            tempXml.append(gen.writeValueOf("WorkitemId", String.valueOf(workItemId)));
            tempXml.append(gen.writeValueOf("TotalPrTime", "0"));
            tempXml.append(gen.writeValueOf("DelayTime", "0"));
            tempXml.append(gen.writeValueOf("WKInDelay", "0"));
            tempXml.append(gen.writeValueOf("ReportType", "D"));
            tempXml.append(gen.writeValueOf("Flag", "1"));
            tempXml.append("</Message>");
            /** *****************************************************************************
             *	Changed By  : Ruhi Hira
             *  Changed On  : 04/05/2005
             *  Description : Bug # WFS_6_013 , DataType changed for Message in WFMessageTable.
             *******************************************************************************/
            if ((dbType == JTSConstant.JTS_MSSQL) || (dbType == JTSConstant.JTS_DB2) || (dbType == JTSConstant.JTS_POSTGRES)) {
                // Changed By Varun Bhansaly 0n 08/02/2007 for Bugzilla Bug 74
                pstmt = con.prepareStatement("Insert into WFMessageTable (message, status, ActionDateTime) Values ( ?, " + WFSUtil.TO_STRING("N", true, dbType) + ", " + getDate(dbType) + ")");
                pstmt.setCharacterStream(1, new java.io.StringReader(tempXml.toString()), tempXml.toString().length());
                pstmt.execute();
                pstmt.close();
            } else if (dbType == JTSConstant.JTS_ORACLE) {
                String messageId = "0";
                stmt = con.createStatement();
                if (con.getAutoCommit()) {
                    con.setAutoCommit(false);
                    commit = true; //mean yah per false kiya gaya hai.

                }
                messageId = nextVal(con, "seq_messageId", dbType);
                // Changed By Varun Bhansaly 0n 08/02/2007 for Bugzilla Bug 74
                stmt.execute("Insert into WFMessageTable (messageId, message, status, ActionDateTime) Values ( " + WFSUtil.TO_SANITIZE_STRING(messageId,false) + ", EMPTY_CLOB(), " + WFSUtil.TO_STRING("N", true, dbType) + ", " + getDate(dbType) + ")");
                writeOracleCLOB(con, stmt, "WFMessageTable", "message", "messageId = " + messageId, tempXml.toString());
                if (commit && !con.getAutoCommit()) {
                    con.commit();
                    con.setAutoCommit(true);
                    commit = false;	//Bugzilla Bug 1671

                }
            }
        } catch (SQLException e) {
            printErr(engineName,"", e);
        } catch (Exception e) {
            printErr(engineName,"", e);
        } // WFS_6_004, Statement closed in finally.
        finally {
            try {
                if (commit && !con.getAutoCommit()) {
                    con.rollback();
                    con.setAutoCommit(true);
                }
            } catch (Exception ignored) {
            }
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
            } catch (Exception ignored) {
            }
        }
    }

    public static String generateRandomPattern(int percent, int radix) {
        BigInteger b = BigInteger.ZERO;
        java.security.SecureRandom randomizer = new java.security.SecureRandom();
        randomizer.setSeed(System.currentTimeMillis());
        b = b.setBit(20);
        while (b.bitCount() != ((percent/5) + 1)) {
            b = b.setBit(randomizer.nextInt(20));
        }
        return b.toString(radix);
    }

    public static StringBuffer readLargeString(Reader reader) throws IOException {
//ODBC cannot return string more than 30 character length
//therefore we employ this method to read in large strings
        char[] buf = null;
        StringBuffer strBuf = null;

        if (reader != null) {
            strBuf = new StringBuffer();
            buf = new char[2048];
            while (true) {
                int size = reader.read(buf);
                if (size > 0) {
                    strBuf.append((new String(buf)).trim());
                } else {
                    break;
                }
            }
            reader.close();
        }
        return strBuf;
    }
    
//----------------------------------------------------------------------------------------------------
//	Function Name 			:	DB_SetString
//	Date Written (DD/MM/YYYY):	16/05/2002
//	Author					:	Krishan
//	Input Parameters		:	Pos,value,pstmt,dbType
//	Output Parameters		:   none
//	Return Values			:	none
//	Description				:   Set string for prepared statement depending on datatype.
//----------------------------------------------------------------------------------------------------

    public static void DB_SetString(int pos, String value, PreparedStatement pstmt, int dbType) throws SQLException {

        if (dbType == JTSConstant.JTS_ORACLE) {
            if (value == null || value.equals("")) {
                pstmt.setNull(pos, java.sql.Types.CHAR);
            } else {
                //Ashish modified for added for Jboss
                if (pstmt instanceof oracle.jdbc.OraclePreparedStatement) {
            ((oracle.jdbc.OraclePreparedStatement) pstmt).setFormOfUse(pos, oracle.jdbc.driver.OraclePreparedStatement.FORM_NCHAR);
                //} else if (pstmt instanceof org.jboss.resource.adapter.jdbc.WrappedPreparedStatement) {	//Bugzilla Bug 267
                } else if (pstmt.getClass().getName().equals("org.jboss.resorce.adapter.jdbc.WrappedPreparedStatement")) {	//Bugzilla Bug 267

            ((oracle.jdbc.OraclePreparedStatement) ((org.jboss.resource.adapter.jdbc.WrappedPreparedStatement) pstmt).getUnderlyingStatement()).setFormOfUse(pos, oracle.jdbc.driver.OraclePreparedStatement.FORM_NCHAR);
                }
                pstmt.setString(pos, value);
            }
        } else {
            if (value == null || value.equals("")) {
                pstmt.setNull(pos, java.sql.Types.CHAR);
            } else {
                pstmt.setString(pos, value);
            }
        }
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 			:	genDMSLog
//	Date Written			:	28/07/2004
//	Author					:	Dinesh Parikh
//	Description				:   enters Logging information for DMS related operation
//----------------------------------------------------------------------------------------------------
    public static void genDMSLog(String engineName, Connection con, int actionIndex, String category, int objectIndex, String objectType, String comment, int userIndex) throws SQLException {
        PreparedStatement pstmt = null;
        try {
            int dbType = ServerProperty.getReference().getDBType(engineName);
            pstmt = con.prepareStatement(" Insert into PDBNewAuditTrail_Table(ActionId, Category, ActiveObjectId, ActiveObjectType, Comment, DateTime, UserIndex) values (?,?,?,?,?," + WFSUtil.getDate(dbType) + ",?)");
            pstmt.setInt(1, actionIndex);
            WFSUtil.DB_SetString(2, category, pstmt, dbType);
            pstmt.setInt(3, objectIndex);
            WFSUtil.DB_SetString(4, objectType, pstmt, dbType);
            WFSUtil.DB_SetString(5, comment, pstmt, dbType);
            pstmt.setInt(6, userIndex);
            pstmt.execute();
            pstmt.close();
            pstmt = null;
        } catch (SQLException e) {
            printErr(engineName,"", e);
        } finally {
            try {
                if (pstmt != null) {
                    pstmt.close();
                }
            } catch (Exception e) {
            }
        }
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 			:	checkRights
//	Date Written (DD/MM/YYYY):	05/08/2004
//	Author					:	Krishan
//	Input Parameters		:	con , objectType,objectName, cabinetName,sessionID
//	Output Parameters		:   none
//	Return Values			:	boolean
//	Description				:   Check rights for a user on some object(Queue/Process) .
//----------------------------------------------------------------------------------------------------
// Changed by				: Ashish Mangla
// Changed on				: 16/05/2005
// Description				: CacheTime related changes / removal of thread, no static hashmap.
//----------------------------------------------------------------------------------------------------
    public static boolean checkRights(Connection con, char objectType, String objectName, XMLParser parser, XMLGenerator gen, StringBuffer docId, String rightsFlag) throws JTSException {
        int sessionID = parser.getIntOf("SessionId", 0, false);
        String cabinetName = parser.getValueOf("EngineName", "", false);
        try {
            String folderId = "0";
            StringBuffer strBuff = new StringBuffer(100);
            switch (objectType) {
                case 'P':
                    folderId = (String) CachedObjectCollection.getReference().getCacheObject(con, cabinetName, 0, WFSConstant.CACHE_CONST_CabinetPropertyCache, "ProcessFolder").getData();
                    break;

                case 'Q':
                    folderId = (String) CachedObjectCollection.getReference().getCacheObject(con, cabinetName, 0, WFSConstant.CACHE_CONST_CabinetPropertyCache, "QueueFolder").getData();
                    break;
				case 'T':
                    folderId = (String) CachedObjectCollection.getReference().getCacheObject(con, cabinetName, 0, WFSConstant.CACHE_CONST_CabinetPropertyCache, "OTMS").getData();
                    break;	
                default:
                    folderId = (String) CachedObjectCollection.getReference().getCacheObject(con, cabinetName, 0, WFSConstant.CACHE_CONST_CabinetPropertyCache, "QueueFolder").getData();
                    break;
            }

            if (Integer.parseInt(folderId) == 0) {
                throw new JTSException(WFSError.WFS_NORIGHTS, WFSErrorMsg.getMessage(WFSError.WFS_NORIGHTS));
            } else {
                strBuff = new StringBuffer("<?xml version=\"1.0\"?><NGOGetIDFromName_Input><Option>NGOGetIDFromName</Option><CabinetName>");
                strBuff.append(cabinetName);
                strBuff.append("</CabinetName><UserDBId>");
                strBuff.append(sessionID);
                strBuff.append("</UserDBId><ObjectName>");
                strBuff.append(objectName);
                strBuff.append("</ObjectName><ObjectType>");
                strBuff.append("D</ObjectType><Index>");
                strBuff.append(folderId);
                strBuff.append("</Index><CreatedByAppName>txt</CreatedByAppName></NGOGetIDFromName_Input>");
                parser.setInputXML(strBuff.toString());
                parser.setInputXML(com.newgen.omni.jts.srvr.WFFindClass.getReference().execute("NGOGetIDFromName", cabinetName, con, parser, gen));
                String status = parser.getValueOf("Status");

                if (status.equals("0")) {	//Bugzilla Bug 7226 (JTSException was being thrown in case doc not found)

                    if (docId != null) {
                        docId.append(parser.getValueOf("ObjectIndex"));
                    }
                    if (rightsFlag.substring(2).indexOf("1") != -1) {
                        strBuff = new StringBuffer("<?xml version=\"1.0\"?><NGOGetDocumentProperty_Input><Option>NGOGetDocumentProperty</Option><CabinetName>");
                        strBuff.append(cabinetName);
                        strBuff.append("</CabinetName><UserDBId>");
                        strBuff.append(sessionID);
                        strBuff.append("</UserDBId><DocumentIndex>");
                        strBuff.append(parser.getValueOf("ObjectIndex"));
                        strBuff.append("</DocumentIndex><ParentFolderIndex>");
                        strBuff.append(folderId);
                        strBuff.append("</ParentFolderIndex><DataAlsoFlag>");
                        strBuff.append("N</DataAlsoFlag></NGOGetDocumentProperty_Input>");
                        parser.setInputXML(strBuff.toString());
                        parser.setInputXML(com.newgen.omni.jts.srvr.WFFindClass.getReference().execute("NGOGetDocumentProperty", cabinetName, con, parser, gen));
                        status = parser.getValueOf("Status");
                        if (status.equals("0")) //LoginUserRights
                        {
                            return compareRights(rightsFlag, parser.getValueOf("LoginUserRights"));
                        } else {
                            return false;
                        }
                    }
                    return true;
                } else {
                    return false;
                }
            }
        } catch (Exception e) {
            printErr(cabinetName,"", e);
            return false;
        }
//			return true;
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 			:	compareRights
//	Date Written (DD/MM/YYYY):	05/08/2004
//	Author					:	Krishan
//	Input Parameters		:	rights , checkStr
//	Output Parameters		:   none
//	Return Values			:	boolean
//	Description				:   Compare the rights
//----------------------------------------------------------------------------------------------------
    public static boolean compareRights(String checkStr, String userRights) {
        boolean rights = false;
        if (checkStr.length() < 6) {
            while (checkStr.length() < 6) {
                checkStr += "0";
            }
        }
        if (userRights.length() < 6) {
            while (userRights.length() < 6) {
                userRights += "0";
            }
        }
        int pos;
        while ((pos = checkStr.indexOf("1")) != -1) {
            if (userRights.substring(pos, pos + 1).equals("1")) {
                rights = true;
            } else {
                rights = false;
                break;
            }
            checkStr = checkStr.substring(pos + 1);
            userRights = userRights.substring(pos + 1);
        }
        return rights;
    }

//-----------------------------------------------------------------------------------------------------------
//	Function Name 				:	updateLastModifiedTime
//	Date Written (DD/MM/YYYY)	:	13/08/2004
//	Author						:	Ruhi Hira
//	Input Parameters			:	con, engineName
//	Return Values				:	none
//	Description					:   Update cabinets last modified time that from database in ServerProperty
//-----------------------------------------------------------------------------------------------------------
    /**
     * Method commented as not required, cant remove as used by wrapper, causes NPE - Ruhi Hira
     */
    public static void updateLastModifiedTime(Connection con, String engineName) {
//        Date lastModifiedTime = null;
//        Statement stmt = null;
//        ResultSet rs = null;
//        String date_text = null;
//        try {
//            stmt = con.createStatement();
//            rs = stmt.executeQuery("Select max(lastModifiedOn) From ProcessDefTable");
//            if (rs != null && rs.next()) {
//                date_text = rs.getString(1);
//                lastModifiedTime = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US).parse(date_text);
//            }
//        }
//        catch (Exception ex) {
//            printErr("", ex);
//        }
//        finally {
//            try {
//                if (rs != null) {
//                    rs.close();
//                    rs = null;
//                }
//                if (stmt != null) {
//                    stmt.close();
//                    stmt = null;
//                }
//            }
//            catch (SQLException ignored) {
//                printErr("", ignored);
//            }
//        }
//        if (lastModifiedTime == null)
//            lastModifiedTime = new Date();
//        ServerProperty.getReference().setLastModifiedTime(engineName.trim().toUpperCase(), lastModifiedTime);
    }

    /**
     * Bug # WFS_6.1.2_049,
     * Code inconsitent,
     * modified so as to make it same as in WMUser - Ruhi Hira
     */
    public static String getFormattedString(String string){
    	String newStr = string;
        return newStr;
   }
    public static WFParticipant WFCheckSession(Connection con, int sessionId) throws SQLException {
        WFParticipant wfPt = null;
        PreparedStatement pstmt = null;
		PreparedStatement pstmt1 = null;
        ResultSet rs = null;
		ResultSet rs1 = null;
		boolean isExist = false;
		boolean isPSFlag = false;
		String queryStr = null;		
		String databaseType = null;
		String tableLockStr = null;
        try {
			java.sql.DatabaseMetaData dbMetaData = con.getMetaData();
			databaseType = dbMetaData.getDatabaseProductName();
			if(databaseType.contains("Microsoft")){
				tableLockStr = " WITH (NOLOCK) ";
			} else {
				tableLockStr = "";
			}			
			queryStr = "Select UserID ,  null as UserName , 'U' as ParticipantType , Scope, Locale from " + " WFSessionView " + tableLockStr + " where SessionID = ?";				
			pstmt = con.prepareStatement(queryStr);						
            pstmt.setInt(1, sessionId);            
            pstmt.execute();
            rs = pstmt.getResultSet();						
			if (rs.next()) {
				isExist = true;
			} else {
				if(rs != null){
					rs.close();
					rs = null;
				}
				if(pstmt != null){
					pstmt.close();
					pstmt = null;
				}
				queryStr = "Select PSReg.PSID as UserId  , " + " PSReg.PSName as UserName , PSReg.Type as ParticipantType , 'ADMIN' as Scope, null as Locale, PSReg.Data as Data from PSRegisterationTable PSReg " + tableLockStr + ", WFPSConnection PSCon " + tableLockStr + " where PSCon.SessionID = ? and PSReg.PSID = PSCon.PSID ";
				pstmt = con.prepareStatement(queryStr);						
				pstmt.setInt(1, sessionId);            
				pstmt.execute();
				rs = pstmt.getResultSet();
				if (rs.next()) {
					isExist = true;
				} 	
			}
			
            /* WFS_5_161, MultiLingual Support (Inherited from 5.0), 05/06/2007 - Ruhi Hira */			
            if (isExist) {
				int userIndex = Integer.parseInt(getFormattedString(Integer.toString(rs.getInt(1))));
				String userName = getFormattedString(rs.getString(2));
				char participantType = getFormattedString(rs.getString(3)).charAt(0);
				String scope = getFormattedString(rs.getString(4));
				String locale = getFormattedString(rs.getString("Locale"));
				int parentIndex = 0;
				if(locale!=null && locale.indexOf('-') != -1){
					locale = locale.replace('-', '_');
				}
				if(participantType == 'U'){										
					pstmt1 = con.prepareStatement("Select UserName, ParentGroupIndex from PDBUser where UserIndex = ?");
					pstmt1.setInt(1, userIndex);
					pstmt1.execute();
					rs1 = pstmt1.getResultSet();
					if (rs1.next()) {
						userName = getFormattedString(rs1.getString(1));
						parentIndex = Integer.parseInt(getFormattedString(Integer.toString(rs1.getInt(2))));
					}										
					if(rs1 != null){
						rs1.close();
						rs1 = null;
					}
					if(pstmt1 != null){
						pstmt1.close();
						pstmt1 = null;
					}										
				} 
				else {
					isPSFlag = ("PROCESS SERVER").equalsIgnoreCase(getFormattedString(rs.getString("Data")));
				}
				wfPt = new WFParticipant(userIndex, userName, participantType,
                        scope, locale);
				wfPt.setPSFlag(isPSFlag);
				if(parentIndex > 0) {
					wfPt.setParentGroupIndex(parentIndex);
				}
						
            }		
			
            if (rs != null) {	//Bugzilla Bug 368

                rs.close();
                rs = null;
            }
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (Exception ee) {
            }
			try {                
				if(rs1 != null){
					rs1.close();
					rs1 = null;
				}
            } catch (Exception ee) {
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
            } catch (Exception ee) {
            }
			try {                
				if(pstmt1 != null){
					pstmt1.close();
					pstmt1 = null;
				}									
            } catch (Exception ee) {
            }
        }
        return wfPt;
    }

    //----------------------------------------------------------------------------------------------------
    //	Function Name 				:	insertInWFJMSMessageTable
    //	Author						:	Virochan
    //  Date						:	27/12/2005
    //	Input Parameters			:	JMSMessage, destination, engineName
    //	Output Parameters			:   none
    //	Return Values				:	void
    //	Description					:   Inserts Message in WFJMSMEssageTable of appropriate cabinet/engine name
    //----------------------------------------------------------------------------------------------------
    public static boolean insertInWFJMSMessageTable(String jmsMessage, String destination, String engineName) {
        Statement stmt = null;
        ResultSet rs = null;
        PreparedStatement pstmt = null;
        Connection conn = null;
        String destinationType = null;
        boolean commit = false;
        java.io.Writer dataWriter = null;
        boolean successful = true; //true if insertion in wfjmsmessagetable is successful

        String entryDateTime = null;
        try {
            int dbType = ServerProperty.getReference().getDBType(engineName);
            conn = (Connection) NGDBConnection.getDBConnection(engineName, null);

            //WFS_6.1.2_035 JMS Message will be inserted by the MDB with entrydatetime = 2min + currendatetime of database server.
            if (destination.equalsIgnoreCase("NewgenCreate")) {
                destinationType = "C";
                entryDateTime = WFSUtil.getDate(dbType);
            } //WFS_6.1.2_001 New destination type "O" added Although backward compatibility is still there sas destination type "C" is also defined.
            else if (destination.equalsIgnoreCase("WFWSResQueue")) {
                destinationType = "O";
                entryDateTime = DATEADD(WFSConstant.WFL_mi, "2", WFSUtil.getDate(dbType), dbType);
            } else {
                destinationType = "S";
                entryDateTime = DATEADD(WFSConstant.WFL_mi, "2", WFSUtil.getDate(dbType), dbType);
            }

            if (dbType == JTSConstant.JTS_ORACLE) {
                String messageId = "0";
                stmt = conn.createStatement();
                if (conn.getAutoCommit()) {
                    conn.setAutoCommit(false);
                    commit = true; //Commit is used either to rollback or commit a transaction.

                }

                messageId = nextVal(conn, "JMSMessageId", dbType);
                stmt.execute("Insert Into WFJMSMessageTable (messageId, message, destination, entrydatetime, operationtype) Values ( " + WFSUtil.TO_SANITIZE_STRING(messageId,false) + ", EMPTY_CLOB(), " + WFSUtil.TO_STRING(destination, true, dbType) + "," + entryDateTime + "," + WFSUtil.TO_STRING(destinationType, true, dbType) + ")");
                writeOracleCLOB(conn, stmt, "WFJMSMessageTable", "message", "messageId = " + messageId, jmsMessage);
                //If commit is true and no exception has been generated then database commit is executed.
                if (commit && !conn.getAutoCommit()) {
                    conn.commit();
                    conn.setAutoCommit(true);
                }
            } else {
                pstmt = conn.prepareStatement("Insert into WFJMSMessageTable (message, destination, entrydatetime, operationtype) Values (?," + WFSUtil.TO_STRING(destination, true, dbType) + "," + entryDateTime + "," + WFSUtil.TO_STRING(destinationType, true, dbType) + ")");
                pstmt.setCharacterStream(1, new java.io.StringReader(jmsMessage), jmsMessage.length());
                pstmt.execute();
                pstmt.close();
            }
        } catch (SQLException e) {
            successful = false; //false if insertion in wfjmsmessagetable is NOT successful

            printErr(engineName,"", e);
        } catch (Exception e) {
            successful = false; //false if insertion in wfjmsmessagetable is NOT successful

            printErr(engineName,"", e);
        } finally {
            //WFS_6.1.2_003. House keeping statements are properly ordered.
            try {
                if (!successful) {
                    writeLog(jmsMessage, engineName, destination);
                }
            } catch (Exception ignored) {
            }
            //WFS_6.1.2_002. CLob writer is closed.
            try {
                if (dataWriter != null) {
                    dataWriter.close();
                    dataWriter = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (commit && !conn.getAutoCommit()) {
                    conn.rollback();
                    conn.setAutoCommit(true);
                }
            } catch (Exception ignored) {
            }
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (conn != null) {
                    NGDBConnection.closeDBConnection(conn, null);
                    conn = null;
                }
            } catch (Exception ignored) {
            }
        }
        return successful;
    }

    //----------------------------------------------------------------------------------------------------
    //	Function Name 				:	generateLog
    //	Author						:	Virochan
    //  Date						:	03/12/2005
    //	Input Parameters			:	fileName, dataToDump, miscInfo, messageType
    //	Output Parameters			:   none
    //	Return Values				:	void
    //	Description					:   Generate log in the file FailedJMSMessages.log
    //----------------------------------------------------------------------------------------------------
    public static void generateLog(String fileName, String dataToDump, String miscInfo, String messageType) {
    	RandomAccessFile logFile=null;
    	try {
            java.io.File file = new java.io.File(fileName);
             logFile = new RandomAccessFile(file, "rw");
            logFile.seek(logFile.length());
            String date = new java.text.SimpleDateFormat("yyyy-MM-dd H:mm:ss", Locale.US).format(new java.util.Date());

            if (miscInfo == null) {
                miscInfo = "";
            }
            String messageInformation = "Time:" + date + " MessageType:" + messageType + " MessageInfo:" + miscInfo +
                    " Message:" + dataToDump + "\n";
            logFile.write(messageInformation.getBytes());
            logFile.close();
            logFile=null;
        } catch (IOException ioex) {
//            printOut("Log File Error");
//            printErr(Level.DEBUG,"", ioex);
        }finally{
        	try{
        		if(logFile!=null){
        			logFile.close();
        			logFile=null;
        		}
        	}catch(Exception ignore){
        		
        	}
        }
    }


    //----------------------------------------------------------------------------------------------------
    //	Function Name 				:	TO_SQL_EXT
    //	Author						:	Ashish Mangla
    //  Date						:	02/02/2006
    //	Input Parameters			:	value, jdbcType, dbType
    //	Output Parameters			:   none
    //	Return Values				:	string
    //	Description					:   converts the value to a string that can be passed in sql query (like enclosing string in ')
    //----------------------------------------------------------------------------------------------------
    public static String TO_SQL_EXT(String value, int jdbcType, int dbType) throws JTSException {
        String newLastValule = null;
        int type = JDBCTYPE_TO_WFSTYPE(jdbcType); //SrNo-9

        newLastValule = WFSUtil.TO_SQL(value, type, dbType, true);
        return newLastValule;
    }
    //----------------------------------------------------------------------------------------------------
    //	Function Name 				:	JDBCTYPE_TO_WFSTYPE
    //	Author						:	Shilpi Srivastava
    //  Date						:	23/11/2007
    //	Input Parameters			:	jdbcType
    //	Output Parameters			:   wfstype
    //	Return Values				:	int
    //	Description					: SrNo-9,  converts jdbc datatype to wfs datatype
    //----------------------------------------------------------------------------------------------------

    public static int JDBCTYPE_TO_WFSTYPE(int jdbcType) {
        int type;

        switch (jdbcType) {
            case java.sql.Types.VARCHAR:
            case java.sql.Types.CHAR: {

                type = WFSConstant.WF_STR;
                break;
            }
            case java.sql.Types.LONGVARCHAR: {

                type = WFSConstant.WF_NTEXT;
                break;
            }
			case -16 : {

                type = WFSConstant.WF_NTEXT;
                break;
            }
            case java.sql.Types.TIMESTAMP:
            case java.sql.Types.TIME:
            case java.sql.Types.DATE: {

                type = WFSConstant.WF_DAT;
                break;
            }

            case java.sql.Types.SMALLINT:
            case java.sql.Types.TINYINT: {

                type = WFSConstant.WF_INT;
                break;
            }

            case java.sql.Types.INTEGER:
            case java.sql.Types.BIGINT: {

                type = WFSConstant.WF_LONG;
                break;
            }

            case java.sql.Types.FLOAT:
            case java.sql.Types.REAL:
            case java.sql.Types.DOUBLE:
            case java.sql.Types.NUMERIC:
            case java.sql.Types.DECIMAL: {

                type = WFSConstant.WF_FLT;
                break;
            }
            case java.sql.Types.BOOLEAN: {
                type = WFSConstant.WF_BOOLEAN;
                break;
            }

            default: {
                type = WFSConstant.WF_STR;
            }
        }

        return type;
    }


    //----------------------------------------------------------------------------------------------------
    //	Function Name 				:	getReportGroupBy (for SrNo-3. Hourly Report Support)
    //	Author						:	Ashish Mangla
    //  Date						:	10/05/2006
    //	Input Parameters			:	repType
    //	Output Parameters			:   none
    //	Return Values				:	string
    //	Description					:   returns the string for from range, to range for different reports...
    //----------------------------------------------------------------------------------------------------
    public static WFReportInfo getReportGroupBy(char repType, int dbType, String columnName) {
        String datepart = "";
        String datefromPart = "";
        String datetoPart = "";

        switch (dbType) {
            case JTSConstant.JTS_POSTGRES: {
                int unit = 0;
                switch (repType) {
                    case 'H':
                        unit = WFSConstant.WFL_hh;
                        break;
                    case 'D':
                        unit = WFSConstant.WFL_dy;
                        break;
                    case 'W':
                        unit = WFSConstant.WFL_wk;
                        break;
                    case 'M':
                        unit = WFSConstant.WFL_mm;
                        break;
                    case 'Q':
                        unit = WFSConstant.WFL_qq;
                        break;
                    case 'Y':
                        unit = WFSConstant.WFL_yy;
                        break;
                }
                datepart = DATEPART(unit, columnName, dbType);
                datefromPart = postgresDateTrunc(unit, columnName);
                datetoPart = postgresDateCeil(unit, columnName);
                break;
            }
            default: {
                String sYearPart = DATENAME(WFSConstant.WFL_yy, columnName, dbType);

                switch (repType) {
                    case 'H':
                        datepart = DATEPART(WFSConstant.WFL_hh, columnName, dbType);
                        datefromPart = DATEADD(WFSConstant.WFL_hh, datepart, DATEADD(WFSConstant.WFL_dy, DATEPART(WFSConstant.WFL_dy, columnName, dbType) + "-1", sYearPart, dbType), dbType);
                        datetoPart = DATEADD(WFSConstant.WFL_ss, "59", DATEADD(WFSConstant.WFL_mi, "59", datefromPart, dbType), dbType);
                        break;

                    case 'D':
                        datepart = DATEPART(WFSConstant.WFL_dy, columnName, dbType);
                        datefromPart = DATEADD(WFSConstant.WFL_dy, datepart + "-1", sYearPart, dbType);
                        datetoPart = DATEADD(WFSConstant.WFL_dy, datepart, sYearPart, dbType) + (dbType == JTSConstant.JTS_DB2 ? "-1 days" : " -1");
                        break;

                    case 'W':
                        //				if(dbType == JTSConstant.JTS_MSSQL)
                        //				{
                        datepart = DATEPART(WFSConstant.WFL_wk, columnName, dbType);
                        datefromPart = DATEADD(WFSConstant.WFL_wk, "(" + datepart + "-1)", DATEADD(WFSConstant.WFL_dd, "1-" + DATEPART(WFSConstant.WFL_dw, sYearPart, dbType), sYearPart, dbType), dbType);
                        datetoPart = DATEADD(WFSConstant.WFL_wk, "(" + datepart + "-1)", DATEADD(WFSConstant.WFL_dd, " 7-" + DATEPART(WFSConstant.WFL_dw, sYearPart, dbType), sYearPart, dbType), dbType);
                        /*				}
                        else if(dbType == JTSConstant.JTS_ORACLE)
                        {
                        datepart =  " to_number ( to_char(" + columnName + ",  'iw'),  '999999') ";
                        datefromPart = "next_day (to_date(to_char(" + columnName + ", 'YYYY-MM-DD'), 'YYYY-MM-DD') - 7, 'Monday')";
                        datetoPart = "next_day (to_date(to_char(" + columnName + ", 'YYYY-MM-DD'), 'YYYY-MM-DD') , 'sunday')";
                        }*/
                        break;
                    case 'M':
                        datepart = DATEPART(WFSConstant.WFL_mm, columnName, dbType);
                        datefromPart = DATEADD(WFSConstant.WFL_mm, datepart + "-1", sYearPart, dbType);
                        datetoPart = DATEADD(WFSConstant.WFL_mm, datepart, sYearPart, dbType) + (dbType == JTSConstant.JTS_DB2 ? "-1 days" : " -1");
                        break;

                    case 'Q':
                        datepart = DATEPART(WFSConstant.WFL_qq, columnName, dbType);
                        datefromPart = DATEADD(WFSConstant.WFL_qq, "(" + datepart + "-1)", sYearPart, dbType);
                        datetoPart = DATEADD(WFSConstant.WFL_qq, datepart, sYearPart, dbType) + (dbType == JTSConstant.JTS_DB2 ? "-1 days" : " -1");
                        break;

                    case 'Y':
                        datepart = DATEPART(WFSConstant.WFL_yy, columnName, dbType);
                        datefromPart = DATEADD(WFSConstant.WFL_yy, "0", sYearPart, dbType);
                        datetoPart = DATEADD(WFSConstant.WFL_yy, "1", sYearPart, dbType) + (dbType == JTSConstant.JTS_DB2 ? "-1 days" : " -1");
                        break;
                }
            }
        }
        return new WFReportInfo(datepart, datefromPart, datetoPart);
    }

    /**
     * *************************************************************
     * Function Name    :   DB_LEN
     * Programmer' Name :   Ruhi Hira
     * Date Written     :   June 28th 2006
     * Input Parameters :   String input string,
     *                      int dbType
     * Output Parameters:   NONE
     * Return Value     :   String -> length function specific to database
     * Description      :   Length function specific to database
     * *************************************************************
     */
    public static String DB_LEN(String in, int dbType) {
        String retStr = null;
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                retStr = " len(" + in + ") ";
                break;
            case JTSConstant.JTS_DB2:
            case JTSConstant.JTS_ORACLE:
            case JTSConstant.JTS_POSTGRES:
            default:
                retStr = " length(" + in + ") ";
        }
        return retStr;
    }

    /**
     * *************************************************************
     * Function Name    :   getLockSuffixStr
     * Programmer' Name :   Ruhi Hira
     * Date Written     :   June 28th 2006
     * Input Parameters :   int -> dbType
     * Output Parameters:   NONE
     * Return Value     :   String -> suffix string for database lock
     * Description      :   Query suffix string for locking row
     *                      in Database
     * *************************************************************
     */
    public static String getLockSuffixStr(int dbType) {
        String suffixStr = null;
        switch (dbType) {
            case JTSConstant.JTS_DB2:
            case JTSConstant.JTS_ORACLE:
            case JTSConstant.JTS_POSTGRES:
                suffixStr = " FOR UPDATE ";
                break;
            case JTSConstant.JTS_MSSQL:
            default:
                suffixStr = "";
        }
        return suffixStr;
    }

    /**
     * *************************************************************
     * Function Name    :   getLockPrefixStr
     * Programmer' Name :   Ruhi Hira
     * Date Written     :   June 28th 2006
     * Input Parameters :   int -> dbType
     * Output Parameters:   NONE
     * Return Value     :   String -> prefix string for database lock
     * Description      :   Query prefix string for locking row
     *                      in Database
     * *************************************************************
     */
    public static String getLockPrefixStr(int dbType) {
        String prefixStr = null;
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                prefixStr = " WITH (UPDLOCK, READPAST) "; //Changed for FIFO Implementation
                break;
            case JTSConstant.JTS_ORACLE:
            case JTSConstant.JTS_DB2:
            case JTSConstant.JTS_POSTGRES:
            default:
                prefixStr = "";
        }
        return prefixStr;
    }

    /**
     * *************************************************************
     * Function Name    :   getFetchSuffixStr
     * Programmer' Name :   Ruhi Hira
     * Date Written     :   June 28th 2006
     * Input Parameters :   int -> dbType
     *                      int -> no of records
     *                      String -> to be appended before string
     *                      just like AND/ WHERE
     * Output Parameters:   NONE
     * Return Value     :   String -> suffix string for database lock
     * Description      :   Query suffix string for fetching limited
     *                      rows from Database
     * *************************************************************
     */
    public static String getFetchSuffixStr(int dbType, int n, String conditionStr) {
        String suffixStr = null;
        switch (dbType) {
            case JTSConstant.JTS_DB2:
                suffixStr = " fetch first " + n + " rows only ";
                break;
            case JTSConstant.JTS_POSTGRES:
                suffixStr = " LIMIT " + n + " ";
                break;
            case JTSConstant.JTS_ORACLE:
                suffixStr = conditionStr + " ROWNUM <= " + n + " ";
                break;
            case JTSConstant.JTS_MSSQL:
            default:
                suffixStr = "";
        }
        return suffixStr;
    }
    
    public static String getFetchSuffixStr(int dbType, int pageNo, int noOfRows, String conditionStr) {
        String suffixStr = null;
        int woritemFrom= (pageNo-1)*noOfRows ;
        int woritemTo= woritemFrom+(noOfRows+1) ;
        switch (dbType) {
            case JTSConstant.JTS_DB2:
                suffixStr = " fetch first " + woritemFrom + " rows only ";
                break;
            case JTSConstant.JTS_POSTGRES:
                suffixStr = " LIMIT " + woritemFrom + " OFFSET " + woritemTo;
                break;
            case JTSConstant.JTS_ORACLE:
                suffixStr = " offset " + (noOfRows *( pageNo-1)) + " rows fetch next " + noOfRows + " rows only ";
                break;
            case JTSConstant.JTS_MSSQL:
            	suffixStr = conditionStr + " ROWNUM > " + woritemFrom + " AND ROWNUM <" + woritemTo + " ";
                break;

            default:
                suffixStr = "";
        }
        return suffixStr;
    }

    /**
     * *************************************************************
     * Function Name    :   getFetchPrefixStr
     * Programmer' Name :   Ruhi Hira
     * Date Written     :   June 28th 2006
     * Input Parameters :   int -> dbType
     *                      int -> no of records
     * Output Parameters:   NONE
     * Return Value     :   String -> prefix string for database lock
     * Description      :   Query prefix string for fetching limited
     *                      rows from Database
     * *************************************************************
     */
    public static String getFetchPrefixStr(int dbType, int n) {
        String prefixStr = null;
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                prefixStr = " Top " + n + " ";
                break;
            case JTSConstant.JTS_ORACLE:
            case JTSConstant.JTS_DB2:
            case JTSConstant.JTS_POSTGRES:
            default:
                prefixStr = " ";
        }
        return prefixStr;
    }
	
	
    public static Object[] getBIGData(Connection con, ResultSet rs, String columnName, int dbType, String encoding) throws Exception {
		return getBIGData(con, rs, columnName, dbType, encoding, false);
	}

    /**
     * *************************************************************
     * Function Name    :   getBIGData
     * Programmer' Name :   Ruhi Hira
     * Date Written     :   July 4th 2006
     * Input Parameters :   ResultSet   -> rs
     *                      String      -> columnName
     *                      int         -> dbType
     *                      String      -> encoding
     * Output Parameters:   NONE
     * Return Value     :   Oject[]     -> zeroth index is the data
     *                                     oneth index is the size
     */
    public static Object[] getBIGData(Connection con, ResultSet rs, String columnName, int dbType, String encoding, boolean huffmanEncode) throws Exception {
        /* Bug # 29, return statement moved at end, 14-07-2006, Ruhi Hira*/
        StringBuffer strBuff = new StringBuffer(1024);
        int columnIndex = rs.findColumn(columnName);
        int len = 0;
        int jdbcType = rs.getMetaData().getColumnType(columnIndex);
        int oId = -1;
        switch (jdbcType) {
            case java.sql.Types.VARCHAR:
            case java.sql.Types.LONGVARCHAR:
			case -16 ://WFS_8.0_101
			case -9 :
            case java.sql.Types.NCLOB://Handling for FormBuffer in WFForm_Table for Oracle
            case java.sql.Types.CLOB:
                java.io.Reader strReader = rs.getCharacterStream(columnName);
                if (!rs.wasNull()) {
                    int size = 0;
                    char[] buf = null;
                    while (true) {
                        buf = new char[1024];
                        size = strReader.read(buf);
                        if (size == -1) {
                            break;
                        }
                        len += size;
                        strBuff.append(new String(buf, 0, size));
                    }
                    strReader.close(); /* Bugzilla Id 122, NPE, 22/08/2006 - Ruhi Hira */
                }
                break;
            case java.sql.Types.LONGVARBINARY:
            case java.sql.Types.BLOB:
                java.io.InputStream fin = rs.getBinaryStream(columnName);
                if (!rs.wasNull()) {
                    byte[] buf = new byte[2048];
                    while (true) {
                        int size = fin.read(buf);
                        if (size > 0) {
                            if (encoding == null) {
                                strBuff.append((new String(buf, 0, size, DatabaseTransactionServer.charSet)));
                            } else {
                                strBuff.append((new String(buf, 0, size, encoding)));
                            }
                            len += size;
                        } else {
                            break;
                        }
                    }
                    fin.close();
                }
                break;
            case java.sql.Types.INTEGER: /* PostgreSQL 7.3 jdbc driver(pg73jdbc2.jar)*/
            case java.sql.Types.BIGINT: /* PostgreSQL 8.3 jdbc driver(postgresql-8.3-604.jdbc3.jar)*/
                /* Get the Large Object Manager to perform operations with */
            	String binClassName= ServerProperty.getReference().getBinClassName("");
            	//org.postgresql.largeobject.LargeObjectManager objectManager = null;
                //if (con.getClass().getName().equals("org.jboss.resource.adapter.jdbc.WrappedConnection")) {
                LargeObjectInterface LOBObj = (LargeObjectInterface)Class.forName(binClassName).newInstance();
				
				org.postgresql.PGConnection pgConn = LOBObj.getUnderlyingConnection(con);
				
				org.postgresql.largeobject.LargeObjectManager largeMgr = pgConn.getLargeObjectAPI();
				
				//Statement stmt = con.createStatement();
				LargeObject largeObj = null;
            	    // Open the large object for reading
           	  //  int oid = rs.getInt("FormBuffer");
			/*	if (con instanceof org.jboss.resource.adapter.jdbc.WrappedConnection) {
                    objectManager = ((org.postgresql.PGConnection) ((org.jboss.resource.adapter.jdbc.WrappedConnection) con).getUnderlyingConnection()).getLargeObjectAPI();
                } else {
                    objectManager = ((org.postgresql.PGConnection) con).getLargeObjectAPI();
                }*/
                org.postgresql.largeobject.LargeObject largeObject = null;
                /* open the large object for reading */
                oId = rs.getInt(columnName);
                if (!rs.wasNull()) {
                	largeObj = largeMgr.open(oId,org.postgresql.largeobject.LargeObjectManager.WRITE);
                  	 byte buf[] = null;
                    int size = 0;
                    	len=0;
                        while (true) {
                        buf = new byte[1024];
                        size = largeObj.read(buf, 0, 1024);
                        if (size <= 0) {
                            break;
                        }
                        len += size;
                        strBuff.append(new String(buf, 0, size));
                    } 
                    strBuff.append(buf);
                    largeObj.close();
                	
                }
                break;
            default:
        }
        return new Object[]{strBuff.toString(), new Integer(len)};
    }

    /**
     * *************************************************************
     * Function Name    :   getDummyTableName
     * Programmer' Name :   Virochan
     * Date Written     :   July 4th 2006
     * Input Parameters :   int -> dbType
     * Output Parameters:   NONE
     * Return Value     :   String -> dummy table names for database servers.
     * Description      :   Dummy Table names for database servers
     *
     * *************************************************************
     */
    public static String getDummyTableName(int dbType) {
        String dummyTableStr = "";
        switch (dbType) {
            case JTSConstant.JTS_ORACLE:
                dummyTableStr = " FROM dual ";
                break;
            case JTSConstant.JTS_DB2:
                dummyTableStr = " FROM sysibm.sysdummy1 ";
                break;
            case JTSConstant.JTS_MSSQL:
            case JTSConstant.JTS_POSTGRES:
            default:
        }
        return dummyTableStr;
    }

    /**
     * *************************************************************
     * Function Name    :   getTableLockHintStr
     * Programmer' Name :   Ruhi Hira
     * Date Written     :   July 5th 2006
     * Input Parameters :   int -> dbType
     * Output Parameters:   NONE
     * Return Value     :   String -> Returns lock hint string for table.
     * Description      :   NOLOCK for MSSQL
     * *************************************************************
     */
    public static String getTableLockHintStr(int dbType) {
        String lockHintStr = "";
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                lockHintStr = " WITH (NOLOCK) ";
                break;
            case JTSConstant.JTS_ORACLE:
            case JTSConstant.JTS_DB2:
            case JTSConstant.JTS_POSTGRES:
            default:
        }
        return lockHintStr;
    }

    /**
     * *************************************************************
     * Function Name    :   getQueryLockHintStr
     * Programmer' Name :   Ruhi Hira
     * Date Written     :   August 17th 2006
     * Input Parameters :   int -> dbType
     * Output Parameters:   NONE
     * Return Value     :   String -> Returns lock hint string for query.
     * Description      :   With UR For DB2 [Bugzilla Id 54]
     * *************************************************************
     */
    public static String getQueryLockHintStr(int dbType) {
        String lockHintStr = "";
        switch (dbType) {
            case JTSConstant.JTS_DB2:
                lockHintStr = " WITH UR ";
                break;
            case JTSConstant.JTS_MSSQL:
            case JTSConstant.JTS_ORACLE:
            case JTSConstant.JTS_POSTGRES:
            default:
        }
        return lockHintStr;
    }

    public static String getOperator(int operator, int dbType, int dataType) throws JTSException {
        String retStr = " ";
        switch (operator) {
            case WFSConstant.WF_OPERATOR_SUBSTRACT:
                retStr = " - ";
                break;
            case WFSConstant.WF_OPERATOR_MULTIPLY:
                retStr = " * ";
                break;
            case WFSConstant.WF_OPERATOR_DIVIDE:
                retStr = " / ";
                break;
            default:
                retStr = (dataType == WFSConstant.WF_STR) ? WFSUtil.concat(dbType) : " + ";
        }
        return retStr;
    }

    /**
     * *************************************************************
     * Function Name    :   getNVARCHARType
     * Programmer' Name :   Ruhi Hira
     * Date Written     :   July 10th 2006
     * Input Parameters :   int -> dbType
     * Output Parameters:   NONE
     * Return Value     :   String -> NVarchar type.
     * Description      :   NVarchar type specific to database.
     * *************************************************************
     */
    public static String getNVARCHARType(int dbType) {
        String varcharType = null;
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                varcharType = " NVARCHAR ";
                break;
            case JTSConstant.JTS_ORACLE:
                varcharType = " NVARCHAR2 ";
                break;
            case JTSConstant.JTS_DB2:
                varcharType = " VARGRAPHIC ";
                break;
            case JTSConstant.JTS_POSTGRES:
                varcharType = " VARCHAR ";
                break;
            default:
        }
        return varcharType;
    }

    /**
     * *************************************************************
     * Function Name    :   getDATEType
     * Programmer' Name :   Ruhi Hira
     * Date Written     :   July 10th 2006
     * Input Parameters :   int -> dbType
     * Output Parameters:   NONE
     * Return Value     :   String -> Date type.
     * Description      :   Date type specific to database.
     * *************************************************************
     */
    public static String getDATEType(int dbType) {
        String varcharType = null;
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                varcharType = " DATETIME ";
                break;
            case JTSConstant.JTS_ORACLE:
                varcharType = " DATE ";
                break;
            case JTSConstant.JTS_POSTGRES:
            case JTSConstant.JTS_DB2:
                varcharType = " TIMESTAMP ";
                break;
            default:
        }
        return varcharType;
    }
	
	/**
     * *************************************************************
     * Function Name    :   getMAXValue
     * Programmer' Name :   Kahkeshan
     * Date Written     :   July 7th ,2013
     * Input Parameters :   int -> dbType
     * Output Parameters:   NONE
     * Return Value     :   String -> Date type.
     * Description      :   Maximum Value of nvarchar2 specific to the database
     * *************************************************************
     */
    public static String getMAXValue(int dbType) {
        String maxVal = null;
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                maxVal = "max";
                break;
            case JTSConstant.JTS_ORACLE:
                maxVal = "2000";
                break;
            case JTSConstant.JTS_POSTGRES:
            	maxVal = "2000";
                break;
            case JTSConstant.JTS_DB2:
                
                break;
            default:
        }
        return maxVal;
    }
    /**
     * *************************************************************
     * Function Name    :   isObjectTable
     * Programmer' Name :   Ruhi Hira
     * Date Written     :   July 10th 2006
     * Input Parameters :   int -> dbType
     * Output Parameters:   NONE
     * Return Value     :   boolean -> flag.
     * Description      :   returns true if object is a table else
     *                          false.
     * *************************************************************
     */
    public static boolean isObjectTable(Connection con, String strObjName, int dbType) throws SQLException {
        Statement stmt=null ;
        ResultSet rs = null;
        String strTemp = null;
        boolean tabFlag = false;

        try {
            switch (dbType) {
                case JTSConstant.JTS_MSSQL:
                	stmt = con.createStatement();
                    rs = stmt.executeQuery("SELECT xtype FROM SysObjects WHERE Name = '" + WFSUtil.TO_SANITIZE_STRING(strObjName.trim(),true) + "'");
                    if ( rs.next()) {
                        strTemp = rs.getString(1);
                        if (!rs.wasNull()) {
                            if (strTemp.equalsIgnoreCase("U")) {
                                tabFlag = true;
                            } else if (strTemp.equalsIgnoreCase("V")) {
                                tabFlag = false;
                            }
                        }
                    }
                    stmt.close();
                    break;
                case JTSConstant.JTS_ORACLE:
                	stmt = con.createStatement();
                    rs = stmt.executeQuery("SELECT object_type FROM User_Objects WHERE Object_Name = '" + WFSUtil.TO_SANITIZE_STRING(strObjName.trim().toUpperCase(),true) + "'");
                    if (rs.next()) {
                        strTemp = rs.getString(1);
                        if (!rs.wasNull()) {
                            if (strTemp.equalsIgnoreCase("TABLE")) {
                                tabFlag = true;
                            } else if (strTemp.equalsIgnoreCase("VIEW")) {
                                tabFlag = false;
                            }
                        }
                    }
                    stmt.close();
                    break;
                    
                case JTSConstant.JTS_DB2:
                	stmt = con.createStatement();
                    rs = stmt.executeQuery("SELECT Type FROM SYSCAT.TABLES WHERE TabName = '" + WFSUtil.TO_SANITIZE_STRING(strObjName.trim().toUpperCase(),true) + "'");
                    if (rs.next()) {
                        strTemp = rs.getString(1);
                        if (!rs.wasNull()) {
                            if (strTemp.equalsIgnoreCase("T")) {
                                tabFlag = true;
                            } else if (strTemp.equalsIgnoreCase("V")) {
                                tabFlag = false;
                            }
                        }
                    }
                    stmt.close();
                    break;
                case JTSConstant.JTS_POSTGRES:
                	stmt = con.createStatement();
                    rs = stmt.executeQuery("SELECT relKind FROM pg_class WHERE relName = " + TO_STRING(strObjName, true, dbType));
                    if (rs.next()) {
                        strTemp = rs.getString(1);
                        if (!rs.wasNull()) {
                            if (strTemp.equalsIgnoreCase("r")) {
                                tabFlag = true;
                            }
                        }
                    }
                    stmt.close();
                    break;
                default:
            }
            if(rs!=null){
            rs.close();
            }
            rs = null;
            if(stmt!=null){
            stmt.close();
            }
            stmt = null;
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (SQLException ignored) {
            }
            try {
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
            } catch (SQLException ignored) {
            }
        }
        return tabFlag; /* Bug # 29, return statement moved at end, 14-07-2006, Ruhi Hira*/
    }

	public static String getCalendarData(Connection con, String associationFlag, XMLGenerator gen, int processDefId, int calId) throws SQLException {
	return getCalendarData(con, associationFlag, gen, processDefId, calId, true);
	}

    // Added by Ahsan Javed.
    /** Bugzilla Bug 944, Duplicate data returned from API, 24/05/2007 - Ruhi Hira */
    public static String getCalendarData(Connection con, String associationFlag, XMLGenerator gen, int processDefId, int calId, boolean isRegistered) throws SQLException {
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        StringBuffer tempXml = new StringBuffer(100);
        int calRuleId = 0;
        boolean tagAppended = false;
		String tablePrefix = "WF";
		String str1 = null;
		String str2 = null;
		String startStr = null;
		String endStr = null;
		
		/*Bug 31829 fixed*/
		if(!isRegistered && processDefId != 0){
				tablePrefix	= "PMW";
			}
		try {
			pstmt = con.prepareStatement("SELECT calName, gmtDiff,lastModifiedOn, comments FROM " + tablePrefix+ "CalDefTable WHERE calId = ? AND processDefId = ?");
			pstmt.setInt(1, calId);
            pstmt.setInt(2, processDefId);
			rs = pstmt.executeQuery();
            if (rs.next()) {
                
				tempXml.append(gen.writeValueOf("CalendarId", String.valueOf(calId)));
                tempXml.append("\n");
                tempXml.append(gen.writeValueOf("CalendarName", rs.getString("calName")));
                tempXml.append("\n");
                tempXml.append(gen.writeValueOf("GMTDiff", rs.getString("gmtDiff")));
                tempXml.append("\n");
                rs.getDate("lastModifiedOn");
                tempXml.append(gen.writeValueOf("LastModifiedOn", rs.getString("lastModifiedOn")));
                tempXml.append("\n");
                tempXml.append(gen.writeValueOf("Comments", rs.getString("comments")));
                tempXml.append("\n");
                pstmt.close();
                rs = null;
            } else {
                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
                return "";
            }
            // Fetching data from hour range table ...
            pstmt = con.prepareStatement(" SELECT calRuleId, rangeId, startTime, endTime FROM " + tablePrefix+ "CalHourDefTable WHERE calId =  ? AND processdefId = ? ORDER BY calRuleId");
            pstmt.setInt(1, calId);
            pstmt.setInt(2, processDefId);
			rs = pstmt.executeQuery();
			
            if (rs != null) {
                tempXml.append("<DefaultHourRange>\n");
                while (rs.next()) {
                    calRuleId = rs.getInt("calRuleId");
                    if (calRuleId > 0 && !tagAppended) {
                        tempXml.append("</DefaultHourRange>\n");
                        tempXml.append("<CalHourDefinition>\n");
                        tagAppended = true;
                    }
					str1 = rs.getString("startTime");
					/*Bug 37143 fixed*/
					//if(str1.equals("0"))
						//str1 = "0000";
					//startStr = str1.substring(0,2) + ":" + str1.substring(2);
					
					//str2 = rs.getString("endTime");
					/*Bug 37143 fixed*/
					//if(str2.equals("0"))
						//str2 = "0000";
					//endStr = str2.substring(0,2) + ":" + str2.substring(2);
					
					/* 03/01/2013 Kahkeshan       Reverted Changes done for Bug 33893 and Bug36819 as colon support is to be provided at 
                                          omniflow web. */
					
					/* Reverting changes for 24 hr calendar support*/
					startStr=rs.getString("startTime");
					endStr=rs.getString("endTime");
					
                    tempXml.append("<HourRange>\n");
                    tempXml.append(gen.writeValueOf("CalRuleId", String.valueOf(calRuleId)));
                    tempXml.append("\n");
                    tempXml.append(gen.writeValueOf("HourRangeId", rs.getString("rangeId")));
                    tempXml.append("\n");
                    tempXml.append(gen.writeValueOf("StartTime", startStr));
                    tempXml.append("\n");
                    tempXml.append(gen.writeValueOf("EndTime", endStr));
                    tempXml.append("\n");
                    tempXml.append("</HourRange>\n");
                }
				
                if (!tagAppended) {
                    tempXml.append("</DefaultHourRange>\n");
                    tempXml.append("<CalHourDefinition>\n");
                }
                tempXml.append("</CalHourDefinition>\n");
               
            }
            if(rs!=null){
            rs.close();
            }
            rs = null;
            pstmt.close();
            pstmt = null;
            // fetching data from cal rule def table ...
            pstmt = con.prepareStatement(" SELECT calRuleId, def, calDate, occurrence, workingMode, dayOfWeek, wef FROM " + tablePrefix+ "CalRuleDefTable WHERE calId = ? AND processDefId = ?");
            pstmt.setInt(1, calId);
            pstmt.setInt(2, processDefId);
            rs = pstmt.executeQuery();
            if (rs != null) {
                tempXml.append("<CalRuleDefinition>\n");
                while (rs.next()) {
                    tempXml.append("<CalRule>\n");
                    tempXml.append(gen.writeValueOf("CalRuleId", rs.getString("calRuleId")));
                    tempXml.append("\n");
                    tempXml.append(gen.writeValueOf("CalRuleName", rs.getString("def")));
                    tempXml.append("\n");
                    tempXml.append(gen.writeValueOf("CalDate", rs.getString("calDate")));
                    tempXml.append("\n");
                    tempXml.append(gen.writeValueOf("Occurrence", rs.getString("occurrence")));
                    tempXml.append("\n");
                    tempXml.append(gen.writeValueOf("WorkingMode", rs.getString("workingMode")));
                    tempXml.append("\n");
                    tempXml.append(gen.writeValueOf("DayOfWeek", rs.getString("dayOfWeek")));
                    tempXml.append("\n");
                    tempXml.append(gen.writeValueOf("WEF", rs.getString("wef")));
                    tempXml.append("\n");
                    tempXml.append("</CalRule>\n");
                }
                tempXml.append("</CalRuleDefinition>\n");
                
            }
            if(rs!=null){
            rs.close();
            }
            pstmt.close();
            pstmt = null;
            if (associationFlag.equalsIgnoreCase("Y")) {
                String queryStr = "SELECT processDefId, activityId, calType FROM " + tablePrefix+ "CalendarAssocTable WHERE calId = ?";
                // adding condition for calType, if processDefId = 0 then calType = 'G'else calType = 'L'
                if (processDefId == 0) {
                    queryStr += " And calType = 'G'";
                } else {
                    queryStr += " And calType = 'L'";
                }
                pstmt = con.prepareStatement(queryStr);
                pstmt.setInt(1, calId);
                rs = pstmt.executeQuery();
                if (rs != null) {
                    tempXml.append("<Associations>\n");
                    while (rs.next()) {
                        tempXml.append("<Association>\n");
                        tempXml.append(gen.writeValueOf("ProcessDefinitionId", rs.getString("processDefId")));
                        tempXml.append("\n");
                        tempXml.append(gen.writeValueOf("ActivityId", rs.getString("activityId")));
                        tempXml.append("\n");
                        tempXml.append(gen.writeValueOf("CalendarType", rs.getString("calType")));
                        tempXml.append("\n");
                        tempXml.append("</Association>\n");
                    }
                    tempXml.append("</Associations>\n");
                }
                rs.close();
                rs = null;
                pstmt.close();
                pstmt = null;
            }
            if (pstmt != null) {
                pstmt.close();
                pstmt = null;
            }
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (SQLException ignored1) {
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
            } catch (SQLException ignored2) {
            }
        }
        return tempXml.toString();
    }

    /**
     * *****************************************************************
     * Function Name    :   getClassNameForExternalInterface
     * Programmer' Name :   Ruhi Hira
     * Date Written     :   May 10th 2007
     * Input Parameters :   String -> interfaceName
     * Output Parameters:   NONE
     * Return Value     :   String -> interface class name.
     * Description      :   returns the classname for interface name.
     * *****************************************************************
     */
    public static String getClassNameForExternalInterface(String interfaceName, String engineName) {
        String className = null;
        printOut(engineName, "[WFSUtil] getClassNameForExternalInterface() interfaceName >> " + interfaceName);
        if (interfaceName.equalsIgnoreCase(WFSConstant.EXT_INT_ACTION_NAME)) {
            className = WFSConstant.EXT_INT_ACTION_CLASS;
        } else if (interfaceName.equalsIgnoreCase(WFSConstant.EXT_INT_ARCHIVE_NAME)) {
            className = WFSConstant.EXT_INT_ARCHIVE_CLASS;
        } else if (interfaceName.equalsIgnoreCase(WFSConstant.EXT_INT_DOCUMENT_NAME)) {
            className = WFSConstant.EXT_INT_DOCUMENT_CLASS;
        } else if (interfaceName.equalsIgnoreCase(WFSConstant.EXT_INT_EXCEPTION_NAME)) {
            className = WFSConstant.EXT_INT_EXCEPTION_CLASS;
        } else if (interfaceName.equalsIgnoreCase(WFSConstant.EXT_INT_FORM_NAME)) {
            className = WFSConstant.EXT_INT_FORM_CLASS;
        } else if (interfaceName.equalsIgnoreCase(WFSConstant.EXT_INT_PRINTFAXMAIL_NAME)) {
            className = WFSConstant.EXT_INT_PRINTFAXMAIL_CLASS;
        } else if (interfaceName.equalsIgnoreCase(WFSConstant.EXT_INT_TODOLIST_NAME)) {
            className = WFSConstant.EXT_INT_TODOLIST_CLASS;
        } else if (interfaceName.equalsIgnoreCase(WFSConstant.EXT_INT_SCANTOOL_NAME)) {
            className = WFSConstant.EXT_INT_SCANTOOL_CLASS;
        } else if (interfaceName.equalsIgnoreCase(WFSConstant.EXT_INT_SAPGUIADAPTER_NAME)) {
            className = WFSConstant.EXT_INT_SAPGUIADAPTER_CLASS;
        } else if (interfaceName.equalsIgnoreCase(WFSConstant.EXT_INT_FORMEXT_NAME)) {
            className = WFSConstant.EXT_INT_FORMEXT_CLASS;
        } else {
            className = WFSConstant.EXT_INT_PACKAGE + "." + interfaceName + "Class";
        }
        printOut(engineName, "[WFSUtil] getClassNameForExternalInterface() className >> " + className);
        return className;
    }

    /**
     * *************************************************************
     * Function Name    :   readFile
     * Programmer' Name :   Ruhi Hira
     * Date Written     :   February 21st 2007
     * Input Parameters :   String -> fileName
     * Output Parameters:   NONE
     * Return Value     :   String -> fileBuffer.
     * Description      :   read the file with filename in input
     *                      and return the buffer. Bugzilla # 477.
     * *************************************************************
     */
    public static String readFile(String fileName) {
    	fileName=FilenameUtils.normalize(fileName);
        File file = new File(fileName);
        String fileBuffer = readFile(file);
        return fileBuffer;
    }

    /**
     * *************************************************************
     * Function Name    :   readFile
     * Programmer' Name :   Ruhi Hira
     * Date Written     :   February 21st 2007
     * Input Parameters :   File -> file
     * Output Parameters:   NONE
     * Return Value     :   String -> fileBuffer.
     * Description      :   read the file in input and return the buffer.
     * *************************************************************
     */
    public static String readFile(File file) {
        StringBuffer fileBuffer = new StringBuffer(1024);
        FileInputStream fIn = null;
        byte[] buffer = null;
        int read = 0;
        int sanitizedRead = 0;
        try {
            fIn = new FileInputStream(file);
            buffer = new byte[1024];
            read = fIn.read(buffer);
            sanitizedRead = Integer.parseInt(Integer.toString(read).replaceAll("'","''"));
            while (sanitizedRead > 0) {
                fileBuffer.append(new String(buffer, 0, sanitizedRead));
                sanitizedRead = fIn.read(buffer);
            }
            fIn.close();
        } catch (Exception ex) {
            printErr("","\n\n[WFSUtil] readFile() Exception while reading file " + ex.getMessage());
        } finally {
            try {
                if (fIn != null) {
                    fIn.close();
                    fIn = null;
                }
            } catch (Exception ignored) {
            }
        }
        return fileBuffer.toString();
    }

    /**
     * *************************************************************
     * Function Name    :	parseQueryFilter
     * Programmer' Name :   Varun Bhansaly
     * Date Written     :   23/08/2007
     * Input Parameters :   Connection -> SQL Connection, String -> QueryFilter,
    String -> IndexType, int -> SystemIndex, int -> DatabaseType
     * Output Parameters:   NONE
     * Return Value     :   String -> QueryFilter.
     * Description      :   Parse QueryFilter and substitute values for Macros
    of type &<UserIndex.ColumnName>&/ &<GroupIndex.ColumnName>&.
    WFFilterTable must exist in the Cabinet.
     * *************************************************************
     */
    public static String parseQueryFilter(Connection con, String queryFilter, String objectType, int objectIndex, int dbType, String engineName) {
        int startIndex = -1;
        int endIndex = -1;
        int length = -1;
        int count = 0;
        int numOfColumns = 0;
        String toFind = "";
        String query = "";
        String queryFilterUpper = "";
        String column = "";
        String value = "";
        String tempValue = "";
        String columns = "";
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        ResultSetMetaData rsmd = null;
        ArrayList columnNames = new ArrayList();
        /* Columns Used in the Filter */
        /*ArrayList columnTypes = new ArrayList();*/
        /* Types of the Columns Determined from RSMD */
        ArrayList columnValues = new ArrayList();
		boolean bMultipleDataFlag = false;
        /* Values corresponding to the column */
        /*ArrayList columnSQLOperators = new ArrayList();*/
        /* SQLOperator used for the column, introduced to handle special case for 'IN' */

        /*
         * Still scope for optimization of the method, 4 ArrayList are being used,
         * requiring unneccessary ArrayList index-offeset calculations
         * Instead an inner class can be used to the contain all data for a column,
         * and an ArrayList be maintained to hold the inner class object references.
         * Thus only one ArrayList will be accessed.
         * - Varun Bhansaly
         */
        if (objectType.equalsIgnoreCase("U")) {
            toFind = "&<UserIndex.";
        } else if (objectType.equalsIgnoreCase("G")) {
            toFind = "&<GroupIndex.";
        } else {
            return queryFilter;
        }
        toFind = toFind.toUpperCase();
        length = toFind.length();
        queryFilter = queryFilter.replaceAll("=\\s+", "=").toUpperCase().trim();
        while ((startIndex = queryFilterUpper.indexOf(toFind, startIndex)) != -1) {
            endIndex = queryFilterUpper.indexOf(">&", startIndex);
            column = queryFilterUpper.substring(startIndex + length, endIndex);
            if (!columnNames.contains(column)) {
                /* Unlike '=' & '!=' 'IN' will always have to be preceded by a space character */
                columnNames.add(new String(column));
                columnValues.add("");
                if (count != 0) {
                    columns += ", ";
                }
                columns += column;
            }
            startIndex = endIndex;
            count++;
        }
        if (columns.length() > 0) {
            try {
                query = "Select " + WFSUtil.TO_SANITIZE_STRING(columns,true) + " from WFFilterTable " + WFSUtil.getTableLockHintStr(dbType) + "  where ObjectIndex = ? and ObjectType = ?";
                pstmt = con.prepareStatement(query);
                pstmt.setInt(1, objectIndex);
                pstmt.setString(2, objectType);
                pstmt.executeQuery();
                rs = pstmt.getResultSet();

                rsmd = rs.getMetaData();
                /**
                 * numOfColumns may not be equal to count.
                 * For eg. consider case - VAR_INT1 != &<UserIndex.age>& OR VAR_INT1 != &<UserIndex.age>&
                 * - Varun Bhansaly
                 */
                numOfColumns = rsmd.getColumnCount();
                columnNames.ensureCapacity(numOfColumns);
                columnValues.ensureCapacity(numOfColumns);
				int iCnt = 0;
				while (rs.next()) {					
					for (int i = 0; i < numOfColumns; i++) {
						value = rs.getString(i + 1);
						int colType = JDBCTYPE_TO_WFSTYPE(rsmd.getColumnType(i+1));
						if (colType != WFSConstant.WF_DAT && colType != WFSConstant.WF_INT && colType != WFSConstant.WF_LONG && colType != WFSConstant.WF_FLT) {
							value = "'"+value.trim()+"'";
						}
						String val = (String)columnValues.get(i);
						if(val != null && !val.equals(""))	{						
							if(!val.contains(value)) {
								//value += ","+val;
								val+= ","+value;
								bMultipleDataFlag = true;
							}
							columnValues.set(i, val);
						}
						else {							
							columnValues.set(i, value);
						}					
						//queryFilter = replaceIgnoreCase(queryFilter, toFind + (String) columnNames.get(i) + ">&", value);						
					}
					iCnt++;					
				}
                for (int i = 0; i < numOfColumns; i++) {
                    String values = (String) columnValues.get(i);
					if(bMultipleDataFlag) {
						values  = " IN (" +values+ ")";
						//queryFilter = replaceIgnoreCase(queryFilter.trim(),"=","");
					}
					//queryFilter = replaceIgnoreCase(queryFilter,"'","");
                    queryFilter = replaceIgnoreCase(queryFilter.trim(), "="+toFind + (String) columnNames.get(i) + ">&", values);					
                }
                pstmt.close();
            } catch (SQLException sqle) {
                printErr(engineName,"", sqle);
            } finally {
                try {
                    if (rs != null) {
                        rs.close();
                        rs = null;
                    }
                } catch (SQLException sqle) {
                    printErr(engineName,"", sqle);
                }
                try {
                    if (pstmt != null) {
                        pstmt.close();
                        pstmt = null;
                    }
                } catch (SQLException sqle) {
                    printErr(engineName,"", sqle);
                }
            }
        }
        return queryFilter;
    }

    /**
     * *************************************************************
     * Function Name    :   readFileAsResource
     * Author			:   Varun Bhansaly
     * Date Written     :   18/10/2007
     * Input Parameters :   String -> fileName
     * Output Parameters:   NONE
     * Return Value     :   String -> fileBuffer.
     * Description      :   Reads file embedded in Jar
     * *************************************************************
     */
    public static String readFileAsResource(String fileName) {
        InputStream input = WFSUtil.class.getClassLoader().getResourceAsStream(fileName);
        BufferedReader bReader = null;
        String line = "";
        StringBuffer temp = new StringBuffer();
        try {
            if (input != null) {
                bReader = new BufferedReader(new InputStreamReader(input));
                line = bReader.readLine();
                while (line != null) {
                    temp.append(line);
                    line = bReader.readLine();
                }
            }
        } catch (IOException ioe) {
           // printErr(engine,"", ioe);
        } finally {
            try {
                if (bReader != null) {
                    bReader.close();
                    bReader = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (input != null) {
                    input.close();
                    input = null;
                }
            } catch (Exception ignored) {
            }
        }
        return temp.toString();
    }

      /**
     * *************************************************************
     * Function Name    :   printErr
     * Author			:   Varun Bhansaly
     * Date Written     :   18/10/2007
     * Input Parameters :   Object -> message
     * Output Parameters:   NONE
     * Return Value     :   void
     * Description      :   To print Error messages in Error.log
     * *************************************************************
     */
//    public static void printErr(Object message) {
//        WFLogger.printErr(message);
//    }
	
//	public static void printErr(XMLParser parser, Object message) {
//		/*
//        String cabinetName =null;
//        if(parser != null && !(parser.getValueOf("EngineName") == null || parser.getValueOf("EngineName").equalsIgnoreCase("")))
//            cabinetName = parser.getValueOf("EngineName");
//        if(cabinetName == null || cabinetName.equalsIgnoreCase(""))
//             WFLogger.printErr(message);
//        else
//            WFLogger.printErr(message,cabinetName);
//		*/
//		WFLogger.printErr(message);
//    }
    public static void printErr(String cabinetName, Object message) {
		/*
        if(cabinetName == null || cabinetName.equalsIgnoreCase(""))
            WFLogger.printErr(message);
        else
            WFLogger.printErr(message,cabinetName);
		*/
		//WFLogger.printErr(message);
        NGUtil.writeErrorLog(cabinetName, WFSConstant.CONST_MODULE_NAME, message);
    }
	
//    public static void printErr(XMLParser parser,Object message, Throwable t) {
//        //String cabinetName = parser.getValueOf("EngineName");
//        //WFLogger.printErr(message,t,cabinetName);
//        //WFLogger.writeLog('E', message.toString(), cabinetName);
//          WFLogger.printErr(message, t);
//    }
    public static void printErr(String cabinetName,Object message, Throwable t) {
        NGUtil.writeErrorLog(cabinetName, WFSConstant.CONST_MODULE_NAME, message, t);
    }

    /**
     * *************************************************************
     * Function Name    :   printErr
     * Author			:   Varun Bhansaly
     * Date Written     :   18/10/2007
     * Input Parameters :   Object -> message, Throwable t
     * Output Parameters:   NONE
     * Return Value     :   void
     * Description      :   To print Error messages &
     *						exception stacktrace in Error.log
     * *************************************************************
     */
   

    /**
     * *************************************************************
     * Function Name    :   printErr
     * Author			:   Varun Bhansaly
     * Date Written     :   18/10/2007
     * Input Parameters :   Level -> level, Object -> message, Throwable t
     * Output Parameters:   NONE
     * Return Value     :   void
     * Description      :   To print Error messages &
     *						exception stacktrace in Error.log at
     *						User-defined Priority
     * *************************************************************
     */
//    public static void printErr(Level level, Object message, Throwable t) {
//        WFLogger.printErr(level, message, t);
//    }

//    public static void printErr(XMLParser parser, Level level, Object message, Throwable t) {
//        //String cabinetName = parser.getValueOf("EngineName");
//        //WFLogger.printErr(level, message, t, cabinetName);
//		printErr(level, message, t);
//    }

    /**
     * *************************************************************
     * Function Name    :   printOut
     * Author			:   Varun Bhansaly
     * Date Written     :   18/10/2007
     * Input Parameters :   Object -> message
     * Output Parameters:   NONE
     * Return Value     :   void
     * Description      :   To print debugging messages in Console.log
     * *************************************************************
     */
//    public static void printOut(Object message) {
//        WFLogger.printOut(message);
//    }
	
    public static void printOut(String engineName, Object message) {
         /*User/API logging support- sajid khan**/
        /******************************************/
        String strArr[] = returnUserApiStatus();
        String userApiStatus = strArr[1];

         if(userApiStatus.equals("10")){
             NGUtil.writeUserConsoleLog(engineName, WFSConstant.CONST_MODULE_NAME, message);
         }else if (userApiStatus.equals("01")){
            NGUtil.writeApiConsoleLog(engineName, WFSConstant.CONST_MODULE_NAME, message);
         }else if (userApiStatus.equals("11")){
            NGUtil.writeUserConsoleLog(engineName, WFSConstant.CONST_MODULE_NAME, message);
         }
		/*
        if(engineName == null || engineName.equalsIgnoreCase(""))
            WFLogger.printOut(message);
        else
            WFLogger.printOut(message, engineName);
		*/
		//printOut(message);
        NGUtil.writeConsoleLog(engineName, WFSConstant.CONST_MODULE_NAME, message);
    }
 /*User/API logging support- sajid khan**/
        /******************************************/

    public static String[] returnUserApiStatus(){
         String strArr[] = null;
         strArr = new String[2];
         WFUserApiContext context = WFUserApiThreadLocal.get();
          String uName = "";
         String apiName = "";
         if(context != null){
          uName = context.getUserName();
          apiName = context.getApiName();
         }
         //System.out.println("-------------------INSIDE WFSUtil.printOut()----------------->" + context.getUserName());
          //System.out.println("---------------INSIDE WFSUtil.printOut()---------------------->" +context.getApiName());
         strArr[0] =  uName;
         strArr[1] =  NGUserAPIConfig.checkUserAPIStatus(uName, apiName);
        return strArr;
  }
//     public static void printOut(XMLParser parser, Object message) {
//		/*
//        String cabinetName = parser.getValueOf("EngineName");
//        WFLogger.printOut(message,cabinetName);
//		*/
//       printOut(message);
//    }

    /**
     * *************************************************************
     * Function Name    :   printOut
     * Author			:   Varun Bhansaly
     * Date Written     :   18/10/2007
     * Input Parameters :   Level -> level, Object -> message
     * Output Parameters:   NONE
     * Return Value     :   void
     * Description      :   To print debugging messages in Out.log at
     *						User-defined Priority
     * *************************************************************
     */
//    public static void printOut(Level level, Object message) {
//        WFLogger.printOut(level, message);
//    }
	
//	public static void printOut(String engineName, Level level, Object message) {
//		/*
//        if(engineName == null || engineName.equalsIgnoreCase(""))
//            WFLogger.printOut(level, message);
//        else
//            WFLogger.printOut(level, message, engineName);
//		*/
//		printOut(level, message);
//    }
//    public static void printOut(XMLParser parser, Level level, Object message) {
//		/*
//        String cabinetName = parser.getValueOf("EngineName");
//        WFLogger.printOut(level, message, cabinetName);
//		*/
//		printOut(level, message);
//    }
	/**
     * *************************************************************
     * Function Name    :   printQuery
     * Author			:   Kahkeshan
     * Date Written     :   29/08/2013
     * Input Parameters :   Object -> message ,long -> startTime, long ->endTime, 
	                        String -> ProcessInstanceId,int SessionId ,String ->query,String -> engineName
     * Output Parameters:   NONE
     * Return Value     :   void
     * Description      :   Cabinet based logging To print queries in Query.log
     * *************************************************************
     */
public static boolean jdbcExecute(String ProcessInstanceId,int sessionId,int userId,String query,Statement pstmt,ArrayList parameters,Boolean flag,String engineName) throws SQLException{
		//printOut("printquery with 8 args");
        Boolean res = false;
        PreparedStatement pstmtNew = null;
        int queryTimeout = getQueryTimeOut();
        if(flag){
            StringBuffer message = new StringBuffer();
            long startTime = System.currentTimeMillis();
            if(pstmt instanceof PreparedStatement){
                pstmtNew = (PreparedStatement)pstmt;
                if(queryTimeout <= 0)
        			pstmtNew.setQueryTimeout(60);
                else
        			pstmtNew.setQueryTimeout(queryTimeout);
                res = pstmtNew.execute();
            }else{
            	if(queryTimeout <= 0)
        			pstmt.setQueryTimeout(60);
                else
        			pstmt.setQueryTimeout(queryTimeout);
                res = pstmt.execute(WFSUtil.TO_SANITIZE_STRING(query,true));
            }
                long endTime = System.currentTimeMillis();
                if(sessionId != 0){
                        message.append(" SessionID: ");
                        message.append(sessionId);
                        message.append(" UserID: ");
                        message.append(userId);
                }
                if(ProcessInstanceId != null){
                        message.append(" ProcessInstanceId: ");
                        message.append(ProcessInstanceId);
                }
                message.append(" StartTime: ");
                message.append(startTime);
                message.append(" EndTime: ");
                message.append(endTime);
                message.append(" Difference: ");
                message.append(endTime - startTime);
                message.append("\n Query: ");
                message.append(query);
			
                if(parameters != null){
                message.append("\n Parameters :\n index\tvalues\n");
                for(int i=0;i<parameters.size();i++){
                        String val = parameters.get(i)!=null?parameters.get(i).toString():"null";
                        message.append(" "+(i+1)+"\t\t"+val+"\n");
                }
            if(engineName != null)
                NGUtil.writeQueryLog(engineName, WFSConstant.CONST_MODULE_NAME,message);
                //WFLogger.printQuery(message,engineName);
            }
		}else{
            if(pstmt instanceof PreparedStatement){
                pstmtNew = (PreparedStatement)pstmt;
                if(queryTimeout <= 0)
        			pstmtNew.setQueryTimeout(60);
                else
        			pstmtNew.setQueryTimeout(queryTimeout);
                res = pstmtNew.execute();
            }else {
            	if(queryTimeout <= 0)
        			pstmt.setQueryTimeout(60);
                else
        			pstmt.setQueryTimeout(queryTimeout);
                res = pstmt.execute(WFSUtil.TO_SANITIZE_STRING(query,true));
            }
        }
		return res;
	}

	public static int jdbcExecuteUpdate(String ProcessInstanceId,int sessionId,int userId,String query,Statement pstmt,ArrayList parameters,Boolean flag,String engineName) throws SQLException{
		//printOut("jdbcExecuteUpdate");
		int res = 0;
        PreparedStatement pstmtNew = null;
        int queryTimeout = getQueryTimeOut();
		if(flag){
			StringBuffer message = new StringBuffer();
			long startTime = System.currentTimeMillis(); 
            if(pstmt instanceof PreparedStatement){
                pstmtNew = (PreparedStatement)pstmt;
                if(queryTimeout <= 0)
          			pstmtNew.setQueryTimeout(60);
                else
          			pstmtNew.setQueryTimeout(queryTimeout);

                res = pstmtNew.executeUpdate();
            }else {
            	if(queryTimeout <= 0)
          			pstmt.setQueryTimeout(60);
                else
          			pstmt.setQueryTimeout(queryTimeout);
                res = pstmt.executeUpdate(WFSUtil.TO_SANITIZE_STRING(query,true));
            }
			
			long endTime = System.currentTimeMillis(); 
			if(sessionId != 0){
				message.append(" SessionID: ");
				message.append(sessionId);
				message.append(" UserID: ");
				message.append(userId);
			}
			if(ProcessInstanceId != null){
				message.append(" ProcessInstanceId: ");
				message.append(ProcessInstanceId);
			}
			message.append(" StartTime: ");
			message.append(startTime);
			message.append(" EndTime: ");
			message.append(endTime);
			message.append(" Difference: ");	
			message.append(endTime - startTime);
			message.append("\n Query: ");
			message.append(query);
			
			if(parameters != null){
                message.append("\n Parameters :\n index\tvalues\n");
				for(int i=0;i<parameters.size();i++){
					
					String val = parameters.get(i)!=null?parameters.get(i).toString():"null";
					message.append(" "+(i+1)+"\t\t"+val+"\n");
				}
                if(engineName != null)
                     NGUtil.writeQueryLog(engineName, WFSConstant.CONST_MODULE_NAME,message);
                    //WFLogger.printQuery(message,engineName);
			}
		}else{
            if(pstmt instanceof PreparedStatement){
                pstmtNew = (PreparedStatement)pstmt;
                if(queryTimeout <= 0)
          			pstmtNew.setQueryTimeout(60);
                else
          			pstmtNew.setQueryTimeout(queryTimeout);
                res = pstmtNew.executeUpdate();
            }else {
            	if(queryTimeout <= 0)
          			pstmt.setQueryTimeout(60);
                else
          			pstmt.setQueryTimeout(queryTimeout);
                res = pstmt.executeUpdate(WFSUtil.TO_SANITIZE_STRING(query,true));
            }
        }
		return res;
	}

	public static ResultSet jdbcExecuteQuery(String ProcessInstanceId,int sessionId,int userId,String query,Statement pstmt,ArrayList parameters,Boolean flag,String engineName) throws SQLException{
		//printOut("jdbcExecuteQuery");
        PreparedStatement pstmtNew = null;
        ResultSet res = null;
        int queryTimeout = getQueryTimeOut();
		if(flag){
			StringBuffer message = new StringBuffer();
			long startTime = System.currentTimeMillis(); 
			if(pstmt instanceof PreparedStatement){
                pstmtNew = (PreparedStatement)pstmt;
                if(queryTimeout <= 0)
          			pstmtNew.setQueryTimeout(60);
                else
          			pstmtNew.setQueryTimeout(queryTimeout);

                res = pstmtNew.executeQuery();
            }else {
            	if(queryTimeout <= 0)
          			pstmt.setQueryTimeout(60);
            	else
          			pstmt.setQueryTimeout(queryTimeout);

                res = pstmt.executeQuery(WFSUtil.TO_SANITIZE_STRING(query,true));
            }
			
			long endTime = System.currentTimeMillis(); 
			if(sessionId != 0){
				message.append(" SessionID: ");
				message.append(sessionId);
				message.append(" UserID: ");
				message.append(userId);
			}
			if(ProcessInstanceId != null){
				message.append(" ProcessInstanceId: ");
				message.append(ProcessInstanceId);
			}
			message.append(" StartTime: ");
			message.append(startTime);
			message.append(" EndTime: ");
			message.append(endTime);
			message.append(" Difference: ");	
			message.append(endTime - startTime);
			message.append("\n Query: ");
			message.append(query);
			
			if(parameters != null){
                message.append("\n Parameters :\n index\tvalues\n");
				for(int i=0;i<parameters.size();i++){
					String val = parameters.get(i)!=null?parameters.get(i).toString():"null";
					message.append(" "+(i+1)+"\t\t"+val+"\n");
				}
                if(engineName != null)
                     NGUtil.writeQueryLog(engineName, WFSConstant.CONST_MODULE_NAME,message);
                	//WFLogger.printQuery(message,engineName);
			}
		}else{
            if(pstmt instanceof PreparedStatement){
                pstmtNew = (PreparedStatement)pstmt;
                if(queryTimeout <= 0)
          			pstmtNew.setQueryTimeout(60);
                else
          			pstmtNew.setQueryTimeout(queryTimeout);

                res = pstmtNew.executeQuery();
            }else {
            	if(queryTimeout <= 0)
          			pstmt.setQueryTimeout(60);
            	else
          			pstmt.setQueryTimeout(queryTimeout);

                res = pstmt.executeQuery(WFSUtil.TO_SANITIZE_STRING(query,true));
            }
        }
		return res;
	}

	public static int[] jdbcExecuteBatch(String ProcessInstanceId,int sessionId,int userId,ArrayList query,Statement stmt,ArrayList parameters,Boolean flag,String engineName) throws SQLException{
		//printOut("jdbcExecuteBatch");
        int[] res = null;
		if(flag){
			StringBuffer message = new StringBuffer();
			long startTime = System.currentTimeMillis(); 
			if(sessionId != 0){
				message.append(" SessionID: ");
				message.append(sessionId);
				message.append(" UserID: ");
				message.append(userId);
			}
			if(ProcessInstanceId != null){
				message.append(" ProcessInstanceId: ");
				message.append(ProcessInstanceId);
			}
			message.append(" StartTime: ");
			message.append(startTime);
            res = stmt.executeBatch();
			message.append(" EndTime: ");
            long endTime = System.currentTimeMillis(); 
			message.append(endTime);
			message.append(" Difference: ");	
			message.append(endTime - startTime);
            for(int i=0; i< query.size(); i++){
                message.append("\n Query["+i+"]: ");
                message.append(query.get(i));
            }
//			
//			if(parameters != null){
//                message.append("\n Parameters :\n index\tvalues\n");
//				for(int i=0;i<parameters.size();i++){
//					String val = parameters.get(i).toString();
//					message.append(" "+(i+1)+"\t\t"+val+"\n");
//				}
//				WFLogger.printQuery(message,engineName);
//			}
            if(engineName != null)
                 NGUtil.writeQueryLog(engineName, WFSConstant.CONST_MODULE_NAME,message);
               // WFLogger.printQuery(message,engineName);
			return res;
		}else
            res = stmt.executeBatch();
		return res;
	}

    /**
     * *************************************************************
     * Function Name    :   writeLog
     * Author			:   Varun Bhansaly
     * Date Written     :   18/10/2007
     * Input Parameters :   String -> clientId,
     *						String -> strOption, String input1,
     *						String -> input2, int state
     * Output Parameters:   NONE
     * Return Value     :   void
     * Description      :   Log in Transaction.log
     * *************************************************************
     */
    public static void writeLog(String clientId, String strOption, long input1, long input2, int state) {
        StringBuffer message = new StringBuffer();
       // message.append("Transaction: ");
        message.append(strOption);
       // message.append(" Status: ");
        if (state == 0 || state == 18) {
            message.append(" Success");
        } else {
            message.append(" Failed");
        }
     //   message.append(" Client: ");
      //  message.append(clientId);
       // message.append(" StartTime: ");
      //  message.append(input1);
       // message.append(" EndTime: ");
       // message.append(input2);
        message.append(" Difference: ");
        message.append(input2 - input1);
        NGUtil.writeTransactionLog("", WFSConstant.CONST_MODULE_NAME, message);
        //WFLogger.writeLog('T', message);
        message = null;
    }
	
	/**
     * *************************************************************
     * Function Name    :   writeLog
     * Author			:   Vikas Saraswat
     * Date Written     :   27/08/2010
     * Input Parameters :   String -> clientId,
     *						String -> strOption, String input1,
     *						String -> input2, int state
     * Output Parameters:   NONE
     * Return Value     :   void
     * Description      :   Log in Transaction.log
     * *************************************************************
     */
	//WFS_8.0_127
    public static void writeLog(String clientId, String strOption, long input1, long input2, int state,String OutputXml) {
        StringBuffer message = new StringBuffer();
       // message.append("Transaction: ");
        message.append(strOption);
       // message.append(" Status: ");
        if (state == 0 || state == 18) {
            message.append(" Success");
        } else {
            message.append(" Failed");
        }
       // message.append(" Client: ");
        //message.append(clientId);
     //   message.append(" StartTime: ");
       // message.append(input1);
      //  message.append(" EndTime: ");
     //   message.append(input2);
        message.append(" Difference: ");
        message.append(input2 - input1);
        message.append(" Size: ");
        message.append(OutputXml.length());
        NGUtil.writeTransactionLog("", WFSConstant.CONST_MODULE_NAME, message);
        //WFLogger.writeLog('T', message);
        message = null;
    }


    /**
     * *************************************************************
     * Function Name    :   writeLog
     * Author			:   Vikas Saraswat
     * Date Written     :   27/08/2010
     * Input Parameters :   String -> clientId,
     *						String -> strOption, String input1,
     *						String -> input2, int state
     * Output Parameters:   NONE
     * Return Value     :   void
     * Description      :   Log in Transaction.log
     * *************************************************************
     */
	//WFS_8.0_127
    public static void writeLog(String clientId, String strOption, long input1, long input2, int state,String OutputXml, String strCabinetName, boolean flag, long connectionTime, int sessionID, int userID) {
        StringBuffer message = new StringBuffer();
      //  message.append("Transaction:");
		//message.append("\t");
        message.append(strOption);
		message.append("\t");
	//	message.append("Status:");
	//	message.append("\t");
        if (state == 0 || state == 18) {
            message.append("Success");
			message.append("\t");
        } else {
            message.append("Failed");
			message.append("\t");
        }
     //   message.append("Client:");
		//message.append("\t");
      //  message.append(clientId);  /* Bug 38914 */
		//message.append("\t");
		message.append("SessionID:");
		message.append("\t");
		message.append(sessionID);
		message.append("\t");
		message.append(" UserID");
		message.append("\t");
		message.append(userID);
		message.append("\t");
      //  message.append("StartTime:");
	//	message.append("\t");
       // message.append(input1);
	//	message.append("\t");
      //  message.append("EndTime:");
	//	message.append("\t");
      //  message.append(input2);
	//	message.append("\t");
        message.append("Difference:");
		message.append("\t");
        message.append(input2 - input1);
		message.append("\t");
		message.append("ConnectionTime:");
		message.append("\t");
		message.append(connectionTime);
		message.append("\t");
        message.append("Size:");
		message.append("\t");
        message.append(OutputXml.length());
		message.append("\t");
	//	message.append("CabinetName:");
		//message.append("\t");
	//	message.append(strCabinetName);
	//	message.append("\t");
        NGUtil.writeTransactionLog(strCabinetName, WFSConstant.CONST_MODULE_NAME, message);
       // WFLogger.writeLog('T', message.toString(), strCabinetName);
        message = null;
    }


	/**
     * *************************************************************
     * Function Name    :   writeLog
     * Author			:   Saurabh Kamal
     * Date Written     :   19/08/2010
     * Input Parameters :   String -> clientId,
     *						String -> strOption, String input1,
     *						String -> input2, int state, String inputXml, String outputXml
     * Output Parameters:   NONE
     * Return Value     :   void
     * Description      :   Log in Threshold.log
     * *************************************************************
     */
    public static void writeLog(String clientId, String strOption, long input1, long input2, int state, String inputXml, String outputXml) {
        writeLog(clientId, strOption, input1, input2, state,outputXml);//WFS_8.0_127
        writeLog(inputXml, outputXml);
         String cabName = "";
        XMLParser parser = new XMLParser();
        parser.setInputXML(inputXml);
        cabName = parser.getValueOf("EngineName");
        //WFS_8.0_127
		String ThresHoldTime="";
        String ThresHoldSize="";
        ThresHoldTime=WFServerProperty.getSharedInstance().getThresholdData().getProperty(WFSConstant.CONST_THRESHOLD_TIME);

        if(ThresHoldTime==null || ThresHoldTime.equalsIgnoreCase(""))
            ThresHoldTime="5000";

        ThresHoldSize=WFServerProperty.getSharedInstance().getThresholdData().getProperty(WFSConstant.CONST_THRESHOLD_SIZE);

        if(ThresHoldSize==null || ThresHoldSize.equalsIgnoreCase(""))
            ThresHoldSize="102400";

        long execTime = input2-input1;
		//WFS_8.0_127
        if(execTime > Integer.parseInt(ThresHoldTime)){
            StringBuffer message = new StringBuffer();
            message.append("Time Threshold : ");//WFS_8.0_127
            message.append("Time taken by API ");
            message.append(strOption);
            message.append(" is ");
            message.append(execTime);
            message.append(" Client: ");
            message.append(clientId);
            message.append(" StartTime: ");
            message.append(input1);
            message.append(" EndTime: ");
            message.append(input2);
            message.append("\n");
            message.append("Input XML : \n");
            message.append(inputXml);
            message.append("\n");
            message.append("Output XML : \n");
            message.append(outputXml);
            NGUtil.writeTimeThresholdLog(cabName, WFSConstant.CONST_MODULE_NAME, message);
            //WFLogger.writeLog('H', message);
            message = null;
        }
        if(outputXml.length() > Integer.parseInt(ThresHoldSize)){//WFS_8.0_127
            StringBuffer message = new StringBuffer();
            message.append("Size Threshold : ");
            message.append("Size of API ");
            message.append(strOption);
            message.append(" is ");
            message.append(outputXml.length());
            message.append(" Client: ");
            message.append(clientId);
            message.append(" StartTime: ");
            message.append(input1);
            message.append(" EndTime: ");
            message.append(input2);
            message.append("\n");
            message.append("Input XML : \n");
            message.append(inputXml);
            message.append("\n");
            message.append("Output XML : \n");
            message.append(outputXml);
            NGUtil.writeSizeThresholdLog(cabName, WFSConstant.CONST_MODULE_NAME, message);
            //WFLogger.writeLog('S', message);
            message = null;
        }
    }
    public static void writeRecordSizeThresholdLog(String clientId, String cabName, String strOption, long execStartTime, long execEndTime,
            int state, String inputXml, String outputXml, int recordCount) {
        writeLog(clientId, strOption, execStartTime, execEndTime, state, outputXml);//WFS_8.0_127
        writeLog(inputXml, outputXml);
        String ThresHoldRecord = WFServerProperty.getSharedInstance().getThresholdData().getProperty(WFSConstant.CONST_THRESHOLD_RECORD);
        if (ThresHoldRecord == null || ThresHoldRecord.equalsIgnoreCase("")) {
            ThresHoldRecord = "2000";
        }
        if (recordCount > Integer.parseInt(ThresHoldRecord)) {
            StringBuffer message = new StringBuffer();
            message.append("Record Threshold : ");
            message.append("Record from API ");
            message.append(strOption);
            message.append(" is ");
            message.append(recordCount);
            message.append(" Client: ");
            message.append(clientId);
            message.append(" StartTime: ");
            message.append(execStartTime);
            message.append(" EndTime: ");
            message.append(execEndTime);
            message.append("\n");
            message.append("Input XML : \n");
            message.append(inputXml);
            message.append("\n");
            message.append("Output XML : \n");
            message.append(outputXml);
            NGUtil.writeSizeThresholdLog(cabName, WFSConstant.CONST_MODULE_NAME, message);
            //WFLogger.writeLog('S', message);
            message = null;
        }
    }
	/**
     * *************************************************************
     * Function Name    :   writeLog
     * Author			:   Neeraj Kumar
     * Date Written     :   19/08/2010
     * Input Parameters :   String -> clientId,
     *						String -> strOption, String input1,
     *						String -> input2, int state, String inputXml, String outputXml
     * Output Parameters:   NONE
     * Return Value     :   void
     * Description      :   Log in Threshold.log
     * *************************************************************
     */
    public static void writeLog(String clientId, String strOption, long input1, long input2, int state, String inputXml, String outputXml, String strCabinetName, long connectionTime,int sessionID, int userID) { /* 38914 */
        writeLog(clientId, strOption, input1, input2, state,outputXml,strCabinetName, true,connectionTime,sessionID,userID);
  
		String ThresHoldTime="";
        String ThresHoldSize="";
        ThresHoldTime=WFServerProperty.getSharedInstance().getThresholdData().getProperty(WFSConstant.CONST_THRESHOLD_TIME);
        if(ThresHoldTime==null || ThresHoldTime.equalsIgnoreCase(""))
            ThresHoldTime="5000";

        ThresHoldSize=WFServerProperty.getSharedInstance().getThresholdData().getProperty(WFSConstant.CONST_THRESHOLD_SIZE);

        if(ThresHoldSize==null || ThresHoldSize.equalsIgnoreCase(""))
            ThresHoldSize="102400";

        long execTime = input2-input1;
		//WFS_8.0_127
        if(execTime > Integer.parseInt(ThresHoldTime)){
            StringBuffer message = new StringBuffer();
            message.append("Time Threshold : ");//WFS_8.0_127
            message.append("Time taken by API ");
            message.append(strOption);
            message.append(" is ");
            message.append(execTime);
            message.append(" Client: ");
            message.append(clientId);
            message.append(" StartTime: ");
            message.append(input1);
            message.append(" EndTime: ");
            message.append(input2);
            message.append("\n");
			if(sessionID != 0){  /* 38914 */
				message.append(" SessionID: ");
				message.append(sessionID);
				message.append(" UserID ");
				message.append(userID);
			}
			message.append("\n");
            message.append("Input XML : \n");
            message.append(inputXml);
            message.append("\n");
            message.append("Output XML : \n");
            message.append(outputXml);
            NGUtil.writeTimeThresholdLog(strCabinetName, WFSConstant.CONST_MODULE_NAME, message);
            //WFLogger.writeLog('H', message);
            message = null;
        }
        if(outputXml.length() > Integer.parseInt(ThresHoldSize)){//WFS_8.0_127
            StringBuffer message = new StringBuffer();
            message.append("Size Threshold : ");
            message.append("Size of API ");
            message.append(strOption);
            message.append(" is ");
            message.append(outputXml.length());
            message.append(" Client: ");
            message.append(clientId);
            message.append(" StartTime: ");
            message.append(input1);
            message.append(" EndTime: ");
            message.append(input2);
            message.append("\n");
			if(sessionID != 0){  /* 38914 */
				message.append(" SessionID: ");
				message.append(sessionID);
				message.append(" UserID ");
				message.append(userID);
			}
			message.append("\n");
            message.append("Input XML : \n");
            message.append(inputXml);
            message.append("\n");
            message.append("Output XML : \n");
            message.append(outputXml);
            NGUtil.writeSizeThresholdLog(strCabinetName, WFSConstant.CONST_MODULE_NAME, message);
            //WFLogger.writeLog('S', message);
            message = null;
        }
    }


    /**
     * *************************************************************
     * Function Name    :   writeLog
     * Author			:   Varun Bhansaly
     * Date Written     :   18/10/2007
     * Input Parameters :   String -> clientId,
     *						String -> strOption, String input1,
     *						String -> input2, int state
     * Output Parameters:   NONE
     * Return Value     :   void
     * Description      :   Log in XML.log
     * *************************************************************
     */
    public static void writeLog(String input1, String input2) {
        StringBuffer message = new StringBuffer();
        message.append(input1);
        message.append(System.getProperty("line.separator"));
        message.append(input2);
        NGUtil.writeXmlLog("",WFSConstant.CONST_MODULE_NAME,input1,input2);
        //WFLogger.writeLog('X', message);
        message = null;
    }

    /**
     * *************************************************************
     * Function Name    :   writeSAPLog
     * Author			:  Minakshi Sharma
     * Date Written     :   16/07/2009
     * Input Parameters :   String -> clientId,
     *						String -> input1,
     *						String -> input2
     * Output Parameters:   NONE
     * Return Value     :   void
     * Description      :   Log in SAPXML.log
     * *************************************************************
     */
    public static void writeSAPLog(String input1, String input2) {
        XMLParser parser = new XMLParser();
        parser.setInputXML(input1);
        String cabName = "";
        cabName = parser.getValueOf("EngineName");
        StringBuffer message = new StringBuffer();
        input1 = Utility.changePassword(input1);
        input2 = Utility.changePassword(input2);
        message.append(input1);
        message.append(System.getProperty("line.separator"));
        message.append(input2);
        NGUtil.writeXmlLog(cabName, WFSConstant.CONST_SAP_MODULE, input1, input2);
        //WFLogger.writeLog('P', message);
        message = null;
    }

    /**
     * *************************************************************
     * Function Name    :   writeLog
     * Author			:   Varun Bhansaly
     * Date Written     :   18/10/2007
     * Input Parameters :   String -> msg,
     *						String -> cabinet,
     *						String -> destination,
     * Output Parameters:   NONE
     * Return Value     :   void
     * Description      :   To print JMS Failure Messages in JMS.log
     * *************************************************************
     */
    public static void writeLog(String msg, String cabinet, String destination) {
        
        StringBuffer message = new StringBuffer();
        message.append(" Cabinet: ");
        message.append(cabinet);
        message.append(" Destination: ");
        message.append(destination);
        message.append(" Message: ");
        message.append(msg);
        NGUtil.writeXmlLog(cabinet, WFSConstant.CONST_JMS_MODULE, message.toString(),"");
        //WFLogger.writeLog('J', message);
        message = null;
    }

     /**
     * *************************************************************
     * Function Name    :   writeLog
     * Author			:   Varun Bhansaly
     * Date Written     :   18/10/2007
     * Input Parameters :   String -> msg,
     *						String -> cabinet,
     *						String -> destination,
     * Output Parameters:   NONE
     * Return Value     :   void
     * Description      :   To print XML Logs.
     * *************************************************************
     */
     public static void writeLog(String input1, String input2, String strCabinetName, boolean flag) {
         /*User/API logging support- sajid khan**/
        /******************************************/
        String strArr[] = returnUserApiStatus();
        String uName = strArr[0];
        String userApiStatus = strArr[1];
        StringBuffer message = new StringBuffer();
        message.append(" ["+uName+"]  "+input1);
        message.append(System.getProperty("line.separator"));
        message.append(" ["+uName+"]  "+input2);
        if(userApiStatus.equals("10")){
            NGUtil.writeUserXmlLog(strCabinetName,WFSConstant.CONST_MODULE_NAME ,message);
         }else if (userApiStatus.equals("01")){
            NGUtil.writeApiXmlLog(strCabinetName,WFSConstant.CONST_MODULE_NAME, message);
         }else if (userApiStatus.equals("11")){
            NGUtil.writeUserXmlLog(strCabinetName, WFSConstant.CONST_MODULE_NAME, message);
         }
        NGUtil.writeXmlLog(strCabinetName, WFSConstant.CONST_MODULE_NAME," ["+uName+"] "+ input1," ["+uName+"]  "+  input2);
        //WFLogger.writeLog('X', message.toString(), strCabinetName);
        message = null;
        //writeLog(input1, input2);
    }

    /**
     * *************************************************************
     * Function Name    :   isLogEnabled
     * Author			:   Varun Bhansaly
     * Date Written     :   18/10/2007
     * Input Parameters :   char -> logType, Level -> level
     * Output Parameters:   NONE
     * Return Value     :   boolean
     * Description      :   To avoid cost of parameter construction
     * *************************************************************
     */
//    public static boolean isLogEnabled(char logType, Level level) {
//        return WFLogger.isLogEnabled(logType, level);
//    }

    /**
     * *************************************************************
     * Function Name    :   nextVal
     * Author			:   Ashish Mangla
     * Date Written     :   21/11/2007
     * Input Parameters :   Connection, Sequence name, datatbase type
     * Output Parameters:   NONE
     * Return Value     :   String value having next value for the defined sequence
     * Description      :   To get the next value for a given sequence name
     * *************************************************************
     */
    public static String nextVal(Connection con, String sequenceName, int dbType) throws SQLException {
        Statement stmt = null;
        ResultSet rs = null;
        String sqlQuery = "";
        String nextValue = "";

        switch (dbType) {
            case JTSConstant.JTS_ORACLE: {
                sqlQuery = "SELECT " + WFSUtil.TO_SANITIZE_STRING(sequenceName,false) + ".NextVal From Dual";
                break;
            }
            case JTSConstant.JTS_POSTGRES: {
                sqlQuery = "SELECT NextVal('" + WFSUtil.TO_SANITIZE_STRING(sequenceName,false) + "')";
                break;
            }
            case JTSConstant.JTS_DB2: {
                sqlQuery = "SELECT NextVal for " + WFSUtil.TO_SANITIZE_STRING(sequenceName,false) + " from sysibm.sysdummy1";
                break;
            }
        }

        try {
            stmt = con.createStatement();
            rs = stmt.executeQuery(sqlQuery);
            if (rs != null && rs.next()) {
                nextValue = rs.getString(1);
                rs.close();
            }
            rs = null;

            stmt.close();
            stmt = null;

        } finally {
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (Exception ignored) {
            }
            if (stmt != null) {
                try {
                    stmt.close();
                    stmt = null;
                } catch (Exception ignored) {
                }
            }
        }
        return WFSUtil.TO_SANITIZE_STRING(nextValue,false);
    }

    /**
     * *************************************************************
     * Function Name    :   createTempTable
     * Author			:   Ashish Mangla
     * Date Written     :   23/11/2007
     * Input Parameters :
     * Output Parameters:   NONE
     * Return Value     :   String value having next value for the defined sequence
     * Description      :   To get the next value for a given sequence name
     * *************************************************************
     */
    public static void createTempTable(Statement stmt, String tableName, String columnList, int dbType) throws SQLException {
        createTempTable(stmt, tableName, columnList, "", "", dbType);
    }

    public static void createTempTable(Statement stmt, String tableName, String columnList, String indexName, String indexList, int dbType) throws SQLException {
        String sqlQuery = "";
        String indexQuery = "";

        switch (dbType) {
            case JTSConstant.JTS_ORACLE: {
                //We are using global Temporary table
                return;
            }
            case JTSConstant.JTS_POSTGRES: {
                sqlQuery = "CREATE TEMP TABLE " + tableName + "(" + columnList + ")";
                if (indexList != null && !indexList.trim().equalsIgnoreCase("")) {
                    indexQuery = "CREATE INDEX " + indexName + " on " + tableName + " (" + indexList + ")";
                }
                break;
            }
            default: {
                sqlQuery = "CREATE TABLE " + tableName + "(" + columnList + ")";
                if (indexList != null && !indexList.trim().equalsIgnoreCase("")) {
                    indexQuery = "CREATE INDEX " + indexName + " on " + tableName + " (" + indexList + ")";
                }
                break;
            }
        }
        stmt.execute(sqlQuery);

        if (!indexQuery.trim().equalsIgnoreCase("")) {
            stmt.execute(indexQuery);
        }
    }

    public static void dropTempTable(Statement stmt, String tableName, int dbType) throws SQLException {
        String sqlQuery = "";

        switch (dbType) {
            case JTSConstant.JTS_ORACLE: {
                sqlQuery = "Truncate Table " + tableName;	//Bugzilla Bug 3430

                break;
            }
            case JTSConstant.JTS_POSTGRES: {
                sqlQuery = "Drop Table IF EXISTS " + tableName;	//Bugzilla Bug 3430

                break;
            }
            default: {
                sqlQuery = "Drop Table " + tableName;
                break;
            }
        }
        stmt.execute(sqlQuery);
    }

    public static String getTempTableName(Connection con, String tableName, int dbType) {
        String newName = null;

        switch (dbType) {
            case JTSConstant.JTS_MSSQL: {
                newName = "#" + tableName;
                break;
            }
            case JTSConstant.JTS_ORACLE: {
                newName = "G" + tableName;
                break;
            }
            case JTSConstant.JTS_DB2: {
                newName = "G" + tableName + "_" + con.hashCode();
                break;
            }
            default: {
                newName = tableName;
                break;
            }
        }
        return newName;
    }

    //----------------------------------------------------------------------------------------------------
    //	Function Name 				:	getQueryFilter
    //	Author						:	Ashish Mangla
    //  Date						:	07/09/2007
    //	Input Parameters			:	Connection, queueId, dbtype, user information, QueueFilter
    //									QueueFilter will be non-empty if and only if
    //									1. QueueType is N No-Assignment Queue
    //									2. filter is non-empty
    //	Output Parameters			:   none
    //	Return Values				:	string[] ->	zeroth index is the QueryFilter
    //												oneth index is the OrderBy String
    //	Description					:   returns the queryFilter + OrderBy String(if present) for the given
    //									user associated in the given queue
    //									When using getQueryFilter on Queues of type other than 'N' QueueFilter
    //									should be empty
    //----------------------------------------------------------------------------------------------------
    public static String[] getQueryFilter(Connection con, int queueId, int dbType, WFParticipant participant, String queueFilter, String engineName) throws SQLException {
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        String queryFilter = "";
        String innerOrderBy = "";
        String tempFilter1 = "";
        StringBuffer tempFilter = new StringBuffer(10);
        int userId = participant.getid();
        int groupId = -1;
        int counter = 0;
        int orderByPos = -1;

        try {
            String toSearch = "ORDER BY";
            pstmt = con.prepareStatement("SELECT QueryFilter FROM QueueUserTable " + WFSUtil.getTableLockHintStr(dbType) + "  WHERE QueueId = ? AND userId = ? AND AssociationType = 0");
            pstmt.setInt(1, queueId);
            pstmt.setInt(2, participant.getid());
            pstmt.execute();
            rs = pstmt.getResultSet();

            if (rs != null && rs.next()) {
                queryFilter = rs.getString("QueryFilter");
                queryFilter = rs.wasNull() ? "" : queryFilter.trim();
                queryFilter = WFSUtil.parseQueryFilter(con, queryFilter, "U", userId, dbType, engineName);
                orderByPos = queryFilter.toUpperCase().indexOf(toSearch);
                if (orderByPos != -1) {
                    innerOrderBy = queryFilter.substring(orderByPos + toSearch.length());
                    queryFilter = queryFilter.substring(0, orderByPos);
                }
                pstmt.close();
            } else {
                //might be group is added to the queue. So find the filter criteria and for groups of which user is a member and return the results after ORing....
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
                pstmt.close();
                pstmt = null;

                pstmt = con.prepareStatement("SELECT QueryFilter, GroupId FROM QUserGroupView WHERE QueueId = ? AND userId = ?");// AND GroupId IS NOT NULL");

                /** Last condition no longer needed,
                 * as code will come in this block only when particular user is not associated to the Queue directly.
                 */
                pstmt.setInt(1, queueId);
                pstmt.setInt(2, participant.getid());
                pstmt.execute();
                rs = pstmt.getResultSet();

                if (rs != null) {
                    while (rs.next()) {
                        queryFilter = rs.getString("QueryFilter");
                        queryFilter = rs.wasNull() ? "" : queryFilter.trim();
                        groupId = rs.getInt("GroupId");
                        queryFilter = WFSUtil.parseQueryFilter(con, queryFilter.trim(), "U", userId, dbType, engineName);
                        if (!queryFilter.equals("")) {
                            orderByPos = queryFilter.toUpperCase().indexOf(toSearch);
                            if (orderByPos != -1) {
                                innerOrderBy = queryFilter.substring(orderByPos + toSearch.length());
                                queryFilter = queryFilter.substring(0, orderByPos);
                            }
                            if (!queryFilter.equals("")) {
                                queryFilter = WFSUtil.parseQueryFilter(con, queryFilter, "G", groupId, dbType, engineName);
                                queryFilter = "(" + queryFilter.trim() + ")";
                                tempFilter.append(((counter == 0) ? queryFilter : " OR " + queryFilter));
                                counter++;
                            }
                        } else {
							tempFilter = new StringBuffer(10);	//WFS_8.0_046
							break; //break while loop no need to go further	//WFS_8.0_046
						}
                    }
                    queryFilter = tempFilter.toString();
                }
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
                pstmt.close();
                pstmt = null;
            }
            
            /**
             * 1. QueueFilter has to be considered for QueueType = 'N' only &,
             * 2. It has to be evaluated only when QueryFilter is empty &,
             * 3. when queueFilter is not itself empty.
             */
            if (queryFilter.trim().equals("") && queueFilter != null && !queueFilter.trim().equals("")) {
                queryFilter = WFSUtil.TO_SANITIZE_STRING(queueFilter,true);
                /* Note OrderBy will occur only once in the Filter */
                orderByPos = queryFilter.toUpperCase().indexOf(toSearch);
                if (orderByPos != -1) {
                    innerOrderBy = queryFilter.substring(orderByPos + toSearch.length());
                    queryFilter = queryFilter.substring(0, orderByPos);
                }
                if (!queryFilter.trim().equals("")) {
                    queryFilter = WFSUtil.parseQueryFilter(con, queryFilter, "U", userId, dbType, engineName);
                    tempFilter1 = queryFilter;
                    pstmt = con.prepareStatement("SELECT GroupId , QueryFilter FROM QUserGroupView WHERE QueueId = ? AND UserId = ? AND GroupId IS NOT NULL ");
                    pstmt.setInt(1, queueId);
                    pstmt.setInt(2, userId);
                    pstmt.execute();
                    rs = pstmt.getResultSet();

                    while (rs != null && rs.next()) {
                        /** User can be member of multiple groups, for each of the groups, replace &<GroupIndex.*>& with respective values.
                         * If logged in user is member of 2 groups and both of the groups have rights on the Queue.
                         * Parsed version of filter VAR_INT1 = 1000 AND VAR_STR1 = &<GroupIndex.City>& will be like
                         * ((VAR_INT1 =1000 AND VAR_STR1 = 'Pune') OR (VAR_INT1 =1000 AND VAR_STR1 = 'Kolkata'))
                         * Though it should be like ((VAR_INT1 =1000 AND (VAR_STR1 = 'Pune' OR VAR_STR1 = 'Kolkata'))
                         */
                        groupId = rs.getInt("GroupId");
                        queryFilter = WFSUtil.parseQueryFilter(con, queryFilter, "G", groupId, dbType, engineName);
                        queryFilter = "(" + queryFilter + ")";
						if (counter == 0) {
							tempFilter1 = queryFilter;  //WFS_8.0_040
						} else {
							tempFilter1 = tempFilter1 + " OR " + queryFilter;
						}
                        counter = counter + 1;
                    }
					queryFilter = tempFilter1;
                }
            }
            if (rs != null) {
                rs.close();
                rs = null;
            }
            if (pstmt != null) {
                pstmt.close();
                pstmt = null;
            }
            if (!queryFilter.equals("")) {
                queryFilter = replaceIgnoreCase(queryFilter, "&<UserIndex>&", participant.getid() + "");
                queryFilter = replaceIgnoreCase(queryFilter, "&<UserName>&", participant.getname());
            }
			
			int functionPos = queryFilter.indexOf("&<FUNCTION>&");
            if(functionPos != -1){
                queryFilter = getFunctionFilter(con, queryFilter, dbType);
            }
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
            } catch (Exception ignored) {
            }
        }
        return new String[]{queryFilter, innerOrderBy};
    }
	
/*	public static String[] getQueryFilter(Connection con, int queueId, int dbType, WFParticipant participant, String queueFilter, String engineName) throws SQLException {
        String[] stArr = getQueryFilter(con, queueId, dbType, participant, queueFilter);
		return stArr;
    }*/

    /**
     * *************************************************************
     * Function Name    :   isSyncRoutingMode()
     * Author			:   Ruhi Hira
     * Date Written     :   18/12/2007
     * Input Parameters :   NONE
     * Output Parameters:   NONE
     * Return Value     :   boolean : Synchronous routing mode
     * Description      :   Returns whether server is running in
     *                      synchronous routing mode or not.
     * *************************************************************
     */
    public static boolean isSyncRoutingMode() {
        boolean syncRoutingFlag = false;
        try {
            syncRoutingFlag = ((String) WFFindClass.wfGetServerPropertyMap().get(WFSConstant.CONST_SYNC_ROUTING_MODE)).equalsIgnoreCase("Y") ? true : false;
        } catch (Exception ignored) {
            //printOut(cabName,"[WFSUtil] isSyncRoutingMode() ignoring exception >> " + ignored);
        }
        return syncRoutingFlag;
    }
    
    /**
     * *************************************************************
     * Function Name    :   isRegHyphen()
     * Author			:   Satyanarayan Sharma
     * Date Written     :   23/08/2021
     * Input Parameters :   NONE
     * Output Parameters:   NONE
     * Return Value     :   String : hyphenRequiredFlag
     * Description      :   Returns hyphenRequired or not.
     * *************************************************************
     */
    public static String isRegHyphen() {
        String hyphenRequiredFlag = "N";
        try {
            hyphenRequiredFlag = ((String) WFFindClass.wfGetServerPropertyMap().get(WFSConstant.CONST_Hyphen_Required)).equalsIgnoreCase("Y") ? "Y" : "N";
        } catch (Exception ignored) {
            //printOut(cabName,"[WFSUtil] isRegHyphen() ignoring exception >> " + ignored);
        }
        return hyphenRequiredFlag ;
    }
    
    
    /**
     * *************************************************************
     * Function Name    :   isEnableAxis1()
     * Author			:   Satyanarayan Sharma
     * Date Written     :   25/09/2022
     * Input Parameters :   NONE
     * Output Parameters:   NONE
     * Return Value     :   String : EnableAxis1
     * Description      :   Returns EnableAxis1 or not.
     * *************************************************************
     */
    public static boolean isEnableAxis1() {
    	boolean enableAxis1Flag = false;
        try {
        	enableAxis1Flag = ((String) WFFindClass.wfGetServerPropertyMap().get(WFSConstant.CONST_ENABLEAXIS1)).equalsIgnoreCase("Y") ? true : false;
        } catch (Exception ignored) {
            //printOut(cabName,"[WFSUtil] isEnableAxis1() ignoring exception >> " + ignored);
        }
        return enableAxis1Flag;
    }
    
    /**
     * *************************************************************
     * Function Name    :   isSoftDeleteForArray
     * Author			:   Nikhil Garg
     * Date Written     :   25/4/2023
     * Input Parameters :   NONE
     * Output Parameters:   NONE
     * Return Value     :   String : softDelete
     * Description      :   Returns SoftDelete or not.
     * *************************************************************
     */
    public static boolean isSoftDeleteForArray() {
    	boolean softDelete = false;
        try {
        	softDelete = ((String) WFFindClass.wfGetServerPropertyMap().get(WFSConstant.CONST_SOFTDELETEFORARRAY)).equalsIgnoreCase("Y") ? true : false;
        } catch (Exception ignored) {
            //printOut(cabName,"[WFSUtil] isEnableAxis1() ignoring exception >> " + ignored);
        }
        return softDelete;
    }


    //----------------------------------------------------------------------------------------------------
    //	Function Name 				: getDivert
    //	Date Written (DD/MM/YYYY)	: 17/06/2003
    //	Author						: Prashant
    //	Input Parameters			: Connection con , int userId, int dbType
    //	Output Parameters			: none
    //	Return Values				: int
    //	Description					: Performs the collection of distributed Workitems
    //----------------------------------------------------------------------------------------------------
    // Changed By						: Prashant
    // Reason / Cause (Bug No if Any)	: Bug No TSR_3.0.2.0023
    // Change Description				: In case of fixed assignment to a user
    //									  check for diversions.
    //----------------------------------------------------------------------------
    /** 08/01/2008, Bugzilla Bug 1649, Method moved from OraCreateWI - Ruhi Hira */
    public static int getDivert(Connection con, int userId, int dbType) {
        Statement stmt = null;
        ResultSet rs = null;
        int tuserId = 0;
        try {
            stmt = con.createStatement();
            rs = stmt.executeQuery(
                    "Select AssignedUserIndex from UserDiversionTable " + WFSUtil.getTableLockHintStr(dbType) + "  where DivertedUserIndex = " + userId + " and " + WFSUtil.getDate(dbType) + " >= fromDate and toDate >= " + WFSUtil.getDate(dbType));
            if (rs.next()) {
                tuserId = rs.getInt(1);
            }
            if (rs != null) {
                rs.close();
            }
            stmt.close();
            stmt = null;
        } catch (Exception e) {
        } finally {
        	try {
                if (rs != null) {
                    rs.close();
                    rs=null;
                }
            } catch (SQLException ex) {
            }
            try {
                if (stmt != null) {
                    stmt.close();
                }
            } catch (SQLException ex) {
            }
        }

        if (tuserId > 0) {
            userId = getDivert(con, tuserId, dbType);
        }
        return userId;
    }

  //----------------------------------------------------------------------------------------------------
    //	Function Name 				: getDivert
    //	Date Written (DD/MM/YYYY)	: 23/08/2023
    //	Author						: Nikhil Garg
    //	Input Parameters			: Connection con , int userId, int dbType,int processdefid, int activityid
    //	Output Parameters			: none
    //	Return Values				: int
    //	Description					: Performs the collection of distributed Workitems
    //----------------------------------------------------------------------------------------------------
    /** 08/01/2008, Bugzilla Bug 1649, Method moved from OraCreateWI - Ruhi Hira */
    public static int getDivert(Connection con, int userId, int dbType, int processdefid, int activityid) {
        Statement stmt = null;
        ResultSet rs = null;
        ResultSet rs1 = null;
        ResultSet rs2 = null;
        int tuserId = 0;
        int tprocid = 0;
        int tactId = 0;
        try {
            stmt = con.createStatement();
            rs = stmt.executeQuery(
                    "Select AssignedUserIndex,processdefid, activityid from UserDiversionTable " + WFSUtil.getTableLockHintStr(dbType) + "  where DivertedUserIndex = " + userId +"and activityid = "+ activityid +" and processdefid= "+processdefid+ " and " + WFSUtil.getDate(dbType) + " >= fromDate and toDate >= " + WFSUtil.getDate(dbType));
            if (rs.next()) {
                tuserId = rs.getInt(1);
            }else{
            	rs1 = stmt.executeQuery(
                        "Select AssignedUserIndex,processdefid, activityid from UserDiversionTable " + WFSUtil.getTableLockHintStr(dbType) + "  where DivertedUserIndex = " + userId +" and processdefid= "+processdefid  + " and "+WFSUtil.getDate(dbType) + " >= fromDate and toDate >= " + WFSUtil.getDate(dbType));
            	if(rs1.next()){
            		tuserId = rs1.getInt("AssignedUserIndex");
            	}
            	else{
            		rs2 = stmt.executeQuery(
                            "Select AssignedUserIndex,processdefid, activityid from UserDiversionTable " + WFSUtil.getTableLockHintStr(dbType) + "  where DivertedUserIndex = " + userId +"and activityid = 0 and processdefid= 0 and " + WFSUtil.getDate(dbType) + " >= fromDate and toDate >= " + WFSUtil.getDate(dbType));
                	if(rs2.next()){
                		tuserId = rs2.getInt("AssignedUserIndex");
                	}
            	}
            }
            if (rs != null) {
                rs.close();
            }
            if (rs1 != null) {
                rs1.close();
            }
            stmt.close();
            stmt = null;
        } catch (Exception e) {
        } finally {
        	try {
                if (rs != null) {
                    rs.close();
                    rs=null;
                }
            } catch (SQLException ex) {
            }
            try {
                if (stmt != null) {
                    stmt.close();
                }
            } catch (SQLException ex) {
            }
        }

        if (tuserId > 0) {
            userId = getDivert(con, tuserId, dbType, processdefid, activityid);
        }
        return userId;
    }

    /**
     * *************************************************************
     * Function Name    :   getLikeFilterStr
     * Programmer' Name :   Ruhi Hira
     * Date Written     :   January 15th 2008
     * Input Parameters :   XMLParser -> parser
     *                      String    -> columnName
     *                      String    -> data
     *                      int       -> dbType
     *                      boolean   -> UTF8Flag
     * Output Parameters:   NONE
     * Return Value     :   String -> like filter String
     * Description      :   Returns like filter string
     *                      Upper(RTrim(<COLUMN_NAME>)) LIKE
     *                      Upper(RTrim(<DATA>)) ESCAPE N'\\'
     * *************************************************************
     */
    public static String getLikeFilterStr(XMLParser parser, String columnName, String data, int dbType, boolean UTF8Flag, int varType) {
        String returnStr = null;
        boolean excludeQueuePrefixFlag = parser.getValueOf("ExcludeQueuePrefix").startsWith("Y");
        if (dbType == JTSConstant.JTS_MSSQL) {
            data = WFSUtil.replace(parser.convertToSQLString(data), "*", "%");
        } else if(dbType == JTSConstant.JTS_POSTGRES) {
            data = WFSUtil.replace(convertToPostgresLikeSQLString(data), "*", "%");
        }else{
            data = WFSUtil.replace(parser.convertToSQLString(data, dbType), "*", "%");
        }
        if(excludeQueuePrefixFlag)
        {
        	returnStr = " " + TO_STRING(columnName, false, dbType) + " NOT LIKE " + TO_STRING(TO_STRING(data, true, dbType), false, dbType);
        }
        else
        {
        returnStr = " " + TO_STRING(columnName, false, dbType) + " LIKE " + TO_STRING(TO_STRING(data, true, dbType), false, dbType);
        }
        /** @todo Need to check in DB2 - Ruhi Hira */
        /** 11/11/2008, Bugzilla Bug 6941, PickList give error when search with some value in int field in Oracle.
         * - Ruhi Hira */
        if (varType == WFSConstant.WF_STR) {
            if ((dbType == JTSConstant.JTS_ORACLE && UTF8Flag) || dbType == JTSConstant.JTS_DB2) {
                if ((returnStr.indexOf("_") != -1) || (returnStr.indexOf("[\\%]") != -1)) {
                    returnStr += " Escape " + WFSUtil.TO_STRING("\\", true, dbType);
                }
            }
        }
        returnStr += " ";
        return returnStr;
    }

    public static String getLikeFilterStr(XMLParser parser, String columnName, String data, int dbType, boolean UTF8Flag) {
        return getLikeFilterStr(parser, columnName, data, dbType, UTF8Flag, WFSConstant.WF_STR);
    }

    public static String convertToPostgresLikeSQLString(String paramString) {
        try {
            int i = paramString.indexOf("\\");
            while(i != -1) {
                paramString = paramString.substring(0, i) + "\\\\" + paramString.substring(i + 1, paramString.length());
                i = paramString.indexOf("\\", i + 2);
            }
        }
        catch(Exception localException1) {
        }
        try {
            int j = paramString.indexOf("_");
            while(j != -1) {
                paramString = paramString.substring(0, j) + "\\_" + paramString.substring(j + 1, paramString.length());
                j = paramString.indexOf("_", j + 2);
            }
        }
        catch(Exception localException2) {
        }
        try {
            int k = paramString.indexOf("%");
            while(k != -1) {
                paramString = paramString.substring(0, k) + "\\%" + paramString.substring(k + 1, paramString.length());
                k = paramString.indexOf("%", k + 2);
            }

        }
        catch(Exception localException3) {
        }

        paramString = paramString.replace('?', '_');
        return paramString;
    }
    //----------------------------------------------------------------------------------------------------
    //	Function Name 			:	insertMessage
    //	Date Written (DD/MM/YYYY):	24/01/2008
    //	Author					:	Sirish Gupta
    //	Input Parameters		:	message, con, dbtype
    //	Output Parameters		:   none
    //	Return Values			:	none
    //	Description				:   inserts messages into WFMessageTable
    //----------------------------------------------------------------------------------------------------
    public static void insertMessage(String message, Connection con, int dbType) {
       // ResultSet rs = null;
        Statement stmt = null;
        PreparedStatement pstmt = null;
        boolean commit = false;
        try {
            if ((dbType == JTSConstant.JTS_MSSQL) || (dbType == JTSConstant.JTS_DB2) || (dbType == JTSConstant.JTS_POSTGRES)) {
                pstmt = con.prepareStatement("Insert into WFMessageTable (message, status, ActionDateTime) Values (" + message + ", " + WFSUtil.TO_STRING("N", true, dbType) + ", " + getDate(dbType) + ")");
                pstmt.execute();
                pstmt.close();
                return;
            } else if (dbType == JTSConstant.JTS_ORACLE) {
                String messageId = "0";
                stmt = con.createStatement();
                if (con.getAutoCommit()) {
                    con.setAutoCommit(false);
                    commit = true;
                }

                messageId = nextVal(con, "seq_messageId", dbType);
                stmt.execute("Insert into WFMessageTable (messageId, message, status, ActionDateTime) Values ( " + WFSUtil.TO_SANITIZE_STRING(messageId,false) + ", EMPTY_CLOB(), " + WFSUtil.TO_STRING("N", true, dbType) + ", " + getDate(dbType) + ")");
                writeOracleCLOB(con, stmt, "WFMessageTable", "message", "messageId = " + messageId, message.toString());
                if (commit && !con.getAutoCommit()) {
                    con.commit();
                    con.setAutoCommit(true);
                    commit = false;
                }
            }
        } catch (Exception e) {
            //System.out.println("Exception caught.");
			//printErr("WFSUtil>> insertMessage" + e);
        }finally{
//        	try{
//        		if(rs!=null){
//        			rs.close();
//        			rs=null;
//        		}
//        	}catch(Exception e){
//        		
//        	}
        	try{
        		if(pstmt!=null){
        			pstmt.close();
        			pstmt=null;
        		}
        	}catch(Exception e){
        		
        	}
        }
    }

    public static String generalError(String txnName, String cabinetName, XMLGenerator generator, int error, String errorMessage) {
        StringBuffer strOutputBuffer = new StringBuffer();
        try {
            strOutputBuffer.append(generator.createOutputFile(txnName));
            strOutputBuffer.append(generator.writeValueOf("Status", String.valueOf(error)));
            strOutputBuffer.append(generator.writeValueOf("Error", errorMessage));
            strOutputBuffer.append(generator.closeOutputFile(txnName));
        } catch (Exception e) {
            WFSUtil.printErr(cabinetName,"[WFClientServiceHandler] generalError() I " + e);
            WFSUtil.printErr(cabinetName,"General Exception Occured(In Function generalError(JTS)) at time " + new java.text.SimpleDateFormat("dd.MM.yyyy hh:mm:ss", Locale.US).format(new java.util.Date()) + " with message " + e.getMessage());
        }
        return strOutputBuffer.toString();
    } //end-generalError


    public static String generalError(String txnName, String engineName, XMLGenerator generator, int mainErrorCode, int subErrorCode, String typeOfError, String errorMessage, String errorDescription) {
    	return generalError(txnName, engineName, generator, mainErrorCode, subErrorCode, typeOfError, errorMessage, errorDescription, null);
    }
    public static String generalError(String txnName, String engineName, XMLGenerator generator, int mainErrorCode, int subErrorCode, String typeOfError, String errorMessage, String errorDescription, String dataXML) {
        StringBuffer strOutputBuffer = new StringBuffer();
        try {
            strOutputBuffer.append(generator.createOutputFile(txnName));
            strOutputBuffer.append(generator.writeValueOf("Status", String.valueOf(mainErrorCode)));
            strOutputBuffer.append("<Error>");
            strOutputBuffer.append("<Exception>");
            strOutputBuffer.append(generator.writeValueOf("MainCode", String.valueOf(mainErrorCode)));
            strOutputBuffer.append(generator.writeValueOf("SubErrorCode", String.valueOf(subErrorCode)));
            strOutputBuffer.append(generator.writeValueOf("TypeOfError", String.valueOf(typeOfError)));
            if(errorMessage!=null && !errorMessage.isEmpty()){
            strOutputBuffer.append(generator.writeValueOf("Subject", String.valueOf(errorMessage)));
            }
            else{
            	strOutputBuffer.append(generator.writeValueOf("Subject", String.valueOf(errorDescription)));
            }
            strOutputBuffer.append(generator.writeValueOf("Description", errorDescription));
            strOutputBuffer.append("</Exception>");
            strOutputBuffer.append("</Error>");
            if (dataXML != null && !dataXML.trim().equals("")) {
                strOutputBuffer.append(dataXML);
            }
            strOutputBuffer.append(generator.closeOutputFile(txnName));
        } catch (Exception e) {
        }
        return strOutputBuffer.toString();
    }

//----------------------------------------------------------------------------------------------------
//	Function Name 					:	createProcessInstance
//	Date Written (DD/MM/YYYY)		:	31/05/2003
//	Author							:	Prashant
//	Input Parameters				:	Connection , XMLParser , XMLGenerator
//	Output Parameters				:   none
//	Return Values					:	String
//	Description						:   Returns Definiton details of Process
//----------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------
// Changed By											: Prashant
// Reason / Cause (Bug No if Any)	: Bug No TSR_3.0.2.0011
// Change Description							:	WMCreateProcessInstance to update the starting no
//																	in ProcessDeftable each time a Process Instance is
//																	created and to use the same as the running sequence
//																	number instead of calculating the same from the tables.
//----------------------------------------------------------------------------
// Changed By						: Harmeet
// Reason / Cause (Bug No if Any)	: Bug No WSE_I_5.0.1_694
// Change Description				: Created date time was shown greater then other action  times.
//----------------------------------------------------------------------------
// Changed By						: Harmeet
// Reason / Cause (Bug No if Any)	: Bug No WFS_6_026
// Change Description				: Transaction added while creating workitem (executing batch)
//----------------------------------------------------------------------------
    public static HashMap<String,String> createProcessInstance(Connection con, int procDefID, int userid, String username,
            int streamId, int queueId, String queuename, int dbType,
            StringBuffer activityId, StringBuffer activityName, boolean syncRoutingFlag, XMLParser parser, int procVarId) throws WFSException, Exception{
    
        //return createProcessInstanceOld(con, procDefID, userid, username, streamId, queueId, queuename, dbType, activityId, activityName, syncRoutingFlag, parser, procVarId, false, 0, null);
         return createProcessInstance(con, procDefID, userid, username, streamId, queueId, queuename, dbType, activityId, activityName, syncRoutingFlag, parser, procVarId, false, 0, null);
    }
    
    public static HashMap<String,String> createProcessInstance(Connection con, int procDefID, int userid, String username,
    int streamId, int queueId, String queuename, int dbType,
    StringBuffer activityId, StringBuffer activityName, boolean syncRoutingFlag, XMLParser parser, int procVarId, boolean debug, int sessionId, String engine) throws WFSException, Exception {
    	HashMap<String,String> returnMap=new HashMap<String,String>();
    	Statement stmt = con.createStatement();
        engine = parser.getValueOf("EngineName");
        ResultSet rs = null;
        boolean regNoGenerated; 
        ResultSet rsProcVar = null;
        String pName;
        String prefix ;
        String suffix ;
        int startingno ;
        int maxlen ;
        String pinstId = "";
        String procName = "";
        int version=0 ;
        int res ;
        int regStartingNo ;
        /* 02/01/2008, Bugzilla Bug 3056, to avoid nested transactions in sync routing mode - Ruhi Hira */
        boolean commitFlag = false;
        CallableStatement cstmt = null;
        String queryCallable = null;
        String strValue = "";
        String cursorName = "";
        int mainCode = 0;
        int subCode = 0;
        String subject = null;
        String descr = null;
        String errType = WFSError.WF_TMP;
        String urn="";
        try {
            if (con.getAutoCommit()) {
                con.setAutoCommit(false);
                commitFlag = true;
            }
            rs = stmt.executeQuery("Select ProcessName from ProcessDefTable "+ getTableLockHintStr(dbType) + " where processdefid = " + procDefID);
            if(rs.next()){
                    procName = rs.getString(1);
                    rs.close();
                    rs = null ;
            }else{
                    mainCode = WFSError.WF_INVALID_PROCESS_DEFINITION;
                    subCode = 0;
                    errType = WFSError.WF_TMP;
                    subject = WFSErrorMsg.getMessage(mainCode);
                    descr = WFSErrorMsg.getMessage(subCode);
                    throw new WFSException(mainCode, subCode, errType, subject, descr);
            }
            int actId = 0;
            String actName = "";
            boolean ActivityIdPassed = false;
            //If actId, actName are already sent, do not do anything....
            if (activityId.toString().equals("")) {
                rs = stmt.executeQuery("SELECT ACTIVITYID, ACTIVITYNAME from ACTIVITYTABLE " + WFSUtil.getTableLockHintStr(dbType) + "  where ProcessDefID = " + procDefID + " and ActivityType = " + WFSConstant.ACT_INTRODUCTION + " and PrimaryActivity = " + WFSUtil.TO_STRING("Y", true, dbType));
                if (rs.next()) {
                    actId = rs.getInt(1);
                    actName = rs.getString(2);
                    rs.close();
                } else {
                    //Error should be thrown that no introduction activityID defined... or no default Introduction activityId defined in the process
                    if (rs != null) {
                        rs.close();
                    }
                    throw new WFSException(WFSError.WM_INVALID_PROCESS_DEFINITION, WFSError.WF_NO_AUTHORIZATION,
                            WFSError.WF_TMP, WFSErrorMsg.getMessage(WFSError.WM_INVALID_PROCESS_DEFINITION),
                            WFSErrorMsg.getMessage(WFSError.WF_NO_AUTHORIZATION));
                }
            } else {
                ActivityIdPassed = true;
                actId = Integer.parseInt(activityId.toString());
                actName = activityName.toString();
            }
           if ( (dbType == JTSConstant.JTS_ORACLE))  
                queryCallable = "{call WFGenerateRegistration(?,?,?,?,?,?,?,?,?,?,?)}";
           else
                queryCallable = "{call WFGenerateRegistration(?,?,?,?,?,?,?,?,?)}";
            cstmt = con.prepareCall(queryCallable);
            cstmt.setInt(1, userid);
            cstmt.setInt(2, procDefID);						
            strValue = parser.getValueOf("ValidationRequired");
            if (strValue.equals("")) {
                    cstmt.setNull(3, Types.VARCHAR);
            } else {
                    cstmt.setString(3, strValue);
            }

            cstmt.setInt(4, actId);            
            cstmt.setString(5, actName);

            strValue = parser.getValueOf("DataDefName");
            if (strValue.equals("")) {
                    cstmt.setNull(6, Types.VARCHAR);
            } else {
                    cstmt.setString(6, strValue);
            }

             cstmt.setInt(7,procVarId);
			 cstmt.setString(8,"N");
           if ( (dbType == JTSConstant.JTS_ORACLE)) {
                cstmt.registerOutParameter(9, java.sql.Types.INTEGER);
                cstmt.registerOutParameter(10, oracle.jdbc.OracleTypes.CURSOR);
                cstmt.registerOutParameter(11, oracle.jdbc.OracleTypes.VARCHAR);
            } else{
				cstmt.setString(9,isRegHyphen());
			}
           
         
            WFSUtil.jdbcCallableExecute(cstmt, engine, queryCallable);

            if ( (dbType == JTSConstant.JTS_ORACLE)) {
                mainCode = cstmt.getInt(9);
                WFSUtil.printOut(engine,"WFGenerateRegistration	mainCode	:	"+mainCode);							
                if(mainCode == 0) {
                    rs = (ResultSet) cstmt.getObject(10);
                    if(rs != null && rs.next()) {
                            pinstId = rs.getString("ProcessInstanceId");	
                            urn=rs.getString("URN");
                            WFSUtil.printOut(engine,"ProcessInstanceId : "+pinstId);
                    }
                }
                else
                {
                        subCode = 0;
                        errType = WFSError.WF_TMP;
                        subject = WFSErrorMsg.getMessage(mainCode);
                        descr = WFSErrorMsg.getMessage(subCode);
                        throw new WFSException(mainCode, subCode, errType, subject, descr);
                }
            }
            else {
                rs = cstmt.getResultSet();
                if (rs != null && rs.next()) {
                    if (dbType == JTSConstant.JTS_POSTGRES) {
                        stmt = con.createStatement();
                        cursorName = rs.getString(1);
                        rs.close();
                        rs = stmt.executeQuery("Fetch All In \"" + WFSUtil.TO_SANITIZE_STRING(cursorName,true) + "\"");
                        if (rs != null) {
                                rs.next();
                        }
                    }                            
                    mainCode = rs.getInt(1);
                    if(mainCode == 0) {
                        pinstId = rs.getString(2);
                        urn=rs.getString("URN");
                        WFSUtil.printOut(engine,"WFGeneratetRegistration processInstanceId " + pinstId);
                    }
                    else
                    {
                        subCode = 0;
                        errType = WFSError.WF_TMP;
                        subject = WFSErrorMsg.getMessage(mainCode);
                        descr = WFSErrorMsg.getMessage(subCode);
                        throw new WFSException(mainCode, subCode, errType, subject, descr);
                    }
                }																						
            }
            String lockStatus = "N";
            String routingStatus = "N";
            if (syncRoutingFlag) {
                routingStatus = "Y";
                lockStatus = "Y";
            }
            String queryString = "insert into WFInstrumentTable (URN,ProcessInstanceId,ProcessDefID,Createdby,CreatedDatetime,ProcessinstanceState,CreatedByName,IntroducedAt,WorkItemID,SaveStage,InstrumentStatus,CheckListCompleteFlag,ProcessName,Activityname,Activityid,Entrydatetime,ParentWorkitemid,Q_StreamId,Q_Queueid,workitemstate,ProcessVersion,Statename,Queuename,Queuetype, ProcessVariantId,LockStatus, RoutingStatus) values ("+WFSUtil.TO_STRING(urn, true, dbType)+"," + WFSUtil.TO_STRING(pinstId, true, dbType) + "," + procDefID + "," + userid + "," + WFSUtil.getDate(dbType) + ", 1 ," + WFSUtil.TO_STRING(username, true, dbType) + "," + WFSUtil.TO_STRING(actName, true, dbType) + ",1," + WFSUtil.TO_STRING(actName, true, dbType) + "," + WFSUtil.TO_STRING("N", true, dbType) + "," + WFSUtil.TO_STRING("N", true, dbType) + "," + WFSUtil.TO_STRING(procName.trim(), true, dbType) + "," + WFSUtil.TO_STRING(actName, true, dbType) + "," + actId + " ," + WFSUtil.getDate(dbType) + ",0," + streamId + "," + queueId + ",1," + version + "," + WFSUtil.TO_STRING(WFSConstant.WF_NOTSTARTED, true, dbType) + "," + WFSUtil.TO_STRING(queuename, true, dbType) + "," + WFSUtil.TO_STRING("I", true, dbType) + " ,"+procVarId+ ", " + WFSUtil.TO_STRING(lockStatus, true, dbType) + ", " + WFSUtil.TO_STRING(routingStatus, true, dbType) + " )";
            jdbcExecute(pinstId, sessionId, userid, queryString, stmt, null, debug, engine);
           

            //Transaction added by Ashish for WFS_6_026
            if (con.getAutoCommit()) {
                con.setAutoCommit(false);
                commitFlag = true;
            }
            int[] resArray = stmt.executeBatch();
            for (int i = 0; i < resArray.length; i++) {
                if (resArray[i] <= 0) {
                    if (commitFlag && !con.getAutoCommit()) {
                        con.rollback();
                        con.setAutoCommit(true);
                    /** @todo throw Exception - Ruhi */
                    }
                    break;
                }
            }
            if (commitFlag && !con.getAutoCommit()) {
                con.commit();
                con.setAutoCommit(true);
            }
            //emd Transaction added by Ashish for WFS_6_026

            try {
                /*if((dbType == JTSConstant.JTS_ORACLE) || (dbType == JTSConstant.JTS_DB2)){
                rs = stmt.executeQuery(" Select SystemDefinedName,DefaultValue ,VariableType from VarMappingTable where VariableScope != " + WFSConstant.WF_VARCHARPREFIX + "I' and DefaultValue is not null AND  DefaultValue is not null and ProcessDefId = "
                + procDefID);
                } else{
                rs = stmt.executeQuery(" Select SystemDefinedName,DefaultValue ,VariableType from VarMappingTable where VariableScope != " + WFSConstant.WF_VARCHARPREFIX + "I' and DefaultValue is not null AND  DefaultValue != '' and ProcessDefId = "
                + procDefID);
                }*/
                // Tirupati Srivastava : changes made to make code compatible with postgreSQL
                if ((dbType == JTSConstant.JTS_ORACLE) || (dbType == JTSConstant.JTS_DB2)) {
                    rs = stmt.executeQuery(" Select SystemDefinedName,DefaultValue ,VariableType from VarMappingTable where VariableScope != " + WFSUtil.TO_STRING("I", true, dbType) + " and DefaultValue is not null and ProcessDefId = " + procDefID +" and processVariantId in (0,TO_CHAR("+procVarId+"))");                
                } else {
                    rs = stmt.executeQuery(" Select SystemDefinedName,DefaultValue ,VariableType from VarMappingTable " + WFSUtil.getTableLockHintStr(dbType) + "  where VariableScope != " + WFSUtil.TO_STRING("I", true, dbType) + " and DefaultValue is not null AND  DefaultValue != '' and ProcessDefId = " + procDefID +" and processVariantId in (0, "+procVarId+")");

                }
                // Update NEWTABLE set system variables with default value
                //StringBuffer queryBuffer = new StringBuffer();
                StringBuffer queryStr = new StringBuffer();
                StringBuffer workLstr = new StringBuffer();
                queryStr.append("Update WFInstrumentTable SET ");
                workLstr.append("Update WFInstrumentTable SET ");
                //String workLstr = "Update " + tableName + " SET ";
                boolean executeQueryStr = false;
                String strTmp = "";
                while (rs.next()) {
                    strTmp = rs.getString(1);
                    strTmp = rs.wasNull() ? "" : strTmp.trim();
                    if (!strTmp.equalsIgnoreCase("PriorityLevel")) {
                    	executeQueryStr = true;
                        queryStr.append(strTmp);
                        queryStr.append(" = ");
                        queryStr.append(WFSUtil.TO_SQL(rs.getString(2), rs.getInt(3), dbType, true));
                        queryStr.append(" , ");
                    } else {
                        workLstr.append(strTmp);
                        workLstr.append(" = ");
                        workLstr.append(rs.getString(2));
                    }
                }
                if (rs != null) {
                    rs.close();
                }

                /*try{
                stmt.execute(queryStr.substring(0,
                queryStr.lastIndexOf(",")) + " WHERE " + WFSUtil.TO_STRING("ProcessInstanceID", false,
                dbType) + " = " + WFSConstant.WF_VARCHARPREFIX + pinstId.toUpperCase() + "'");
                } catch(Exception ex){}
                stmt.execute(workLstr + " WHERE " + WFSUtil.TO_STRING("ProcessInstanceID", false,
                dbType) + " = " + WFSConstant.WF_VARCHARPREFIX + pinstId.toUpperCase() + "'");*/
                // Tirupati Srivastava : changes made to make code compatible with postgreSQL
                queryStr.append(" WHERE ProcessInstanceID = ").append( WFSUtil.TO_STRING(pinstId, true, dbType));
                workLstr.append( " WHERE ProcessInstanceID = " + WFSUtil.TO_STRING(pinstId, true, dbType)+" and RoutingStatus = " + WFSUtil.TO_STRING("N", true, dbType) +" and LockStatus = " + WFSUtil.TO_STRING(lockStatus, true, dbType));
                try {
                	if(executeQueryStr)
                    jdbcExecute(pinstId, sessionId, userid, queryStr.toString(), stmt, null, debug, engine); 
                    //stmt.execute(queryStr.substring(0, queryStr.lastIndexOf(",")) + " WHERE ProcessInstanceID = " + WFSUtil.TO_STRING(pinstId, true, dbType)); //Bug # 2824

                } catch (Exception ex) {
                	WFSUtil.printErr(engine,"", ex);
                } //Bugzilla Bug 2300
                jdbcExecute(pinstId, sessionId, userid, workLstr.toString(), stmt, null, debug, engine); 
                //stmt.execute(workLstr + " WHERE ProcessInstanceID = " + WFSUtil.TO_STRING(pinstId, true, dbType)); //Bug # 2824
                returnMap.put("ProcessInstanceID", pinstId);
                returnMap.put("URN", urn);
            } catch (Exception e) {
                WFSUtil.printErr(engine,"", e);
            }
            if (!ActivityIdPassed) {
                activityId = activityId.append(actId + "");
                activityName = activityName.append(actName);
            }
        } catch (WFSException e) {
            throw e;
        } catch (Exception e) {
            throw e;
        } finally {
            if (commitFlag && !con.getAutoCommit()) {
                con.rollback();
                con.setAutoCommit(true);
            }
            if(stmt!=null){
            stmt.close();
            stmt = null;
            }
        }
        return returnMap;
    }
    public static String createProcessInstanceOld(Connection con, int procDefID, int userid, String username,
            int streamId, int queueId, String queuename, int dbType,
            StringBuffer activityId, StringBuffer activityName, boolean syncRoutingFlag, XMLParser parser, int procVarId, boolean debug, int sessionId, String engine) throws WFSException, Exception {
        Statement stmt = con.createStatement();
        engine = parser.getValueOf("EngineName");
        ResultSet rs = null;
        boolean regNoGenerated = false; 
        ResultSet rsProcVar = null;
        String pName=null;
        String prefix = "";
        String suffix = "";
        int startingno = 0;
        int maxlen = 0;
        String pinstId = "";
        String procName = "";
        int version = 0;
        int res = 0;
        int regStartingNo = 0;
        /* 02/01/2008, Bugzilla Bug 3056, to avoid nested transactions in sync routing mode - Ruhi Hira */
        boolean commitFlag = false;
        try {
            if (con.getAutoCommit()) {
                con.setAutoCommit(false);
                commitFlag = true;
            }
            rs = stmt.executeQuery(
                    "Select ProcessName  from ProcessDefTable  where ProcessDefID = " + procDefID );
            if(rs != null && rs.next()) {
            	pName = rs.getString("ProcessName");
            	pName=pName.replace(" ", "");
			}
            if (rs != null) {
				rs.close();
				rs = null ;
			}
			if (stmt != null) {
				stmt.close();
				stmt = null;
			}
			stmt=con.createStatement();
            if (dbType == JTSConstant.JTS_MSSQL)
                    {  
                        stmt.execute("insert IDE_Reg_"+WFSUtil.TO_SANITIZE_STRING(pName,true)+" default values");
                        stmt.execute("Select @@IDENTITY");
					rs = stmt.getResultSet();
					if(rs != null && rs.next()) {
						regStartingNo = rs.getInt(1);
						rs.close();
						regNoGenerated=true;
					}
                    }
            if (dbType == JTSConstant.JTS_ORACLE  || dbType == JTSConstant.JTS_POSTGRES)
            {
                regStartingNo =Integer.parseInt(WFSUtil.nextVal(con, "SEQ_Reg_"+pName, dbType));
                regNoGenerated=true;
            }
            /*res = stmt.executeUpdate(
                    "Update ProcessDefTable Set RegStartingNo="+regStartingNo+ " where ProcessDefID = " + procDefID);*/
            if (regNoGenerated) {
                rs = stmt.executeQuery(
                        "Select ProcessState,RegPrefix,RegSuffix,RegStartingNo,RegSeqLength,ProcessName,VersionNo, ProcessType from ProcessDefTable b "+ getTableLockHintStr(dbType) + " where ProcessDefID = " + procDefID + " and VersionNo = (Select Max(VersionNo) " + "from ProcessDeftable "+ getTableLockHintStr(dbType) + " where ProcessName = b.Processname)");
                String procType = null;
                if (rs.next()) {     
                    if (!rs.getString(1).trim().equalsIgnoreCase("Enabled")) {
                        rs.close();
                        throw new WFSException(WFSError.WM_INVALID_PROCESS_DEFINITION,
                                WFSError.WF_NO_AUTHORIZATION, WFSError.WF_TMP,
                                WFSErrorMsg.getMessage(WFSError.WM_INVALID_PROCESS_DEFINITION),
                                WFSErrorMsg.getMessage(WFSError.WF_NO_AUTHORIZATION));
                    }
                    procType = rs.getString("ProcessType");
                    
                    if("M".equalsIgnoreCase(procType)){
                        rsProcVar = stmt.executeQuery("Select RegPrefix,RegSuffix,RegStartingNo from WFProcessVariantDefTable " + WFSUtil.getTableLockHintStr(dbType) 
                                + "where ProcessDefID = " + procDefID + " and processVariantId = "+procVarId+"");
                        if(rsProcVar.next()){
                            prefix = rs.getString(1);
                            suffix = rs.getString(2);
                            startingno = rs.getInt(3);
                        }
                        if(rsProcVar != null){
                            rsProcVar.close();
                            rsProcVar = null;
                        }
                    }else{
                        prefix = rs.getString(2);
                        suffix = rs.getString(3);
                        startingno = regStartingNo;
                    }   
                    prefix = rs.wasNull() ? "" : prefix.trim() + WFSConstant.WF_DELMT;
                    if(suffix!=null && !suffix.trim().equals(""))	/*WFS_8.0_090*/
                    {
                            suffix = WFSConstant.WF_DELMT + suffix.trim();
                    }else
                    {
                            suffix = "";
                    }
                    //suffix = rs.wasNull() ? "" : WFSConstant.WF_DELMT + suffix.trim();
                    maxlen = rs.getInt(5);

                    if (String.valueOf(startingno).length() > maxlen - prefix.length() - suffix.length()) {
                        if (rs != null) {
                            rs.close();
                        }
                        throw new WFSException(WFSError.WM_INVALID_PROCESS_DEFINITION,
                                WFSError.WM_INSUFFICIENT_BUFFER_SIZE, WFSError.WF_TMP,
                                WFSErrorMsg.getMessage(WFSError.WM_INVALID_PROCESS_DEFINITION),
                                WFSErrorMsg.getMessage(WFSError.WM_INSUFFICIENT_BUFFER_SIZE));
                    }
                    procName = rs.getString(6);
                    version = rs.getInt(7);
                    if (rs != null) {
                        rs.close();
                    }
                } else {
                    if (rs != null) {
                        rs.close();
                    }
                    throw new WFSException(WFSError.WM_INVALID_PROCESS_DEFINITION, 0, WFSError.WF_TMP,
                            WFSErrorMsg.getMessage(WFSError.WM_INVALID_PROCESS_DEFINITION), "");
                }
            } else {
                throw new WFSException(WFSError.WM_INVALID_PROCESS_DEFINITION, 0, WFSError.WF_TMP,
                        WFSErrorMsg.getMessage(WFSError.WM_INVALID_PROCESS_DEFINITION), "");
            }
            if (commitFlag && !con.getAutoCommit()) {
                con.commit();
                con.setAutoCommit(true);
            }
			char chr21 = (char)21;
			prefix = prefix.replace('%',chr21);
			suffix = suffix.replace('%',chr21);
            java.text.DecimalFormat df = new java.text.DecimalFormat(prefix + "########" + suffix);
            df.setMinimumIntegerDigits(maxlen - prefix.length() - suffix.length());
            pinstId = df.format(startingno);
			pinstId = pinstId.replace(chr21,'%');

            int actId = 0;
            String actName = "";
            boolean ActivityIdPassed = false;
            //If actId, actName are already sent, do not do anything....
            if (activityId.toString().equals("")) {
                /*rs = stmt.executeQuery("SELECT ACTIVITYID, ACTIVITYNAME from ACTIVITYTABLE where ProcessDefID = " + procDefID
                + " and ActivityType = " + WFSConstant.ACT_INTRODUCTION + " and PrimaryActivity = " + WFSConstant.WF_VARCHARPREFIX + "Y' ");*/
                // Tirupati Srivastava : changes made to make code compatible with postgreSQL
                rs = stmt.executeQuery("SELECT ACTIVITYID, ACTIVITYNAME from ACTIVITYTABLE " + WFSUtil.getTableLockHintStr(dbType) + "  where ProcessDefID = " + procDefID + " and ActivityType = " + WFSConstant.ACT_INTRODUCTION + " and PrimaryActivity = " + WFSUtil.TO_STRING("Y", true, dbType));
                if (rs.next()) {
                    actId = rs.getInt(1);
                    actName = rs.getString(2);
                    rs.close();
                } else {
                    //Error should be thrown that no introduction activityID defined... or no default Introduction activityId defined in the process
                    if (rs != null) {
                        rs.close();
                    }
                    throw new WFSException(WFSError.WM_INVALID_PROCESS_DEFINITION, WFSError.WF_NO_AUTHORIZATION,
                            WFSError.WF_TMP, WFSErrorMsg.getMessage(WFSError.WM_INVALID_PROCESS_DEFINITION),
                            WFSErrorMsg.getMessage(WFSError.WF_NO_AUTHORIZATION));
                }
            } else {
                ActivityIdPassed = true;
                actId = Integer.parseInt(activityId.toString());
                actName = activityName.toString();
            }
            // Insert into NEWTABLE with 
            /*stmt.addBatch(
            "  Insert into ProcessInstanceTable ( ProcessInstanceId , ProcessDefID , Createdby , "
            + " CreatedDatetime , ProcessinstanceState , CreatedByName, IntroducedAt) Values (" + WFSConstant.WF_VARCHARPREFIX + pinstId + "',"
            + procDefID + "," + userid + "," + WFSUtil.getDate(dbType) + ", 1 ," + WFSConstant.WF_VARCHARPREFIX + username + "'," + WFSConstant.WF_VARCHARPREFIX + actName + "') ");*/

            // Tirupati Srivastava : changes made to make code compatible with postgreSQL
            //OF Optimization
            
//            stmt.addBatch(
//                    "  Insert into ProcessInstanceTable ( ProcessInstanceId , ProcessDefID , Createdby , " + " CreatedDatetime , ProcessinstanceState , CreatedByName, IntroducedAt, ProcessVariantId) Values (" + WFSUtil.TO_STRING(pinstId, true, dbType) + "," + procDefID + "," + userid + "," + WFSUtil.getDate(dbType) + ", 1 ," + WFSUtil.TO_STRING(username, true, dbType) + "," + WFSUtil.TO_STRING(actName, true, dbType) +","+procVarId +" ) ");

            /*stmt.addBatch("  Insert into QueueDataTable (ProcessInstanceID , WorkItemID , SaveStage , "
            + " InstrumentStatus , CheckListCompleteFlag ) Values (" + WFSConstant.WF_VARCHARPREFIX + pinstId + "' , 1, " + WFSConstant.WF_VARCHARPREFIX
            + actName + "'," + WFSConstant.WF_VARCHARPREFIX + "N'," + WFSConstant.WF_VARCHARPREFIX + "N') ");*/

            //stmt.addBatch("  Insert into QueueDataTable (ProcessInstanceID , WorkItemID , SaveStage , " + " InstrumentStatus , CheckListCompleteFlag ) Values (" + WFSUtil.TO_STRING(pinstId, true, dbType) + " , 1, " + WFSUtil.TO_STRING(actName, true, dbType) + "," + WFSUtil.TO_STRING("N", true, dbType) + "," + WFSUtil.TO_STRING("N", true, dbType) + " ) ");

            /*stmt.addBatch("  Insert into WorkListTable (ProcessInstanceId,WorkItemId,ProcessName, "
            + " ProcessDefID,Activityname,Activityid,Entrydatetime,ParentWorkitemid, "
            + " Q_StreamId,Q_Queueid,CreatedDateTime,workitemstate,ProcessVersion,"
            + " Statename,Queuename,Queuetype) values " + " (" + WFSConstant.WF_VARCHARPREFIX + pinstId + "',1," + WFSConstant.WF_VARCHARPREFIX + procName.trim()
            + "'," + procDefID + "," + WFSConstant.WF_VARCHARPREFIX + actName + "'," + actId + " ," + WFSUtil.getDate(dbType)
            + ",0," + streamId + "," + queueId + "," + WFSUtil.getDate(dbType) + ",1," + version
            + "," + WFSConstant.WF_VARCHARPREFIX + WFSConstant.WF_NOTSTARTED + "'," + WFSConstant.WF_VARCHARPREFIX + queuename + "'," + WFSConstant.WF_VARCHARPREFIX + "I')");*/
            //WFS_6.1.2_068

            //String tableName = "WorkListTable";
            String lockStatus = "N";
            String routingStatus = "N";
            if (syncRoutingFlag) {
                //tableName = "WorkInProcessTable";
                routingStatus = "Y";
                lockStatus = "Y";
            }
            String queryString = "insert into WFInstrumentTable (ProcessInstanceId,ProcessDefID,Createdby,CreatedDatetime,ProcessinstanceState,CreatedByName,IntroducedAt,WorkItemID,SaveStage,InstrumentStatus,CheckListCompleteFlag,ProcessName,Activityname,Activityid,Entrydatetime,ParentWorkitemid,Q_StreamId,Q_Queueid,workitemstate,ProcessVersion,Statename,Queuename,Queuetype, ProcessVariantId,LockStatus, RoutingStatus) values (" + WFSUtil.TO_STRING(pinstId, true, dbType) + "," + procDefID + "," + userid + "," + WFSUtil.getDate(dbType) + ", 1 ," + WFSUtil.TO_STRING(username, true, dbType) + "," + WFSUtil.TO_STRING(actName, true, dbType) + ",1," + WFSUtil.TO_STRING(actName, true, dbType) + "," + WFSUtil.TO_STRING("N", true, dbType) + "," + WFSUtil.TO_STRING("N", true, dbType) + "," + WFSUtil.TO_STRING(procName.trim(), true, dbType) + "," + WFSUtil.TO_STRING(actName, true, dbType) + "," + actId + " ," + WFSUtil.getDate(dbType) + ",0," + streamId + "," + queueId + ",1," + version + "," + WFSUtil.TO_STRING(WFSConstant.WF_NOTSTARTED, true, dbType) + "," + WFSUtil.TO_STRING(queuename, true, dbType) + "," + WFSUtil.TO_STRING("I", true, dbType) + " ,"+procVarId+ ", " + WFSUtil.TO_STRING(lockStatus, true, dbType) + ", " + WFSUtil.TO_STRING(routingStatus, true, dbType) + " )";
            jdbcExecute(pinstId, sessionId, userid, queryString, stmt, null, debug, engine);
            //stmt.addBatch("  Insert into " + tableName + " (ProcessInstanceId,WorkItemId,ProcessName, " + " ProcessDefID,Activityname,Activityid,Entrydatetime,ParentWorkitemid, " + " Q_StreamId,Q_Queueid,CreatedDateTime,workitemstate,ProcessVersion," + " Statename,Queuename,Queuetype, ProcessVariantId) values " + " (" + WFSUtil.TO_STRING(pinstId, true, dbType) + ",1," + WFSUtil.TO_STRING(procName.trim(), true, dbType) + "," + procDefID + "," + WFSUtil.TO_STRING(actName, true, dbType) + "," + actId + " ," + WFSUtil.getDate(dbType) + ",0," + streamId + "," + queueId + "," + WFSUtil.getDate(dbType) + ",1," + version + "," + WFSUtil.TO_STRING(WFSConstant.WF_NOTSTARTED, true, dbType) + "," + WFSUtil.TO_STRING(queuename, true, dbType) + "," + WFSUtil.TO_STRING("I", true, dbType) +","+procVarId+ " )"); //WFS_6.1.2_068

            //Transaction added by Ashish for WFS_6_026
            if (con.getAutoCommit()) {
                con.setAutoCommit(false);
                commitFlag = true;
            }
            int[] resArray = stmt.executeBatch();
            for (int i = 0; i < resArray.length; i++) {
                if (resArray[i] <= 0) {
                    if (commitFlag && !con.getAutoCommit()) {
                        con.rollback();
                        con.setAutoCommit(true);
                    /** @todo throw Exception - Ruhi */
                    }
                    break;
                }
            }
            if (commitFlag && !con.getAutoCommit()) {
                con.commit();
                con.setAutoCommit(true);
            }
            //emd Transaction added by Ashish for WFS_6_026

            try {
                /*if((dbType == JTSConstant.JTS_ORACLE) || (dbType == JTSConstant.JTS_DB2)){
                rs = stmt.executeQuery(" Select SystemDefinedName,DefaultValue ,VariableType from VarMappingTable where VariableScope != " + WFSConstant.WF_VARCHARPREFIX + "I' and DefaultValue is not null AND  DefaultValue is not null and ProcessDefId = "
                + procDefID);
                } else{
                rs = stmt.executeQuery(" Select SystemDefinedName,DefaultValue ,VariableType from VarMappingTable where VariableScope != " + WFSConstant.WF_VARCHARPREFIX + "I' and DefaultValue is not null AND  DefaultValue != '' and ProcessDefId = "
                + procDefID);
                }*/
                // Tirupati Srivastava : changes made to make code compatible with postgreSQL
                if ((dbType == JTSConstant.JTS_ORACLE) || (dbType == JTSConstant.JTS_DB2)) {
                    rs = stmt.executeQuery(" Select SystemDefinedName,DefaultValue ,VariableType from VarMappingTable where VariableScope != " + WFSUtil.TO_STRING("I", true, dbType) + " and DefaultValue is not null and ProcessDefId = " + procDefID +" and processVariantId in (0,TO_CHAR("+procVarId+"))");                
                } else {
                    rs = stmt.executeQuery(" Select SystemDefinedName,DefaultValue ,VariableType from VarMappingTable " + WFSUtil.getTableLockHintStr(dbType) + "  where VariableScope != " + WFSUtil.TO_STRING("I", true, dbType) + " and DefaultValue is not null AND  DefaultValue != '' and ProcessDefId = " + procDefID +" and processVariantId in (0, "+procVarId+")");

                }
                // Update NEWTABLE set system variables with default value
                //StringBuffer queryBuffer = new StringBuffer();
                StringBuffer queryStr = new StringBuffer();
                StringBuffer workLstr = new StringBuffer();
                queryStr.append("Update WFInstrumentTable SET ");
                workLstr.append("Update WFInstrumentTable SET ");
                //String workLstr = "Update " + tableName + " SET ";
                boolean executeQueryStr = false;
                String strTmp = "";
                while (rs.next()) {
                    strTmp = rs.getString(1);
                    strTmp = rs.wasNull() ? "" : strTmp.trim();
                    if (!strTmp.equalsIgnoreCase("PriorityLevel")) {
                    	executeQueryStr = true;
                        queryStr.append(strTmp);
                        queryStr.append(" = ");
                        queryStr.append(WFSUtil.TO_SQL(rs.getString(2), rs.getInt(3), dbType, true));
                        queryStr.append(" , ");
                    } else {
                        workLstr.append(strTmp);
                        workLstr.append(" = ");
                        workLstr.append(rs.getString(2));
                    }
                }
                if (rs != null) {
                    rs.close();
                }

                /*try{
                stmt.execute(queryStr.substring(0,
                queryStr.lastIndexOf(",")) + " WHERE " + WFSUtil.TO_STRING("ProcessInstanceID", false,
                dbType) + " = " + WFSConstant.WF_VARCHARPREFIX + pinstId.toUpperCase() + "'");
                } catch(Exception ex){}
                stmt.execute(workLstr + " WHERE " + WFSUtil.TO_STRING("ProcessInstanceID", false,
                dbType) + " = " + WFSConstant.WF_VARCHARPREFIX + pinstId.toUpperCase() + "'");*/
                // Tirupati Srivastava : changes made to make code compatible with postgreSQL
                queryStr.append(" WHERE ProcessInstanceID = ").append( WFSUtil.TO_STRING(pinstId, true, dbType));
                workLstr.append( " WHERE ProcessInstanceID = " + WFSUtil.TO_STRING(pinstId, true, dbType)+" and RoutingStatus = " + WFSUtil.TO_STRING("N", true, dbType) +" and LockStatus = " + WFSUtil.TO_STRING(lockStatus, true, dbType));
                try {
                	if(executeQueryStr)
                    jdbcExecute(pinstId, sessionId, userid, queryStr.toString(), stmt, null, debug, engine); 
                    //stmt.execute(queryStr.substring(0, queryStr.lastIndexOf(",")) + " WHERE ProcessInstanceID = " + WFSUtil.TO_STRING(pinstId, true, dbType)); //Bug # 2824

                } catch (Exception ex) {
                	WFSUtil.printErr(engine,"", ex);
                } //Bugzilla Bug 2300
                jdbcExecute(pinstId, sessionId, userid, workLstr.toString(), stmt, null, debug, engine); 
                //stmt.execute(workLstr + " WHERE ProcessInstanceID = " + WFSUtil.TO_STRING(pinstId, true, dbType)); //Bug # 2824

            } catch (Exception e) {
                WFSUtil.printErr(engine,"", e);
            }
            if (!ActivityIdPassed) {
                activityId = activityId.append(actId + "");
                activityName = activityName.append(actName);
            }
        } catch (WFSException e) {
            throw e;
        } catch (Exception e) {
            throw e;
        } finally {
            if (commitFlag && !con.getAutoCommit()) {
                con.rollback();
                con.setAutoCommit(true);
            }
            if(stmt!=null){
            stmt.close();
            stmt = null;
            }
        }
        return pinstId;
    }

//        private static void setVariableValue(Connection con, HashMap keyValueMap, String tableName, HashMap attributes,
//            HashMap fieldInfoMap, String pTableName, HashMap pAttributes, int dbType) throws Exception {
//
//
//            PreparedStatement pstmt = null;
//            ResultSet rs = null;
//
//            HashMap simpleAttributes = null;
//            HashMap complexAttributes = new LinkedHashMap();
//            HashMap parentRelationColumns = new HashMap();
//            HashMap parentRelationValues = new HashMap();
//            StringBuffer querySelect = new StringBuffer();
//            StringBuffer queryInsert = new StringBuffer();
//            StringBuffer queryUpdate = new StringBuffer();
//            StringBuffer valueString = new StringBuffer();
//
//            queryUpdate.append("Update ");
//            queryUpdate.append(tableName);
//            queryUpdate.append(" Set ");
//
//            //Update table (child table)
//            //update relation fields in parent table if required
//
//            Iterator iter = attributes.keySet().iterator();
//            String key = null;
//            String value = null;
//            ArrayList valueList = null;
//            WFFieldInfo fieldInfo = null;
//
//            while (iter.hasNext()) {
//                key = (String) iter.next();
//                valueList = (ArrayList) attributes.get(key);
//                fieldInfo = (WFFieldInfo) fieldInfoMap.get(key);
//                if (fieldInfo.getWfType() != WFSConstant.WF_COMPLEX) {
//                    value = getAttributeValue(key, attributes);
//                    printOut("Simple value has come for being set **** Attribute Name : " + key + "  Value : " + value);
//
//                    simpleAttributes.put(key, valueList);
//
//                    queryUpdate.append(fieldInfo.getMappedColumn());
//                    queryUpdate.append(" = ");
//                    queryUpdate.append(TO_SQL(value, fieldInfo.getWfType(), dbType, true));
//                    queryUpdate.append(" ,");
//
//                    queryInsert.append(fieldInfo.getMappedColumn());
//                    valueString.append(TO_SQL(value, fieldInfo.getWfType(), dbType, true));
//                    queryInsert.append(" ,");
//                    valueString.append(" ,");
//
//
//                } else {
//                    printOut("Complex value has come for being set **** Attribute Name : " + key + "  Value (in the form of XML): " + (String) valueList.get(1));
//                    complexAttributes.put(key, valueList);
//                    //Find the relation map for each complex structure from fieldInfoMap....
//                    HashMap relationMap = null;
//                    relationMap = fieldInfo.getRelationMap();
//                    WFRelationInfo relInfo = null;
//
//                    Iterator relationIter = null;
//                    HashMap columnList = null;
//
//                    relationIter = relationMap.values().iterator();
//                    while (relationIter.hasNext()) {
//                        relInfo = (WFRelationInfo) relationIter.next();
//                        columnList = (HashMap) parentRelationColumns.get(relInfo.getParentObject());
//                        if (columnList == null) {
//                            columnList = new HashMap();
//                            parentRelationColumns.put(relInfo.getParentObject(), columnList);
//                        }
//                        columnList.put(relInfo.getForeignKey(), null);
//                    }
//                }
//            }
//
//            int complexCount = complexAttributes.size();
//            String parentObject = null;
//
//            if (complexCount > 0) {
//                //Recursion case
//                Iterator parentValueIterator = null;
//                parentValueIterator = parentRelationColumns.keySet().iterator();
//                while (parentValueIterator.hasNext()) {
//                    parentObject = (String) parentValueIterator.next();
//                    querySelect.append("SELECT ");
//                    HashMap columnList = (HashMap) parentRelationColumns.get(parentObject);
//                    Iterator colListIter = null;
//                    colListIter = columnList.keySet().iterator();
//                    while (colListIter.hasNext()) {
//                        querySelect.append((String) colListIter.next());
//                        querySelect.append(" ,");
//                    }
//                    querySelect.deleteCharAt(querySelect.length() - 1);
//                    querySelect.append(" FROM ");
//                    querySelect.append(parentObject);
//                    querySelect.append(" WHERE ");
//
//                    Iterator conditionIter = keyValueMap.entrySet().iterator();
//                    while (conditionIter.hasNext()) {
//                        Map.Entry mapEntry = (Map.Entry) conditionIter.next();
//                        querySelect.append((String) mapEntry.getKey());
//                        querySelect.append(" = '");
//                        querySelect.append(mapEntry.getValue());
//                        /** Todo metadata should be get from resultSet and then date / int/ string should be considered.*/
//                        querySelect.append("'");
//                    }
//
//
//                    querySelect.append("conditon");
//
//                    pstmt = con.prepareStatement(querySelect.toString());
//                    rs = pstmt.executeQuery();
//                    if (rs != null && rs.next()) {
//                        ArrayList colvalueList = new ArrayList();
//
//                        for (int counter = 0; counter < colvalueList.size(); counter++) {
//                            colvalueList.add(rs.getString(counter));
//                        }
//                        parentRelationValues.put(parentObject, colvalueList);
//                    }
//                }
//
//            //Now we have found the values of the parent attribute... rather current attributes
//            // we can now call the function recursively using complex variable
//
//            //Find the mapping columns whose values are required from the parent table before inserting any data in parent table
//
//            }
//
//            //Make a loop for all the complex structures at this level.
//
//            HashMap relationMap = null;	// should come as a parameter in this method
//            WFRelationInfo relInfo = null;
//            String[] pTableValue = new String[relationMap.size()];
//            String[] pValueFromAttrib = new String[relationMap.size()];
//            String[] valueFromAttrib = new String[relationMap.size()];
//            boolean valueExistsInParentTable = false;
//            boolean valueComingInChildAttribute = false;
//            boolean valueComingInParentAttribute = false;
//
//            int counter = 0;
//
//            //Prepare where condition from relation Map
//            iter = relationMap.values().iterator();
//            querySelect.append("SELECT ");
//            while (iter.hasNext()) {
//                relInfo = (WFRelationInfo) iter.next();
//                querySelect.append(relInfo.getForeignKey());
//                querySelect.append(" ,");
//                pValueFromAttrib[counter] = getAttributeValue(relInfo.getMappedParentField(), pAttributes);
//                valueComingInParentAttribute = pValueFromAttrib[counter] == null ? valueComingInChildAttribute : true;
//                valueFromAttrib[counter] = getAttributeValue(relInfo.getMappedChildField(), attributes);
//                valueComingInChildAttribute = valueFromAttrib[counter] == null ? valueComingInChildAttribute : true;
//            }
//            querySelect.append(" FROM ");
//            querySelect.append(pTableName);
//
//            pstmt = con.prepareStatement(querySelect.toString());
//            rs = pstmt.executeQuery();
//            if (rs != null && rs.next()) {
//                for (counter = 0; counter < relationMap.size(); counter++) {
//                    pTableValue[counter] = rs.getString(counter + 1);
//                    if (!rs.wasNull()) {
//                        valueExistsInParentTable = true;
//                    }
//                /*if rs.WasNull(){
//                pTableValue[counter] = null;
//                }*/
//                }
//            }
//
//            rs.close();
//            rs = null;
//
//            pstmt.close();
//            pstmt = null;
//
//            //If all the values in the pTableValue are blank, we have to insert a new row...
//            if (!valueExistsInParentTable) {
//                pstmt = con.prepareStatement(" Insert into " + tableName + " (" + queryInsert.deleteCharAt(queryInsert.length() - 1) +
//                    ") VALUES (" + valueString.deleteCharAt(valueString.length() - 1) + ")");
//                int res = pstmt.executeUpdate();
//
//            //After insertion of values in child table, update parent table also.
//
//            } else {
//                if (!valueComingInChildAttribute && !valueComingInParentAttribute) {
//                //NO value coming in attribute xml
//                // Also case is not of autogenerate as parent columns for mapping are having some values
//                //Try updating fields of child data
//                //if updation returns no results, try inserting data.
//                //No changes are required in parent table
//                } else {
//                // check if values are different, then try updating child as well as parent
//                // along with the keys of both parent and child tables
//
//                }
//            }
//
//
//            //Execute the query for simple type present in the attributes.
//            //For all complex types this method can be used recursively in loop.
//
//            if (tableName != null) {
//            //Called from 1st level// check QUeueDataTable / External Table
//            } else {
//
//            }
//
//        }

//    private static String getAttributeValue(String attributeName, HashMap attributes) {
//        String value = null;
//
//        Node node = (Node) attributes.get(attributeName);
//        value = node.getChildNodes().item(0).getNodeValue();
//
//        return value;
//    }

    // for top level structure wfFieldInfo will be null.
     private static SimplifiedValueMap simplifyValueMap(HashMap valueMap, HashMap fieldMap, boolean debugFlag, String engineName) throws WFSException {

        return simplifyValueMap(valueMap, fieldMap, debugFlag, engineName, "N");
    }
    protected static SimplifiedValueMap simplifyValueMap(HashMap valueMap, HashMap fieldMap, boolean debugFlag, String engineName,String sVarValidationRequired)throws WFSException {
        HashMap primitiveMap = new HashMap();
        HashMap complexMap = new HashMap();
        WFFieldInfo fieldInfo = null;
        String attribName = null;
        Map.Entry entry = null;
        for (Iterator itr = valueMap.entrySet().iterator(); itr.hasNext();) {
            entry = (Map.Entry) itr.next();
            attribName = (String) entry.getKey();
            fieldInfo = (WFFieldInfo) fieldMap.get(attribName);
            if (debugFlag) {
                printOut(engineName, " [WFSUtil] simplifyValueMap() attribName >> " + attribName);
            }
            if (fieldInfo != null) {
                if (debugFlag) {
                    printOut(engineName, " [WFSUtil] simplifyValueMap() fieldInfo.isComplex() >> " + fieldInfo.isComplex());
                    printOut(engineName, " [WFSUtil] simplifyValueMap() fieldInfo.isArray() >> " + fieldInfo.isArray());
                }
                if(fieldInfo.getScope() != '\0'){
                	 if (fieldInfo.isComplex() || fieldInfo.isArray()) {
             			complexMap.put(attribName, new WFFieldValueComplex(fieldInfo, (ArrayList) entry.getValue()));
                	 } else {
                		 primitiveMap.put(attribName, new WFFieldValuePrimitive(fieldInfo, getValueForPrimitiveAttribute((ArrayList) entry.getValue())));
                	 }
                }
            } else {
                //printErr(engineName,"[WFSUtil] simplifyValueMap() Check this case WFFieldInfo is null in fieldMap for key >> " + attribName);
                  if ("Y".equalsIgnoreCase(sVarValidationRequired)) {
                    throw new WFSException(WFSError.WF_ERROR_INVALID_OR_READONLY_VARIABLE_NAME, WFSError.WF_ERROR_INVALID_OR_READONLY_VARIABLE_NAME, WFSError.WF_TMP, WFSErrorMsg.getMessage(WFSError.WF_ERROR_INVALID_OR_READONLY_VARIABLE_NAME), WFSErrorMsg.getMessage(WFSError.WF_ERROR_INVALID_OR_READONLY_VARIABLE_NAME) + "-" + attribName);
            }
        }
        }
        SimplifiedValueMap simplifiedValueMap = new SimplifiedValueMap(primitiveMap, complexMap);
        return simplifiedValueMap;
    }

//    private static HashMap parseAttributeXML(String xmlToParse) {
//        HashMap attributes = new HashMap();
//        String attribName = null;
//        ArrayList valueList = null;
//
//        try {
//            Document document = WFXMLUtil.createDocument(xmlToParse);
//            NodeList nList = document.getElementsByTagName("Attributes").item(0).getChildNodes();/*nodeList will and must have only one element in it.*/
//            for (int counter = 0; counter < nList.getLength(); counter++) {
//                if (nList.item(counter).getNodeType() == Node.ELEMENT_NODE) {
//                    attribName = nList.item(counter).getNodeName();
//                    printOut(attribName);
//                    valueList = (ArrayList) attributes.get(attribName);
//                    if (valueList != null) {
//                        valueList = new ArrayList();
//                        attributes.put(attribName, valueList);
//                    }
//                    valueList.add(nList.item(counter));
//                //processNodes(nList.item(i), 0, this.wfProcess.getFieldInfoMap(), 0, 0);
//                }
//            }
//        } catch (Exception e) {
//            e.printStackTrace();
//        }
//        return attributes;
//    }
//        private static void setComplexVariableValue(Connection con, ArrayList value,
//            WFVariabledef attribs, String engine, String pinstId, int workItemID, XMLGenerator gen) {
//
//            String mappedTableName = null;
//            StringBuffer insertQuery = new StringBuffer();
//            StringBuffer valueStr = new StringBuffer();
//
//            insertQuery.append("Insert into tableName (");
//
//            //It is assumed that the value to be updated / inserted are for complex variable only
//            //There may be more than 1 complex structure, but user might set 1 value only
//
//            //Whatever value is coming in field is to be set
//            // find that fieldinfo
//            WFFieldInfo fieldInfo = null;
//    //        fieldInfo = (WFFieldInfo) attribs.getAttribMap().get(fieldValue.getName().toUpperCase());
//            fieldInfo = (WFFieldInfo) attribs.getAttribMap().get("".toUpperCase());
//            if (fieldInfo != null) {
//                HashMap relationMap = fieldInfo.getRelationMap();
//                if (relationMap == null) {
//                    WFSUtil.printErr("CHECK CHECK CHECK RelationMap is null"); //nevr shud be the case
//                } else {
//                    Iterator iter = relationMap.entrySet().iterator();
//                    mappedTableName = fieldInfo.getMappedTable().toUpperCase();
//                    WFSUtil.printOut("line num 407" + mappedTableName);
//                    StringBuffer parentRelationQuery = new StringBuffer();
//                    parentRelationQuery.append("Select ");
//                    while (iter.hasNext()) {
//                        Map.Entry relationEntries = (Map.Entry) iter.next();
//                        WFRelationInfo relationInfo = (WFRelationInfo) relationEntries.getValue();
//                        //String tempParentObject = relationInfo.getParentObject().toUpperCase();
//                        //String tempChildObject = relationInfo.getChildObject().toUpperCase();
//                        //String tempForeignKey = relationInfo.getForeignKey();
//                        //String tempRefKey = relationInfo.getRefKey();
//                        parentRelationQuery.append(relationInfo.getForeignKey());
//                        parentRelationQuery.append(" ,");
//
//                    //Now find the value of mapped column of child from attribute xml
//                    //For this, find the mapped name if any of the columns coming in relation
//                    //This can be done from
//
//                    /** @todo why is this condition - Ruhi Hira */
//    //                    if (tempParentObject.equalsIgnoreCase("QueueDataTable") || tempParentObject.equalsIgnoreCase(attribs.getExt_tablename())) {
//    //                    //Select the values of columns coming in relation....
//    //
//    //                    } else if (tempParentObject.equalsIgnoreCase(tablename)) {
//    //                    } else if (tempParentObject.equalsIgnoreCase(tempTableName)) {
//    //                    } else {
//    //                    }
//    //
//    //                    whereCondition.append(tempChildObject + "." + tempRefKey + "=" + tempParentObject + "." + tempForeignKey + " AND ");
//                    }
//
//
//                    //Get the child values from fieldValue, as the variable is complex type variable
//                    /** @todo check this case */
//                    ArrayList childValues = null;
//    //                ArrayList childValues = fieldValue.getListOfMaps();
//                    for (Iterator it = childValues.iterator(); it.hasNext();) {
//                        WFFieldValue childFieldValue = (WFFieldValue) it.next();
//                        //Get the mapped column name for the child field and append it in the query
//                        insertQuery.append(childFieldValue.getName());
//                        valueStr.append(childFieldValue.getName()); //getValue gety soem value from arraylist
//                    }
//
//                //Find all the primitive childs, as they wil be from the same table.
//                //For complex one, the method might have to called recurvisely.
//                //For Array, method would have to be called more than once.
//
//                }
//            } else {
//            //This should never be the case.
//            }
//
//        //find the structure from fieldInfo Map in the form of parent child relationship
//        //find extobjid and from this find table name
//        // prepare queries to fired on table
//        // in first stage just insert the values
//
//        // in second stage update/insert or delete/insert will be supported
//
//        }
    static class SimplifiedValueMap {

        HashMap primitiveValueMap = null; // Map of WFFieldValuePrimitive

        HashMap complexValueMap = null; // Map of WFFieldValueComplex


        SimplifiedValueMap(HashMap primitiveValueMap, HashMap complexValueMap) {
            this.primitiveValueMap = primitiveValueMap;
            this.complexValueMap = complexValueMap;
        }
    }

    static class WFFieldValuePrimitive {

        WFFieldInfo fieldInfo = null;
        String value = null;

        WFFieldValuePrimitive(WFFieldInfo fieldInfo, String value) {
            this.fieldInfo = fieldInfo;
            this.value = value;
        }
    }

    static class WFFieldValueComplex {

        WFFieldInfo fieldInfo = null;
        ArrayList value = null; // List of String / List of HashMap (1 or Many)


        WFFieldValueComplex(WFFieldInfo fieldInfo, ArrayList value) {
            this.fieldInfo = fieldInfo;
            this.value = value;
        }
    }

    /**
     * *************************************************************
     * Function Name    :   writeOracleCLOB
     * Programmer' Name :   Ashish Mangla
     * Date Written     :   May 23 2008
     * Input Parameters :   connection, statement object, tableName, clob column name, FilterString (which row to be selected), data to be inserted
     * Output Parameters:   NONE
     * Return Value     :   NONE
     * Description      :   Method to insert clob data in Oracle
     * *************************************************************
     */
    public static void writeOracleCLOB(Connection con, Statement stmt, String tableName, String columnName, String filterString, String dataToInsert) throws Exception {

        if (con.getAutoCommit()) {
            throw new IllegalStateException("AutoCommit should be false while calling this method writeOracleCLOB");
        }

        ResultSet rs = null;

        rs = stmt.executeQuery("SELECT " + columnName + " From " + tableName + " Where " + filterString + getLockSuffixStr(JTSConstant.JTS_ORACLE));
        if (rs != null && rs.next()) {
            Object object = rs.getObject(columnName);
            if (object instanceof oracle.sql.CLOB || object instanceof oracle.sql.NCLOB) {// NCLOB Changes For saving FormBuffer
                if (!rs.wasNull()) {
                    java.io.Writer dataWriter = (java.io.Writer) object.getClass().getMethod("getCharacterOutputStream", (Class[]) null).invoke(object, (Object[]) null);
                    dataWriter.write(dataToInsert.toCharArray());
                    dataWriter.close();
                    rs.close();
                    rs = null;
                }
            } else {
            	try{
            		weblogic.jdbc.vendor.oracle.OracleThinClob dataClob = (weblogic.jdbc.vendor.oracle.OracleThinClob) rs.getClob(columnName);	//Bugzilla Bug 5823

            		if (!rs.wasNull()) {
            			java.io.Writer dataWriter = dataClob.getCharacterOutputStream();
            			dataWriter.write(dataToInsert.toCharArray());
            			dataWriter.close();
            			rs.close();
            			rs = null;
            		}
            	}
            	catch(ClassCastException e)
            	{
            		if (!rs.wasNull()) {
            			java.io.Writer dataWriter = (java.io.Writer) object.getClass().getMethod("getCharacterOutputStream", (Class[]) null).invoke(object, (Object[]) null);
            			dataWriter.write(dataToInsert.toCharArray());
            			dataWriter.close();
            			rs.close();
            			rs = null;
            		}
            	}
            }
        }
    }

    //----------------------------------------------------------------------------------------------------
    //	Function Name 					:	generateLog
    //	Date Written (DD/MM/YYYY)		:	31/08/2009
    //	Author							:	Shilpi S
    //	Input Parameters				:	engineName, con, actionId, processInst, workItemId, procDefId,
	//                                      activityId, actName, qId, userID, userName, fieldID, fieldName,
	//                                      currentDateTime, entryDateTime, lockedTime, expectedWIDelay
    //	Output Parameters				:   none
    //	Return Values					:	void
    //	Description						:   Generates log for genLog and genLogSummary.
    //----------------------------------------------------------------------------------------------------
    public static void generateLog(String engineName, Connection con, int actionId,
            String processInst, int workItemId,
            int procDefId, int activityId, String actName, int qId,
            int userID, String userName, int fieldID, String fieldName,
            String currentDateTime, String entryDateTime, String lockedTime, String expectedWIDelay) throws SQLException,WFSException {
		generateLog(engineName, con, actionId, processInst, workItemId, procDefId, activityId, actName,
				qId, userID, userName, fieldID, fieldName, currentDateTime, entryDateTime,
				lockedTime, expectedWIDelay, null);
	}
	//----------------------------------------------------------------------------------------------------
    //	Function Name 					:	generateLog
    //	Date Written (DD/MM/YYYY)		:	30/04/2008
    //	Author							:	Sirish Gupta
    //	Input Parameters				:	engineName, con, actionId, processInst, workItemId, procDefId, activityId, actName, qId, userID, userName, fieldID, fieldName, currentDateTime, entryDateTime, lockedTime, expectedWIDelay
    //	Output Parameters				:   none
    //	Return Values					:	void
    //	Description						:   Generates log for genLog and genLogSummary.
    //----------------------------------------------------------------------------------------------------
    public static void generateLog(String engineName, Connection con, int actionId,
            String processInst, int workItemId,
            int procDefId, int activityId, String actName, int qId,
            int userID, String userName, int fieldID, String fieldName,
            String currentDateTime, String entryDateTime, String lockedTime, String expectedWIDelay, String calendarName) throws SQLException ,WFSException{
        int summaryFlag = 0;

        switch (actionId) {
            case WFSConstant.WFL_CreateProcessInstance:
            case WFSConstant.WFL_StartProcessInstance:
            case WFSConstant.WFL_ProcessInstanceDiscarded:
            case WFSConstant.WFL_ProcessInstanceRouted:		//

            case WFSConstant.WFL_ProcessInstanceAborted:
            case WFSConstant.WFL_ProcessInstanceDistributed:	//

            case WFSConstant.WFL_WorkItemUnlock:
            case WFSConstant.WFL_Exception_Raised:
            case WFSConstant.WFL_Exception_Cleared:
            case WFSConstant.WFL_ProcessInstanceCompleted:
            case WFSConstant.WFL_WorkItemCompleted:
            case WFSConstant.WFL_WorkItemExpired:
            case WFSConstant.WFL_AdHocRouted:
			case WFSConstant.ACTION_ADD_TO_MAILQUEUE:
                summaryFlag = 3;
                break;
            default:
                summaryFlag = 1;
                break;
        }

        generateLog(engineName, con, actionId, processInst, workItemId, procDefId, activityId, actName,
                qId, userID, userName, fieldID, fieldName, currentDateTime,
                entryDateTime, lockedTime, expectedWIDelay, summaryFlag, calendarName);
    }
//----------------------------------------------------------------------------------------------------
    //	Function Name 					:	generateLog
    //	Date Written (DD/MM/YYYY)		:	31/08/2009
    //	Author							:	Shilpi S
    //	Input Parameters				:	engineName, con, actionId, processInst, workItemId,
    //                                      procDefId, activityId, actName, qId, userID, userName,
	//                                      fieldID, fieldName, currentDateTime, entryDateTime,
	//										lockedTime, expectedWIDelay
    //	Output Parameters				:   none
    //	Return Values					:	void
    //	Description						:   Generates log for genLog and genLogSummary.
    //----------------------------------------------------------------------------------------------------
	public static void generateLog(String engineName, Connection con, int actionId,
            String processInst, int workItemId,
            int procDefId, int activityId, String actName, int qId,
            int userID, String userName, int fieldID, String fieldName,
            String currentDateTime, String entryDateTime,
            String lockedTime, String expectedWIDelay, int summaryFlag) throws SQLException ,WFSException{
		generateLog(engineName, con, actionId, processInst, workItemId, procDefId, activityId, actName,
				qId, userID, userName, fieldID, fieldName, currentDateTime, entryDateTime, lockedTime,
				expectedWIDelay, summaryFlag, null);
	}
     //----------------------------------------------------------------------------------------------------
    //	Function Name 					:	generateLog
    //	Date Written (DD/MM/YYYY)		:	30/04/2008
    //	Author							:	Sirish Gupta
    //	Input Parameters				:	engineName, con, actionId, processInst, workItemId, procDefId, activityId, actName, qId, userID, userName, fieldID, fieldName, 	currentDateTime, entryDateTime, lockedTime, expectedWIDelay
    //	Output Parameters				:   none
    //	Return Values					:	void
    //	Description						:   Generates log for genLog and genLogSummary.
    //----------------------------------------------------------------------------------------------------
    public static void generateLog(String engineName, Connection con, int actionId,
            String processInst, int workItemId,
            int procDefId, int activityId, String actName, int qId,
            int userID, String userName, int fieldID, String fieldName,
            String currentDateTime, String entryDateTime,
            String lockedTime, String expectedWIDelay, int summaryFlag, String calendarName) throws SQLException,WFSException {
            StringBuffer tempXml = new StringBuffer(100);
            Statement stmt = null;
            PreparedStatement pstmt = null;
            PreparedStatement pstmt1 = null;
            CallableStatement cstmt = null;
            ResultSet rs = null;
            boolean commit = false; 
            int mainCode = 0; 
            int subCode = 0;
            String subject = null;
            String descr = null;
            String errType = WFSError.WF_TMP;
			long fieldID1=0;

            int dbType = ServerProperty.getReference().getDBType(engineName);
        	String urn="";
            int taskId = 0;
            int subtaskId = 0;
            XMLParser parser = new XMLParser();
            int iTotalDuration = 0;
            int iTotalPrTime = 0;
            int iDelayTime = 0;
            String associatedFieldName ="";
            String newValue = "";
            String associatedDateTime = null;
            String sReportType = "D";
            String isReport = "";
            Connection tarConn = null;
            boolean tarCommit = false;
            String targetCabinetName = null;
			boolean tarHistoryLog = false;
			ArrayList nameValuePair = new ArrayList();
			
            parser.setInputXML(fieldName);
			
            switch (actionId) {
                case WFSConstant.WFL_WorkItemUnlock:
                    associatedDateTime = lockedTime;
                    break;
                case WFSConstant.WFL_StartProcessInstance:
                case WFSConstant.WFL_ProcessInstanceCompleted:	//createddatetime is coming in entrydatetime

                case WFSConstant.WFL_WorkItemCompleted:
                    associatedDateTime = entryDateTime;
                    break;
                case WFSConstant.WFL_AdHocRouted:
                	associatedDateTime=getCurrentDateTimeFromDB(con, engineName, dbType);
                break;
                case WFSConstant.WFL_WorkItemExpired:
                	associatedDateTime=getDate(dbType);
                break;
            }
            targetCabinetName = getTargetCabinetName(con);
			printOut(engineName,"Target Cabinet Name : " + targetCabinetName);
			tarHistoryLog = checkIfHistoryLoggingOnTarget(targetCabinetName);

            if (summaryFlag > 1) {
                iDelayTime = getTimeDiff(expectedWIDelay, currentDateTime, engineName); // Actual delay time calaculated
                if(iDelayTime<0)
                	iDelayTime=0; 
                iTotalPrTime = getTimeDiff(lockedTime, currentDateTime, engineName);	// Calendar not considered - user may work in nonworking time

                iTotalDuration = getTimeDiff(entryDateTime, currentDateTime, engineName); // For introduction calendar not considered

                switch (actionId) {
                    case WFSConstant.WFL_StartProcessInstance:	// For introduction calendar not considered

                        break;
                    case WFSConstant.WFL_ProcessInstanceDiscarded:
                        break;
                    case WFSConstant.WFL_ProcessInstanceCompleted:
                        iTotalPrTime = 0;
                        iTotalDuration = getTimeDiff(entryDateTime, currentDateTime, engineName);	//createdDate is sent in entryDateTime parameter
                        //expectedProcessDelay is sent in expectedWIDelay

                        break;
                    case WFSConstant.WFL_WorkItemCompleted:
                        WFCalAssocData wfCalAssocData = WFSUtil.getWICalendarInfo(con, engineName, procDefId, String.valueOf(activityId), calendarName);
                        if (wfCalAssocData != null && wfCalAssocData.getTatCalFlag() == 'Y') {
                            try {
                                iTotalDuration = (int) WFCalUtil.getSharedInstance().subtractDate(new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US).parse(entryDateTime),
                                        new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US).parse(currentDateTime),
                                        wfCalAssocData.getProcessDefId(), wfCalAssocData.getCalId()); //bug # 1608

                            } catch (Exception e) {
                                iTotalDuration = 0;
                            }
                        }
                        break;
                }
            }

            try {
            	if(tarHistoryLog){
            	tarConn=createConnectionToTargetCabinet(targetCabinetName, "", engineName);
            	}
                int procVariantId = 0;
                String sFieldName = "";
                if (fieldName != null) {
                    procVariantId = parser.getIntOf("VariantId", 0, true);
                    sFieldName = parser.getValueOf("FieldName", "", true);
                }
                if(processInst != null && !processInst.isEmpty()){
                	pstmt = con.prepareStatement("Select URN from WFinstrumentTable "+getTableLockHintStr(dbType)+" where ProcessInstanceId=?");
                    pstmt.setString(1,processInst);
                    rs=pstmt.executeQuery();
                    if(rs.next()){
                    	urn=rs.getString("URN");
                    }
                    rs.close();
                    pstmt.close();
                }
                XMLGenerator gen = new XMLGenerator();
                //Message Agent Optimization
                //check for sumaryflag = 3 for actions whose history needs to be genereated after starting message agent.
                /*if(summaryFlag==3 && userID < 10000000 ){
                	printOut(engineName,"Case when sumaary flag is only 3");
                            tempXml.append("<Message>");
                            tempXml.append(gen.writeValueOf("ActionId", String.valueOf(actionId)));
                            tempXml.append(gen.writeValueOf("UserId", String.valueOf(userID)));
                            tempXml.append(gen.writeValueOf("ProcessDefId", String.valueOf(procDefId)));
                            tempXml.append(gen.writeValueOf("ActivityId", String.valueOf(activityId)));
                            tempXml.append(gen.writeValueOf("QueueId", String.valueOf(qId)));
                            tempXml.append(gen.writeValueOf("UserName", userName));
                            tempXml.append(gen.writeValueOf("ActivityName", actName));
                            tempXml.append(gen.writeValueOf("TotalWiCount", "1"));
                            tempXml.append(gen.writeValueOf("TotalDuration", String.valueOf(iTotalDuration)));
                            tempXml.append(gen.writeValueOf("AssociatedDateTime", associatedDateTime));
                            tempXml.append(gen.writeValueOf("ProcessInstance", processInst));
                            tempXml.append(gen.writeValueOf("FieldId", String.valueOf(fieldID)));
                            tempXml.append(gen.writeValueOf("WorkitemId", String.valueOf(workItemId)));
                            tempXml.append(gen.writeValueOf("TotalPrTime", String.valueOf(iTotalPrTime)));
                            tempXml.append(gen.writeValueOf("DelayTime", String.valueOf(iDelayTime)));
                            tempXml.append(gen.writeValueOf("WKInDelay", "0"));
                            tempXml.append(gen.writeValueOf("ReportType", "D"));
                            tempXml.append(gen.writeValueOf("LoggingFlag", String.valueOf(summaryFlag)));

                            if (fieldName != null) {

                                    tempXml.append(gen.writeValueOf("FieldName", replace(fieldName, "'", "''")));
                            } else {
                                    tempXml.append(gen.writeValueOf("FieldName", fieldName));
                            }
                            tempXml.append("</Message>");
							
                if ((dbType == JTSConstant.JTS_MSSQL) || (dbType == JTSConstant.JTS_DB2) || (dbType == JTSConstant.JTS_POSTGRES)) {
                    pstmt = con.prepareStatement("Insert into WFMessageTable (message, status, ActionDateTime) Values ( ?, " + WFSUtil.TO_STRING("N", true, dbType) + ", " + getDate(dbType) + ")");
                   // pstmt.setCharacterStream(1, new java.io.StringReader(tempXml.toString()), tempXml.toString().length());
					WFSUtil.DB_SetString(1, tempXml.toString(), pstmt, dbType);
                    pstmt.execute();
                } else if(dbType == JTSConstant.JTS_ORACLE){
                    String messageId = "0";
                    stmt = con.createStatement();
                    if (con.getAutoCommit()) {
                        con.setAutoCommit(false);
                        commit = true; //mean yah per false kiya gaya hai.

                    }

                    messageId = nextVal(con, "seq_messageId", dbType);
                    // Changed By Varun Bhansaly 0n 08/02/2007 for Bugzilla Bug 74
                    pstmt = con.prepareStatement("Insert into WFMessageTable (messageId, message, status, ActionDateTime) Values ( " + WFSUtil.TO_SANITIZE_STRING(messageId,false) + ",?, " + WFSUtil.TO_STRING("N", true, dbType) + ", " + getDate(dbType) + ")");
                  //  writeOracleCLOB(con, stmt, "WFMessageTable", "message", "messageId = " + messageId, tempXml.toString());
                    WFSUtil.DB_SetString(1, tempXml.toString(), pstmt, dbType);
                    pstmt.execute();
					
                    if (commit && !con.getAutoCommit()) {
                        con.commit();
                        con.setAutoCommit(true);
                        commit = false;	//Bugzilla Bug 1671

                    }
                }
                    pstmt.close();
                    pstmt = null;
			  }*/
			  //checks for summaryflag = 1 or 3 for insertion into WFCurrentRouteLogtable.
             if(summaryFlag == 1 || summaryFlag == 3){
                printOut(engineName,"Case when summary flag = 1 or 3");
                HashMap actionMap = (HashMap) CachedActionObject.getReference().getCacheObject(con, engineName);
                HashMap actionIDMap = (HashMap) actionMap.get(new Integer(0));
                if (actionIDMap.containsKey(new Integer(actionId))) {
                    switch (actionId) {
                        case WFSConstant.WFL_ScheduleEscalationAction:
                            NGXmlList escList = parser.createList("EscalationData", "Escalate");
                            String escData = null;
                            for (escList.reInitialize(); escList.hasMoreElements(); escList.skip()) {
                                escData = escList.getVal("Escalate");
                                parser.setInputXML(escData);
                                String escalationId = "";
                                String sEscMode = parser.getValueOf("EscalationMode", "", false);
                                String sEscConcernedAuthInfo = parser.getValueOf("ConcernedAuthInfo", "", false);
                                String sEscComments = parser.getValueOf("Comments", "", false);
                                String sEscMessage = parser.getValueOf("Message", "", false);
                                String sEscSchDate = parser.getValueOf("ScheduleTime", "", false);
                                String sEscFrom = parser.getValueOf("From", "", false);    /* Bug 39079 */
                                String sEscCC = parser.getValueOf("cc", "", true);
								if(sEscCC.trim().equalsIgnoreCase("null"))
									sEscCC = null;
                                String sEscBCC = parser.getValueOf("bcc", "", true);
								if(sEscBCC.trim().equalsIgnoreCase("null"))
									sEscBCC = null;

                                if ((dbType == JTSConstant.JTS_MSSQL) || (dbType == JTSConstant.JTS_DB2) || (dbType == JTSConstant.JTS_POSTGRES)) {
                     
                                    pstmt = con.prepareStatement("Insert Into WFEscalationTable (ProcessInstanceId, WorkitemId, ProcessDefId, ActivityId, EscalationMode, ConcernedAuthInfo, Comments, Message, FromId, CCId, BCCId,ScheduleTime) Values (?, ?, ?, ?, ?, ?, ?, ?,?,?,?," + WFSUtil.TO_SANITIZE_STRING(WFSUtil.TO_DATE(sEscSchDate, true, dbType),true) + ")");					/* Bug 39079 */
                                } else if (dbType == JTSConstant.JTS_ORACLE) {
                                    if (con.getAutoCommit()) {
                                        con.setAutoCommit(false);
                                        commit = true;
                                    }
                                    escalationId = WFSUtil.nextVal(con, "EscalationId", dbType);
                                    pstmt = con.prepareStatement("Insert Into WFEscalationTable (EscalationId, ProcessInstanceId, WorkitemId, ProcessDefId, ActivityId, EscalationMode, ConcernedAuthInfo, Comments, Message, FromId, CCId, BCCId,ScheduleTime) Values (" + WFSUtil.TO_SANITIZE_STRING(escalationId,false) + ", ?, ?, ?, ?, ?, ?, ?, EMPTY_CLOB(),?,?,?," + WFSUtil.TO_SANITIZE_STRING(WFSUtil.TO_DATE(sEscSchDate, true, dbType),true) + ")");   /* Bug 39079 */
                                }
                                WFSUtil.DB_SetString(1, processInst, pstmt, dbType);
                                pstmt.setInt(2, workItemId);
                                pstmt.setInt(3, procDefId);
                                pstmt.setInt(4, activityId);
                                WFSUtil.DB_SetString(5, sEscMode, pstmt, dbType);
                                WFSUtil.DB_SetString(6, sEscConcernedAuthInfo, pstmt, dbType);
                                WFSUtil.DB_SetString(7, sEscComments, pstmt, dbType);

                            if ((dbType == JTSConstant.JTS_MSSQL) || (dbType == JTSConstant.JTS_DB2) || (dbType == JTSConstant.JTS_POSTGRES)) {
                                    pstmt.setCharacterStream(8, new java.io.StringReader(sEscMessage), sEscMessage.length());
                                    WFSUtil.DB_SetString(9, sEscFrom, pstmt, dbType);
                                    WFSUtil.DB_SetString(10, sEscCC, pstmt, dbType);
                                    WFSUtil.DB_SetString(11, sEscBCC, pstmt, dbType);
                             }
                              if (dbType == JTSConstant.JTS_ORACLE){
                                    WFSUtil.DB_SetString(8, sEscFrom, pstmt, dbType);
                                    WFSUtil.DB_SetString(9, sEscCC, pstmt, dbType);
                                    WFSUtil.DB_SetString(10, sEscBCC, pstmt, dbType);
                                }
                                pstmt.execute();
                                pstmt.close();
                                pstmt = null;
                            if (dbType == JTSConstant.JTS_ORACLE){
									
                                stmt = con.createStatement();
                                WFSUtil.writeOracleCLOB(con, stmt, "WFEscalationTable", "Message", "escalationId = " + escalationId, sEscMessage);
                                stmt.close();
                                stmt = null;
                                if (commit) {
                                    con.commit();
                                    con.setAutoCommit(true);
                                    commit = false;
                                }
                            }
                                //WFSUtil.DB_SetString(9, sEscFrom, pstmt, dbType);
                                //WFSUtil.DB_SetString(10, sEscCC, pstmt, dbType);

                            }
							
                             break;
							
                        case WFSConstant.WFL_Attribute_Set:
                                boolean attribMsg = false;
                                tempXml.append("<Message>");
                                tempXml.append(gen.writeValueOf("ActionId", String.valueOf(actionId)));
                                tempXml.append(gen.writeValueOf("UserId", String.valueOf(userID)));
                                tempXml.append(gen.writeValueOf("ProcessDefId", String.valueOf(procDefId)));
                                tempXml.append(gen.writeValueOf("ActivityId", String.valueOf(activityId)));
                                tempXml.append(gen.writeValueOf("QueueId", String.valueOf(qId)));
                                tempXml.append(gen.writeValueOf("UserName", userName));
                                tempXml.append(gen.writeValueOf("ActivityName", actName));
                                tempXml.append(gen.writeValueOf("TotalWiCount", "1"));
                                tempXml.append(gen.writeValueOf("TotalDuration", String.valueOf(iTotalDuration)));
                                tempXml.append(gen.writeValueOf("AssociatedDateTime", associatedDateTime));
                                tempXml.append(gen.writeValueOf("ProcessInstance", processInst));
                                tempXml.append(gen.writeValueOf("FieldId", String.valueOf(fieldID)));
                                tempXml.append(gen.writeValueOf("WorkitemId", String.valueOf(workItemId)));
                                tempXml.append(gen.writeValueOf("TotalPrTime", String.valueOf(iTotalPrTime)));
                                tempXml.append(gen.writeValueOf("DelayTime", String.valueOf(iDelayTime)));
                                tempXml.append(gen.writeValueOf("WKInDelay", "0"));
                                tempXml.append(gen.writeValueOf("ReportType", "D"));
                                tempXml.append(gen.writeValueOf("LoggingFlag", String.valueOf(summaryFlag)));
                                tempXml.append(gen.writeValueOf("URN", urn));
                            if (fieldName != null) {
                                  HashMap varMap_temp = (HashMap) actionMap.get(new Integer(procDefId));
                                  HashMap varMap=new HashMap();
                                  if(varMap_temp!=null && !varMap_temp.isEmpty()){
	                                  Iterator it=varMap_temp.entrySet().iterator();
	                                  while(it.hasNext()){
	                                	  Map.Entry map=(Entry) it.next();
	                                	  String key=(String) map.getKey();
	                                	  varMap.put(key.toUpperCase(), map.getValue());
	                                  }
                                  }
                                  String outerTag = "Attributes";
                                  String innerTag = "Attribute";
                                  StringBuffer attribXml = new StringBuffer(500);
                                   int start = parser.getStartIndex(outerTag, 0, 0);
                                    int deadend = parser.getEndIndex(outerTag, start, 0);
                                    int noOfAtt = parser.getNoOfFields(innerTag, start, deadend);
                                    int end = 0;
                                    String tempStr = "";
                                    String attrName = null;
                                    String attrValue = null;
                                    String attrPrevValue = null;
                                    String attrType = null;
                                    String attrNameCheck = null;
                                    int count = 0;
                                    int ipos = 0;

                                    attribXml.append("<Attributes>");
                                    for (int counter = 0; counter < noOfAtt; counter++) {
                                    	start = parser.getStartIndex(innerTag, end, 0);
                                        end = parser.getEndIndex(innerTag, start, 0);
                                        attrName = parser.getValueOf("Name", start, end).trim();
                                        attrPrevValue=parser.getValueOf("PreviousValue", start, end).trim();
                                        attrValue = parser.getValueOf("Value", start, end).trim();
                                        attrType =parser.getValueOf("Type", start, end).trim();
                                        String insertionOrderId = parser.getValueOf("InsertionOrderId", start, end).trim();
										attrValue = WFSUtil.handleSpecialCharInXml(attrValue);										
                                        ipos = attrName.indexOf(".");
                                        attrNameCheck = ipos > 0 ? attrName.substring(0, ipos) : attrName;
                                        
                                        printOut(engineName, "@@printing map" + varMap);
                                        
                                        if (varMap != null && varMap.containsKey(attrNameCheck.toUpperCase())) {
                                           attribXml.append("<Attribute>");
                                           attribXml.append(gen.writeValue("Name", attrName));
                                           attribXml.append(gen.writeValue("PreviousValue", "<![CDATA["+attrPrevValue+"]]>"));
                                           attribXml.append(gen.writeValue("Value", "<![CDATA["+attrValue+"]]>"));
										   if(attrValue == null || attrValue.trim().equalsIgnoreCase("") || attrValue.trim().equalsIgnoreCase("null")){
												attribXml.append(gen.writeValue("isNull", "Y"));												
										   } else {
												attribXml.append(gen.writeValue("isNull", "N"));
										   }
                                           attribXml.append(gen.writeValue("Type" , attrType));
                                           if(insertionOrderId!=null&&!insertionOrderId.equals("")) {
                                               attribXml.append(gen.writeValue("InsertionOrderId", insertionOrderId));

                                           }
                                           attribXml.append("</Attribute>");
                                           attribMsg = true;
                                           
                                        }
                                        
                                    }
                                    attribXml.append("</Attributes>");
                                    tempXml.append(gen.writeValueOf("FieldName", replace(attribXml.toString(), "'", "''")));
                                    //Attributes tag no longer required in AssociatedFieldname in WFCurrentRouteLogTable after MessageAgentOptimization
                                    fieldName = null;
                                } else {
                                        tempXml.append(gen.writeValueOf("FieldName", fieldName));
                                }
                                        tempXml.append("</Message>");
                                //Convert tempXml into JSON
                                 String finalXml = escapeXML(tempXml.toString());
                                 JSONObject JSON = org.json.XML.toJSONObject(finalXml);
                                 String jMessage =JSON.toString();
                                 printOut(engineName,"WFSUTIL>>>SET_ATRRIBUTE>>>>JSON MESSAGE FOR ACTION ID = 16 "+jMessage);
                                if(attribMsg){
									
									ResultSet res2 = null;
									int pVarId = 0;
									pstmt = con.prepareStatement("Select ProcessVariantId from WFInstrumentTable " + getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkitemId = ? ");
									WFSUtil.DB_SetString(1, processInst, pstmt, dbType);
									pstmt.setInt(2,workItemId);
									res2 = pstmt.executeQuery();
									if (res2 != null && res2.next()) {
										pVarId = res2.getInt(1);
									}
									if (res2 != null) {
										res2.close();
										res2 = null;
									}
									if (pstmt != null) {
										pstmt.close();
										pstmt = null;
									}
                                     if ((dbType == JTSConstant.JTS_MSSQL) || (dbType == JTSConstant.JTS_DB2) || (dbType == JTSConstant.JTS_POSTGRES)) {
                                        pstmt = con.prepareStatement("Insert into WFAttriButeMessageTable (ProcessDefId,ProcessInstanceId ,WorkitemId , ProcessVariantId, message, status, ActionDateTime) Values (?,?, ?, ?, ?," + WFSUtil.TO_STRING("N", true, dbType) + ", " + getDate(dbType) + ")");
					                    pstmt.setInt(1,procDefId);
					                    WFSUtil.DB_SetString(2, processInst, pstmt, dbType);
					                    pstmt.setInt(3,workItemId);
					                    pstmt.setInt(4,pVarId);
                                        pstmt.setCharacterStream(5, new java.io.StringReader(jMessage), jMessage.length());
                                        pstmt.execute();
                                        stmt = con.createStatement();
                                if(dbType == JTSConstant.JTS_MSSQL){
                                        stmt.execute("Select @@IDENTITY");
                                        rs = stmt.getResultSet();
                                        if(rs != null && rs.next()) {
                                            fieldID1 = rs.getLong(1);
                                            rs.close();
                                                }
                                }else if(dbType == JTSConstant.JTS_POSTGRES){
                                     stmt.execute("Select currval('wfattributemessagetable_messageid_seq')");
                                        rs = stmt.getResultSet();
                                                if(rs != null && rs.next()) {
                                                        fieldID1 = rs.getLong(1);
                                                        rs.close();
                                                }
                                        }
                                        rs = null;
                                        printOut(engineName,"messageId to be inserted into AssocaitedField id = "+fieldID);

                            } else if(dbType == JTSConstant.JTS_ORACLE){
                                        String messageId = "0";
                                        if(!tarHistoryLog){
                                        	stmt = con.createStatement();
                                            if (con.getAutoCommit()) {
                                                con.setAutoCommit(false);
                                                commit = true;
                                            }
                                        }else {
                                        	stmt = tarConn.createStatement();
                                            if (tarConn.getAutoCommit()) {
                                            	tarConn.setAutoCommit(false);
                                                tarCommit = true;
                                            }
                                        	
                                        }
                                        if(!tarHistoryLog){
                                        	messageId = nextVal(con, "seq_attribmessageId", dbType);
                                            fieldID1 = Long.parseLong(messageId);
                                            printOut(engineName,"messageId to be inserted into AssocaitedField id = "+fieldID);
                                            pstmt = con.prepareStatement("Insert into WFAttriButeMessageTable (ProcessDefId,ProcessInstanceId ,WorkitemId , ProcessVariantId, messageId, message, status, ActionDateTime) Values ( ?,?,?,? , " + WFSUtil.TO_SANITIZE_STRING(messageId,false) + ",EMPTY_CLOB(), " + WFSUtil.TO_STRING("N", true, dbType) + ", " + getDate(dbType) + ")");
    					                    pstmt.setInt(1,procDefId);
    					                    WFSUtil.DB_SetString(2, processInst, pstmt, dbType);
    					                    pstmt.setInt(3,workItemId);
    					                    pstmt.setInt(4,pVarId);	
                                            pstmt.execute();
                                            writeOracleCLOB(con, stmt, "WFAttriButeMessageTable", "message", "messageId = " + messageId, jMessage);
                                        } else {
                                        	 messageId = nextVal(tarConn, "seq_attribmessageId", dbType);
                                             fieldID1 = Long.parseLong(messageId);
                                             printOut(engineName,"messageId to be inserted into AssocaitedField id = "+fieldID);
                                             pstmt = tarConn.prepareStatement("Insert into WFAttriButeMessageTable (ProcessDefId,ProcessInstanceId ,WorkitemId , ProcessVariantId, messageId, message, status, ActionDateTime) Values ( ?,?,?,? , " + WFSUtil.TO_SANITIZE_STRING(messageId,false) + ",EMPTY_CLOB(), " + WFSUtil.TO_STRING("N", true, dbType) + ", " + getDate(dbType) + ")");
     					                    pstmt.setInt(1,procDefId);
     					                    WFSUtil.DB_SetString(2, processInst, pstmt, dbType);
     					                    pstmt.setInt(3,workItemId);
     					                    pstmt.setInt(4,pVarId);	
                                             pstmt.execute();
                                             writeOracleCLOB(tarConn, stmt, "WFAttriButeMessageTable", "message", "messageId = " + messageId, jMessage);
                                        }
                                       if(tarHistoryLog){ 
                                        if (tarConn.getAutoCommit()) {
                                        	tarConn.setAutoCommit(false);
                                            tarCommit = true;
                                        }
                                        
                                        if (tarCommit) {
                                            tarConn.commit();
                                            tarConn.setAutoCommit(true);
                                            tarCommit = false;
                                        }
                                       }
                                        
                                        }
										nameValuePair.add(new ActionFieldPair(WFSConstant.WFL_AttributeHasBeenSet, null, null,fieldID1));
                                    }
                                if(pstmt!= null){
                                        pstmt.close();
                                        pstmt = null;
                                }
                            
                            break;
                        case WFSConstant.WFL_Exception_Raised:
                        case WFSConstant.WFL_Exception_Cleared:
                            associatedFieldName = parser.getValueOf("ExceptionName");
                            newValue = parser.getValueOf("ExceptionComments");
                            nameValuePair.add(new ActionFieldPair(actionId, associatedFieldName, newValue,fieldID));
                            break;
                        case WFSConstant.WFL_ToDoItemStatus_Modified:
                            associatedFieldName = parser.getValueOf("Name");
                            newValue = parser.getValueOf("Value");
                            nameValuePair.add(new ActionFieldPair(actionId, associatedFieldName, newValue,fieldID));
                            break;
                        case WFSConstant.WFL_WorkitemHolded:
                        case WFSConstant.WFL_WorkitemUnholded:
                            fieldName = parser.getValueOf("TargetActivityName");
                            newValue = parser.getValueOf("HoldType");
                            nameValuePair.add(new ActionFieldPair(actionId, associatedFieldName, newValue,fieldID));
                            break;
                        case WFSConstant.WFL_Import_Data:                        	
                 		case WFSConstant.WFL_Export_Data:
                 			 XMLParser operParser = new XMLParser(parser.getValueOf("AuditDataForDataExchange"));
                  			int noOfOpers = operParser.getNoOfFields("Operation");
                  			
                  			for(int oprCount = 0; oprCount < noOfOpers; oprCount++)
                  			{
                  				XMLParser operationParser = new XMLParser();
                  				if(oprCount > 0){
                  					operationParser.setInputXML(operParser.getNextValueOf("Operation"));
                  				}
                  				else{
                  					operationParser.setInputXML(operParser.getFirstValueOf("Operation"));
                  				}
                  				 fieldID = Integer.parseInt(operationParser.getValueOf("exchangeId"));
                  				 fieldName = "ExchangeId";
                                  newValue = operationParser.toString();
                                  nameValuePair.add(new ActionFieldPair(actionId, associatedFieldName, newValue,fieldID));
                  			}
                        	break;
                        default:
                            associatedFieldName = sFieldName;   
                            newValue = null; 
							nameValuePair.add(new ActionFieldPair(actionId, associatedFieldName, newValue,fieldID));
                            break;
							
			}
                         }
            //INSERTIONINTO WFCUrretnRouteLogTable
                 if (nameValuePair.size() > 0) {
                        for (int counter = 0; counter < nameValuePair.size() ; counter++) {
                        	ActionFieldPair actionField = null;
                                actionField = (ActionFieldPair) nameValuePair.get(counter);
                                actionId = actionField.actionId;
                                associatedFieldName = actionField.name;
                                fieldID1	= actionField.fieldId;
                                newValue = actionField.value;
                                printOut(engineName,"Value of Field Id >>>WFSUtil>>"+fieldID1);
                                if ((dbType == JTSConstant.JTS_MSSQL) || dbType == JTSConstant.JTS_POSTGRES) {
                                    cstmt = con.prepareCall("{call WFGenerateLog(?, ?, ?, ?, ?, ?, ?, ?, ?,?,?,?,?,?,?,?,?,?,?,?,?)}");
                                 } else if (dbType == JTSConstant.JTS_ORACLE) {
                                	 if(!tarHistoryLog){
                                        if (con.getAutoCommit()) {
                                            con.setAutoCommit(false);
                                            commit = true;
                                        }}
                                        if(tarHistoryLog){
                                        if (tarConn.getAutoCommit()) {
                                        	tarConn.setAutoCommit(false);
                                            tarCommit = true;
                                        }
                                        }
                                        cstmt = con.prepareCall("{call WFGenerateLog(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?,?,?,?,?,?, ? ,?,?,?,?,?)}");
                               }
                                  cstmt.setInt(1, actionId);
				if(WFUserApiThreadLocal.get()==null)
					cstmt.setInt(2, 0);
				else
				cstmt.setInt(2, (WFUserApiThreadLocal.get().getParticipantType()=='P')?0:userID);
				cstmt.setInt(3, procDefId);
				cstmt.setInt(4, activityId);
				cstmt.setInt(5, qId);
                                if(WFUserApiThreadLocal.get()==null)
					WFSUtil.DB_SetString(6, "System", cstmt, dbType);
				else
					WFSUtil.DB_SetString(6, (WFUserApiThreadLocal.get().getParticipantType()=='P')?"System":userName, cstmt, dbType);
				WFSUtil.DB_SetString(7, actName, cstmt, dbType);
				cstmt.setInt(8, iTotalDuration);
				WFSUtil.DB_SetString(9, processInst, cstmt, dbType);
				cstmt.setLong(10, fieldID1);
				WFSUtil.DB_SetString(11, fieldName, cstmt, dbType);
				cstmt.setInt(12, workItemId);
				cstmt.setInt(13, iTotalPrTime);
				cstmt.setInt(14, iDelayTime);
				if (dbType == JTSConstant.JTS_MSSQL  || dbType == JTSConstant.JTS_POSTGRES) {
							    WFSUtil.DB_SetString(15, newValue, cstmt, dbType);
                                    if(actionId !=WFSConstant.WFL_UserLogIn ){
					cstmt.setInt(16, procVariantId);
					}
					else {
						cstmt.setInt(16, 0);
					}
                                    cstmt.setInt(17, taskId); 
                                    cstmt.setInt(18, subtaskId);
                                    cstmt.setString(19,urn);
                                    cstmt.setString(20,associatedDateTime);
                                    cstmt.registerOutParameter(21, java.sql.Types.INTEGER);
				}
				else if(dbType == JTSConstant.JTS_ORACLE){
                                    cstmt.registerOutParameter(15, java.sql.Types.INTEGER);
                                    cstmt.setString(16,isReport);
                                    if(actionId !=WFSConstant.WFL_UserLogIn ){
                                    	cstmt.setInt(17, procVariantId);
                                    }else {
                                    	cstmt.setInt(17, 0);
					}
                                  
                                    cstmt.setInt(18, taskId); 
                                    cstmt.setInt(19, subtaskId);
                                    cstmt.setString(20,urn);
                                    WFSUtil.DB_SetString(21, newValue, cstmt, dbType);
                                    cstmt.setString(22,associatedDateTime);
                                    if(!tarHistoryLog)
                                    	cstmt.setString(23,"N");
                                    else 
                                    	cstmt.setString(23,"Y");
                                    cstmt.setString(24,targetCabinetName);
                                    
				}
                                  cstmt.execute();
                                        cstmt.close();
                                        cstmt = null;
                                        //Changes for bug 50438 -- query executed was not commited.
                                        if(!tarHistoryLog){
                                        if (commit) {
                                            con.commit();
                                            con.setAutoCommit(true);
                                            commit = false;
                                        }
                                        }else {
                                        if (tarCommit) {
                                            tarConn.commit();
                                            tarConn.setAutoCommit(true);
                                            tarCommit = false;
                                        }
                                        }
                                        }
						
                            }
                }
            } catch (SQLException e){
                printErr(engineName,"", e);
                mainCode = WFSError.WM_INVALID_FILTER;
                subCode = WFSError.WFS_SQL;
                subject = WFSErrorMsg.getMessage(mainCode);
                errType = WFSError.WF_FAT;
                if(e.getErrorCode() == 0){
                    if(e.getSQLState().equalsIgnoreCase("08S01")){
                        descr = (new JTSSQLError(e.getSQLState())).getMessage() + "(SQL State : " + e.getSQLState() + ")";
                    }
                } else{
                    descr = e.getMessage();
                }
            }catch(NumberFormatException e){
                WFSUtil.printErr(engineName,"", e);
                mainCode = WFSError.WF_OPERATION_FAILED;
                subCode = WFSError.WFS_ILP;
                subject = WFSErrorMsg.getMessage(mainCode);
                errType = WFSError.WF_TMP;
                descr = e.toString();
            }catch(Exception e){
                WFSUtil.printErr(engineName,"", e);
                mainCode = WFSError.WF_OPERATION_FAILED;
                subCode = WFSError.WFS_EXP;
                subject = WFSErrorMsg.getMessage(mainCode);
                errType = WFSError.WF_TMP;
                descr = e.toString();
            }catch(Error e){
               WFSUtil.printErr(engineName,"", e);
                mainCode = WFSError.WF_OPERATION_FAILED;
                subCode = WFSError.WFS_EXP;
                subject = WFSErrorMsg.getMessage(mainCode);
                errType = WFSError.WF_TMP;
                descr = e.toString();
            } finally {
                // WFS_6_004, Statement closed in finally.
                try {
                    if (commit && !con.getAutoCommit()) {
                        con.rollback();
                        con.setAutoCommit(true);
                    }
                } catch (Exception ignored) {
                }
                try {
                	if(tarConn!=null){
        					if (!tarConn.getAutoCommit()) {
        						tarConn.commit();
        						tarConn.setAutoCommit(true);
        					}
        	                try {
								NGDBConnection.closeDBConnection(tarConn, "");
							} catch (JTSException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
        	                tarConn = null;
        				} 
                	}catch (SQLException e) {
        					//e.printStackTrace();
                		 WFSUtil.printErr(engineName,"", e);
        			}
                try {
                    if (rs != null) {
                        rs.close();
                        rs = null;
                    }
                } catch (Exception ignored) {
                }
                try {
                    if (stmt != null) {
                        stmt.close();
                        stmt = null;
                    }
                } catch (Exception ignored) {
                }
                try {
                    if (pstmt != null) {
                        pstmt.close();
                        pstmt = null;
                    }
                } catch (Exception ignored) {
                }
             
        }
            if(mainCode != 0){
                throw new WFSException(mainCode, subCode, errType, subject, descr);
            }
    }
    
public static  String escapeXML(String content) {
         if (content == null || content.equalsIgnoreCase("")) {
             return "";
         }
         if (content != null && content.trim().contains("&")) {
             content = content.replace("&", "&amp;");
         }
         return content;
     }


public static  String escapeSpecialCharForJson(String content) {
     if (content != null && content.trim().contains("\0")) {
         content = content.replace("\0", " ");
     }
     return content;
 }
	
    private static WFAdminLogValue parseQueueProp(XMLParser parser, String propertyName) throws JTSException {

        int numberOfFields = 0;
        XMLParser parser1 = new XMLParser();
        WFAdminLogValue wfAdminLogValue = null;
		String operation = null;//  27/12/2012	Sajid Khan		Bug 37345 - Audit trail Issue.
		numberOfFields = parser.getNoOfFields(propertyName);
		 String oldOption = null;
            String newOption = null;
            int oldValue = 0;
            int newValue = 0;
		if (numberOfFields > 0){
        if (propertyName.equals("filter")) {
            parser1.setInputXML(parser.getValueOf("filterOption"));
            oldOption = parser1.getValueOf("old", "", true);
            newOption = parser1.getValueOf("new", "", true);
			parser1.setInputXML(parser.getValueOf("filterValue"));
            oldValue = parser1.getIntOf("old", 0, true);
            newValue = parser1.getIntOf("new", 0, true);
		//Bug 37965 - While Generate the log for the queue, same description and Date are showing 2 times in log 
		//handling of different case for queue properties.
		}else if(propertyName.equals("queueName")){
				parser1.setInputXML(parser.getValueOf("queueName"));
				oldOption = parser1.getValueOf("old", "", true);
				newOption = parser1.getValueOf("new", "", true);
			
		
		}else if(propertyName.equals("queueType")){
				parser1.setInputXML(parser.getValueOf("queueType"));
				oldOption = parser1.getValueOf("old", "", true);
				newOption = parser1.getValueOf("new", "", true);
			
		
		}else if(propertyName.equals("allowReassingment")){
				parser1.setInputXML(parser.getValueOf("allowReassingment"));
				oldOption = parser1.getValueOf("old", "", true);
				newOption = parser1.getValueOf("new", "", true);
			
		
		}else if(propertyName.equals("orderBy")){
				parser1.setInputXML(parser.getValueOf("orderBy"));
				oldOption = parser1.getValueOf("old", "", true);
				newOption = parser1.getValueOf("new", "", true);
			
		
		}//else if (propertyName.equals("queueType")){
//				parser1.setInputXML(parser.getValueOf("queueType"));
//				oldOption = parser1.getValueOf("old", "", true);
//				newOption = parser1.getValueOf("new", "", true);
//			
//				}
		else if (propertyName.equals("QueueFilter")){
			parser1.setInputXML(parser.getValueOf("QueueFilter"));
			oldOption = parser1.getValueOf("old", "", true);
			newOption = parser1.getValueOf("new", "", true);
			}
				
		parser1.setInputXML(parser.getValueOf(propertyName));
        //wfAdminLogValue = new WFAdminLogValue(0, null, 0, null, propertyName, parser1.getValueOf("old", "", true), parser1.getValueOf("new", "", true), null, null);           
		wfAdminLogValue = new WFAdminLogValue(oldValue, null, newValue, null, propertyName, parser1.getValueOf("old", "", true), parser1.getValueOf("new", "", true), null, null,operation); 
    }
	return wfAdminLogValue;
	}
	
	private static WFAdminLogValue parseProfileProp(int fieldId, String fieldName, XMLParser parser, String propertyName) throws JTSException {

        int numberOfFields = 0;
        XMLParser parser1 = new XMLParser();
        WFAdminLogValue wfAdminLogValue = null;
		//printOut("propertyName::"+propertyName);
		String operation = null;//  27/12/2012	Sajid Khan		Bug 37345 - Audit trail Issue.
		numberOfFields = parser.getNoOfFields(propertyName);
		//printOut("numberOfFields::"+numberOfFields);
		if (numberOfFields > 0) {
			parser1.setInputXML(parser.getValueOf(propertyName));
			//printOut("parser1::"+parser1);
			wfAdminLogValue = new WFAdminLogValue(fieldId, fieldName, 0, null, propertyName, parser1.getValueOf("old", "", true), parser1.getValueOf("new", "", true), null, null,operation);
		}
        return wfAdminLogValue;
    }

    private static void parseqUserGroupAssoc(XMLParser parser, String outerTag, String innerTag, String fieldId1Tag, String fieldName1Tag, String fieldId2Tag, String fieldName2Tag, String newValueTag, String prop, ArrayList valueList) {

        XMLParser parser1 = new XMLParser();
        int fieldId1 = 0;
        String fieldName1 = null;
        int fieldId2 = 0;
        String fieldName2 = null;
        String oldValue = null;
        String newValue = null;
		String operation = null;
        int start = 0;
        int end = 0;
        int deadend = Integer.MAX_VALUE;

        if (outerTag != null) {
            start = parser.getStartIndex(outerTag, 0, 0);
            end = 0;
            deadend = parser.getEndIndex(outerTag, start, 0);
        }
        //if (innerTag != null) {
        int count = parser.getNoOfFields(innerTag, start, deadend);
        if (count > 0) {
            for (int counter = 0; counter < count; counter++) {
                start = parser.getStartIndex(innerTag, end, 0);
                end = parser.getEndIndex(innerTag, start, 0);
                if (fieldId1Tag != null) {
                    fieldId1 = Integer.parseInt(parser.getValueOf(fieldId1Tag, start, end));
                }
                if (fieldName1Tag != null) {
                    fieldName1 = parser.getValueOf(fieldName1Tag, start, end).trim();
                }

                if (fieldId2Tag != null) {
                    fieldId2 = Integer.parseInt(parser.getValueOf(fieldId2Tag, start, end));
                }
                if (fieldName2Tag != null) {
                    fieldName2 = parser.getValueOf(fieldName2Tag, start, end).trim();
                }
                if (newValueTag != null) {
                    newValue = parser.getValueOf(newValueTag, start, end).trim();

                }


                valueList.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, prop, oldValue, newValue, null, null,operation));
            }
        }
    }
	
	private static void parseProfObjUserGroupAssoc(XMLParser parser, String outerTag, String innerTag, String fieldId1Tag, String fieldName1Tag, String fieldId2Tag, String fieldName2Tag, String newValueTag, String propTag, ArrayList valueList, String propVal) {

        XMLParser parser1 = new XMLParser();
        int fieldId1 = 0;
        String fieldName1 = null;
        int fieldId2 = 0;
        String fieldName2 = null;
        String oldValue = null;
        String newValue = null;
		String operation = null;
		String prop = null;
		boolean propflag = true;
		if(propVal != null){
			propflag = false;
			prop = propVal;
		}
		int start = 0;
        int end = 0;
        int deadend = Integer.MAX_VALUE;
//		printOut("propVal::"+propVal);
//		printOut("prop::"+prop);
//		printOut("propflag::"+propflag);
		//printOut("fieldName2Tag::"+fieldName2Tag);
		if (fieldId1Tag != null) {
		
			fieldId1 = Integer.parseInt(parser.getValueOf(fieldId1Tag, start, end).trim());
//			printOut("fieldId1::"+fieldId1);
		}
		if (fieldName1Tag != null) {
			fieldName1 = parser.getValueOf(fieldName1Tag, start, end).trim();
		}

        if (outerTag != null) {
            start = parser.getStartIndex(outerTag, 0, 0);
            end = 0;
            deadend = parser.getEndIndex(outerTag, start, 0);
        }
        //if (innerTag != null) {
        int count = parser.getNoOfFields(innerTag, start, deadend);
        if (count > 0) {
            for (int counter = 0; counter < count; counter++) {
                start = parser.getStartIndex(innerTag, end, 0);
                end = parser.getEndIndex(innerTag, start, 0);
                if (fieldId2Tag != null) {
					printOut("","parser.getValueOf(fieldId2Tag, start, end)::"+parser.getValueOf(fieldId2Tag, start, end));
                    fieldId2 = Integer.parseInt(parser.getValueOf(fieldId2Tag, start, end));	
                }
                if (fieldName2Tag != null) {
                    fieldName2 = parser.getValueOf(fieldName2Tag, start, end).trim();
                }
                if (newValueTag != null) {
                    newValue = parser.getValueOf(newValueTag, start, end).trim();
                }
				if(propflag){
					if (propTag != null) {
						prop = parser.getValueOf(propTag, start, end).trim();
					}
				}
				printOut("","fieldId2::"+fieldId2);
                valueList.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, prop, oldValue, newValue, null, null,operation));
            }
        }
	}

	

//----------------------------------------------------------------------------------------------------
//	Function Name 					:	genAdminLog
//	Date Written (DD/MM/YYYY)		:	14/05/2008
//	Author							:	Sirish Gupta
//	Input Parameters				:	engineName, con, actionId, procDefId, queueId, queueName, userId, userName, fieldId, fieldName, wefDate, validTillDate
//	Output Parameters				:   none
//	Return Values					:	void
//	Description						:   Generates log for Admin operations.
//----------------------------------------------------------------------------------------------------
    public static void genAdminLog(String engineName, Connection con, int actionId, int procDefId, int queueId, String queueName, int userId, String userName, int fieldId, String fieldName, String wefDate, String validTillDate) throws SQLException {
            PreparedStatement pstmt = null;
            ResultSet rs = null;
            ArrayList values = new ArrayList();
			ArrayList values1 = null;
            XMLParser parser = new XMLParser();
            int dbType = ServerProperty.getReference().getDBType(engineName);
            java.sql.Date tempDate = null;
            DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US);
            try {
                WFAdminLogValue wfAdminLogValue = null;
                int fieldId1 = 0;
                String fieldName1 = null;
                int fieldId2 = 0;
                String fieldName2 = null;
                String property = null;
                String oldValue = null;
                String newValue = null;
				String assoc = null;
				String operation = null;
				int profileId = 0;
                String profileName = null;
                String property1 = null;
				parser.setInputXML(fieldName);
				operation = parser.getValueOf("Operation", null, true);//Bug 37345 - Audit trail Issue.
                printOut(engineName,"fieldName::"+fieldName);
                switch (actionId) {
					  case WFSConstant.WFL_OTMS_ProcessTransported:
                             fieldName1 = parser.getValueOf("SourceCabinet", null, true);
                             fieldName2 = parser.getValueOf("ProcessName", null, true);
                             values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
                      break;
	
				
				
					// Bug 37345 - Audit trail Issue.
					case WFSConstant.WFL_AuthorizationCompleted:
						fieldId1 = parser.getIntOf("AuthorizationId", 0, true);
						fieldName1 = parser.getValueOf("EntityType", null, true);
						fieldName2 = parser.getValueOf("EntityName", null, true);
						property = parser.getValueOf("MakerUserName", null, true);
						values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
					break;
				
				case WFSConstant.WFL_ProcessStateChanged:
						//  Bug 37731 - AuditTrail for Process State Change for registered Processes .
						property1 = String.valueOf(parser.getCharOf("AuthorizationFlag", 'N', true));
						fieldName2= parser.getValueOf("ProcessName",null,true);
                        newValue = parser.getValueOf("ChangedState", "Enabled", true);
                        oldValue = newValue.equals("Enabled") ? "Disabled" : "Enabled";
						fieldId2 = parser.getIntOf("VersionNo", 0, true);// Bug 37632-  Not able to differentiate between checkin of process as same or new version 
                        values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
                        break;

                    case WFSConstant.WFL_ChnQueue:
						property1 = String.valueOf(parser.getCharOf("AuthorizationFlag", 'N', true));
                        wfAdminLogValue = parseQueueProp(parser, "queueName");
                        if (wfAdminLogValue != null) {
                            values.add(wfAdminLogValue);
                        }

                        wfAdminLogValue = parseQueueProp(parser, "queueType");
                        if (wfAdminLogValue != null) {
                            values.add(wfAdminLogValue);
                        }

                        wfAdminLogValue = parseQueueProp(parser, "comments");
                        if (wfAdminLogValue != null) {
                            values.add(wfAdminLogValue);
                        }

                        wfAdminLogValue = parseQueueProp(parser, "allowReassingment");
                        if (wfAdminLogValue != null) {
                            values.add(wfAdminLogValue);
                        }

                        wfAdminLogValue = parseQueueProp(parser, "orderBy");
                        if (wfAdminLogValue != null) {
                            values.add(wfAdminLogValue);
                        }

                        wfAdminLogValue = parseQueueProp(parser, "filter");
                        if (wfAdminLogValue != null) {
                            values.add(wfAdminLogValue);
                        }
                        wfAdminLogValue = parseQueueProp(parser, "QueueFilter");
                        if (wfAdminLogValue != null) {
                            values.add(wfAdminLogValue);
                        }
                        break;
						//  27/12/2012	Sajid Khan				Bug 37345 - Audit trail Issue.
                    case WFSConstant.WFL_ChnQueueColor:     //  Support for colored display on web.     Abhishek Gupta.
                        values.add(new WFAdminLogValue(0, null, 0, null, "Color", null, null, wefDate, validTillDate,operation));// Bug 37345 - Audit trail Issue.
                        break;

                    case WFSConstant.WFL_DivertSet:
                        fieldId1 = fieldId;
                        fieldName1 = parser.getValueOf("DivertedForName", "", true);
                        fieldId2 = parser.getIntOf("DivertedToId", 0, true);
                        fieldName2 = parser.getValueOf("DivertedToName", "", true);
                        values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));// Bug 37345 - Audit trail Issue.
                        break;

                    case WFSConstant.WFL_AddQueue:
                        fieldId1 = fieldId;
                        fieldName1 = fieldName;
                        values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
                        break;

                    case WFSConstant.WFL_DelQueue:
                        fieldId1 = fieldId;
                        fieldName1 = fieldName;
                        values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
                        break;


                    case WFSConstant.WFL_DivertDel:
                        fieldId1 = fieldId;
                        fieldName1 = fieldName;
                        values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
                        break;

                    case WFSConstant.WFL_AddUserToQueue:
                    case WFSConstant.WFL_DeleteUserFromQueue:
						property1 = String.valueOf(parser.getCharOf("AuthorizationFlag", 'N', true));
                        parseqUserGroupAssoc(parser, "UserList", "UserInfo", "UserId", "UserName", null, null, null, "U", values);
                        parseqUserGroupAssoc(parser, "GroupList", "GroupInfo", "GroupId", "GroupName", null, null, null, "G", values);
                        break;

                    case WFSConstant.WFL_AddWorkStepToQueue:
                    case WFSConstant.WFL_DeleteWorkStepFromQueue:
                        parseqUserGroupAssoc(parser, "StreamList", "StreamInfo", "ActivityId", null, "StreamId", "StreamName", null, null, values);
                        break;

                    case WFSConstant.WFL_AddPreferedQueue:
                        parseqUserGroupAssoc(parser, "QueueList", "QueueInfo", "UserId", null, "QueueId", "QueueName", null, null, values);
                        break;

                    case WFSConstant.WFL_DeletePreferedQueue:
                        parseqUserGroupAssoc(parser, "QueueList", "QueueInfo", "UserId", null, "QueueId", "QueueName", null, null, values);
                        //nothing added for now as only count is sent..
                        //dbStatus = insertintoWFAdminLogTable(con, dbType, actionId, procDefId, queueId, queueName, FieldId1, FieldName1, FieldId2, FieldName2, property, userId, userName, oldValue, newValue, wefDate, validTillDate);
                        break;

                    case WFSConstant.WFL_AddAliasToQueue:
                        printOut(engineName,"WFSConstant.WFL_AddAliasToQueue    : " + fieldName);
                        parseqUserGroupAssoc(parser, "AliasList", "AliasInfo", null, "AliasName", null, "MappedVariable", null, null, values);
                        break;

                    case WFSConstant.WFL_DeleteAliasFromQueue:
                    	printOut(engineName, "WFSConstant.WFL_DeleteAliasFromQueue     : " + fieldName);
                        parseqUserGroupAssoc(parser, "AliasList", "AliasInfo", null, "AliasName", null, null, null, null, values);
                        break;

                    case WFSConstant.WFL_ProcessTATime:
                        newValue = parser.getValueOf("ProcessTATime", "", true);
                        fieldName2 = parser.getValueOf("ProcessTATCalFlag", "", true);
                        values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
                        break;

                    case WFSConstant.WFL_ActivityTATime:
                        parseqUserGroupAssoc(parser, "ActivityList", "ActivityInfo", "ActivityId", "ActivityName", null, "ActivityTATCalFlag", "ActivityTATime", null, values);
                        break;

                    case WFSConstant.WFL_AuditLogPreferencesChanged:
                        parseqUserGroupAssoc(parser, "ActionList", "Item", "ActionId", null, null, null, "Value", null, values);
                        parseqUserGroupAssoc(parser, "ProcessVarList", "Item", null, null, null, "VariableName", "Value", null, values);
                        break;

                    case WFSConstant.WFL_QueryFilter_Set:
						property1 = String.valueOf(parser.getCharOf("AuthorizationFlag", 'N', true));
						printOut(engineName,"WFSConstant.WFL_QueryFilter_Set     : " + fieldName);
                        parseqUserGroupAssoc(parser, null, "UserInfo", "UserId", "UserName", null, null, "QueryFilter", "U", values);
                        parseqUserGroupAssoc(parser, null, "GroupInfo", "GroupId", "GroupName", null, null, "QueryFilter", "G", values);
                        break;

                    case WFSConstant.WFL_Constant_Updated:
                        parseqUserGroupAssoc(parser, "DynamicConstants", "DynamicConstant", null, "Name", null, null, "Value", null, values);
                        break;
                    /*
                     * Change By : Saurabh Kamal
                     * Date : 22/10/2009
                     * Description : WFS_8.0_045, Audting of Add Calendar
                     */
                    case WFSConstant.WFL_Add_Calendar:
                    case WFSConstant.WFL_Calendar_Modified:
                        fieldId1 = fieldId;
                        fieldName1 = fieldName;
                        values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
                        break;
					case WFSConstant.WFL_Process_Register:
                        fieldId1 = fieldId;
                        fieldName1 = parser.getValueOf("ApplicationInfo");
						fieldName2 = "10.0";
						oldValue = parser.getValueOf("ProcessName");
						newValue = parser.getValueOf("Comment");
                        values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
                        break;
					case WFSConstant.WFL_Process_UnRegister:
                        fieldId1 = fieldId;
                        fieldName1 = parser.getValueOf("ApplicationInfo");
                        /*Bug 38051 fixed*/
						fieldId2 = parser.getIntOf("ProjectId", 0 ,true);
                        fieldName2 = "10.0";
						oldValue = parser.getValueOf("ProcessName");
						newValue = parser.getValueOf("Comment");
                        values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
                        break;
					case WFSConstant.WFL_Process_CheckOut:
                        fieldId1 = fieldId;
                        fieldName1 = parser.getValueOf("ApplicationInfo");
						fieldName2 = parser.getValueOf("IsCheckOut");// Bug 38374
						oldValue = parser.getValueOf("ProcessName");
						newValue = parser.getValueOf("Comment");
						fieldId2 = parser.getIntOf("FieldId2", 0 ,true);
						property = parser.getValueOf("Property", "" ,true);
                        values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
                        break;
					case WFSConstant.WFL_Process_CheckIn:
                        fieldId1 = fieldId;
                        fieldName1 = parser.getValueOf("ApplicationInfo");
						//Bug 37632- Not able to differentiate between checkin of process as same or new version.
						fieldName2 = parser.getValueOf("VersionNo");
						oldValue = parser.getValueOf("ProcessName");
						newValue = parser.getValueOf("Comment");
                        fieldId2 = parser.getIntOf("FieldId2", 0 ,true);
						property = parser.getValueOf("Property", "" ,true);
						values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
                        break;
					case WFSConstant.WFL_Process_CheckIn_NewVer:
                        fieldId1 = fieldId;
                        fieldName1 = parser.getValueOf("ApplicationInfo");
						//Bug 37632- Not able to differentiate between checkin of process as same or new version.
						fieldName2 = parser.getValueOf("VersionNo");
						oldValue = parser.getValueOf("ProcessName");
						newValue = parser.getValueOf("Comment");
                        fieldId2 = parser.getIntOf("FieldId2", 0 ,true);
						property = parser.getValueOf("Property", "" ,true);
						values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
                        break;	
					case WFSConstant.WFL_Process_UndoCheckOut:
                        fieldId1 = fieldId;
                        fieldName1 = parser.getValueOf("ApplicationInfo");
						fieldName2 = "10.0";
						oldValue = parser.getValueOf("ProcessName");
						newValue = parser.getValueOf("Comment");
						fieldId2 = parser.getIntOf("FieldId2", 0 ,true);
						property = parser.getValueOf("Property", "",true);
                        values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
                        break;
					//Bug 38002 - History is not generated for operation 'Add Variable in Quick Search     Manangement' in Audit log
					//Bug 38003 - History is not generated for operation 'Delete Variable in Quick Search     Manangement' in Audit log
				   case WFSConstant.WFL_Add_QuickSearchVariable:
				   case  WFSConstant.WFL_Delete_QuickSearchVariable:
						fieldName1 =parser.getValueOf("variableName");
						fieldName2 =parser.getValueOf("aliasName");
						property = parser.getValueOf("SearchAllVersion");
						values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
				   break;
				   
					case WFSConstant.WFL_SetExportCabinet:
                    case WFSConstant.WFL_DeleteExportCabinet:
                    case WFSConstant.WFL_ModifyExportCabinet:
                        fieldId1 = fieldId;
                        fieldName1 = fieldName;
                        values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
                        break;

                    case WFSConstant.WFL_AddPurgeCriteria:
                    case WFSConstant.WFL_ModifyPurgeCriteria:
                    case WFSConstant.WFL_DeletePurgeCriteria:
                        fieldId1 = fieldId;
                        fieldName1 = fieldName;
                        values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
                        break;
					case WFSConstant.WFL_SetWorkAudit:
                    case WFSConstant.WFL_ModifiedWorkAudit:
                        fieldId1 = fieldId;
                        fieldName1 = parser.getValueOf("AuditeeUserName", "", true);
                        fieldId2 = parser.getIntOf("AuditorUserId", 0, true);
                        fieldName2 = parser.getValueOf("AuditorUserName", "", true);
                        property = parser.getValueOf("AuditPercentage", "0", true);
                        values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
                        break;
                	case WFSConstant.WFL_DeleteWorkAudit:
                    	fieldId1 = fieldId;
                    	fieldName1 = fieldName;
                    	values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
                    	break;	
                	 case WFSConstant.WFS_Process_DocType_Added:
                         fieldId1 = fieldId;
                         fieldName1 = fieldName;
                         values.add(new WFAdminLogValue(fieldId1, fieldName1, fieldId2, fieldName2, property, oldValue, newValue, wefDate, validTillDate,operation));
                         break;
                    default:
                        break;
                }
				
				
				for (int counter = 0; counter < values.size(); counter++) {
					wfAdminLogValue = (WFAdminLogValue) values.get(counter);
					values1 =  new ArrayList();
					/*wfAdminLogValue.actionId = actionId;
					wfAdminLogValue.procDefId = procDefId;
					wfAdminLogValue.queueId = queueId;
					wfAdminLogValue.queueName = queueName;
					wfAdminLogValue.userId = userId;
					wfAdminLogValue.userName = userName;*/
					wfAdminLogValue.setActionId(actionId);
					wfAdminLogValue.setProcDefId(procDefId);
					wfAdminLogValue.setQueueId(queueId);
					wfAdminLogValue.setQueueName(queueName);
					wfAdminLogValue.setUserId(userId);
					wfAdminLogValue.setUserName(userName);
					wfAdminLogValue.setProfileId(profileId);
					wfAdminLogValue.setProfileName(profileName);
					wfAdminLogValue.setProperty1(property1);
					values1.add(wfAdminLogValue);
					printOut(engineName,"values::"+values+"actionid::"+actionId);
					genAdminLogExt(con, engineName, values1);
				}
				
				
            } catch (Exception e) {
                printErr(engineName,"", e);
            } finally {
                try {
                    if (pstmt != null) {
                        pstmt.close();
                        pstmt = null;
                    }
                } catch (Exception ignored) {
                }
            }
    }

    //----------------------------------------------------------------------------------------------------
//	Function Name 					:	genAdminLogExt
//	Date Written (DD/MM/YYYY)		:	03/01/2013
//	Author							:	Shweta Singhal
//	Input Parameters				:	ArrayList value
//	Output Parameters				:   none
//	Return Values					:	void
//	Description						:   Insert data in WFAdminLogTable for logging
//----------------------------------------------------------------------------------------------------
	//Auditing optimized
    public static void genAdminLogExt(Connection con, String engineName, ArrayList values){
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		//ArrayList values = new ArrayList();
		int dbType = ServerProperty.getReference().getDBType(engineName);
		java.sql.Timestamp tempDate = null;
		DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US);
		try{
			String prop1 = null;
			WFAdminLogValue wfAdminLogValue = null;
			pstmt = con.prepareStatement("Insert into WFAdminLogTable (ActionId, ActionDateTime, ProcessDefId, QueueId , QueueName," +
					" FieldId1, FieldName1, FieldId2, FieldName2, Property, UserId, UserName, OldValue, NewValue, WEFDate," +
					" ValidTillDate, Operation, ProfileId, ProfileName, Property1) Values (?, " + getDate(dbType) + ", ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");// Bug 37345 - Audit trail Issue.

			for (int counter = 0; counter < values.size(); counter++) {
				wfAdminLogValue = (WFAdminLogValue) values.get(counter);
				pstmt.setInt(1, wfAdminLogValue.getActionId());
				pstmt.setInt(2, wfAdminLogValue.getProcDefId());
				pstmt.setInt(3, wfAdminLogValue.getQueueId());
				WFSUtil.DB_SetString(4, wfAdminLogValue.getQueueName(), pstmt, dbType);
				pstmt.setInt(5, wfAdminLogValue.getFieldId1());
				WFSUtil.DB_SetString(6, wfAdminLogValue.getFieldName1(), pstmt, dbType);
				//if(fieldId2 == 0)
				//fieldId2 = wfAdminLogValue.fieldId2;
				pstmt.setInt(7, wfAdminLogValue.getFieldId2());
				WFSUtil.DB_SetString(8, wfAdminLogValue.getFieldName2(), pstmt, dbType);
				WFSUtil.DB_SetString(9, wfAdminLogValue.getProperty(), pstmt, dbType);
				pstmt.setInt(10, wfAdminLogValue.getUserId());
				WFSUtil.DB_SetString(11, wfAdminLogValue.getUserName(), pstmt, dbType);
				WFSUtil.DB_SetString(12, wfAdminLogValue.getOldValue(), pstmt, dbType);
				WFSUtil.DB_SetString(13, wfAdminLogValue.getNewValue(), pstmt, dbType);
				if (wfAdminLogValue.getWefDate() == null) {
					pstmt.setDate(14, null);
				}else{                  
					//Bug 38026 - No History generated for operation 'Set Diversion' 
					tempDate = new java.sql.Timestamp(formatter.parse(wfAdminLogValue.getWefDate()).getTime());
					pstmt.setTimestamp(14, tempDate);
				}
				if (wfAdminLogValue.getValidTillDate() == null) {
					pstmt.setDate(15, null);
				}else{
					//Bug 38026 - No History generated for operation 'Set Diversion' 
					tempDate = new java.sql.Timestamp(formatter.parse(wfAdminLogValue.getValidTillDate()).getTime());
					pstmt.setTimestamp(15, tempDate);
				}
				WFSUtil.DB_SetString(16, wfAdminLogValue.getOperation(), pstmt, dbType);//  27/12/2012	Sajid Khan		Bug 37345 - Audit trail Issue.
			  
				pstmt.setInt(17, wfAdminLogValue.getProfileId());
				WFSUtil.DB_SetString(18, wfAdminLogValue.getProfileName(), pstmt, dbType);
				prop1 = wfAdminLogValue.getProperty1();
				printOut(engineName,"Property1::"+prop1);
				WFSUtil.DB_SetString(19, prop1, pstmt, dbType);
				
				pstmt.execute();
			}
			pstmt.close();
			pstmt = null;
		}catch (Exception e) {
			printErr(engineName,"", e);
		}finally{
			try {
				if (pstmt != null) {
					pstmt.close();
					pstmt = null;
				}
			} catch (Exception ignored) {
			}
		}
	}
	
	
	/*
    private static int insertintoWFAdminLogTable(Connection con, int dbType, int actionId, int procDefId, int queueId, String queueName, int FieldId1, String FieldName1, int FieldId2, String FieldName2, String property, int userId, String userName, String oldValue, String newValue, String wefDate, String validTillDate) throws Exception {
    PreparedStatement pstmt = null;
    int dbStatus = 1;
    try {
    pstmt = con.prepareStatement("Insert into WFAdminLogTable (ActionId, ActionDateTime, ProcessDefId, QueueId , QueueName, FieldId1, FieldName1, FieldId2, FieldName2, Property, UserId, UserName, OldValue, NewValue, WEFDate, ValidTillDate) Values (" + actionId + ", " + getDate(dbType) + ", " + procDefId + ", " + queueId + ", " + WFSUtil.TO_STRING(queueName, true, dbType) + ", " + FieldId1 + ", " + WFSUtil.TO_STRING(FieldName1, true, dbType) + ", " + FieldId2 + ", " + WFSUtil.TO_STRING(FieldName2, true, dbType) + ", " + WFSUtil.TO_STRING(property, true, dbType) + ", " + userId + ", " + WFSUtil.TO_STRING(userName, true, dbType) + ", " + WFSUtil.TO_STRING(oldValue, true, dbType) + ", " + WFSUtil.TO_STRING(newValue, true, dbType) + ", " + (wefDate == null ? null : WFSUtil.TO_STRING(wefDate, true, dbType)) + ", " + (validTillDate == null ? null : WFSUtil.TO_STRING(validTillDate, true, dbType)) + ")");
    pstmt = con.prepareStatement("Insert into WFAdminLogTable (ActionId, ActionDateTime, ProcessDefId, QueueId , QueueName," +
    " FieldId1, FieldName1, FieldId2, FieldName2, Property, UserId, UserName, OldValue, NewValue, WEFDate," +
    " ValidTillDate) Values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
    pstmt.setInt(1, actionId);
    pstmt.setInt(2, actionId);
    pstmt.setInt(3, procDefId);
    pstmt.setInt(4, queueId);
    WFSUtil.DB_SetString(5, queueName, pstmt, dbType);
    pstmt.setInt(6, FieldId1);
    WFSUtil.DB_SetString(7, FieldName1, pstmt, dbType);
    pstmt.setInt(8, FieldId2);
    WFSUtil.DB_SetString(9, FieldName2, pstmt, dbType);
    WFSUtil.DB_SetString(10, property, pstmt, dbType);
    pstmt.setInt(11, userId);
    WFSUtil.DB_SetString(12, userName, pstmt, dbType);
    WFSUtil.DB_SetString(13, oldValue, pstmt, dbType);
    WFSUtil.DB_SetString(14, newValue, pstmt, dbType);
    pstmt.setInt(15, actionId);
    pstmt.setInt(16, actionId);
    pstmt.execute();
    pstmt.close();
    } catch (Exception e) {
    WFSUtil.printErr("", e);
    }
    return dbStatus;
    }
     */
	/*WFS_8.0_049*/
    public static int getTimeDiff(String startDate, String endDate, String engineName) {
        java.util.Date startDt = null;
        java.util.Date endDt = null;
        int diffInSec = 0;
        try {
            if (startDate != null && !startDate.equals("") && endDate != null && !endDate.equals("")) {
                startDt = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US).parse(startDate);
                endDt = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US).parse(endDate);
                diffInSec = (int) ((endDt.getTime() - startDt.getTime()) / 1000);	//Bugzilla Bug 27472
            }
        } catch (Exception e) {
            WFSUtil.printErr(engineName,"", e);
        }
        return diffInSec;
    }
	
	/*public static int getTimeDiff(String startDate, String endDate, String engineName) {
        int diffInSec = getTimeDiff(startDate, endDate);
        return diffInSec;
    }*/

    /** 08/07/2008 Bugzilla Bug 5142, 5530, Boolean/ ShortDate/ Time support in pick list. - Ruhi Hira */
    public static String to_OmniFlow_Value(String value, int wfType) {
        String returnStr = value;
        java.util.Date tempDate = null;
        switch (wfType) {
            case WFSConstant.WF_ANY:
            case WFSConstant.WF_STR: 
            returnStr=handleSpecialCharInXml(value);
        	break;
            case WFSConstant.WF_BOOLEAN:
            case WFSConstant.WF_DAT:
            case WFSConstant.WF_INT:
            case WFSConstant.WF_LONG:
            case WFSConstant.WF_FLT:
                break;
            case WFSConstant.WF_SHORT_DAT:
                try {
                    if (value != null && !value.equals("")) {
                        tempDate = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US).parse(value);
                        returnStr = new java.text.SimpleDateFormat("yyyy-MM-dd", Locale.US).format(tempDate);
                    }
                } catch (Exception ex) {
                    returnStr = value;
                    printErr("","[WFSUtil] to_OmniFlow_Value() Error while converting " + value + " to SHORT DATE !! ");
                }
                break;
            case WFSConstant.WF_TIME:
                try {
                    if (value != null && !value.equals("")) {
                        tempDate = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US).parse(value);
                        returnStr = new java.text.SimpleDateFormat("HH:mm:ss", Locale.US).format(tempDate);
                    }
                } catch (Exception ex) {
                	try{
                	tempDate = new java.text.SimpleDateFormat("HH:mm:ss", Locale.US).parse(value);
                    returnStr = new java.text.SimpleDateFormat("HH:mm:ss", Locale.US).format(tempDate);
                	}
                	catch(Exception e){
                    returnStr = value;
                    printErr("","[WFSUtil] to_OmniFlow_Value() Error while converting " + value + " to TIME !! ");
                }
                }
                break;
        }
        return returnStr;
    }
	
	 public static String to_OmniFlow_Value(String value, int wfType, String engineName) {
		String returnStr = to_OmniFlow_Value(value, wfType);
		return returnStr;
	 }

    /**
     * *************************************************************
     * Function Name    :   printWSRequest
     * Author			:   Varun Bhansaly
     * Date Written     :   06/08/2008
     * Input Parameters :   Object -> message
     * Output Parameters:   NONE
     * Return Value     :   void
     * Description      :   To print webservice request in wsrequest.xml
     * *************************************************************
     */
    public static void printWSRequest(Object message) {
      ///  WFLogger.printWSRequest(message);
        NGUtil.writeXmlLog("", WFSConstant.CONST_WS_MODULE, "[WSRequest]", message.toString());
    }

    public static void printWSRequest(String inputXML, Object message) {
        XMLParser parser = new XMLParser();
        parser.setInputXML(inputXML);
        String cabName = parser.getValueOf("EngineName");
//        parser = null;
//        if(cabName == null || cabName.equalsIgnoreCase(""))
//            WFLogger.printWSRequest(message);
//        else
//            WFLogger.printWSRequest(message, cabName);
        NGUtil.writeXmlLog(cabName, WFSConstant.CONST_WS_MODULE, "[WSRequest]", message.toString());
    }

    /**
     * *************************************************************
     * Function Name    :   printWSRequest
     * Author			:   Varun Bhansaly
     * Date Written     :   15/10/2007
     * Input Parameters :   Level -> level, Object -> message
     * Output Parameters:   NONE
     * Return Value     :   void
     * Description      :   To print webservice request in wsrequest.xml
     *                      at User-defined Priority.
     * *************************************************************
     */
//    public static void printWSRequest(Level level, Object message) {
//        WFLogger.printWSRequest(level, message);
//    }
//    public static void printWSRequest(String inputXML, Level level, Object message) {
//        XMLParser parser = new XMLParser();
//        parser.setInputXML(inputXML);
//        String cabName = parser.getValueOf("EngineName");
//        parser = null;
//        if(cabName == null || cabName.equalsIgnoreCase(""))
//            WFLogger.printWSRequest(level, message);
//        else
//            WFLogger.printWSRequest(level, message, cabName);
//    }

    /**
     * *************************************************************
     * Function Name    :   printWSResponse
     * Author			:   Varun Bhansaly
     * Date Written     :   06/08/2008
     * Input Parameters :   Object -> message
     * Output Parameters:   NONE
     * Return Value     :   void
     * Description      :   To print webservice response in wsrequest.xml
     * *************************************************************
     */
    public static void printWSResponse(Object message) {
       // WFLogger.printWSResponse(message);
         NGUtil.writeXmlLog("", WFSConstant.CONST_WS_MODULE, "[WSRESPONSE]", message.toString());
    }

    public static void printWSResponse(String inputXML, Object message) {
        XMLParser parser = new XMLParser();
        parser.setInputXML(inputXML);
        String cabName = parser.getValueOf("EngineName");
//        parser = null;
//        if(cabName == null || cabName.equalsIgnoreCase(""))
//            WFLogger.printWSResponse(message);
//        else
//            WFLogger.printWSResponse(message, cabName);
         NGUtil.writeXmlLog(cabName, WFSConstant.CONST_WS_MODULE, "[WSRESPONSE]", message.toString());
    }

    /**
     * *************************************************************
     * Function Name    :   printWSRequest
     * Author			:   Varun Bhansaly
     * Date Written     :   15/10/2007
     * Input Parameters :   Level -> level, Object -> message
     * Output Parameters:   NONE
     * Return Value     :   void
     * Description      :   To print webservice response in wsrequest.xml
     *                      at User-defined Priority.
     * *************************************************************
     */
//    public static void printWSResponse(Level level, Object message) {
//        WFLogger.printWSResponse(level, message);
//    }
//
//     public static void printWSResponse(String inputXML, Level level, Object message) {
//        XMLParser parser = new XMLParser();
//        parser.setInputXML(inputXML);
//        String cabName = parser.getValueOf("EngineName");
//        parser = null;
//        if(cabName == null || cabName.equalsIgnoreCase(""))
//            WFLogger.printWSResponse(level, message);
//        else
//            WFLogger.printWSResponse(level, message, cabName);
//    }

    /**
     * *************************************************************
     * Function Name    :   resolveWSDLPath
     * Author			:   Varun Bhansaly
     * Date Written     :   19/08/2008
     * Input Parameters :   String -> path
     * Output Parameters:   NONE
     * Return Value     :   changed path (if reqd.)
     * Description      :   This method searches & replaces for macro &<BPEL_WSDL_Location>&
     * *************************************************************
     */
    public static String resolveWSDLPath(String path,String cabName) {
        String macro = "&<" + WFSConstant.CONST_BPELCONFIG_LOCATION + ">&";
        String replaceWith = configLocator.getPath(Location.IBPS_CONFIG) + File.separator + WFSConstant.CONST_DIRECTORY_BPELCONFIG;
        path = path.replace('\\', File.separatorChar);
        if (path.startsWith(macro)) {
            printOut(cabName,"resolveWSDLPath Input >> " + path);
            path = path.replace(macro, replaceWith);
        }
        printOut(cabName,"resolveWSDLPath Output >> " + path);
        return path;
    }

    /*	Amul Jain : WFS_6.2_013 : 04/10/2008 */
    /**
     * *************************************************************
     * Function Name    : getSearchActivityForUser
     * Author			: Vikram Kumbhar
     * Date Written     : 19/04/2008
     * Input Parameters : Connection -> con, int -> procDefID, int -> userID
     * Output Parameters: NONE
     * Return Value     : int -> searchActivityID
     * Description      : Finds Query Activity ID on which logged in user has rights. (WFS_6.2_013)
     * *************************************************************
     */
    public static int getSearchActivityForUser(Connection con, int procDefID, int userID, int dbType, boolean isAdmin) throws SQLException {
        int searchActivityID = 0;
        PreparedStatement pstmt = null;
        try {
        	if(!isAdmin){
            pstmt = con.prepareStatement("Select ActivityTable.ActivityId " + " from ActivityTable " + WFSUtil.getTableLockHintStr(dbType) + " , QueueStreamTable " + WFSUtil.getTableLockHintStr(dbType) + "  , QUserGroupView  " + WFSUtil.getTableLockHintStr(dbType) + "  where ActivityTable.ProcessDefId = QueueStreamTable.ProcessDefId " + " AND ActivityTable.ActivityId = QueueStreamTable.ActivityId " + " AND QUserGroupView.QueueId = QueueStreamTable.QueueId " + " AND ActivityTable.ActivityType = ? " + " AND ActivityTable.ProcessDefId = ? " + " AND QUserGroupView.UserId = ? " + " order by ActivityTable.ActivityId asc");
            pstmt.setInt(1, WFSConstant.ACT_QUERY);
            pstmt.setInt(2, procDefID);
            pstmt.setInt(3, userID);
        	}else
        	{
        		pstmt = con.prepareStatement("Select DISTINCT ActivityTable.ActivityId from ActivityTable " + WFSUtil.getTableLockHintStr(dbType) + ", QueueStreamTable " + WFSUtil.getTableLockHintStr(dbType) + " where ActivityTable.ProcessDefId = QueueStreamTable.ProcessDefId  AND ActivityTable.ActivityId = QueueStreamTable.ActivityId  AND ActivityTable.ActivityType = ?  AND ActivityTable.ProcessDefId = ?  order by ActivityTable.ActivityId asc");
                pstmt.setInt(1, WFSConstant.ACT_QUERY);
                pstmt.setInt(2, procDefID);
        	}
            pstmt.execute();

            ResultSet rs = pstmt.getResultSet();

            if (rs != null && rs.next()) {
                searchActivityID = rs.getInt("ActivityId");
            } //Else part removed where primary introduction activity was being fetched, Bugzilla Bug 12075
            if (rs != null) {
                rs.close();
                rs = null;
            }

            pstmt.close();
            pstmt = null;
        } finally {
            try {
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
            } catch (Exception ignored) {
            }

        }
        return searchActivityID;
    }

    /*	Amul Jain : WFS_6.2_013 : 04/10/2008 */
    /**
     * *************************************************************
     * Function Name    : replaceFilterTemplate
     * Author			: Vikram Kumbhar
     * Date Written     : 22/04/2008
     * Input Parameters : Connection -> con, String filterString, int -> userID
     * Output Parameters: NONE
     * Return Value     : String -> Filter with templates replaced
     * Description      : To replace &<USERINDEX>&, &<GROUPINDEX>&,
     *                    &<USERINDEX.ColumnName>&, &<GROUPINDEX.ColumnName>& templates from filter (WFS_6.2_013)
     * *************************************************************
     */
    public static String replaceFilterTemplate(Connection con, String filterString, WFParticipant user) throws SQLException {
        String filter = filterString;
        PreparedStatement pstmt = null;
        int userID = user.getid();

        try {
            String filterUpper = filterString.toUpperCase();
            String resultstr = "";

            // Replace &<UserIndex>& template
            filter = replaceIgnoreCase(filter, "&<USERINDEX>&", String.valueOf(userID));
            filter = replaceIgnoreCase(filter, "&<USERNAME>&", String.valueOf(user.getname()));

            // Replace &<UserIndex.ColumnName>& template
            if (filterUpper.indexOf("&<USERINDEX.") > -1) {
                resultstr = replaceFilterTableValue(con, filter, "&<USERINDEX.", userID, "U");
                if (!resultstr.equals("")) {
                    filter = resultstr;
                }
            }

            if (filterUpper.indexOf("&<GROUPINDEX") > -1) {
                // Find Groups to which this user is associated with
                pstmt = con.prepareStatement("Select GroupIndex From PDBGroupMember Where UserIndex = ?");
                pstmt.setInt(1, userID);
                pstmt.execute();
                ResultSet rs = pstmt.getResultSet();
                ArrayList groupList = new ArrayList();
                while (rs != null && rs.next()) {
                    groupList.add(rs.getString(1));
                }
                pstmt.close();
                pstmt = null;

                // Replace &<GroupIndex>& template
                if (filterUpper.indexOf("&<GROUPINDEX>&") > -1) {
                    StringBuffer tempstr = new StringBuffer();
                    filter = " ( " + filter + " ) ";
                    for (int i = 0; i < groupList.size(); i++) {
                        if (i > 0) {
                            tempstr.append(" OR ");
                        }
                        tempstr.append(replaceIgnoreCase(filter, "&<GROUPINDEX>&", String.valueOf(groupList.get(i))));
                    }
                    filter = tempstr.toString();
                }

                // Replace &<GroupIndex.ColumnName>& template
                if (filterUpper.indexOf("&<GROUPINDEX.") > -1) {
                    StringBuffer tempstr = new StringBuffer();
                    filter = " ( " + filter + " ) ";
                    for (int i = 0, counter = 0; i < groupList.size(); i++) {
                        resultstr = replaceFilterTableValue(con, filter, "&<GROUPINDEX.", Integer.parseInt((String) groupList.get(i)), "G");
                        if (!resultstr.equals("")) {
                            if (counter > 0) {
                                tempstr.append(" OR ");
                            }
                            tempstr.append(resultstr);
                            counter++;
                        }
                    }
                    resultstr = tempstr.toString();
                    if (!resultstr.equals("")) {
                        filter = resultstr;
                    }
                }
            }
        } finally {
            try {
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
            } catch (Exception ignored) {
            }
        }

        return filter;
    }

    /*	Amul Jain : WFS_6.2_013 : 04/10/2008 */
    /**
     * *************************************************************
     * Function Name    : replaceFilterTableValue
     * Author			: Vikram Kumbhar
     * Date Written     : 22/04/2008
     * Input Parameters : Connection -> con, String -> filterString, String -> strToReplace, int -> id, String -> type
     * Output Parameters: NONE
     * Return Value     : String -> Filter with templates replaced
     * Description      : To replace &<USERINDEX.ColumnName>&, &<GROUPINDEX.ColumnName>&
     *                    templates from filter with there corresponding values from FilterTable. (WFS_6.2_013)
     * *************************************************************
     */
    public static String replaceFilterTableValue(Connection con, String filterString, String strToReplace, int id, String type) throws SQLException {
        String filter = "";
        PreparedStatement pstmt = null;

        try {
            StringBuffer selectstr = new StringBuffer();
            ArrayList columnNames = new ArrayList();
            String filterUpper = filterString.toUpperCase();
            strToReplace = strToReplace.toUpperCase();
            int length = strToReplace.length();
            int startIndex = -1;
            int endIndex = -1;
            for (int i = 0; (startIndex = filterUpper.indexOf(strToReplace, startIndex)) != -1; i++) {
                endIndex = filterUpper.indexOf(">&", startIndex);
                String column = filterUpper.substring(startIndex + length, endIndex);
                if (!columnNames.contains(column)) {
                    if (i > 0) {
                        selectstr.append(", ");
                    }
                    columnNames.add(column);
                    selectstr.append(column);
                }
                startIndex = endIndex;
            }

            pstmt = con.prepareStatement("Select " + WFSUtil.TO_SANITIZE_STRING(selectstr.toString(),true) + " From WFFilterTable where ObjectIndex = ? and ObjectType = ?");
            pstmt.setInt(1, id);
            pstmt.setString(2, type);
            pstmt.execute();
            ResultSet rs = pstmt.getResultSet();
            if (rs != null && rs.next()) {
                filter = filterString;
                for (int i = 0; i < columnNames.size(); i++) {
                    String columnValue = rs.getString(i + 1).trim();
                    filter = replaceIgnoreCase(filter, strToReplace + columnNames.get(i).toString() + ">&", columnValue);
                }
            }
            pstmt.close();
            pstmt = null;
        } finally {
            try {
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
            } catch (Exception ignored) {
            }
        }

        return filter;
    }

    /**
     * *************************************************************
     * Function Name    : generateAuthorizationID
     * Author			: Vikram Kumbhar
     * Date Written     : 27/12/2007
     * Input Parameters : char -> entityType, int -> entityID, String -> entityName,
     *					  String ->userName, Connection -> con, int -> dbType
     * Output Parameters: NONE
     * Return Value     : int -> authID
     * Description      : To generate new AuthorizationID
     * *************************************************************
     */
    public static int generateAuthorizationID(char entityType, int entityID, String entityName, String userName, Connection con, int dbType, String engineName) throws JTSException {
        int authID = 0;
        int mainCode = 0;
        String descr = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            switch (dbType) {
                case JTSConstant.JTS_MSSQL:
                    stmt = con.createStatement();
                    stmt.execute("Insert into WFAuthorizationTable(EntityType, EntityID, EntityName, ActionDateTime, MakerUserName, CheckerUserName, Comments, Status)values('" + entityType + "', " + String.valueOf(entityID) + ", " + TO_STRING(entityName, true, dbType) + ", " + getDate(dbType) + ", " + TO_STRING(userName, true, dbType) + ", null, null, 'P')");

                    rs = stmt.executeQuery("select @@IDENTITY");
                    if (rs != null && rs.next()) {
                        authID = rs.getInt(1);
                    }
                    stmt.close();
                    break;

                case JTSConstant.JTS_ORACLE:
                    stmt = con.createStatement();
                    rs = stmt.executeQuery("Select Seq_AuthorizationID.nextVal From Dual");
                    if (rs != null && rs.next()) {
                        authID = rs.getInt(1);
                    }

                    stmt.execute("Insert into WFAuthorizationTable(AuthorizationID, EntityType, EntityID, EntityName, ActionDateTime, MakerUserName, CheckerUserName, Comments, Status)values(" + authID + ", '" + entityType + "', " + String.valueOf(entityID) + ", " + TO_STRING(entityName, true, dbType) + ", " + getDate(dbType) + ", " + TO_STRING(userName, true, dbType) + ", null, null, 'P')");
                    stmt.close();
                    break;
                    //Changes done for Bug 62942 : Handling done for Postgres
                case JTSConstant.JTS_POSTGRES:
                    stmt = con.createStatement();
                    stmt.execute("Insert into WFAuthorizationTable(EntityType, EntityID, EntityName, ActionDateTime, MakerUserName, CheckerUserName, Comments, Status)values('" + entityType + "', " + String.valueOf(entityID) + ", " + TO_STRING(entityName, true, dbType) + ", " + getDate(dbType) + ", " + TO_STRING(userName, true, dbType) + ", null, null, 'P')");

                    rs = stmt.executeQuery("select last_value from WFAuthorizationTable_AuthorizationID_seq");
                    if (rs != null && rs.next()) {
                        authID = rs.getInt(1);
                    }
                    stmt.close();
                    break;     
            }
        } catch (Exception e) {
            printErr(engineName,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            descr = e.getMessage();
        } finally {
            try {
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
            } catch (Exception ignored) {
            }

           

        }
        if (mainCode != 0) {
            throw new JTSException(mainCode, descr);
        }

        if (authID == 0) {
            throw new JTSException(WFSError.WF_OPERATION_FAILED, WFSErrorMsg.getMessage(WFSError.WF_OPERATION_FAILED));
        }
        return authID;
    }

    /*SrNo-16*/
    //----------------------------------------------------------------------------------------------------
    //	Function Name 				:	deleteAllChildrenWIs
    //	Date Written (DD/MM/YYYY)		:	17/12/2008
    //	Author					:	Shilpi S
    //	Input Parameters			:	Connection -> con, String -> engine, int -> procDefId String -> pInstId, int -> workitemId
    //	Output Parameters			:	void
    //	Return Values				:	none
    //	Description				:       For a given workitem deletes all its children workitems
    //----------------------------------------------------------------------------------------------------
    //  Change Description          : Changes for Code Optimization-Merging of WorkFlow 
    //								  tables to WFInstrumentTable and logging of Query
    //  Changed by					: Mohnish Chopra  
    public static void deleteAllChildrenWIs(Connection con, String engine, int procDefId, String pInstId, int workitemId) throws SQLException, JTSException {
    	deleteAllChildrenWIs(con, engine, procDefId, pInstId, workitemId,0,0,false);
    	  	
    }
    //  Change Description          : Changes for Code Optimization-Merging of WorkFlow 
    //								  tables to WFInstrumentTable and logging of Query
    //  Changed by					: Mohnish Chopra     
    public static void deleteAllChildrenWIs(Connection con, String engine, int procDefId, String pInstId, int workitemId,int sessionId,int userId, boolean loggingFlag) throws SQLException, JTSException {
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        int error = 0;
        String errorMsg = "";
        ArrayList parameters = new ArrayList();
        try {
            int dbType = ServerProperty.getReference().getDBType(engine);
            String query ="";
            String query1="";
            if(dbType==JTSConstant.JTS_MSSQL){
            query1 = "Delete a from WFTaskStatusTable a inner join WFInstrumentTable b on a.processInstanceId=b.ProcessInstanceId and a.workitemid=b.workitemid and a.processdefid=b.processdefid where b.processInstanceId= ? And b.ParentWorkitemId = ? and b.ActivityType=32" ;
            }
            else if(dbType==JTSConstant.JTS_ORACLE){
                query1 = "Delete  from WFTaskStatusTable where (processInstanceId, workitemid, processdefid ) in (select ProcessInstanceId, workitemid, processdefid from WFInstrumentTable b where b.processInstanceId= ? And b.ParentWorkitemId = ? and b.ActivityType=32 )" ;
                }
            else if(dbType==JTSConstant.JTS_POSTGRES){
                query1 = "Delete  from WFTaskStatusTable a using WFInstrumentTable b where a.processInstanceId=b.ProcessInstanceId and a.workitemid=b.workitemid and a.processdefid=b.processdefid and b.processInstanceId= ? And b.ParentWorkitemId = ? and b.ActivityType=32" ;
                }
            pstmt = con.prepareStatement(query1);
            WFSUtil.DB_SetString(1, pInstId, pstmt, dbType);
            pstmt.setInt(2, workitemId);
            parameters.add(pInstId);
            parameters.add(workitemId);
            jdbcExecute(pInstId, sessionId, userId, query1, pstmt, parameters, loggingFlag, engine);
            parameters.clear();
            pstmt.clearBatch();
            
			if(workitemId==1){
				  
				  query = "Delete from WFEscalationTable where ProcessInstanceId = ? And WorkitemId >= ?";
				  pstmt = con.prepareStatement(query);
                  WFSUtil.DB_SetString(1, pInstId, pstmt, dbType);
                  pstmt.setInt(2, workitemId);
                  parameters.add(pInstId);
                  parameters.add(workitemId);
                  jdbcExecute(pInstId, sessionId, userId, query, pstmt, parameters, loggingFlag, engine);
                  parameters.clear();
                  if (pstmt != null) {
                  	pstmt.close();
                  	pstmt = null;
                  }
                  
                  query = "Delete from WFEscInProcessTable where ProcessInstanceId = ? And WorkitemId >= ?";
				  pstmt = con.prepareStatement(query);
                  WFSUtil.DB_SetString(1, pInstId, pstmt, dbType);
                  pstmt.setInt(2, workitemId);
                  parameters.add(pInstId);
                  parameters.add(workitemId);
                  jdbcExecute(pInstId, sessionId, userId, query, pstmt, parameters, loggingFlag, engine);
                  parameters.clear();
                  if (pstmt != null) {
                  	pstmt.close();
                  	pstmt = null;
                  }
                  
            	  query = "Delete From WFInstrumentTable Where ProcessInstanceId = ? And WorkitemId > ?" ;
                  pstmt = con.prepareStatement(query);
                  WFSUtil.DB_SetString(1, pInstId, pstmt, dbType);
                  pstmt.setInt(2, workitemId);
                  parameters.add(pInstId);
                  parameters.add(workitemId);
                  jdbcExecute(pInstId, sessionId, userId, query, pstmt, parameters, loggingFlag, engine);
                  parameters.clear();
            }
            else{
            
            query = "Delete from WFEscalationTable where ProcessInstanceId = ? and WorkitemId in (Select WorkitemId from WFInstrumentTable" +WFSUtil.getTableLockHintStr(dbType) +" where ProcessInstanceId = ? and (ParentWorkitemId = ? or WorkitemId =?))";
            pstmt = con.prepareStatement(query);
            WFSUtil.DB_SetString(1, pInstId, pstmt, dbType);
            WFSUtil.DB_SetString(2, pInstId, pstmt, dbType);
            pstmt.setInt(3, workitemId);
            pstmt.setInt(4, workitemId);
            parameters.add(pInstId);
            parameters.add(workitemId);
            jdbcExecute(pInstId, sessionId, userId, query, pstmt, parameters, loggingFlag, engine);
            parameters.clear();
            if (pstmt != null) {
              	pstmt.close();
              	pstmt = null;
             }
            
            query = "Delete from WFEscInProcessTable where ProcessInstanceId = ? and WorkitemId in (Select WorkitemId from WFInstrumentTable" +WFSUtil.getTableLockHintStr(dbType) +" where ProcessInstanceId = ? and (ParentWorkitemId = ? or WorkitemId =?))";
            pstmt = con.prepareStatement(query);
            WFSUtil.DB_SetString(1, pInstId, pstmt, dbType);
            WFSUtil.DB_SetString(2, pInstId, pstmt, dbType);
            pstmt.setInt(3, workitemId);
            pstmt.setInt(4, workitemId);
            parameters.add(pInstId);
            parameters.add(workitemId);
            jdbcExecute(pInstId, sessionId, userId, query, pstmt, parameters, loggingFlag, engine);
            parameters.clear();
            if (pstmt != null) {
              	pstmt.close();
              	pstmt = null;
            }
            
            query = "Delete From WFInstrumentTable Where ProcessInstanceId = ? And ParentWorkitemId = ?" ;
            pstmt = con.prepareStatement(query);
            WFSUtil.DB_SetString(1, pInstId, pstmt, dbType);
            pstmt.setInt(2, workitemId);
            parameters.add(pInstId);
            parameters.add(workitemId);
            jdbcExecute(pInstId, sessionId, userId, query, pstmt, parameters, loggingFlag, engine);
            parameters.clear();
            }
            
         /*   stmt.addBatch("Delete From QueueDataTable Where ProcessInstanceId = " + WFSUtil.TO_STRING(pInstId, true, dbType) + " And ParentWorkitemId = " + workitemId);
            stmt.addBatch("Delete From WorkListTable Where  ProcessInstanceId = " + WFSUtil.TO_STRING(pInstId, true, dbType) + " And ParentWorkitemId = " + workitemId);
            stmt.addBatch("Delete From WorkInProcessTable Where  ProcessInstanceId = " + WFSUtil.TO_STRING(pInstId, true, dbType) + " And ParentWorkitemId = " + workitemId);
            stmt.addBatch("Delete From WorkWithPSTable Where  ProcessInstanceId = " + WFSUtil.TO_STRING(pInstId, true, dbType) + " And ParentWorkitemId = " + workitemId);
            stmt.addBatch("Delete From WorkDoneTable Where  ProcessInstanceId = " + WFSUtil.TO_STRING(pInstId, true, dbType) + " And ParentWorkitemId = " + workitemId);
            stmt.addBatch("Delete From PendingWorkListTable Where ProcessInstanceId = " + WFSUtil.TO_STRING(pInstId, true, dbType) + " And ParentWorkitemId = " + workitemId);*/
/*            stmt.executeBatch();*/
        } catch (Exception e) {
            WFSUtil.printErr(engine,"", e);
            error = WFSError.WFS_SYS;
            errorMsg = e.toString();
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (pstmt != null) {
                	pstmt.close();
                	pstmt = null;
                }
            } catch (Exception ignored) {
            }
        }
        if (error != 0) {
            throw new JTSException(error, errorMsg);
        }
    }

    /**
     * *******************************************************************************
     *      Function Name       : getQueueForActivity
     *      Date Written        : 19/12/2008
     *      Author              : Ruhi Hira
     *      Input Parameters    : Connection con, int dbType, int processDefId,
     *                              int activityId, int streamId.
     *      Output Parameters   : NONE
     *      Return Values       : String[] {queueId, queueName, queueType, filterString, streamId}
     *      Description         : to get the queue details associated with an activity.
     * *******************************************************************************
     */
    public static String[] getQueueForActivity(Connection con, int dbType, int processDefId, int activityId, int streamId, String engineName) {
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        String queueId = null;
        String queueName = null;
        String queueType = null;
        String filterString = null;
        String streamIdStr = null;
        StringBuffer strBuff = new StringBuffer(100);
        try {
            if (streamId <= 0) {
                strBuff.append(" SELECT a.QueueName as queueName, a.QueueType as queueType, a.QueueId as queueId, ");
                strBuff.append(" a.FILTERVALUE as filterValue, b.StreamId as streamId ");
                strBuff.append(" FROM QUEUEDEFTABLE a " + WFSUtil.getTableLockHintStr(dbType) + "  , QUEUESTREAMTABLE b " + WFSUtil.getTableLockHintStr(dbType) + "  WHERE a.QueueID =  b.QueueID ");
                strBuff.append(" AND b.streamId = (SELECT streamId FROM STREAMDEFTABLE " + WFSUtil.getTableLockHintStr(dbType) + " WHERE processDefId = ? ");
                strBuff.append(" AND ActivityId = ? AND ");
                strBuff.append(WFSUtil.TO_STRING("StreamName", false, dbType));
                strBuff.append(" = ");
                strBuff.append(WFSUtil.TO_STRING("DEFAULT", true, dbType));
                strBuff.append(" ) AND b.ProcessDefID = ? AND b.ActivityID = ? ");
                pstmt = con.prepareStatement(strBuff.toString());
                pstmt.setInt(1, processDefId);
                pstmt.setInt(2, activityId);
                pstmt.setInt(3, processDefId);
                pstmt.setInt(4, activityId);
            } else {
                strBuff.append(" SELECT a.QueueName as queueName, a.QueueType as queueType, a.QueueId as queueId, ");
                strBuff.append(" a.FILTERVALUE as filterValue, b.StreamId as streamId ");
                strBuff.append(" FROM QUEUEDEFTABLE a " + WFSUtil.getTableLockHintStr(dbType) + "  , QUEUESTREAMTABLE b " + WFSUtil.getTableLockHintStr(dbType) + "  WHERE a.QueueID =  b.QueueID ");
                strBuff.append(" AND b.streamId = ? AND b.ProcessDefID = ? AND b.ActivityID = ? ");
                pstmt = con.prepareStatement(strBuff.toString());
                pstmt.setInt(1, processDefId);
                pstmt.setInt(2, activityId);
                pstmt.setInt(3, streamId);
                pstmt.setInt(4, processDefId);
                pstmt.setInt(5, activityId);
            }
            rs = pstmt.executeQuery();
            if (rs != null && rs.next()) {
                queueName = rs.getString("queueName");
                queueType = rs.getString("queueType");
                queueId = rs.getString("queueId");
                filterString = rs.getString("filterValue");
                streamIdStr = rs.getString("StreamId");
            }
            if (rs != null) {
                rs.close();
                rs = null;
            }
            if (pstmt != null) {
                pstmt.close();
                pstmt = null;
            }
        } catch (Exception ex) {
            printErr(engineName, ex);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
            } catch (Exception ignored) {
            }
        }
        return new String[]{queueId, queueName, queueType, filterString, streamIdStr};
    }
	

    /*SrNo-16*/
    //----------------------------------------------------------------------------------------------------
    //	Function Name 				:	searchAndLockWorkitem
    //	Date Written (DD/MM/YYYY)		:	17/12/2008
    //	Author					:	Shilpi S
    //	Input Parameters			:	Connection -> con, String -> engine, String -> pInstId, int -> workitemId
    //	Output Parameters			:	String
    //	Return Values				:	tableName in which this workitem is found
    //	Description				:       searches workitem in tables and returns the tableName where it is found
    //----------------------------------------------------------------------------------------------------
    /*public static String searchAndLockWorkitem(Connection con, String engine, String pInstId, int workitemId, int sessionId, int userId, boolean debug) throws SQLException, JTSException {
        Statement stmt = null;
        ResultSet rs = null;
        int error = 0;
        String errorMsg = "";
        String tableName = "";
        try {

            stmt = con.createStatement();
            int dbType = ServerProperty.getReference().getDBType(engine);
            rs = stmt.executeQuery("Select ProcessInstanceId, WorkitemId From WorkListTable " + WFSUtil.getLockPrefixStr(dbType) + " Where ProcessInstanceId = " + WFSUtil.TO_STRING(pInstId, true, dbType) + " And WorkItemId  = " + workitemId + WFSUtil.getLockSuffixStr(dbType));
            if (rs != null && rs.next()) {
                tableName = " WorkListTable ";
                rs.close();
                rs = null;
            } else {
                rs = stmt.executeQuery("Select ProcessInstanceId, WorkitemId From WorkInProcessTable " + WFSUtil.getLockPrefixStr(dbType) + " Where ProcessInstanceId = " + WFSUtil.TO_STRING(pInstId, true, dbType) + " And WorkItemId  = " + workitemId + WFSUtil.getLockSuffixStr(dbType));
                if (rs != null && rs.next()) {
                    tableName = " WorkInProcessTable ";
                    rs.close();
                    rs = null;
                } else {
                    rs = stmt.executeQuery("Select ProcessInstanceId, WorkitemId From WorkDoneTable " + WFSUtil.getLockPrefixStr(dbType) + " Where ProcessInstanceId = " + WFSUtil.TO_STRING(pInstId, true, dbType) + " And WorkItemId  = " + workitemId + WFSUtil.getLockSuffixStr(dbType));
                    if (rs != null && rs.next()) {
                        tableName = " WorkDoneTable ";
                        rs.close();
                        rs = null;
                    } else {
                        rs = stmt.executeQuery("Select ProcessInstanceId, WorkitemId From WorkWithPSTable " + WFSUtil.getLockPrefixStr(dbType) + " Where ProcessInstanceId = " + WFSUtil.TO_STRING(pInstId, true, dbType) + " And WorkItemId  = " + workitemId + WFSUtil.getLockSuffixStr(dbType));
                        if (rs != null && rs.next()) {
                            tableName = " WorkWithPSTable ";
                            rs.close();
                            rs = null;

                        } else {
                            rs = stmt.executeQuery("Select ProcessInstanceId, WorkitemId From PendingWorkListTable " + WFSUtil.getLockPrefixStr(dbType) + " Where ProcessInstanceId = " + WFSUtil.TO_STRING(pInstId, true, dbType) + " And WorkItemId  = " + workitemId + WFSUtil.getLockSuffixStr(dbType));
                            if (rs != null && rs.next()) {
                                tableName = " PendingWorkListTable ";
                                rs.close();
                                rs = null;
                            } else {
                                error = WFSError.WM_INVALID_WORKITEM;
                                errorMsg = WFSErrorMsg.getMessage(error);
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            WFSUtil.printErr(engine,"", e);
            error = WFSError.WFS_SYS;
            errorMsg = e.toString();
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
            } catch (Exception ignored) {
            }
        }
        if (error != 0) {
            throw new JTSException(error, errorMsg);
        }
        return tableName;
    }*/
	
	public static String searchAndLockWorkitem(Connection con, String engine, String pInstId, int workitemId) throws SQLException, JTSException {
        
        return searchAndLockWorkitem(con, engine, pInstId, workitemId, 0, 0, false);
    }
	
	//======================================
	
	public static String searchAndLockWorkitem(Connection con, String engine, String pInstId, int workitemId, int sessionID, int userId, boolean debug) throws SQLException, JTSException {
        Statement stmt = null;
        ResultSet rs = null;
        int error = 0;
        String errorMsg = "";
        String tableName = "";
        try {

            stmt = con.createStatement();
            int dbType = ServerProperty.getReference().getDBType(engine);
			String qStr = "Select ProcessInstanceId, WorkitemId From WFInstrumentTable " + WFSUtil.getLockPrefixStr(dbType) + " Where ProcessInstanceId = " + WFSUtil.TO_STRING(pInstId, true, dbType) + " And WorkItemId  = " + workitemId + WFSUtil.getLockSuffixStr(dbType);			
            //rs = stmt.executeQuery();
			rs = WFSUtil.jdbcExecuteQuery(pInstId, sessionID, userId, qStr, stmt, null, debug, engine);
            if (rs != null && rs.next()) {
                tableName = " WFInstrumentTable ";
                rs.close();
                rs = null;
            } 
        } catch (Exception e) {
            WFSUtil.printErr(engine,"", e);
            error = WFSError.WFS_SYS;
            errorMsg = e.toString();
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
            } catch (Exception ignored) {
            }
        }
        if (error != 0) {
            throw new JTSException(error, errorMsg);
        }
        return tableName;
    }
	
//----------------------------------------------------------------------------------------------------
    //	Function Name 				:	copyworkitem
    //	Date Written (DD/MM/YYYY)		:	17/12/2008
    //	Author					:	Shilpi S
    //	Input Parameters			:	Connection -> con, String -> engine, int- > procDefId, String -> pInstId, int -> workitemId
    //	Output Parameters			:	String
    //	Return Values				:	tableName in which this workitem is found
    //	Description				:       searches workitem in tables and returns the tableName where it is found
    //----------------------------------------------------------------------------------------------------
    //  Change Description          : Changes for Code Optimization-Merging of WorkFlow 
    //								  tables to WFInstrumentTable and logging of Query
    //  Changed by					: Mohnish Chopra  

    public static void copyWorkitem(Connection con, String engine, int dbType, int procDefId, String pInstId, int parentWorkitemId, int eventActivityId, String eventActivityName, boolean syncRouting) throws JTSException, SQLException {
    	copyWorkitem(con, engine, dbType, procDefId, pInstId, parentWorkitemId, eventActivityId, eventActivityName, syncRouting,0,0,false);
    }
    
    //  Change Description          : Changes for Code Optimization-Merging of WorkFlow 
    //								  tables to WFInstrumentTable and logging of Query
    //  Changed by					: Mohnish Chopra  
    public static void copyWorkitem(Connection con, String engine, int dbType, int procDefId, String pInstId, int parentWorkitemId, int eventActivityId, String eventActivityName, boolean syncRouting,int sessionId,int userId,boolean loggingFlag) throws JTSException, SQLException {
        WFSUtil.printOut(engine,"[WFSUtil] copyWorkitem()..");
        Statement stmt = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        int error = 0;
        String errorMsg = "";
        int nWorkitemId = 0;
        String query= null;
        boolean commitFlag = false;
        ArrayList parameters = new ArrayList();
        try {
            if (con.getAutoCommit()) {
                con.setAutoCommit(false);
                commitFlag = true;
            }
            stmt = con.createStatement();
            /*where is the workitem in consideration , whether it is workwithps table or workinprocesstable*/
            /* insert into queuedatatable  select * from .... , just change workitem id to workitemId in input
             * insert into worklisttable
            what about external variables etc..??*/
/*            String tableName = " WorkWithPSTable ";
            if (syncRouting) {
                tableName = " WorkInProcessTable ";
            }*/

            rs = stmt.executeQuery(" SELECT a.QueueName as queueName, a.QueueType as queueType, a.QueueId as queueId, a.FILTERVALUE as filterValue, " +
            		"b.StreamId as streamId" +
                    " FROM QUEUEDEFTABLE a " + WFSUtil.getTableLockHintStr(dbType) + "  , QUEUESTREAMTABLE b " + WFSUtil.getTableLockHintStr(dbType) + "  WHERE a.QueueID =  b.QueueID " +
                    " AND b.streamId = (SELECT streamId FROM STREAMDEFTABLE WHERE processDefId =  " + procDefId +
                    " AND ActivityId = " + eventActivityId + " AND " + WFSUtil.TO_STRING("StreamName", false, dbType) + 
                    " = " + WFSUtil.TO_STRING("DEFAULT", true, dbType) + " ) AND b.ProcessDefID =  " + procDefId +
                    " AND b.ActivityID = " + eventActivityId);

            if (rs != null && rs.next()) {
                String eventWIQueueName = rs.getString("QueueName");
                String eventWIQueueType = rs.getString("QueueType");
                int eventWIQueueId = rs.getInt("QueueId");
                String eventWIFilterValue = rs.getString("FilterValue");

                int eventWIStreamId = rs.getInt("StreamId");
                rs.close();
                rs = null;
                query="SELECT MAX(WorkItemID)+1 FROM WFInstrumentTable  WHERE " +
        		"ProcessInstanceid = ? ";
                pstmt = con.prepareStatement(query);
                WFSUtil.DB_SetString(1, pInstId, pstmt, dbType);
                parameters.add(pInstId);
                rs= WFSUtil.jdbcExecuteQuery(pInstId, sessionId, userId, query, pstmt, parameters, loggingFlag, engine);
/*                rs = stmt.executeQuery("SELECT MAX(WorkItemID)+1 FROM queuedatatable  WHERE " +
                		"ProcessInstanceid = " + WFSUtil.TO_STRING(pInstId, true, dbType));*/
                if (rs != null && rs.next()) {
                    nWorkitemId = rs.getInt(1);
                    rs.close();
                    rs = null;

                    /*should i get these targetActvName and targetActvId in input parameters or get them here*/
                  /*  int res1 = stmt.executeUpdate("Insert into WorkListTable (ProcessInstanceId,WorkItemId,ProcessName,ProcessVersion,ProcessDefID," 
                    		+ "LastProcessedBy,ProcessedBy,ActivityName,ActivityId,EntryDateTime,ParentWorkItemId," + "AssignmentType,CollectFlag," +
                    				"PriorityLevel,Q_StreamId,Q_QueueId," + "CreatedDateTime,WorkItemState,PreviousStage," 
                    				+ "LockStatus, QueueName, QueueType, FilterValue, ProcessVariantId )" +
                    				" Select " + "ProcessInstanceId," + nWorkitemId + ",ProcessName,ProcessVersion,ProcessDefID,LastProcessedBy, " 
                    				+ "ProcessedBy, " + WFSUtil.TO_STRING(eventActivityName, true, dbType) + " , " + eventActivityId + " , " 
                    				+ WFSUtil.getDate(dbType) + " , " + parentWorkitemId + " , " + WFSUtil.TO_STRING("S", true, dbType) 
                    				+ " ,CollectFlag,PriorityLevel, " + eventWIStreamId + ", " + eventWIQueueId + ", " 
                    				+ "CreatedDateTime,WorkItemState,PreviousStage,'N'" + " , " + WFSUtil.TO_STRING(eventWIQueueName, true, dbType) 
                    				+ " , " + WFSUtil.TO_STRING(eventWIQueueType, true, dbType) + " , " 
                    				+ WFSUtil.TO_STRING(eventWIFilterValue, true, dbType) + ", ProcessVariantId from " 
                    				+ tableName + " where ProcessInstanceID = " + WFSUtil.TO_STRING(pInstId, true, dbType) 
                    				+ " and WorkItemID = " + parentWorkitemId);

                    int res2 = stmt.executeUpdate("Insert into QueueDataTable ( PROCESSINSTANCEID, WORKITEMID, VAR_INT1, VAR_INT2, VAR_INT3, " 
                    		+ "VAR_INT4, VAR_INT5, VAR_INT6, VAR_INT7, VAR_INT8, VAR_FLOAT1, VAR_FLOAT2, VAR_DATE1, " 
                    		+ "VAR_DATE2, VAR_DATE3, VAR_DATE4, VAR_LONG1, VAR_LONG2, VAR_LONG3, VAR_LONG4, VAR_STR1, " 
                    		+ "VAR_STR2, VAR_STR3, VAR_STR4, VAR_STR5, VAR_STR6, VAR_STR7, VAR_STR8, VAR_REC_1, VAR_REC_2," 
                    		+ "VAR_REC_3, VAR_REC_4, VAR_REC_5, INSTRUMENTSTATUS, CHECKLISTCOMPLETEFLAG, SAVESTAGE, " 
                    		+ "HOLDSTATUS, STATUS, REFERREDTO, REFERREDTONAME, REFERREDBY, REFERREDBYNAME, " 
                    		+ "CHILDPROCESSINSTANCEID, CHILDWORKITEMID, PARENTWORKITEMID) Select " + "PROCESSINSTANCEID, " 
                    		+ nWorkitemId + ", VAR_INT1, VAR_INT2, VAR_INT3, " + "VAR_INT4, VAR_INT5, VAR_INT6, VAR_INT7, VAR_INT8, VAR_FLOAT1, " +
                    		"VAR_FLOAT2, VAR_DATE1, " + "VAR_DATE2, VAR_DATE3, VAR_DATE4, VAR_LONG1, VAR_LONG2, VAR_LONG3, VAR_LONG4, VAR_STR1, " 
                    		+ "VAR_STR2, VAR_STR3, VAR_STR4, VAR_STR5, VAR_STR6, VAR_STR7, VAR_STR8, VAR_REC_1, VAR_REC_2," + "VAR_REC_3, VAR_REC_4," +
                    		" VAR_REC_5, INSTRUMENTSTATUS, CHECKLISTCOMPLETEFLAG, SAVESTAGE, " + "HOLDSTATUS, STATUS, REFERREDTO, REFERREDTONAME, REFERREDBY, REFERREDBYNAME, " + "CHILDPROCESSINSTANCEID, CHILDWORKITEMID, " + parentWorkitemId + " from QueueDataTable where ProcessInstanceID = " + WFSUtil.TO_STRING(pInstId, true, dbType) + " and WorkItemID=" + parentWorkitemId);*/
                    
                    query = "Insert into WFInstrumentTable (ProcessInstanceId,WorkItemId,"
                           + " VAR_INT1, VAR_INT2, VAR_INT3, VAR_INT4, VAR_INT5, VAR_INT6, VAR_INT7,"
+ "VAR_INT8,VAR_FLOAT1, VAR_FLOAT2, VAR_DATE1, VAR_DATE2, VAR_DATE3, VAR_DATE4,VAR_DATE5, VAR_DATE6, VAR_LONG1, VAR_LONG2, VAR_LONG3, VAR_LONG4,VAR_LONG5, VAR_LONG6, VAR_STR1, VAR_STR2, VAR_STR3, VAR_STR4, "
+ "VAR_STR5, VAR_STR6, VAR_STR7, VAR_STR8,VAR_STR9, VAR_STR10, VAR_STR11, VAR_STR12, VAR_STR13, VAR_STR14, VAR_STR15, VAR_STR16, VAR_STR17, VAR_STR18, VAR_STR19, VAR_STR20, VAR_REC_1, VAR_REC_2,VAR_REC_3, VAR_REC_4, VAR_REC_5,"
                            + "		INSTRUMENTSTATUS, CHECKLISTCOMPLETEFLAG, SAVESTAGE, HOLDSTATUS, STATUS, REFERREDTO, REFERREDTONAME, REFERREDBY, REFERREDBYNAME,CHILDPROCESSINSTANCEID, CHILDWORKITEMID,ProcessName,ProcessVersion,ProcessDefID," 
                		+ "LastProcessedBy,ProcessedBy,ActivityName,ActivityId,EntryDateTime,ParentWorkItemId," + "AssignmentType,CollectFlag," +
                		"PriorityLevel,Q_StreamId,Q_QueueId," + "CreatedDateTime,WorkItemState,PreviousStage," 
                		+ "LockStatus,RoutingStatus QueueName, QueueType, FilterValue, ProcessVariantId )" +
                		" Select " + "ProcessInstanceId," + nWorkitemId + ","
                         + " VAR_INT1, VAR_INT2, VAR_INT3, VAR_INT4, VAR_INT5, VAR_INT6, VAR_INT7,"
+ "VAR_INT8,VAR_FLOAT1, VAR_FLOAT2, VAR_DATE1, VAR_DATE2, VAR_DATE3, VAR_DATE4,VAR_DATE5, VAR_DATE6, VAR_LONG1, VAR_LONG2, VAR_LONG3, VAR_LONG4,VAR_LONG5, VAR_LONG6, VAR_STR1, VAR_STR2, VAR_STR3, VAR_STR4, "
+ "VAR_STR5, VAR_STR6, VAR_STR7, VAR_STR8,VAR_STR9, VAR_STR10, VAR_STR11, VAR_STR12, VAR_STR13, VAR_STR14, VAR_STR15, VAR_STR16, VAR_STR17, VAR_STR18, VAR_STR19, VAR_STR20, VAR_REC_1, VAR_REC_2,VAR_REC_3, VAR_REC_4, VAR_REC_5,"
                            + "INSTRUMENTSTATUS, CHECKLISTCOMPLETEFLAG, SAVESTAGE, HOLDSTATUS, STATUS, REFERREDTO, REFERREDTONAME, REFERREDBY, REFERREDBYNAME,CHILDPROCESSINSTANCEID, CHILDWORKITEMID,ProcessName,ProcessVersion,ProcessDefID,LastProcessedBy, " 
                		+ "ProcessedBy, " + WFSUtil.TO_STRING(eventActivityName, true, dbType) + " , " + eventActivityId + " , " 
                		+ WFSUtil.getDate(dbType) + " , " + parentWorkitemId + " , " + WFSUtil.TO_STRING("S", true, dbType) 
                		+ " ,CollectFlag,PriorityLevel, " + eventWIStreamId + ", " + eventWIQueueId + ", " 
                		+ "CreatedDateTime,WorkItemState,PreviousStage,'N'" + " , " + "'N'" + " , " + WFSUtil.TO_STRING(eventWIQueueName, true, dbType) 
                		+ " , " + WFSUtil.TO_STRING(eventWIQueueType, true, dbType) + " , " 
                		+ WFSUtil.TO_STRING(eventWIFilterValue, true, dbType) + ", ProcessVariantId from WFInstrumentTable" +
                		" where ProcessInstanceID = " + WFSUtil.TO_STRING(pInstId, true, dbType) 
                		+ " and WorkItemID = " + parentWorkitemId +" and LockStatus = 'Y'"; 
                   stmt.close();
                    stmt=con.createStatement();
                    int res1= WFSUtil.jdbcExecuteUpdate(pInstId, sessionId, userId, query, stmt, null, loggingFlag, engine);
                    if (!(res1 > 0/* && res1 == res2*/)) {
                        error = WFSError.WM_INVALID_WORKITEM;
                        errorMsg = WFSErrorMsg.getMessage(error);
                        throw new JTSException(error, errorMsg);
                    } else {
                        error = WFSError.WM_INVALID_WORKITEM;
                        errorMsg = WFSErrorMsg.getMessage(error);
                    }
                } else {
                    error = WFSError.WM_INVALID_WORKITEM;
                    errorMsg = WFSErrorMsg.getMessage(error);
                    if(stmt!=null){
                    stmt.close();
                    }
                }
            } else {
                error = WFSError.WM_INVALID_WORKITEM;
                errorMsg = WFSErrorMsg.getMessage(error);
                stmt.close();
            }
            if (error == 0) {
                if (commitFlag && !con.getAutoCommit()) {
                    con.commit();
                    con.setAutoCommit(true);
                    commitFlag = false;
                }
            /* we dont have to move main workitem in pendingworklistable as its parallel processing , no halting of main route should be there
            - shilpi*/
            }
            
        } catch (JTSException jtsException) {
            WFSUtil.printErr(engine,"", jtsException);
            error = WFSError.WM_INVALID_WORKITEM;
            errorMsg = WFSErrorMsg.getMessage(error);
        } catch (SQLException sqlException) {
            WFSUtil.printErr(engine,"", sqlException);
            error = WFSError.WFS_SQL;
            errorMsg = WFSErrorMsg.getMessage(error);
        } catch (Exception e) {
            WFSUtil.printErr(engine,"", e);
            error = WFSError.WFS_SYS;
            errorMsg = e.toString();
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (commitFlag && !con.getAutoCommit()) {
                    con.rollback();
                    con.setAutoCommit(true);
                }
            } catch (Exception exp) {
            }
        }
        if (error != 0) {
            throw new JTSException(error, errorMsg);
        }
    }
    //----------------------------------------------------------------------------------------------------
    //	Function Name 				:	getTimeZoneInfo
    //	Date Written (DD/MM/YYYY)	:	27/07/2009
    //	Author						:	Saurabh Kamal
    //	Input Parameters			:	Connection -> con,
    //	Output Parameters			:	String
    //	Return Values				:
    //	Description					:   WFS_8.0_019 , Provision of TimeZone
    //----------------------------------------------------------------------------------------------------

	/*
	 * Changed by : Saurabh Kamal
	 * Changed Date : 29/08/2009
	 * Description : Provision of TimeZone in Oracle Database
	 */
    public static String getTimeZoneInfo(Connection con,int dbType, XMLParser parser) {
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        String timeZoneInfo = null;
        String engine = parser.getValueOf("EngineName");
        try {
			if(dbType == JTSConstant.JTS_MSSQL){
				pstmt = con.prepareStatement("select datediff(mi,getutcdate(),getdate())");
			} else if(dbType == JTSConstant.JTS_ORACLE){
				pstmt = con.prepareStatement("SELECT TO_CHAR(systimestamp, 'TZH:TZM') AS TimeZone FROM dual");
			} else if(dbType == JTSConstant.JTS_POSTGRES){
                pstmt = con.prepareStatement("SELECT TO_CHAR(extract('timezone_hour' from now()),'S00')||':'|| to_char(extract('timezone_minute' from now()),'FM00')");
            }			
            pstmt.execute();
            rs = pstmt.getResultSet();
            if (rs.next()) {
                timeZoneInfo = rs.getString(1);
            }
            pstmt.close();
			if(dbType == JTSConstant.JTS_ORACLE || dbType == JTSConstant.JTS_POSTGRES){
				timeZoneInfo = String.valueOf(hourToMinute(timeZoneInfo));
			}
        } catch (Exception ex) {
			WFSUtil.printErr(engine,"", ex);
        } finally{
			try {
				if(rs!=null){
					rs.close();
					rs=null;
				}
				
			} catch (SQLException sqlex) {
				WFSUtil.printErr(engine,"", sqlex);
			}
			try{
				if(pstmt!=null){
					pstmt.close();
					pstmt = null;
				}
			}catch (Exception sqlex) {
				WFSUtil.printErr(engine,"", sqlex);
			}
		}

        return timeZoneInfo;
    }

    //----------------------------------------------------------------------------------------------------
    //	Function Name 				:	checkSAPLicense
    //	Date Written (DD/MM/YYYY)	:	20/08/2009
    //	Author						:	Minakshi Sharma
    //	Input Parameters			:	None
    //	Output Parameters			:	boolean
    //	Return Values				:	True or False
    //	Description					:   Check whether SAP License key is correct or not.
    //----------------------------------------------------------------------------------------------------
    public static boolean checkSAPLicense(XMLParser parser) { //SrNo-17

        boolean isSAPLicenseExists = false;
        BufferedReader input = null;
        String engine = parser.getValueOf("EngineName");
        try {
            File file = new File(configLocator.getPath(Location.IBPS_CONFIG) + File.separator + WFSConstant.CONST_DIRECTORY_CONFIG + File.separator + WFSConstant.CONST_FILE_SAPLICENSE);
            if (file.exists()) {
                String licenseKey = "OFSAPADDON-10-09302009-OFADAP-DE21ADE30AGUIA";
                String line = null;
                input = new BufferedReader(new FileReader(file));
                line = input.readLine();
                if (line!=null) {
                    String decodedKey = JTSSecurity.decode(new String((EncodeImage.decodeImageData(line)), "UTF-8"), "UTF-8");
                    if (licenseKey.equalsIgnoreCase(decodedKey)) {
                        isSAPLicenseExists = true;
                    }
                }
                input.close();
            }
        }catch  (Exception ex) {
            WFSUtil.printErr(engine,"", ex);
        } finally {
            try {
                if (input != null) {
                    input.close();
                    input = null;
                }
            } catch (Exception ignored) {
            }
        }

        return isSAPLicenseExists;
    }
		//----------------------------------------------------------------------------------------------------
    //	Function Name 				:	hourToMinute
    //	Date Written (DD/MM/YYYY)	:	29/08/2009
    //	Author						:	Saurabh Kamal
    //	Input Parameters			:	String
    //	Output Parameters			:	int
    //	Return Values				:
    //	Description					:   method for hours to minutes conversion

    //----------------------------------------------------------------------------------------------------

	private static int hourToMinute(String str){
		int minute = 0;
		String hr = str.substring(1, str.indexOf(":"));
		minute = Integer.parseInt(hr)*60+Integer.parseInt(str.substring(str.indexOf(":")+1));
		if(str.charAt(0) == '-'){
			minute = minute*-1;
		}
		return minute;
	}
	//----------------------------------------------------------------------------------------------------
    //	Function Name 				:	getCalendarInfo
    //	Date Written (DD/MM/YYYY)	:	31/08/2009
    //	Author						:	Shilpi Srivastava
    //	Input Parameters			:	Connection -> con, String engineName, int-> procDefID,
    //									int -> activityId, String -> calendarName
    //	Output Parameters			:	WFCalAssocData
    //	Return Values				:	Calendar Data for given calendarname or activityid
    //	Description					:   return Calendar Data for given calendarname or activityid
    //----------------------------------------------------------------------------------------------------
	public static WFCalAssocData getWICalendarInfo(Connection con, String engine, int procDefID, String activityId, String calendarName){
		WFCalAssocData wfCalAssocData = null;
		if(calendarName != null && !calendarName.equals("")){
			wfCalAssocData = (WFCalAssocData) CachedObjectCollection.getReference().getCacheObject(con, engine, procDefID, WFSConstant.CACHE_CONST_CalNameCache, calendarName).getData();
			if(wfCalAssocData != null){
				return wfCalAssocData;
			}
		}
		wfCalAssocData = (WFCalAssocData) CachedObjectCollection.getReference().getCacheObject(con, engine, procDefID, WFSConstant.CACHE_CONST_CalCache, activityId).getData();
		if(wfCalAssocData != null){
			return wfCalAssocData;
		}
		return (WFCalAssocData) CachedObjectCollection.getReference().getCacheObject(con, engine, procDefID, WFSConstant.CACHE_CONST_CalCache, "0").getData();
	}
	//----------------------------------------------------------------------------------------------------
    //	Function Name 				:	CreateXMLExtInterface
    //	Date Written (DD/MM/YYYY)	:	03/09/2009
    //	Author						:	Saurabh Kamal
    //	Input Parameters			:	ArrayList<String> aList, XMLGenerator gen
    //	Output Parameters			:	String
    //	Return Values				:	ExtInterface XML
    //	Description					:   Returns XML for ExtInterfaces
    //----------------------------------------------------------------------------------------------------
	public static String CreateXMLExtInterface(ArrayList<String> aList,XMLGenerator gen){
		StringBuffer strExtXML = new StringBuffer();
		for(int counter = 0; counter < aList.size(); counter++){
			strExtXML.append("<ExtInterface>\n");
			strExtXML.append(gen.writeValueOf("InterfaceType", aList.get(counter).substring(0,aList.get(counter).indexOf(string21))));
			strExtXML.append(gen.writeValueOf("InterfaceElementId", aList.get(counter).substring(aList.get(counter).indexOf(string21)+1)));
			strExtXML.append("</ExtInterface>\n");
		}
		return strExtXML.toString();

	}


	//----------------------------------------------------------------------------------------------------
    //	Function Name 				:	getMappedColumnsInParent
    //	Date Written (DD/MM/YYYY)	:	09/10/2009
    //	Author						:	Ashish Mangla
    //	Input Parameters			:	FieldInfo
    //	Output Parameters			:	None
    //	Return Values				:	ArrayList (having 2 elements, 1st element is parent table columns, 2nd is child table columns)
    //	Description					:   Returns relation column names in parent table and child table (WFS_8.0_041)
    //----------------------------------------------------------------------------------------------------
	private static ArrayList getMappedColumnsInParent(WFFieldInfo fieldInfo, boolean debugFlag, String engineName){
		ArrayList columnList = new ArrayList();
		int counter = 0;
		StringBuffer columnsToSelect = new StringBuffer();	//parent table
		ArrayList columnsToDelete = new ArrayList();	//child Table

		if (fieldInfo != null) {
			if (fieldInfo.isComplex() || fieldInfo.isArray()) {
				/*Find the Relation Map for the complex / array type */
				LinkedHashMap relationMap = fieldInfo.getRelationMap();
				if (relationMap != null){
					Iterator iterRelation = relationMap.entrySet().iterator();
					while (iterRelation.hasNext()) {
						if (counter > 0){
							columnsToSelect.append(", ");
						}
						Map.Entry entryRelation = (Map.Entry) iterRelation.next();
						WFRelationInfo wfRelationInfo = (WFRelationInfo)entryRelation.getValue();
						columnsToSelect.append(wfRelationInfo.getForeignKey());
						columnsToDelete.add(wfRelationInfo.getRefKey());
						counter++;
					}
				}
			 }
		}

		if (debugFlag) {
			printOut(engineName,"[WFSUtil] getMappedColumnsInParent() columnsToSelect >> " + columnsToSelect.toString());
			printOut(engineName,"[WFSUtil] getMappedColumnsInParent() columnsToDelete >> " + columnsToDelete);
		}
		columnList.add(columnsToSelect.toString());
		columnList.add(columnsToDelete);
		return columnList;
	}

	//----------------------------------------------------------------------------------------------------
    //	Function Name 				:	fetchDeleteCondition
    //	Date Written (DD/MM/YYYY)	:	09/10/2009
    //	Author						:	Ashish Mangla
    //	Input Parameters			:	con, dbType, selectquery, deleteColumns list
    //	Output Parameters			:	None
    //	Return Values				:	deleteconditions string in arraylist
    //	Description					:   prepares the deletecondition string (WFS_8.0_041)
    //----------------------------------------------------------------------------------------------------
	private static ArrayList fetchDeleteCondition(Connection con, int dbType, String query, ArrayList deleteColumns, boolean debugFlag, String engineName) throws SQLException, JTSException{
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		ResultSetMetaData rsmd = null;
		StringBuffer delBuffer = null;
		ArrayList delCondition = new ArrayList();

		try {
			if (debugFlag) {
				printOut(engineName,"[WFSUtil] fetchDeleteCondition() Select Query for deleting children >> " + query);
			}
			pstmt = con.prepareStatement(WFSUtil.TO_SANITIZE_STRING(query,true));
			rs = pstmt.executeQuery();
			rsmd = rs.getMetaData();
			if (rs != null) {
				while (rs.next()) {
					delBuffer = new StringBuffer();
					for (int colCounter = 0; colCounter < rsmd.getColumnCount(); colCounter++) {
						if (colCounter > 0) {
							delBuffer.append(" AND ");
						} else {
							delBuffer.append(" WHERE ");
						}
						delBuffer.append((String) deleteColumns.get(colCounter));
						delBuffer.append(" = ");
						delBuffer.append(TO_SQL_EXT(rs.getString(colCounter + 1), rsmd.getColumnType(colCounter + 1), dbType));
					}
					if (debugFlag) {
						printOut(engineName,"[WFSUtil] fetchDeleteCondition() delete condition >> " + delBuffer.toString());
					}
					delCondition.add(delBuffer.toString());
				}
			}
			rs.close();
		} finally {
			if (pstmt != null){
				pstmt.close();
				pstmt = null;
			}
		}
		return delCondition;
	}


	//----------------------------------------------------------------------------------------------------
    //	Function Name 				:	deleteArray
    //	Date Written (DD/MM/YYYY)	:	09/10/2009
    //	Author						:	Ashish Mangla
    //	Input Parameters			:	con, dbType, wfFieldInfo, deleteCondition
    //	Output Parameters			:	None
    //	Return Values				:	None
    //	Description					:   Delete the array (clear all child nodes....) (WFS_8.0_041)
    //----------------------------------------------------------------------------------------------------
	protected static String deleteArray(Connection con, int dbType, WFFieldInfo wfFieldInfo,
            boolean debugFlag, String deleteCondition, String engineName, int processDefId, HashMap eRelationMap) throws SQLException, JTSException {

		PreparedStatement pstmt = null;
		Map.Entry entry = null;
		WFFieldInfo childInfo = null;
		String mappedColumns = null;
		String selectQuery = null;
		ArrayList columnList = null;
		ArrayList deleteConditions = null;
		StringBuffer auditLogStrForDeleteBuff = new StringBuffer(200);
		ResultSet rs =null;
		ResultSet rs2 =null;
		ResultSet rs3 =null;
		ResultSet rs4 =null;
		ResultSet rs5 =null;
		ResultSet rs6 =null;
		int parentTypeId=0;
		int typeFieldId = 0;
		int variableId =0;
		int counterr = 1;
		String colValue=null;
		
		 WFRelationInfo relationInfo = null;
		
		
		try {
			
			for (Iterator relItr = eRelationMap.entrySet().iterator(); relItr.hasNext(); ++counterr) {
	            entry = (Map.Entry) relItr.next();
	            relationInfo = (WFRelationInfo) entry.getValue();
			}
			
			String mappingColumn = relationInfo.getRefKey();
			
			
			if (!wfFieldInfo.isPrimitive()) {	//IN case of primitive no need to go to inner lev
				for (Iterator childIter = wfFieldInfo.getChildInfoMap().entrySet().iterator(); childIter.hasNext();) {
					entry = (Map.Entry) childIter.next();
					childInfo = (WFFieldInfo) entry.getValue();
					if (!childInfo.isPrimitive()) {
						//We have to delete this as well....
						columnList = getMappedColumnsInParent(childInfo, debugFlag, engineName);
						mappedColumns = (String) columnList.get(0);
						selectQuery = "SELECT " + mappedColumns + " FROM " + wfFieldInfo.getMappedTable() + deleteCondition;
						eRelationMap=childInfo.getRelationMap();

						deleteConditions = fetchDeleteCondition(con, dbType, selectQuery, (ArrayList) columnList.get(1), debugFlag, engineName);
						for (int counter = 0; counter < deleteConditions.size(); counter++) {
							String tempAuditLogStr= deleteArray(con, dbType, childInfo, debugFlag, (String) deleteConditions.get(counter),engineName, processDefId,eRelationMap);
							auditLogStrForDeleteBuff.append(tempAuditLogStr);
						}
					}
					if (childInfo.isArray()) {
						//We have to delete this as well....
						columnList = getMappedColumnsInParent(childInfo, debugFlag, engineName);
						mappedColumns = (String) columnList.get(0);
						selectQuery = "SELECT " + mappedColumns + " FROM " + wfFieldInfo.getMappedTable() + deleteCondition;
						eRelationMap=childInfo.getRelationMap();

						deleteConditions = fetchDeleteCondition(con, dbType, selectQuery, (ArrayList) columnList.get(1), debugFlag, engineName);
						for (int counter = 0; counter < deleteConditions.size(); counter++) {
							String tempAuditLogStr=deleteArray(con, dbType, childInfo, debugFlag, (String) deleteConditions.get(counter),engineName, processDefId, eRelationMap);
							auditLogStrForDeleteBuff.append(tempAuditLogStr);
						}
					}
				}
			}
			
			

	
				printOut(engineName,"[WFSUtil] deleteArray()  Delete Query >> DELETE FROM " + wfFieldInfo.getMappedTable() + deleteCondition);
			
		
		if(processDefId>0){
				
			printOut(engineName,"[WFSUtil] deleteArray()  Select Query >> Select * from " + WFSUtil.TO_SANITIZE_STRING(wfFieldInfo.getMappedTable(),true) + WFSUtil.TO_SANITIZE_STRING(deleteCondition,true));	
			
			String fieldName1;
			String parentname = wfFieldInfo.getName() + ".";
			pstmt= con.prepareStatement("Select ParentTypeId, TypeFieldId from WFTYPEDEFTABLE " + getTableLockHintStr(dbType) +" where WFType = 11 and Processdefid=? and FieldName =?");
			pstmt.setInt(1, processDefId);
			pstmt.setString(2, wfFieldInfo.getName());
			rs3 = pstmt.executeQuery();
			
			if(rs3.next())
			{
				parentTypeId= rs3.getInt("ParentTypeId");
				typeFieldId= rs3.getInt("TypeFieldId");
				pstmt= con.prepareStatement("Select VariableId from WFUDTVARMAPPINGTABLE  " + getTableLockHintStr(dbType) +" where ProcessDefId=? and TypeId=? and TypeFieldId = ?");
				pstmt.setInt(1, processDefId);
				pstmt.setInt(2, parentTypeId);
				pstmt.setInt(3, typeFieldId);
				rs4 = pstmt.executeQuery();
				while(rs4.next())
				{
					variableId= rs4.getInt("VariableId");
					pstmt= con.prepareStatement("Select UserDefinedName from VARMAPPINGTABLE  " + getTableLockHintStr(dbType) +" where ProcessDefId=? and VariableId = ?");
					pstmt.setInt(1, processDefId);
					pstmt.setInt(2, variableId);
					rs5= pstmt.executeQuery();
					while(rs5.next()){
						parentname= rs5.getString("UserDefinedName")+"."+parentname;
					}
				}
			}
			
			
			 pstmt= con.prepareStatement("Select * from "+ WFSUtil.TO_SANITIZE_STRING(wfFieldInfo.getMappedTable(),true) + getTableLockHintStr(dbType) +  WFSUtil.TO_SANITIZE_STRING(deleteCondition,true));
				rs = pstmt.executeQuery();
				
			ResultSetMetaData rsMetaData = rs.getMetaData();
			int columnCount = rsMetaData.getColumnCount();
			while(rs.next()){
				for(int i=1; i<=columnCount;i++ ){
				
				pstmt= con.prepareStatement("select  MappedObjectName, FieldName, WFUDTVarMappingTable.TypeId FROM WFUDTVarMappingTable   INNER JOIN WFTypeDefTable  on WFUDTVarMappingTable.TypeFieldId =WFTypeDefTable.TypeFieldId and WFUDTVarMappingTable.TypeId = WFTypeDefTable.ParentTypeId and WFUDTVarMappingTable.ProcessDefId = WFTypeDefTable.ProcessDefId where  WFUDTVarMappingTable.MappedObjectType = 'C' AND UPPER (WFUDTVarMappingTable.MappedObjectName) =UPPER (?) AND WFUDTVarMappingTable.ProcessDefId =?");
				pstmt.setString(1, rsMetaData.getColumnName(i));
				printOut(engineName, "colum name " + rsMetaData.getColumnName(i));
				pstmt.setInt(2, processDefId);
				rs2 = pstmt.executeQuery();
				
				int parentTypeId1 =0;
				printOut(engineName, "printing result set"+ rs2);
				if(rs2.next()){
				//while(rs2.next()){
					auditLogStrForDeleteBuff.append("<Attribute>");
					auditLogStrForDeleteBuff.append("<Name>");
					auditLogStrForDeleteBuff.append(parentname + rs2.getString("FieldName"));
					fieldName1 = rs2.getString("FieldName");
					parentTypeId1=rs2.getInt("TypeId");
		}
			else
				{
					continue;
				}
			/*	while(rs2.next())
				{
					auditLogStrForDeleteBuff.append(rs2.getString("FieldName"));
				}
				*/
				int type=0;
				pstmt= con.prepareStatement("Select WFType from WFTypeDefTable where Processdefid=? and FieldName=? and ParentTypeId=?");
				pstmt.setInt(1, processDefId);
				pstmt.setString(2, fieldName1);
				pstmt.setInt(3, parentTypeId1);
				rs6=pstmt.executeQuery();
				if(rs6 != null && rs6.next()){
					
					type=rs6.getInt("WFTYpe");
				}
				
				auditLogStrForDeleteBuff.append("</Name><PreviousValue>");
				auditLogStrForDeleteBuff.append(rs.getString(rsMetaData.getColumnName(i)));
				auditLogStrForDeleteBuff.append("</PreviousValue>");
				auditLogStrForDeleteBuff.append("<Type>");
				auditLogStrForDeleteBuff.append(type);
				auditLogStrForDeleteBuff.append("</Type>");
                if(wfFieldInfo!=null && wfFieldInfo.isArray() ){
                	auditLogStrForDeleteBuff.append("<InsertionOrderId>-").append(rs.getString("insertionOrderId")).append("</InsertionOrderId>");	
                }
				auditLogStrForDeleteBuff.append("</Attribute>");
				
				}
				
			}
			
		}	
		
		if (rs != null) {
			rs.close();
			rs = null;
		}
		
		if(isSoftDeleteForArray()){
			if(dbType == JTSConstant.JTS_MSSQL){
				pstmt = con.prepareStatement("UPDATE " + WFSUtil.TO_SANITIZE_STRING(wfFieldInfo.getMappedTable(),true) +" SET "+mappingColumn+"= '-' + convert(varchar(63),"+mappingColumn+")"+ WFSUtil.TO_SANITIZE_STRING(deleteCondition,true));
				}
				else if(dbType == JTSConstant.JTS_ORACLE)
				{
					pstmt = con.prepareStatement("UPDATE " + WFSUtil.TO_SANITIZE_STRING(wfFieldInfo.getMappedTable(),true) +" SET "+mappingColumn+"= '-' ||"+mappingColumn+ WFSUtil.TO_SANITIZE_STRING(deleteCondition,true));
				}
				else
				{
					 pstmt= con.prepareStatement("Select "+mappingColumn+" from "+ WFSUtil.TO_SANITIZE_STRING(wfFieldInfo.getMappedTable(),true) + getTableLockHintStr(dbType) +  WFSUtil.TO_SANITIZE_STRING(deleteCondition,true));
					 rs = pstmt.executeQuery();
					 
					 while(rs.next()){
						  colValue= rs.getString(mappingColumn);
					 }
					 
					pstmt = con.prepareStatement("UPDATE " + WFSUtil.TO_SANITIZE_STRING(wfFieldInfo.getMappedTable(),true) +" SET "+mappingColumn+"= '-"+colValue+" ' "+ WFSUtil.TO_SANITIZE_STRING(deleteCondition,true));
				}
		}else{
			pstmt = con.prepareStatement("DELETE FROM " + WFSUtil.TO_SANITIZE_STRING(wfFieldInfo.getMappedTable(),true) + WFSUtil.TO_SANITIZE_STRING(deleteCondition,true));
		}
			
			
			pstmt.executeUpdate();
		} finally {
			if (pstmt != null) {
				pstmt.close();
				pstmt = null;
			}
			
			if (rs != null) {
				rs.close();
				rs = null;
			}
		
			if (rs2 != null) {
				rs2.close();
				rs2 = null;
			}
			if (rs3 != null) {
				rs3.close();
				rs3 = null;
			}
			if (rs4 != null) {
				rs4.close();
				rs4 = null;
			}
			if (rs5 != null) {
				rs5.close();
				rs5 = null;
			}
			if (rs6 != null) {
				rs6.close();
				rs6 = null;
			}
		}
		return auditLogStrForDeleteBuff.toString();
	}

	//----------------------------------------------------------------------------------------------------
    //	Function Name 				:	getOrderBy
    //	Date Written (DD/MM/YYYY)	:	26/11/2009
    //	Author						:	Saurabh Kamal
    //	Input Parameters			:	param1
    //	Output Parameters			:	int
    //	Return Values				:	None
    //	Description					:   Returns orderBy for System Variable
    //----------------------------------------------------------------------------------------------------
		public static int getOrderBy(String param1){
		int OrderBy = 0;
			if (param1.equalsIgnoreCase("PriorityLevel")) {
				OrderBy = 1;
			} else if (param1.equalsIgnoreCase("processinstanceid")) {
				OrderBy = 2;
			} else if (param1.equalsIgnoreCase("ActivityName")) {
				OrderBy = 3;
			} else if (param1.equalsIgnoreCase("lockedByname")) {
				OrderBy = 4;
			} else if (param1.equalsIgnoreCase("introducedby")) {
				OrderBy = 5;
			} else if (param1.equalsIgnoreCase("InstrumentStatus")) {
				OrderBy = 6;
			} else if (param1.equalsIgnoreCase("CheckListCompleteFlag")) {
				OrderBy = 7;
			} else if (param1.equalsIgnoreCase("lockstatus")) {
				OrderBy = 8;
			} else if (param1.equalsIgnoreCase("statename")) {
				OrderBy = 9;
			} else if (param1.equalsIgnoreCase("entrydatetime")) {
				OrderBy = 10;
			} else if (param1.equalsIgnoreCase("ValidTill")) {
				OrderBy = 11;
			} else if (param1.equalsIgnoreCase("LockedTime")) {
				OrderBy = 12;
			} else if (param1.equalsIgnoreCase("introductiondatetime")) {
				OrderBy = 13;
			} else if (param1.equalsIgnoreCase("queuename")) {
				OrderBy = 14;
			} else if (param1.equalsIgnoreCase("processname")) {
				OrderBy = 15;
			} else if (param1.equalsIgnoreCase("assigneduser")) {
				OrderBy = 16;
			} else if (param1.equalsIgnoreCase("Status")) {
				OrderBy = 17;
			} else if (param1.equalsIgnoreCase("createddatetime")) {
				OrderBy = 18;
			} else if (param1.equalsIgnoreCase("expectedWorkitemDelayTime")) {
				OrderBy = 19;
			} else if (param1.equalsIgnoreCase("VAR_INT1")) {
				OrderBy = 101;
			} else if (param1.equalsIgnoreCase("VAR_INT2")) {
				OrderBy = 102;
			} else if (param1.equalsIgnoreCase("VAR_INT3")) {
				OrderBy = 103;
			} else if (param1.equalsIgnoreCase("VAR_INT4")) {
				OrderBy = 104;
			} else if (param1.equalsIgnoreCase("VAR_INT5")) {
				OrderBy = 105;
			} else if (param1.equalsIgnoreCase("VAR_INT6")) {
				OrderBy = 106;
			} else if (param1.equalsIgnoreCase("VAR_INT7")) {
				OrderBy = 107;
			} else if (param1.equalsIgnoreCase("VAR_INT8")) {
				OrderBy = 108;
			} else if (param1.equalsIgnoreCase("VAR_FLOAT1")) {
				OrderBy = 109;
			} else if (param1.equalsIgnoreCase("VAR_FLOAT2")) {
				OrderBy = 110;
			} else if (param1.equalsIgnoreCase("VAR_DATE1")) {
				OrderBy = 111;
			} else if (param1.equalsIgnoreCase("VAR_DATE2")) {
				OrderBy = 112;
			} else if (param1.equalsIgnoreCase("VAR_DATE3")) {
				OrderBy = 113;
			} else if (param1.equalsIgnoreCase("VAR_DATE4")) {
				OrderBy = 114;
			} else if (param1.equalsIgnoreCase("VAR_LONG1")) {
				OrderBy = 115;
			} else if (param1.equalsIgnoreCase("VAR_LONG2")) {
				OrderBy = 116;
			} else if (param1.equalsIgnoreCase("VAR_LONG3")) {
				OrderBy = 117;
			} else if (param1.equalsIgnoreCase("VAR_LONG4")) {
				OrderBy = 118;
			} else if (param1.equalsIgnoreCase("VAR_STR1")) {
				OrderBy = 119;
			} else if (param1.equalsIgnoreCase("VAR_STR2")) {
				OrderBy = 120;
			} else if (param1.equalsIgnoreCase("VAR_STR3")) {
				OrderBy = 121;
			} else if (param1.equalsIgnoreCase("VAR_STR4")) {
				OrderBy = 122;
			} else if (param1.equalsIgnoreCase("VAR_STR5")) {
				OrderBy = 123;
			} else if (param1.equalsIgnoreCase("VAR_STR6")) {
				OrderBy = 124;
			} else if (param1.equalsIgnoreCase("VAR_STR7")) {
				OrderBy = 125;
			} else if (param1.equalsIgnoreCase("VAR_STR8")) {
				OrderBy = 126;
			}
		return OrderBy;
	}

    //----------------------------------------------------------------------------------------------------
    //	Function Name 				:	getFunctionFilter
    //	Date Written (DD/MM/YYYY)	:	10/03/2011
    //	Author						:	Saurabh Kamal
    //	Input Parameters			:	con, functionString
    //	Output Parameters			:	String
    //	Return Values				:	functionString
    //	Description					:   Returns queryFilter with return value of present Functions.
    //----------------------------------------------------------------------------------------------------

    public static String getFunctionFilter(Connection con, String functionString, int dbType) throws SQLException {
        int functionPos = 0;
        int funPos1 = 0;
        int funPos2 = 0;
        String FunValue = null;
        String queryFunStr = null;
        String prevFilter = null;
        String funFilter = null;
        String postFilter = null;
        String tempFunStr = null;
        int funLength = 0;
        Statement stmt = null;
        ResultSet rs = null;
        try{
            functionPos = functionString.indexOf("&<FUNCTION>&");
            if(functionPos != -1){
                funLength = "&<FUNCTION>&".length();
                while(functionPos != -1){
					stmt = con.createStatement();
                    if(functionPos != 0)
                        prevFilter = functionString.substring(0, functionPos);
                    else
                        prevFilter = "";
                    funPos1 = functionString.indexOf("{");
                    tempFunStr = functionString.substring((functionPos + funLength), funPos1).trim();
                    
                    if(tempFunStr == null || tempFunStr.equals("")){
                        funPos2 = functionString.indexOf("}");
                        funFilter = functionString.substring(funPos1 + 1, funPos2); 
						if((funPos2+1) < functionString.length()){
                           postFilter = functionString.substring(funPos2 + 1);
                        } else {
                            postFilter = "";
                        }
                        if(dbType == JTSConstant.JTS_MSSQL){
                                queryFunStr = "SELECT dbo." + WFSUtil.TO_SANITIZE_STRING(funFilter,true);
                        } else if(dbType == JTSConstant.JTS_ORACLE){
                                queryFunStr = "SELECT " + WFSUtil.TO_SANITIZE_STRING(funFilter,true)  + " from DUAL";
                        } else if(dbType == JTSConstant.JTS_POSTGRES) {
                                queryFunStr = "SELECT " + WFSUtil.TO_SANITIZE_STRING(funFilter,true);	
                        }                        
                        rs = stmt.executeQuery(queryFunStr);
                        if(rs != null && rs.next()){
                            FunValue = rs.getString(1);
                        }
                        functionString = prevFilter + " " + WFSUtil.TO_SANITIZE_STRING(FunValue,true) + " " + postFilter;
                    }else{
                        break;
                    }
                    functionPos = functionString.indexOf("&<FUNCTION>&");
					if(stmt != null){
						stmt.close();
						stmt = null;
					}
					if(rs != null){
						rs.close();
						rs = null;
					}
                }
				if(getOccurence(functionString,'(') != getOccurence(functionString,')')){
                    if(functionString.lastIndexOf(")") == functionString.length()-1){
                            functionString = functionString.substring(0, functionString.length()-1);
                    }                
                }
            }
        } finally {
            if(rs != null){
                rs.close();
                rs = null;
            }
            if(stmt != null){
                stmt.close();
                stmt = null;
            }

        }
        return WFSUtil.TO_SANITIZE_STRING(functionString,true);
    }/**
	 * *************************************************************
	 * Function Name    : checkSQLInjectionInDate
	 * Author			: Ashish Mangla
	 * Date Written     : 26/07/2011
	 * Input Parameters : String
	 * Output Parameters: NONE
	 * Return Value     : String -> true is valid date pattern 
	 * Description      : to avoid SQL INjection in date type field 
	 * *************************************************************
	 */
	public static boolean checkSQLInjectionInDate(String in, boolean isConst){
		in = in.trim();
		Matcher m = null;
		if (isConst) {
			m = WFSConstant.WF_DATE_PATTERN.matcher(in);
		} else {
			m = WFSConstant.WF_DATE_PATTERN1.matcher(in);
			in = in.substring(1);	//remove ' from the 1st index for SimpleDateFormatting
		}
			
		boolean testMatch = m.matches();
		if (!testMatch) {
			return false;
		} else {
			SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
			sdf.setLenient(false);
			try {
				java.util.Date testDate = sdf.parse(in);
			} catch (ParseException ex) {
				return false;
			}
	   }
	   return testMatch;
	}
	
	/**
     * *************************************************************
     * Function Name    : getColString
     * Author	    : Shweta Singhal
     * Date Written     : 24/08/2011
     * Input Parameters : Connection con, String tablename
     * Output Parameters: NONE
     * Return Value     : String
     * Description      : return column String of given table seperated by comma
     * *************************************************************
     */
    public static String getColString(Connection con, String tablename, int dbType) throws SQLException {
        ResultSetMetaData rsmd = null;
        ResultSet rs = null;
        Statement stmt = null;
        String colString = null;
        try {
            stmt = con.createStatement();
            rs = stmt.executeQuery("select * from " + WFSUtil.TO_SANITIZE_STRING(tablename,false) + getTableLockHintStr(dbType) + " where 1=2");
            rsmd = rs.getMetaData();
            
            int count = rsmd.getColumnCount();
            for (int i = 1; i <= count; i++) {
                //if (!rsmd.isAutoIncrement(i)) {
                    if (i != 1) {
						if(rsmd.getColumnName(i).equalsIgnoreCase("ProcessDefId")){
							colString=  "ProcessDefId" + "," + colString;
//						}else if(rsmd.getColumnName(i).equalsIgnoreCase("ProcessVariantId")){//Process Variant Support Changes
//							continue;
						}else{
							colString = colString + "," + rsmd.getColumnName(i);
						}
                    }
                    else {
                        colString = rsmd.getColumnName(i);
                    }
               // }
            }
            rs.close();
            stmt.close();
            
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
            } catch (SQLException e) {
            }
        }
        return WFSUtil.TO_SANITIZE_STRING(colString,true);
    }

    /**
     * *************************************************************
     * Function Name    : insertIntoWF
     * Author           : Shweta Singhal
     * Date Written     : 24/08/2011
     * Input Parameters : Connection con, String processName, HashMap tMap,
     *                    int processDefId, Boolean isVersionExists, int dbType
     * Output Parameters: NONE
     * Return Value     : String
     * Description      : Fetches data from web to the wftables.
     * *************************************************************
     */
    public static int insertIntoWF(Connection con, String processName, HashMap tMap, int pmwProcessDefId, boolean isVersionExists, int dbType, String engine, WFParticipant user, int pmwProjectId) throws SQLException, Exception {
        PreparedStatement pstmt = null;
        Statement stmt = null;
        ResultSet rs = null;
        ResultSet rs1 = null;
        String pmwColString = null;
        String ColString = null;
        int processdefid = 0;
        double versionNo = 1.0;
		boolean insertProjectTableData = false;
		boolean brmsFlag1 = false;
		//boolean brmsFlag2 = false;
                boolean restFlag = false;
         boolean soapWebServiceFlag=false;
         boolean externalMethodFlag=false;
        try {
            if (isVersionExists) {
                pstmt = con.prepareStatement("select max(VersionNo) as versionNo from processdeftable "+ getTableLockHintStr(dbType) + " where processname= ?");
				WFSUtil.DB_SetString(1, processName, pstmt, dbType);// Change done for Bug 37885
                rs = pstmt.executeQuery();
                if (rs != null && rs.next()) {
                    versionNo = (double) (rs.getInt("versionNo") + 1);
                }
            }
			String vers= "V"+ (int)versionNo;
			if (rs != null) {
                rs.close();
                rs = null;
            }
            if (pstmt != null) {
                pstmt.close();
                pstmt = null;
            }
			int projectId = 0;
			pstmt = con.prepareStatement("select projectid from wfprojectlisttable " + WFSUtil.getTableLockHintStr(dbType) + "  where projectname = (select ProjectName from pmwprojectlisttable where projectid = ?)");
			pstmt.setInt(1, pmwProjectId);
			//printOut("select projectid from wfprojectlisttable where projectname = (select ProjectName from pmwprojectlisttable where projectid = "+pmwProjectId+")");
			rs = pstmt.executeQuery();
			if(rs != null && rs.next()){
				projectId = rs.getInt(1);
			} else {
				insertProjectTableData = true;
			}
			
			pstmt.close();
			pstmt = null;
			stmt = con.createStatement();
			int userID = user.getid();
			String userName = user.getname();
			if(insertProjectTableData) {
				rs = stmt.executeQuery("select max(ProjectId)+1 as ProjectId from WFPROJECTLISTTABLE ");
				if(rs.next()){
					projectId = rs.getInt(1);
				}
				
				ColString = WFSUtil.getColString(con, "WFPROJECTLISTTABLE", dbType).toUpperCase();
				ColString = ColString.replace("CREATIONDATETIME,", "");
				ColString = ColString.replace("LASTMODIFIEDON,", "");
				
                pmwColString = ColString.replace("PROJECTID,", "");
				stmt.executeUpdate("insert into WFPROJECTLISTTABLE (" + ColString + ", CreationDateTime, LastModifiedOn) select  " + projectId + ", " + pmwColString + ", " +WFSUtil.getDate(dbType) +  ", " +WFSUtil.getDate(dbType) + " from PMWPROJECTLISTTABLE where ProjectId=" + pmwProjectId + "");
		        stmt.close();
		        
		        //System.out.println("Before");
		        stmt = con.createStatement();
		        stmt.executeUpdate("insert into WFSectionsTable (ProcessDefId, ProjectId, OrderId, SectionName, Description, Exclude, ParentID , SectionId ) select  0, " + projectId +", OrderId, SectionName, Description, Exclude , ParentID , SectionId from PMWSectionsTable where ProjectId= " + pmwProjectId + " and ProcessDefId = 0");
		        //stmt.close();
		        
		        //System.out.println("After1");
				
				//int userID = user.getid();
				String[] objectTypeStr = getIdForName(con, dbType, WFSConstant.CONST_OBJTYPE_PROJECT, "O");
				int objTypeId = Integer.parseInt(objectTypeStr[1]);
				
				associateObjectsWithUser(stmt, dbType, userID, 0, projectId, objTypeId, 0, WFSConstant.CONST_DEFAULT_PROJECT_RIGHTSTR, null, 'I',engine);
				
			}
			
            ColString = WFSUtil.getColString(con, "ProcessDefTable", dbType).toUpperCase();;
			ColString = ColString.replace("PROJECTID,", "");
			ColString = ColString.replace("CREATEDON,", "");
			ColString = ColString.replace("LASTMODIFIEDON,", "");
            if (ColString.indexOf(",") != -1) {
                pmwColString = ColString.substring(ColString.indexOf(","));
                if (pmwColString.indexOf(",") != -1) {
                    pmwColString = pmwColString.substring(1);
                    pmwColString = pmwColString.substring(pmwColString.indexOf(","));
                }				
            }
            if (dbType != JTSConstant.JTS_MSSQL) {
                processdefid =Integer.parseInt(WFSUtil.nextVal(con, "ProcessDefId", dbType));
            }
            //Bug 40315
            String st = null;
            if (dbType == JTSConstant.JTS_MSSQL) {
                st = "insert into ProcessDefTable (VersionNo,ProcessName,ProcessState,RegPrefix,RegSuffix,RegStartingNo,ProcessTurnAroundTime,RegSeqLength,CreatedOn,LastModifiedOn,WSFont,WSColor,CommentsFont,CommentsColor,Backcolor,TATCalFlag,Description,CreatedBy,LastModifiedBy,ProcessShared,ProjectId,Cost,Duration,FormViewerApp, ProcessType,ThresholdRoutingCount,CreateWebService,DisplayName,ISSECUREFOLDER,OWNEREMAILID,VolumeId,SiteId)"
                        +"select  " + versionNo + " ," + TO_STRING(processName, true, dbType) + ",ProcessState,RegPrefix,RegSuffix,RegStartingNo,ProcessTurnAroundTime,RegSeqLength,"+WFSUtil.getDate(dbType)+","+WFSUtil.getDate(dbType)+",WSFont,WSColor,CommentsFont,CommentsColor,Backcolor,TATCalFlag,Description," + TO_STRING(userName, true, dbType) + "," + TO_STRING(userName, true, dbType) + ",ProcessShared," + projectId + ",Cost,Duration,FormViewerApp, ProcessType,ThresholdRoutingCount,CreateWebService,DisplayName,ISSECUREFOLDER,OWNEREMAILID,VolumeId, SiteId "
                        +" from PMWProcessDefTable where ProcessDefId=" + pmwProcessDefId + "";
						printOut(engine,"print at line 14317: " + st);
            }else if (dbType == JTSConstant.JTS_ORACLE || dbType == JTSConstant.JTS_POSTGRES) {
                /*Bug 38270 fixed*/
                st = "insert into ProcessDefTable (ProcessDefId, VersionNo,ProcessName,ProcessState,RegPrefix,RegSuffix,RegStartingNo,ProcessTurnAroundTime,RegSeqLength,CreatedOn,LastModifiedOn,WSFont,WSColor,CommentsFont,CommentsColor,Backcolor,TATCalFlag,Description,CreatedBy,LastModifiedBy,ProcessShared,ProjectId,Cost,Duration,FormViewerApp, ProcessType,ThresholdRoutingCount,CreateWebService,DisplayName,ISSECUREFOLDER,OWNEREMAILID,VolumeId,SiteId)"
                        +" Select  " + processdefid + ", " + versionNo + " ," + TO_STRING(processName, true, dbType) + ",ProcessState,RegPrefix,RegSuffix,RegStartingNo,ProcessTurnAroundTime,RegSeqLength,"+WFSUtil.getDate(dbType)+","+WFSUtil.getDate(dbType)+",WSFont,WSColor,CommentsFont,CommentsColor,Backcolor,TATCalFlag,Description," + TO_STRING(userName, true, dbType) + "," + TO_STRING(userName, true, dbType) + ",ProcessShared," + projectId + ",Cost,Duration,FormViewerApp, ProcessType,ThresholdRoutingCount,CreateWebService,DisplayName,ISSECUREFOLDER,OWNEREMAILID,VolumeId,SiteId"
                        +" from PMWProcessDefTable where ProcessDefId=" + pmwProcessDefId + "";
/*            
                st = "insert into ProcessDefTable (" + ColString + ", ProjectId, CreatedOn, LastModifiedOn) select  "+processdefid+", " + versionNo + " " + pmwColString  + ", " + projectId + ", " +WFSUtil.getDate(dbType) +  ", " +WFSUtil.getDate(dbType) + " from PMWProcessDefTable where ProcessDefId=" + pmwProcessDefId + "";
*/                
            }
//            else if (dbType == JTSConstant.JTS_POSTGRES) {
//                st = "insert into ProcessDefTable (" + ColString + ", ProjectId, CreatedOn, LastModifiedOn) select  "+processdefid+" ," + versionNo + " " + pmwColString + ", " + projectId + ", " +WFSUtil.getDate(dbType) +  ", " +WFSUtil.getDate(dbType) + " from PMWProcessDefTable where ProcessDefId=" + pmwProcessDefId + "";
//            }
            stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
            if(dbType == JTSConstant.JTS_MSSQL){
				stmt.execute("Select @@IDENTITY");
				rs = stmt.getResultSet();
                if(rs != null && rs.next()) {
					processdefid = rs.getInt(1);
					rs.close();
				}
			}
            //Bug 40355
           /* if(dbType == JTSConstant.JTS_ORACLE){
                String seqName = "SEQ_RegistrationNumber_"+processdefid;
                String seqQuery = null;
                seqQuery = "select 1 from user_sequences where sequence_name like UPPER("+TO_STRING(seqName, true, dbType)+")";
                rs = stmt.executeQuery(seqQuery);        
                seqQuery = "CREATE SEQUENCE "+seqName+" INCREMENT BY 1 START WITH 1 NOCACHE";
                if(!rs.next()){
                    printOut("seqQuery>>"+seqQuery);
                    stmt.execute(seqQuery);        
                }
                if(rs != null){
                    rs.close();
                    rs = null;
                }
            }*/
            
			Iterator itr = tMap.keySet().iterator();
            int flag = 0;
			while (itr.hasNext()) {
				String filterString = "";
                String tablename = (String) itr.next();
                if(tablename.equalsIgnoreCase("WFTaskFormTable")){
    				filterString =" and StatusFlag = 'P'";
                }
                printOut(engine,"Table Name :::::::"+tablename);
                String pmwTableName = (String) tMap.get(tablename);
                ColString = getColString(con, tablename, dbType).toUpperCase();
                if(ColString.toUpperCase().contains("PROCESSVARIANTID"))//Process Variant Support Changes
                    ColString = ColString.toUpperCase().replace(",PROCESSVARIANTID", "");
				printOut(engine,"<InsertintoWF> ColString>>"+ColString);
				//ColString = ColString.replace("PROCESSVARIANTID,", "");
                if(!(tablename.equalsIgnoreCase("WFLaneQueueTable") || tablename.equalsIgnoreCase("QueueStreamTable"))){
					if (ColString.indexOf(",") != -1) {
						pmwColString = ColString.substring(ColString.indexOf(","));
					}
					if(tablename.equalsIgnoreCase("WFSectionsTable")){
							pmwColString = pmwColString.substring(pmwColString.indexOf(",",1));
							pmwColString=","+projectId+pmwColString;
					}
					st = "insert into " + tablename + " (" + ColString + ") select " + processdefid + " " + pmwColString + " from " + WFSUtil.TO_SANITIZE_STRING(pmwTableName,false) + " where ProcessDefId=" + pmwProcessDefId + filterString;
					flag = stmt.executeUpdate(WFSUtil.TO_SANITIZE_STRING(st,true));
					if(tablename.equalsIgnoreCase("wfJMSPublishTable") && flag > 0)
						transferJMSData(con, false, pmwProcessDefId, processdefid, dbType);
						// Bug 39613 - Fixed
					if(tablename.equalsIgnoreCase("wfjmssubscribetable") && flag > 0)
						transferJMSSubscriberData(con, false, pmwProcessDefId, processdefid, dbType);
						
					// Changes done for BRMS	
						
					if(tablename.equalsIgnoreCase("WFBRMSActivityAssocTable") && flag > 0){
						brmsFlag1 = true; 							
					}
						
//					if(tablename.equalsIgnoreCase("WFBRMSMappingTable") && flag > 0){
//						brmsFlag2 = true; 							
//					}
						
					
                                        
                                        if(tablename.equalsIgnoreCase("WFRestActivityAssocTable") && flag > 0){
                                            restFlag = true;						
					}
                     if("WFWebserviceTable".equalsIgnoreCase(tablename) && flag > 0){
                    	soapWebServiceFlag=true;
                    }
				}
            }
          if(restFlag){
        	  transferRESTData(con, false, pmwProcessDefId, processdefid, dbType,engine);
          }
          if(soapWebServiceFlag){
               transferWebServiceData(con, false, pmwProcessDefId, processdefid, dbType,engine);
          }
          if(brmsFlag1){
				transferBRMSData(con, false, pmwProcessDefId, processdefid, dbType,engine);
			}
          transferExternalMethodData(con, false, pmwProcessDefId, processdefid, dbType, engine);
                        /*Bug 40819, create sequence for array type complex variables*/
            /*if(dbType == JTSConstant.JTS_ORACLE){
                st = "select distinct ExtObjId from varmappingtable where processdefid = "+processdefid+" and unbounded = 'Y' and variableid in (select distinct(variableid) from wfudtvarmappingtable where processdefid = "+processdefid+" )";
            //st = "select ExtObjId from EXTDBCONFTABLE where  ProcessDefId = "+processdefid+" ";
            //printOut("print at line 14331: " + st);
                rs = stmt.executeQuery(st);
                String seqName = null;
                int extObjId = 0;
                while(rs.next()){
                    extObjId = rs.getInt("ExtObjId");
                    seqName = "WFSEQ_ARRAY_"+processdefid+"_"+extObjId;
                    String seqQuery = null;
                    seqQuery = "select 1 from user_sequences where sequence_name like UPPER("+TO_STRING(seqName, true, dbType)+")";
                    rs1 = stmt.executeQuery(seqQuery);        
                    seqQuery = "CREATE SEQUENCE "+seqName+" INCREMENT BY 1 START WITH 1 NOCACHE";
                    if(!rs1.next()){
                        printOut("seqQuery>>"+seqQuery);
                        stmt.execute(seqQuery);        
                    }
                    if(rs1 != null){
                        rs1.close();
                        rs1 = null;
                    }
                }
                if(rs != null){
                    rs.close();
                    rs = null;
                }
                
            }*/
			/* Bug 31606 fixed*/
			st = "update IMPORTEDPROCESSDEFTABLE set ProcessType =" + TO_STRING("R", true, dbType) + " where  ProcessDefId = "+processdefid+" ";
			//printOut("print at line 14331: " + st);
			stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
			
			if (stmt != null) {
				stmt.close();
				stmt = null;
			}
			if (rs != null) {
				rs.close();
				rs = null;
			}	
			//Create Procesfolders and other info
            // Changes done for removing OD dependency for rights checking
            //Workitem was not getting created as initially createProcessDocument() was commented
                        if(restFlag){
                            WFSUtil.transferRESTData(con, false, pmwProcessDefId, processdefid, dbType,engine);
                            
                        }
            /**
             * Changes for sharepoint related support (insertion of sharepoint folder IDs into RouteFolderDefTable)
             */
            stmt = con.createStatement();
            rs = stmt.executeQuery("select 1 from WFUnderlyingDMS " + getTableLockHintStr(dbType) + " where DMSType = 2 AND UPPER(DMSName) = 'SHAREPOINT'");
            if(rs.next()){
            	int libraryId = 0;
    			if (rs != null) {
                    rs.close();
                    rs = null;
                }
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
            	stmt = con.createStatement();
                rs = stmt.executeQuery("select LibraryId from WFprocesssharepointassoc " + getTableLockHintStr(dbType) + " where ProcessDefId = " + processdefid);
            	if(rs.next()){
            		libraryId = rs.getInt(1);
            	}
            	int updateRetVal = createProcessDocsForSharepoint(con, user, processName, vers, processdefid, engine, dbType, libraryId);
            	printOut(engine, "Return value of createProcessDocsForSharepoint : " + updateRetVal);
            }else{
				WFTMSUtil.createProcessDocument(con, processdefid, processName, vers, user, dbType, engine);
				//WFTMSUtil.createOTMSDocument(con, processdefid, "OTMS", user, dbType, engine);
	            WFTMSUtil.insertRouteFolderInfo(con, processdefid, processName, vers, engine, dbType);	
            }
			if (rs != null) {
                rs.close();
                rs = null;
            }
            if (stmt != null) {
                stmt.close();
                stmt = null;
            }

		} finally {
            try {
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
				if (rs != null) {
                    rs.close();
                    rs = null;
                }
			} catch (Exception e) {
				printOut(engine,"Exception "+e);
            }
        }
        return processdefid;
    }
	/**
	* This Method is to create an empty folder in Sharepoint within the given folder GUID.
	* @param con
	* @param processDefId
	* @param processName
	* @param version
	* @param participant
	 * @param folderName 
	 * @param parentFolderGUID 
	* @param dbType
	* @param engine
	* @param createProcessDocFlag
	* @throws SQLException
	* @throws Exception
	*/
	public static String createEmptyFolderInSharepoint(Connection con, String engine, WFParticipant participant, int processDefId, String parentFolderGUID, String folderName, int libraryId) throws SQLException, Exception {
		WFDMSImpl wfDms = null;
        StringBuffer inputXML = new StringBuffer();
        StringBuffer inputAddFolderXML = new StringBuffer();
        StringBuffer tempXml = new StringBuffer();
        String outputAddFolderXML = null;
        String outputAddDocumentXML = null;
        int userId = 0;
        String foloderGUID = "";
        XMLParser parser1 = new XMLParser();
        XMLGenerator gen = new XMLGenerator();
        String spDetails[] = readSharePointConfig(engine);
        inputAddFolderXML.append(gen.writeValue("EngineName", engine));
        //inputAddFolderXML.append(gen.writeValue("SessionId", sessionID+""));
        inputAddFolderXML.append(gen.writeValue("ParentFolderIndex", parentFolderGUID));
        inputAddFolderXML.append(gen.writeValue("FolderName", folderName));
        inputAddFolderXML.append(gen.writeValue("ProcessDefId", processDefId+""));
        if(spDetails!=null)
        {
        inputAddFolderXML.append(gen.writeValue("DMSUserName", spDetails[0]));
        inputAddFolderXML.append(gen.writeValue("DMSPassword", spDetails[1]));
        
        inputAddFolderXML.append(gen.writeValue("LibraryId", libraryId+""));
        parser1.setInputXML(inputAddFolderXML.toString());
        wfDms = (WFDMSImpl) Class.forName("com.newgen.omni.wf.wfdms.SharePointOperation").newInstance();
        outputAddFolderXML = wfDms.addFolder(parser1, spDetails[0], spDetails[1]);
        }else{
        	throw new Exception("WFSUtil.createEmptyFolderInSharepoint :: spDetails is null");
        }
        parser1.setInputXML(outputAddFolderXML);
        int status = parser1.getIntOf("Status", -1, true);
        printErr(engine, "Output of AddFolder API for folder " + folderName + " : "+ outputAddFolderXML);
        if(status != 0){
        	String descr = parser1.getValueOf("Error", "", true);
            int mainCode = WFSError.WF_SHAREPOINT_ERROR;
            int subCode = WFSError.WF_SHAREPOINT_ERROR;
            String errType = WFSError.WF_TMP;
            String subject = WFSErrorMsg.getMessage(mainCode);
			throw new WFSException(mainCode, subCode, errType, subject, descr);
        } else {
        	foloderGUID = parser1.getValueOf("Output");
        }
		return foloderGUID;
	}
	
	/**
	 * This method reads the sharepoint confiurations details from the properties file (SharepointConfig.properties).
	 * @param engine
	 * @return Array of Strings(sharepoint username, sharepoint password)
	 * @throws Exception
	 */
    private static String[] readSharePointConfig(String engine) throws Exception{
    	String[] spDetails = null;
        FileInputStream fstream = null;
        String sharepointConfigFile="SharePointConfig.properties";
        WFConfigLocator configurationLocator = WFConfigLocator.getInstance();
        String filePath = configurationLocator.getPath(Location.IBPS_CONFIG) + File.separator + WFSConstant.CONST_DIRECTORY_CONFIG + File.separatorChar + sharepointConfigFile;
        try {
            fstream = new FileInputStream(filePath);
            Properties prop = new Properties();
            prop.load(fstream);
            spDetails = new String[2];
            spDetails[0]= prop.getProperty("SharePointUserName");
            spDetails[1]=prop.getProperty("SharePointPassword");
        } catch (Exception ex) {
            printErr(engine, "Error in loading SharePoint User Details");
            printErr(engine, ex);
            throw ex;
        }
        finally {
            try {
            	if(fstream!=null){
            		fstream.close();
            	}
            } catch (IOException ex) {
                printErr(engine, "Error in closing the filestream");
            }
        }
        return spDetails;
    }
    
	/**
	 * This Method create 4 different folders for each process in sharepoint that will contain the workitem data.
	 * @param con
	 * @param user
	 * @param processName
	 * @param vers
	 * @param processDefId
	 * @param engine
	 * @param dbType
	 * @return updateReturnCode
	 * @throws Exception
	 */
	public static int createProcessDocsForSharepoint(Connection con, WFParticipant user, String processName, String vers, int processDefId, String engine, int dbType, int libraryId) throws Exception{
    	String parentFolderGUID = "";
    	String scratchFolderGUID = "";
    	String workFlowFolderGUID = "";
    	String completedFolderGUID = "";
    	String discardFolderGUID = "";
    	PreparedStatement pstmt = null;
    	int insertRetVal = 0;
    	try{
	    	parentFolderGUID = createEmptyFolderInSharepoint(con, engine, user, processDefId, "", processName + " " + vers, libraryId);
	    	scratchFolderGUID = createEmptyFolderInSharepoint(con, engine, user, processDefId, parentFolderGUID, "Scratch", libraryId);
	    	workFlowFolderGUID = createEmptyFolderInSharepoint(con, engine, user, processDefId, parentFolderGUID, "WorkFlow", libraryId);
	    	completedFolderGUID = createEmptyFolderInSharepoint(con, engine, user, processDefId, parentFolderGUID, "Completed", libraryId);
	    	discardFolderGUID = createEmptyFolderInSharepoint(con, engine, user, processDefId, parentFolderGUID, "Discard", libraryId);
	    	
	    	printOut(engine, "parentFolderGUID : " + parentFolderGUID);
	    	printOut(engine, "scratchFolderGUID : " + scratchFolderGUID);
	    	printOut(engine, "workFlowFolderGUID : " + workFlowFolderGUID);
	    	printOut(engine, "completedFolderGUID : " + completedFolderGUID);
	    	printOut(engine, "discardFolderGUID : " + discardFolderGUID);
	    	//Logic to insert the above folderGUIDs into RouteFolderDefTable.
	    	pstmt = con.prepareStatement("Insert into RouteFolderDefTable (ProcessDefId, CabinetName, RouteFolderId, ScratchFolderId,WorkFlowFolderId, CompletedFolderId, DiscardFolderId) values (?,?,?,?,?,?,?)");
	    	pstmt.setInt(1, processDefId);
	    	DB_SetString(2, engine, pstmt, dbType);
	    	DB_SetString(3, parentFolderGUID, pstmt, dbType);
	    	DB_SetString(4, scratchFolderGUID, pstmt, dbType);
	    	DB_SetString(5, workFlowFolderGUID, pstmt, dbType);
	    	DB_SetString(6, completedFolderGUID, pstmt, dbType);
	    	DB_SetString(7, discardFolderGUID, pstmt, dbType);
	    	insertRetVal = pstmt.executeUpdate();
	    	printOut(engine, "RouteFolderDefTable update for Sharepoint returned : " + insertRetVal);
	        if (pstmt != null) {
	        	pstmt.close();
	        	pstmt = null;
	        }
        }
        finally{
	        if (pstmt != null) {
	        	pstmt.close();
	        	pstmt = null;
	        }
	    }
        return insertRetVal;
	}
	
	public static int getRevisionNumber(Connection con, Statement stmt, int dbType) throws SQLException {
			ResultSet rs = null;
			int revisionNo = 0;
			if (dbType != JTSConstant.JTS_MSSQL) {
				revisionNo =Integer.parseInt(WFSUtil.nextVal(con, "RevisionNoSequence", dbType));
			}
		  
			if (dbType == JTSConstant.JTS_MSSQL) {
				stmt.execute("Insert into RevisionNoSequence values (null)");
			}
		  
			if(dbType == JTSConstant.JTS_MSSQL){
			stmt.execute("Select @@IDENTITY");
			rs = stmt.getResultSet();
				if(rs != null && rs.next()) {
					revisionNo = rs.getInt(1);
					rs.close();
				}
				rs = null;
			}
			return Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(revisionNo),false));
	} 
	
	
	/**
     * ***************************************************************************
     * Function Name    : insertIntoPMWtoWFQueues
     * Author           : Shweta Singhal
     * Date Written     : 25/11/2011
     * Input Parameters : Connection con, int targetProcessDefId, HashMap tMap, int processDefId, int dbType
     * Output Parameters: NONE
     * Return Value     : NONE
     * Description      : Fetch data from PMW Queue tables to WF Queue tables for the given processdefid of PMW process and return outputXML as StringBuffer
     * ****************************************************************************
     */
	//Sajid Khan		Changes Done for Queue conflict Management.  
    public static void insertIntoPMWtoWFQueues(Connection con, int targetProcessDefId, String processName, boolean updateQFlag, String locProcessName, int processDefId, int dbType, String engine, WFParticipant user) throws SQLException, JTSException, Exception {
    
    PreparedStatement pstmt = null;
    PreparedStatement pstmt1 = null;
    PreparedStatement pstmt3=null;
    PreparedStatement pstmt2 = null;
    Statement stmt = null;      
    ResultSet rs= null; 
    ResultSet rs1= null; 
    ResultSet rs2= null; 
    ResultSet rs3= null; 
    ResultSet rs4= null; 
    WFUserInfo userInfo = null; 
    String ColString = null;
    String status= null;
    String st= null; 
    int mainCode = 0;
    int subCode = 0;
    String subject = null;
    String descr = null;
    String errType = WFSError.WF_TMP;
    StringBuffer outputXML = null;
    //StringBuffer tempXml= null; 
    try {
     String queuename = null;
     int pmwQueueId = 0;
     int wfqueueId = 0;
     int revisionNo = 0;
     String filterOption = null;
     int orderBy = 0;
     int refreshInterval = 0;
     String queueType = null;
     String comments = null;
     String allowReassignment = null;
     String filterValue = null;
     String queueFilter = null;
     String sortOrder = null;
     //tempXml = new StringBuffer(100);
     String documentIndex = "";
     String pdbDocQuery = "";
     int pfeQueueId=0;
     int archiveQueueId=0;
     int activityId=0;
     int folderId = 0;
     String folderIndex = "";
     StringBuffer sbAddDoc = new StringBuffer(100);
     int userID = 0;
     int objTypeId = 0;
     String[] objectTypeStr = null;
     
     XMLGenerator gen = new XMLGenerator();
    // tempXml.append("<ConflictingQueueUserAssocs>\n");
     String queuenotexist= getdefaultqueue(con,dbType);
     
     pstmt = con.prepareStatement("select QueueId, QueueName from QueueDefTable "+ WFSUtil.getTableLockHintStr(dbType)+ " where QueueName= " + TO_STRING("SystemPFEQueue", true, dbType) + " OR QueueName = " + TO_STRING("SystemArchiveQueue", true, dbType) + " Order By QueueName ");
     rs1= pstmt.executeQuery();
     
     if(rs1.next()){
      archiveQueueId = rs1.getInt(1);
     }
     
     if(rs1.next()){
      pfeQueueId = rs1.getInt(1);
     }
     
     queuenotexist=queuenotexist.replace("[","");
     queuenotexist=queuenotexist.replace("]","");
     if(!queuenotexist.trim().isEmpty()|| !queuenotexist.equals("")){
      mainCode = WFSError.WM_SYSTEMQUEUE_NOT_EXISTS;
      subCode = 0;
      subject = WFSErrorMsg.getMessage(mainCode);
      subject=subject.concat(queuenotexist);
      descr = WFSErrorMsg.getMessage(subCode);
      errType = WFSError.WF_TMP;
      
      outputXML = new StringBuffer(500);
      outputXML.append(gen.createOutputFile("WFCheckInProcess"));
      outputXML.append("<Status>");
      outputXML.append(mainCode);
      outputXML.append("</Status>");
      outputXML.append("<Exception>");
      outputXML.append("<MainCode>");
      outputXML.append(mainCode);
      outputXML.append("</MainCode>");
      outputXML.append("<SubErrorCode>");
      outputXML.append(subCode);
      outputXML.append("</SubErrorCode>");
      outputXML.append("<TypeOfError>");
      outputXML.append(errType);
      outputXML.append("</TypeOfError>");
      outputXML.append("<Subject>");
      outputXML.append(subject);
      outputXML.append("</Subject>");
      outputXML.append("<Description>");
      outputXML.append(descr);
      outputXML.append("</Description>");
      outputXML.append("</Exception>");
      outputXML.append(gen.closeOutputFile("WFCheckInProcess"));
      
     }
     
     if(rs1 != null){
      rs1.close();
      rs1 = null;
     }  
     if(mainCode == 0){
      /*
      pstmt = con.prepareStatement("select PFEInterfaceId from PMWPRINTFAXEMAILTABLE where processdefid= ?");
      pstmt.setInt(1, processDefId);
      rs1= pstmt.executeQuery();
      while(rs1!=null && rs1.next()){
       activityId = rs1.getInt("PFEInterfaceId"); 
            
       pstmt = con.prepareStatement("insert into QueueStreamTable (ProcessDefId, QueueID, StreamId, ActivityId) select "+targetProcessDefId+", "+pfeQueueId+", 1, "+activityId+" from pmwqueuestreamtable where processdefid= ? and streamId = 1 and activityId= ?");
       pstmt.setInt(1, processDefId);
       pstmt.setInt(2, activityId);
       pstmt.execute();
      }
      
      if (rs1 != null) {
       rs1.close();
       rs1 = null;
      }
      
      printOut("[insertIntoPMWtoWFQueues] select ActivityId from PMWARCHIVETABLE where processdefid = ?");
      pstmt = con.prepareStatement("select ActivityId from PMWARCHIVETABLE where processdefid = ?");
      pstmt.setInt(1, processDefId);
      rs1= pstmt.executeQuery();
      while(rs1!=null && rs1.next()){
       activityId = rs1.getInt("ActivityId"); 
       printOut("[insertIntoPMWtoWFQueues] insert into QueueStreamTable (ProcessDefId, QueueID, StreamId, ActivityId) select "+targetProcessDefId+", "+archiveQueueId+", 1, "+activityId+" from pmwqueuestreamtable where processdefid= ? and streamId = 1 and activityId= ?");
   
       pstmt = con.prepareStatement("insert into QueueStreamTable (ProcessDefId, QueueID, StreamId, ActivityId) select "+targetProcessDefId+", "+archiveQueueId+", 1, "+activityId+" from pmwqueuestreamtable where processdefid= ? and streamId = 1 and activityId= ?");
       pstmt.setInt(1, processDefId);
       pstmt.setInt(2, activityId);
       pstmt.execute();
      }
      
      if (rs1 != null) {
       rs1.close();
       rs1 = null;
      } 
      */
      userID = user.getid();
      pstmt.close();
 
  //Check for queueid < 0
      pstmt1 = con.prepareStatement("select * from PMWQueueDefTable "+ WFSUtil.getTableLockHintStr(dbType)+" where ProcessDefId = ? and queueid < 0");
      pstmt1.setInt(1, processDefId);
      rs = pstmt1.executeQuery();
      printOut(engine," <insertIntoPMWtoWFQueues> ResultSet :: "+rs);
      
      String wfQueueName = null;
     // If queueId < 0  
      
      if(rs.next()){
       do{
		printOut(engine,"QueueId < 0 ");
        queuename = rs.getString("QUEUENAME"); 
        wfQueueName = queuename;
        if(updateQFlag){
         wfQueueName  = queuename.replace(locProcessName,processName);
        }
		printOut(engine,"wfQueueName ::" +wfQueueName);
        pmwQueueId = rs.getInt("QUEUEID"); 
        queueType = rs.getString("QueueType");
        comments = rs.getString("Comments");
        allowReassignment = rs.getString("AllowReassignment");
        filterValue = rs.getString("FilterValue");
        queueFilter = rs.getString("QueueFilter");
        sortOrder = rs.getString("SortOrder");
        
        /*Bug 31883 fixed*/
        filterOption = rs.getString("FilterOption");
        
        orderBy = rs.getInt("OrderBy");
        refreshInterval = rs.getInt("RefreshInterval");
        /* Bug 36167 fixed*/
        
 //qId < 0 and Queue exists.
        if(pstmt!=null){
            pstmt.close();
            pstmt=null;
         }
        pstmt = con.prepareStatement("select QUEUEID from queuedeftable " + WFSUtil.getTableLockHintStr(dbType)+ " where queuename = ?");
        WFSUtil.DB_SetString(1, wfQueueName.trim(), pstmt, dbType);
        rs1 = pstmt.executeQuery();
     
        stmt = con.createStatement();
//qid < 0 qname exists    
   if (rs1.next()) {
		printOut(engine,"QueueId < 0 and queue exists");
        wfqueueId = rs1.getInt("QUEUEID");
        
        
// overwriting queuedeftable if queueid < 0 and queue exists.
        if(pstmt!=null){
            pstmt.close();
            pstmt=null;
          }
		 printOut(engine,"Overwriting queuedeftable when queueid < 0 and queueexists.");
         pstmt = con.prepareStatement("update queuedeftable set QueueName= " + TO_STRING(wfQueueName, true, dbType) + ", QueueType= "+TO_STRING(queueType, true, dbType) + ", Comments= " +TO_STRING(comments, true, dbType) + ", AllowReassignment= " +TO_STRING(allowReassignment, true, dbType)+ ",FilterOption= " +WFSUtil.TO_SANITIZE_STRING(filterOption,true)+ ", FilterValue= " +TO_STRING(filterValue, true, dbType) + ", OrderBy= " +Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(orderBy),true))+ ", QueueFilter= " + TO_STRING(queueFilter, true, dbType) + ", RefreshInterval= " +Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(refreshInterval),true))+ ", SortOrder= " + TO_STRING(sortOrder, true, dbType) + ",LastModifiedOn= " + WFSUtil.getDate(dbType) +" where QueueId= ?");
         pstmt.setInt(1, wfqueueId);
         pstmt.execute(); 
         if(pstmt!=null){
             pstmt.close();
             pstmt=null;
          }
//Inserting missing rows in QueueStreamTable and WFlaneQueueTable .  
		 pstmt = con.prepareStatement("delete from QueueStreamTable where QueueID= ? and processdefid= ?");
         pstmt.setInt(1, wfqueueId);
         pstmt.setInt(2, targetProcessDefId);
		 pstmt.execute();
		 if(pstmt!=null){
		        pstmt.close();
		        pstmt=null;
		 }
		 ColString = getColString(con, "QueueStreamTable", dbType);
         ColString = ColString.toUpperCase();
         ColString = ColString.replace(",QueueId".toUpperCase(), "");
         ColString = ColString.replace("ProcessDefID,".toUpperCase(), "");
         if(queuename.equalsIgnoreCase("SystemPFEQueue")){
				wfqueueId = pfeQueueId;
		}else if(queuename.equalsIgnoreCase("SystemArchiveQueue")){
				wfqueueId = archiveQueueId ;
		 }
		 
		 printOut(engine,"Delted Entries from QueueStreamTable for QueueId = "+wfqueueId+ "and processdefID = "+targetProcessDefId);
		 
		 pstmt = con.prepareStatement("Insert into QueueStreamTable (QUEUEID, PROCESSDEFID, "+ColString+") select "+wfqueueId+","+targetProcessDefId+", "+ColString+" from pmwQueueStreamTable where QueueId = ? and processdefid =?");
         pstmt.setInt(1, pmwQueueId);
         pstmt.setInt(2, processDefId);
         pstmt.execute();
         if(pstmt!=null){
             pstmt.close();
             pstmt=null;
          }
		 printOut(engine,"Inserted Entries into  QueueStreamTable for QueueId = "+wfqueueId+ "and processdefID = "+targetProcessDefId);
         
		 pstmt = con.prepareStatement("delete from WFLaneQueueTable where QueueID= ? and processdefid= ?");
         pstmt.setInt(1, wfqueueId);
         pstmt.setInt(2, targetProcessDefId);
         pstmt.execute();
         if(pstmt!=null){
             pstmt.close();
             pstmt=null;
          }
		 printOut(engine,"Deleted  Entries from  WFLaneQueueTable for QueueId = "+wfqueueId+ "and processdefID = "+targetProcessDefId);
         
         pstmt = con.prepareStatement("Insert into WFLaneQueueTable (PROCESSDEFID,QUEUEID, Swimlaneid,DefaultQueue) select "+targetProcessDefId+","+wfqueueId+", swimlaneid ,DefaultQueue from  PMWLaneQueueTable where QueueId = ? and processdefid =?");
         pstmt.setInt(1, pmwQueueId);
         pstmt.setInt(2, processDefId);
         pstmt.execute();
         if(pstmt!=null){
             pstmt.close();
             pstmt=null;
             }
		 printOut(engine,"Inserted Entries into  WFLaneQueueTable for QueueId = "+wfqueueId+ "and processdefID = "+targetProcessDefId);
		 printOut(engine,"QueueName>>>>"+ queuename);
       
//code commnented for handling queue manangement.
		 /* pstmt = con.prepareStatement("select * from QueueUserTable where userid in(select userid from pmwqueueUsertable    where associationtype = 1 and queueid= ? and processdefid = ?) and queueid= ?");
         pstmt.setInt(1, pmwQueueId);
         pstmt.setInt(2, processDefId);
         pstmt.setInt(3, wfqueueId);
         rs1 = pstmt.executeQuery();
         if(rs1 != null && !rs1.next()){
         
          ColString = getColString(con, "QueueUserTable", dbType).toUpperCase();
          ColString = ColString.replace("QueueId,".toUpperCase(), "");
          ColString = ColString.replace(",RevisionNo".toUpperCase(), "");
          revisionNo = getRevisionNumber(con, stmt, dbType);
          
          printOut(" QueueUserTable RevisionNo 1::" + revisionNo);
          printOut("columnString of QueueUserTable ::" + ColString);
          printOut("[insertIntoPMWtoWFQueues] insert into QueueUserTable (QUEUEID, REVISIONNO, "+ColString+") select "+wfqueueId+","+revisionNo+", "+ColString+" from pmwqueueusertable where queueid= "+pmwQueueId+" and processdefid ="+processDefId+"");
          
          st = "insert into QueueUserTable (QUEUEID, REVISIONNO, "+ColString+") select "+wfqueueId+","+revisionNo+", "+ColString+" from pmwqueueusertable where queueid= "+pmwQueueId+" and processdefid ="+processDefId+" ";
          stmt.execute(st);
          
          }*/
 //Inserting Missing rows in QueueUserTable and overwriting if entry exists.
  
         pstmt = con.prepareStatement("select * from PMWQueueUserTable "+ WFSUtil.getTableLockHintStr(dbType)+" where ProcessDefId = ? and queueid = ?");
         pstmt.setInt(1, processDefId);
         pstmt.setInt(2, pmwQueueId);
         rs2 = pstmt.executeQuery();
         printOut(engine,"Fetching rows from pmwqueueusertable for local processId :"+processDefId+" >>>"+rs);
         
         while(rs2.next()){ 
         
         int userId1 = rs2.getInt("UserId");
         int assocType = rs2.getInt("AssociationType");
         String qryFilter = rs2.getString("QueryFilter");
         String assignedTime = rs2.getString("AssignedTillDATETIME");
         String qryPreview = rs2.getString("QueryPreview");
        
         //pstmt.close();
         
         pstmt2 = con.prepareStatement("select * from QueueUserTable " + WFSUtil.getTableLockHintStr(dbType)+" where userid =? and associationType = ? and queueid= ?");
         
         pstmt2.setInt(1, userId1);
         pstmt2.setInt(2, assocType);
         pstmt2.setInt(3, wfqueueId);
         
         rs3 = pstmt2.executeQuery();
         
         if(!rs3.next()){
       
          printOut(engine,"No Entry exists in queueusertable for userid ="+userId1+" and queueId ="+wfqueueId);
          ColString = getColString(con, "QueueUserTable", dbType).toUpperCase();
          ColString = ColString.replace("QueueId,".toUpperCase(), "");
          ColString = ColString.replace(",RevisionNo".toUpperCase(), "");
          revisionNo = getRevisionNumber(con, stmt, dbType);
          pstmt2.close();
          st = "insert into QueueUserTable (QUEUEID, REVISIONNO, "+ColString+") select "+wfqueueId+","+revisionNo+", "+ColString+" from pmwqueueusertable where queueid= "+pmwQueueId+" and userid =" +userId1+" and processdefid = "+processDefId+"and associationType = " +assocType+ "";
          stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
          printOut(engine,"Sucessful insertion in QueueUserTable for userId ="+userId1);
        }else{
        	pstmt2.close();
          printOut(engine,"Entry exists in queueusertable for userid ="+userId1+" and queueId ="+wfqueueId);
          pstmt2 = con.prepareStatement("update QueueUserTable set  AssignedTillDATETIME= " +TO_STRING(assignedTime, true, dbType) + ", QueryFilter= " +TO_STRING(qryFilter, true, dbType)+ ",QueryPreview = " +TO_STRING(qryPreview, true, dbType)+ " where QueueId = ? and userid = ? and associationType = ?");
         pstmt2.setInt(1, wfqueueId);
		 pstmt2.setInt(2, userId1);
		 pstmt2.setInt(3, assocType);
         pstmt2.execute(); 
         printOut(engine,"Updated the queueUsertable for userId ="+userId1);
         pstmt2.close();
          
          }
		if (rs3 != null) {
			rs3.close();
			rs3 = null;
        }
       }
		if (rs2 != null) {
			rs2.close();
			rs2 = null;
        }
		if(pstmt!=null){
			pstmt.close();
			pstmt=null;
		}
          
 //COde commented for handling conflict management.
          /* String key = null;
          String userName = "";
          int userid = 0;
          int associationType = 0;
          int revisionNoCopied = 0;
          String assignedTillDATETIME = null;
          String userqueryFilter = null;
          String queryPreview = null;
          int conflictId =0;
          printOut("[insertIntoPMWtoWFQueues] 11");*/
          /*if(!rs1.next()){
          /*
           printOut("[insertIntoPMWtoWFQueues] 22");
           
           userid = rs1.getInt("Userid");
           associationType = rs1.getInt("AssociationType");
           revisionNo = rs1.getInt("RevisionNo");
           assignedTillDATETIME = rs1.getString("AssignedTillDATETIME");
           userqueryFilter =rs1.getString("QueryFilter");
           queryPreview = rs1.getString("QueryPreview");
           
           pstmt = con.prepareStatement("select 1 from ConflictingQueueUserTable where revisionNo=?");
           pstmt.setInt(1, revisionNo);
           
           rs2 = pstmt.executeQuery();
           
           if(!rs2.next()){
            if (dbType != JTSConstant.JTS_MSSQL) {
             conflictId =Integer.parseInt(WFSUtil.nextVal(con, "ConflictIdSequence", dbType));
            }
            ColString = getColString(con, "ConflictingQueueUserTable", dbType);
            ColString = ColString.toUpperCase();
            ColString = ColString.replace(",ConflictId".toUpperCase(), "");
            ColString = ColString.replace("ProcessDefId,".toUpperCase(), "");
            
            printOut("columnString of QueueDefTable ::" + ColString);
            
            if (dbType == JTSConstant.JTS_MSSQL) {
             st= "insert into ConflictingQueueUserTable (QueueID, Userid, AssociationType, AssignedTillDATETIME, QueryFilter, QueryPreview, RevisionNo, ProcessDefId) values ( "+wfqueueId+", "+userid+", "+associationType+", "+TO_STRING(assignedTillDATETIME, true, dbType)+", "+ TO_STRING(userqueryFilter, true, dbType)+", "+TO_STRING(queryPreview, true, dbType)+", "+revisionNo+", "+targetProcessDefId+")";
            }else{
             st= "insert into ConflictingQueueUserTable (QueueID, Userid, AssociationType, AssignedTillDATETIME, QueryFilter, QueryPreview, RevisionNo, ProcessDefId, ConflictId) values ( "+wfqueueId+", "+userid+", "+associationType+", "+TO_STRING(assignedTillDATETIME, true, dbType)+", "+ TO_STRING(userqueryFilter, true, dbType)+", "+TO_STRING(queryPreview, true, dbType)+", "+revisionNo+", "+targetProcessDefId+" ,"+conflictId+")";
            }
            stmt.execute(st);
            if(dbType == JTSConstant.JTS_MSSQL){
             stmt.execute("Select @@IDENTITY");
             rs1 = stmt.getResultSet();
             if(rs1 != null && rs1.next()) {
              conflictId = rs1.getInt(1);
              rs1.close();
             }
             rs1 = null;
            }
           }*/
           //printOut("[insertIntoPMWtoWFQueues] insert into ConflictingQueueUserTable (QueueID, Userid, AssociationType, AssignedTillDATETIME, QueryFilter, QueryPreview, RevisionNo) values ( "+wfqueueId+", "+userid+", "+associationType+", "+TO_STRING(assignedTillDATETIME, true, dbType)+", "+ TO_STRING(userqueryFilter, true, dbType)+", "+TO_STRING(queryPreview, true, dbType)+", "+revisionNo+")");
           
           //stmt.execute("insert into ConflictingQueueUserTable (QueueID, Userid, AssociationType, AssignedTillDATETIME, QueryFilter, QueryPreview, RevisionNo) values ( "+wfqueueId+", "+userid+", "+associationType+", "+TO_STRING(assignedTillDATETIME, true, dbType)+", "+ TO_STRING(userqueryFilter, true, dbType)+", "+TO_STRING(queryPreview, true, dbType)+", "+revisionNo+")");
          /* key = "userIndex#"+String.valueOf(userid);
   
           userInfo = (WFUserInfo) CachedObjectCollection.getReference().getCacheObject(con,engine,targetProcessDefId, WFSConstant.CACHE_CONST_UserCache, key).getData();
           userName = userInfo.getUserName(); 
           
           tempXml.append("<ConflictingQueueUserAssoc>\n");
           tempXml.append(gen.writeValueOf("QueueID", String.valueOf(wfqueueId)));
           tempXml.append("\n");
           tempXml.append(gen.writeValueOf("QueueName", queuename));
           tempXml.append("\n");
           tempXml.append(gen.writeValueOf("UserId", String.valueOf(userid)));
           tempXml.append("\n");
           tempXml.append(gen.writeValueOf("UserName", userName));
           tempXml.append("\n");
           tempXml.append(gen.writeValueOf("AssociationType", String.valueOf(associationType)));
           tempXml.append("\n");
           tempXml.append(gen.writeValueOf("RevisionNo", String.valueOf(revisionNo)));
           tempXml.append("\n");
           tempXml.append("</ConflictingQueueUserAssoc>\n");
           
          } */
        /* else{                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
          ColString = getColString(con, "QueueUserTable", dbType).toUpperCase();
          ColString = ColString.replace("QueueId,".toUpperCase(), "");
          ColString = ColString.replace(",RevisionNo".toUpperCase(), "");
          revisionNo = getRevisionNumber(con, stmt, dbType);
          
          printOut(" QueueUserTable RevisionNo 1::" + revisionNo);
          printOut("columnString of QueueUserTable ::" + ColString);
          printOut("[insertIntoPMWtoWFQueues] insert into QueueUserTable (QUEUEID, REVISIONNO, "+ColString+") select "+wfqueueId+","+revisionNo+", "+ColString+" from pmwqueueusertable where queueid= "+pmwQueueId+" and processdefid ="+processDefId+"");
          
          st = "insert into QueueUserTable (QUEUEID, REVISIONNO, "+ColString+") select "+wfqueueId+","+revisionNo+", "+ColString+" from pmwqueueusertable where queueid= "+pmwQueueId+" and processdefid ="+processDefId+" ";
          stmt.execute(st);
   
         }*/
		 
		 
		 if (rs1 != null) {
				rs1.close();
				rs1 = null;
        }
        }
		
       // If 
     else{
    	 pstmt.close();
		 printOut(engine,"case for queueId < 0 and queue does not exists.");
         /*if (dbType != JTSConstant.JTS_MSSQL) {
          wfqueueId =Integer.parseInt(WFSUtil.nextVal(con, "QUEUEID", dbType));
         }*/
         ColString = getColString(con, "PMWQueueDefTable", dbType);
         ColString = ColString.toUpperCase();
         ColString = ColString.replace(",QueueID".toUpperCase(), "");
         ColString = ColString.replace("QueueName,".toUpperCase(), "");
         ColString = ColString.replace("ProcessDefId,".toUpperCase(), "");
         
         printOut(engine,"columnString of QueueDefTable ::" + ColString);
         if (dbType == JTSConstant.JTS_MSSQL) {
          printOut(engine,"[insertIntoPMWtoWFQueues] insert into queuedeftable (QueueName,"+ColString+", LastModifiedOn) select  "+TO_STRING(wfQueueName, true, dbType)+", "+ColString+", "+WFSUtil.getDate(dbType)+" from PMWQueueDefTable where QueueName= " + TO_STRING(queuename, true, dbType) + " and processdefid = "+ processDefId +" ");
         }else {
          printOut(engine,"[insertIntoPMWtoWFQueues] insert into queuedeftable (QueueName, "+ColString+", LastModifiedOn) select  "+TO_STRING(wfQueueName, true, dbType)+", "+ColString+", "+WFSUtil.getDate(dbType)+"  from PMWQueueDefTable  where QueueName= " + TO_STRING(queuename, true, dbType) + " and processdefid = "+ processDefId +" ");
         }
   
         if (dbType == JTSConstant.JTS_MSSQL) {
          st = "insert into queuedeftable (QueueName,"+ColString+", LastModifiedOn) select "+TO_STRING(wfQueueName, true, dbType)+","+ColString+","+WFSUtil.getDate(dbType)+" from pmwqueuedeftable where QueueName= " + TO_STRING(queuename, true, dbType) + "and processdefid = "+ processDefId +" ";
         }else {
          /*Bug 36021 fixed*/
          st = "insert into queuedeftable (QueueName,"+ColString+", LastModifiedOn) select "+TO_STRING(wfQueueName, true, dbType)+","+ColString+","+WFSUtil.getDate(dbType)+" from PMWQueueDefTable  where QueueName= " + TO_STRING(queuename, true, dbType) + " and processdefid = "+ processDefId +" ";
         }
         stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
         if(dbType == JTSConstant.JTS_MSSQL){
          stmt.execute("Select @@IDENTITY");
          rs1 = stmt.getResultSet();
          if(rs1 != null && rs1.next()) {
           wfqueueId = rs1.getInt(1);
           rs1.close();
          }
          rs1 = null;
         }
         if(dbType != JTSConstant.JTS_MSSQL){
          st = "select queueid from QueueDefTable " + WFSUtil.getTableLockHintStr(dbType)+" where queueName = "+ TO_STRING(wfQueueName, true, dbType) + " ";
          rs1 = stmt.executeQuery(WFSUtil.TO_SANITIZE_STRING(st,true));
          if(rs1.next())
           wfqueueId = rs1.getInt("queueid");
         }
         if(processName!=null&&!processName.equalsIgnoreCase(locProcessName)){
        	 String queueUpdate="Update QueueDefTable set ProcessName="+TO_STRING(processName, true, dbType)+" where queueid=?";
        	 pstmt3=con.prepareStatement(queueUpdate);
        	 pstmt3.setInt(1, wfqueueId);
        	 int k1=pstmt3.executeUpdate();
        	 if(pstmt3!=null){
        		 pstmt3.close();
        		 pstmt3=null;
        	 }
        	 
         }
         
         //Default values for variableid to be inserted into WFWorkListConfigTable for the default queues-OF MObile Requiremetn
         insertIntoWFWorkListConfig(con,wfqueueId,engine);
         ColString = getColString(con, "QueueStreamTable", dbType);
         ColString = ColString.toUpperCase();
         ColString = ColString.replace(",QueueId".toUpperCase(), "");
         ColString = ColString.replace("ProcessDefID,".toUpperCase(), "");
         
         printOut(engine,"columnString of QueueStreamTable ::" + ColString);
         
         if(queuename.equalsIgnoreCase("SystemPFEQueue")){
          wfqueueId = pfeQueueId;
         }else if(queuename.equalsIgnoreCase("SystemArchiveQueue")){
          wfqueueId = archiveQueueId;
         }
         printOut(engine,"[insertIntoPMWtoWFQueues] Insert into QueueStreamTable (QUEUEID, PROCESSDEFID, "+ColString+") select "+wfqueueId+","+targetProcessDefId+", "+ColString+" from pmwQueueStreamTable where QueueId = "+pmwQueueId+" and processdefid ="+processDefId+"");
          
         pstmt = con.prepareStatement("Insert into QueueStreamTable (QUEUEID, PROCESSDEFID, "+ColString+") select "+wfqueueId+","+targetProcessDefId+", "+ColString+" from pmwQueueStreamTable where QueueId = ? and processdefid =?");
         pstmt.setInt(1, pmwQueueId);
         pstmt.setInt(2, processDefId);
         pstmt.execute();
         
         ColString = getColString(con, "QueueUserTable", dbType);
         ColString = ColString.toUpperCase();
         ColString = ColString.replace("QueueId,".toUpperCase(), "");
         ColString = ColString.replace(",RevisionNo".toUpperCase(), "");
         revisionNo = getRevisionNumber(con, stmt, dbType);
         
         printOut(engine," QueueUserTable RevisionNo 2::" + revisionNo);
         printOut(engine,"columnString of QueueUserTable ::" + ColString);
         
         printOut(engine,"[insertIntoPMWtoWFQueues] insert into QueueUserTable (QUEUEID, REVISIONNO, "+ColString+")  select  "+wfqueueId+","+revisionNo+", "+ColString+" from PMWQueueUserTable where QueueId= " + pmwQueueId + " and processdefid ="+processDefId+"");
         
         st = "insert into QueueUserTable (QUEUEID, REVISIONNO, "+ColString+")  select  "+wfqueueId+","+revisionNo+", "+ColString+" from PMWQueueUserTable where QueueId= " + pmwQueueId + " and processdefid ="+processDefId+"";
         stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
         
         
         printOut(engine,"[insertIntoPMWtoWFQueues]insert into WFLaneQueueTable (QUEUEID, PROCESSDEFID, SwimLaneId, DefaultQueue)  select  "+wfqueueId+","+targetProcessDefId+", SwimLaneId, DefaultQueue from PMWLaneQueueTable where QueueId= " + pmwQueueId + " and processdefid ="+processDefId+"");
         
         st = "insert into WFLaneQueueTable (QUEUEID, PROCESSDEFID, SwimLaneId, DefaultQueue)  select  "+wfqueueId+","+targetProcessDefId+", SwimLaneId ,DefaultQueue from PMWLaneQueueTable where QueueId= " + pmwQueueId + " and processdefid ="+processDefId+"";
         stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
         
         //Provide full rights to the owner of queue
         objectTypeStr = getIdForName(con, dbType, WFSConstant.CONST_OBJTYPE_QUEUE, "O");
         objTypeId = Integer.parseInt(objectTypeStr[1]);
         associateObjectsWithUser(stmt, dbType, userID, 0, wfqueueId, objTypeId, 0, WFSConstant.CONST_DEFAULT_QUEUE_RIGHTSTR, null, 'I',engine);
         
         
         /*
          * Make a new entry into PDBDocument also for this Queue.
          */
          
         if(dbType != JTSConstant.JTS_MSSQL){
          documentIndex = WFSUtil.nextVal(con, "DocumentId", dbType);
         }
         pdbDocQuery = WFTMSUtil.getPDBDocQuery(documentIndex, dbType, user, wfQueueName);
         stmt.execute(pdbDocQuery);
         if(dbType == JTSConstant.JTS_MSSQL){
    //        stmt.execute("Select DocumentIndex from PDBDocument Where Name = '"+ name + "'");
          stmt.execute("Select @@IDENTITY");
          rs1 = stmt.getResultSet();
   
          if(rs1 != null && rs1.next()) {
           documentIndex = rs1.getString(1);
           rs1.close();
          }
          rs1 = null;
         }
         //Get Folder Index for QueueFolder...
                              // Changes done for removing OD dependency for rights checking
         //WFTMSUtil.printOut("CachedCollection Object Cabinet Prop Folder Id :::= "+CachedObjectCollection.getReference().getCacheObject(con,engine,processDefId, WFSConstant.CACHE_CONST_CabinetPropertyCache, WFTMSConstants.PDB_QUEUE_FOLDER).getData());
         /*folderIndex = (String) CachedObjectCollection.getReference().getCacheObject(con,engine,processDefId, WFSConstant.CACHE_CONST_CabinetPropertyCache, WFTMSConstants.PDB_QUEUE_FOLDER).getData();
         folderId = Integer.parseInt(folderIndex);       
   
         stmt.execute("select " + WFSUtil.isnull("max(DocumentOrderNo)", "0", dbType) + " + 1 from PDBDocumentcontent where ParentFolderIndex= " + folderId);
   
         rs1 = stmt.getResultSet();
         int order = 0;
         if(rs1.next())
          order = rs1.getInt(1);
         sbAddDoc = new StringBuffer(100);
         sbAddDoc.append("Insert Into PDBDocumentContent (ParentFolderIndex, DocumentIndex, FiledBy, FiledDatetime,DocumentOrderNo, RefereceFlag, DocStatus ) ");
         sbAddDoc.append("values(" + folderId);
         sbAddDoc.append("," + documentIndex);
         sbAddDoc.append(", 1, ").append(WFSUtil.getDate(dbType)).append(",");
         sbAddDoc.append(order);
         sbAddDoc.append(", 'O', 'A')");
         stmt.execute(sbAddDoc.toString());
         if(rs1 != null){
          rs1.close();
          rs1 = null;
         }*/
        }
      }while(rs.next());
     }
      else{ 
    	  pstmt.close();
	  stmt = con.createStatement();
	  printOut(engine,"Handling case for queuId > 0 when conflcit has been managed at pmweb end");
      pstmt = con.prepareStatement("select * from PMWQueueDefTable "+ WFSUtil.getTableLockHintStr(dbType)+" where ProcessDefId = ? and queueid > 0");
      pstmt.setInt(1, processDefId);
	  rs1 = pstmt.executeQuery();
     
	  printOut(engine,"Record found for positive queueId for ProcessDefId ="+processDefId);
     // wfQueueName = null;
   
	  if(rs1.next()){
	       do{
			printOut(engine,"Record found for positive queueId for ProcessDefId ="+processDefId);
			queuename = rs1.getString("QUEUENAME"); 
			wfQueueName = queuename;
        if(updateQFlag){
			wfQueueName  = queuename.replaceFirst(locProcessName,processName);
			}
			pmwQueueId = rs1.getInt("QUEUEID"); 
			queueType = rs1.getString("QueueType");
			comments = rs1.getString("Comments");
			allowReassignment = rs1.getString("AllowReassignment");
			filterValue = rs1.getString("FilterValue");
			queueFilter = rs1.getString("QueueFilter");
			sortOrder = rs1.getString("SortOrder");
			filterOption = rs1.getString("FilterOption");
			orderBy = rs1.getInt("OrderBy");
			refreshInterval = rs1.getInt("RefreshInterval");
   
//overwriting queuedeftable when queueid > 0 in pmwqueuedeftable
			printOut(engine,"Overwriting QueueDefTable for QueueId = "+ pmwQueueId);
			pstmt = con.prepareStatement("update queuedeftable set QueueName= " + TO_STRING(wfQueueName, true, dbType) + ", QueueType= " +TO_STRING(queueType, true, dbType) + ", Comments= " +TO_STRING(comments, true, dbType) + ", AllowReassignment= " +TO_STRING(allowReassignment, true, dbType)+ ",FilterOption= " +WFSUtil.TO_SANITIZE_STRING(filterOption,true)+ ", FilterValue= " +TO_STRING(filterValue, true, dbType) + ", OrderBy= " +Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(orderBy),true))+ ", QueueFilter= " + TO_STRING(queueFilter, true, dbType) + ", RefreshInterval= " +Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(refreshInterval),true))+ ", SortOrder= " + TO_STRING(sortOrder, true, dbType) + ",LastModifiedOn = "+ WFSUtil.getDate(dbType)+ " where QueueId= ?");
			pstmt.setInt(1, pmwQueueId);
			pstmt.execute(); 
         
// MAnaging queuestreamtable and WFLaneQueueTable
		 pstmt = con.prepareStatement("delete from QueueStreamTable where QueueID= ? and processdefid= ?");
         pstmt.setInt(1, pmwQueueId);
         pstmt.setInt(2, targetProcessDefId);
		 pstmt.execute();
		 ColString = getColString(con, "QueueStreamTable", dbType);
         ColString = ColString.toUpperCase();
         ColString = ColString.replace(",QueueId".toUpperCase(), "");
         ColString = ColString.replace("ProcessDefID,".toUpperCase(), "");
         if(queuename.equalsIgnoreCase("SystemPFEQueue")){
				pmwQueueId = pfeQueueId;
		 }else if(queuename.equalsIgnoreCase("SystemArchiveQueue")){
				pmwQueueId = archiveQueueId ;
		 }
		 
		 printOut(engine,"Delted Entries from QueueStreamTable for QueueId = "+pmwQueueId+ "and processdefID = "+targetProcessDefId);
		 
		 pstmt = con.prepareStatement("Insert into QueueStreamTable (QUEUEID, PROCESSDEFID, "+ColString+") select "+pmwQueueId+","+targetProcessDefId+", "+ColString+" from pmwQueueStreamTable where QueueId = ? and processdefid =?");
         pstmt.setInt(1, pmwQueueId);
         pstmt.setInt(2, processDefId);
         pstmt.execute();
		 
		 printOut(engine,"Inserted Entries into  QueueStreamTable for QueueId = "+pmwQueueId+ "and processdefID = "+targetProcessDefId);
         
		 pstmt = con.prepareStatement("delete from WFLaneQueueTable where QueueID= ? and processdefid= ?");
         pstmt.setInt(1, pmwQueueId);
         pstmt.setInt(2, targetProcessDefId);
         pstmt.execute();
		 
		 printOut(engine,"Deleted  Entries from  WFLaneQueueTable for QueueId = "+pmwQueueId+ "and processdefID = "+targetProcessDefId);
         
         pstmt = con.prepareStatement("Insert into WFLaneQueueTable (PROCESSDEFID,QUEUEID, Swimlaneid, DefaultQueue) select "+targetProcessDefId+","+pmwQueueId+", swimlaneid, DefaultQueue from  PMWLaneQueueTable where QueueId = ? and processdefid =?");
         pstmt.setInt(1, pmwQueueId);
         pstmt.setInt(2, processDefId);
         pstmt.execute();
     
		 printOut(engine,"Inserted Entries into  WFLaneQueueTable for QueueId = "+pmwQueueId+ "and processdefID = "+targetProcessDefId);
		 printOut(engine,"QueueName>>>>"+ queuename);
       

   //Managing QueueUserTable for queueId > 0.
         
         pstmt = con.prepareStatement("select * from PMWQueueUserTable "+ WFSUtil.getTableLockHintStr(dbType)+" where ProcessDefId = ? and queueid = ?");
         pstmt.setInt(1, processDefId);
		 pstmt.setInt(2, pmwQueueId);
         rs2 = pstmt.executeQuery();
         printOut(engine,"Fetching record from pmwQueueUsertable for +ve QueuId for processid = "+processDefId);
 
    while(rs2.next()){
         int userId1 = rs2.getInt("UserId");
         int assocType = rs2.getInt("AssociationType");
         String qryFilter = rs2.getString("QueryFilter");
         String assignedTime = rs2.getString("AssignedTillDATETIME");
         String qryPreview = rs2.getString("QueryPreview");
      
		 pstmt = con.prepareStatement("select * from QueueUserTable "+ WFSUtil.getTableLockHintStr(dbType)+" where userid =? and associationTYpe = ?  and queueid= ?");
         pstmt.setInt(1, userId1);
         pstmt.setInt(2, assocType);
         pstmt.setInt(3, pmwQueueId);      
         rs3 = pstmt.executeQuery();
         
    if(!rs3.next()){
          printOut(engine,"Inserting missig rows in  QueueUserTable for QueueId,UserId>>"+pmwQueueId+" ,"+userId1 );
          ColString = getColString(con, "QueueUserTable", dbType).toUpperCase();
          ColString = ColString.replace("QueueId,".toUpperCase(), "");
          ColString = ColString.replace(",RevisionNo".toUpperCase(), "");
          revisionNo = getRevisionNumber(con, stmt, dbType);
          
          st = "insert into QueueUserTable (QUEUEID, REVISIONNO, "+ColString+") select "+pmwQueueId+","+revisionNo+", "+ColString+" from pmwqueueusertable where queueid= "+pmwQueueId+" and userid =" +userId1+" and processdefid = "+processDefId+"and associationType = " +assocType+ "";
          stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
          printOut(engine,"Sucessful insertion in QueueUserTable for userId ="+userId1);
          }else{
    
			printOut(engine,"Overwriting QueueUserTable for +ve QueueId whose data is availabe in queueusertable for QueueId,UserId>>"+pmwQueueId+" ,"+userId1 );
			pstmt = con.prepareStatement("update QueueUserTable set    AssignedTillDATETIME= " +TO_STRING(assignedTime, true, dbType) + ", QueryFilter= " +TO_STRING(qryFilter, true, dbType)+ ",QueryPreview = " +WFSUtil.TO_STRING(qryPreview, true, dbType)+ ", RevisionNo = " +revisionNo+ "where userid= ? and associationType =? and queueid =?");
			pstmt.setInt(1, userId1);
			pstmt.setInt(2, assocType);
			pstmt.setInt(3, pmwQueueId);
			pstmt.execute(); 
          
          }
		  if (rs3 != null) {
			rs3.close();
			rs3 = null;
          }
		 } 
		if (rs2 != null) {
			rs2.close();
			rs2 = null;
          }
         } while(rs1.next());// end of do while  statement
        }
        if (rs1 != null) {
			rs1.close();
			rs1 = null;
        }
       }
      pstmt1.close();
      }
    } 
     
     //tempXml.append("</ConflictingQueueUserAssocs>\n"); 
     finally {
    	 try {  
				if(rs!=null){
					rs.close();
					rs = null;
				}
			}catch(Exception e){
				WFSUtil.printErr(engine,"", e);
			}
    	 try {  
				if(rs1!=null){
					rs1.close();
					rs1 = null;
				}
			}catch(Exception e){
				WFSUtil.printErr(engine,"", e);
			}
    	 try {  
				if(rs2!=null){
					rs2.close();
					rs2 = null;
				}
			}catch(Exception e){
				WFSUtil.printErr(engine,"", e);
			}
    	 try {  
				if(rs3!=null){
					rs3.close();
					rs3 = null;
				}
			}catch(Exception e){
				WFSUtil.printErr(engine,"", e);
			}
    	 try {  
				if(rs4!=null){
					rs4.close();
					rs4 = null;
				}
			}catch(Exception e){
				WFSUtil.printErr(engine,"", e);
			}
    	 try{
				if(stmt!=null){
					stmt.close();
					stmt = null;
				} 
			}catch(Exception e){
				WFSUtil.printErr(engine,"", e);
			}
    	 try{
				if(pstmt!=null){
					pstmt.close();
					pstmt = null;
				} 
			}catch(Exception e){
				WFSUtil.printErr(engine,"", e);
			}
    	 try{
				if(pstmt2!=null){
					pstmt2.close();
					pstmt2 = null;
				} 
			}catch(Exception e){
				WFSUtil.printErr(engine,"", e);
			}
    	 try{
				if(pstmt1!=null){
					pstmt1.close();
					pstmt1= null;
				} 
			}catch(Exception e){
				WFSUtil.printErr(engine,"", e);
			}
    	 
    	 try{
    		 if(pstmt3!=null){
        		 pstmt3.close();
        		 pstmt3=null;
        	 }
    	 }catch(Exception e){
				WFSUtil.printErr(engine,"", e);
			}
     
    }
    if(mainCode != 0){
        throw new WFSException(mainCode, subCode, errType, subject, descr, outputXML.toString());
       }
	//tempXml.append("</ConflictingQueueUserAssocs>\n"); 
   //return tempXml;
 }

	
	
	 /**
     * ***************************************************************************
     * Function Name    : insertIntoPMW
     * Author           : Shweta Singhal
     * Date Written     : 14/10/2011
     * Input Parameters : Connection con,String processName, int targetProcessDefId, HashMap tMap,
                         int processDefId, Boolean isVersionExists, String checkOutIPAddress, int dbType
     * Output Parameters: NONE
     * Return Value     : String
     * Description      : Fetches data from web to the wftables.
     * ****************************************************************************
     */
    public static void insertIntoPMW(Connection con,String processName, int targetProcessDefId, HashMap tMap, int processDefId, boolean isNewVersion, String checkOutIPAddress, int dbType, boolean saveAsLocal, String newProcessName,String engine, int userID,int sessionID,XMLGenerator gen,boolean validateFlag) throws SQLException {
        PreparedStatement pstmt = null;
        Statement stmt = null;        
        String wfColString = null;
        String ColString = null;
        String status= null;
        String st= null;	
        StringBuffer qBuffer = null;
		boolean brmsFlag1 = false;
        boolean restFlag = false; 
        boolean soapWebServiceFlag=false;
        PreparedStatement pstmt1 = null;
        PreparedStatement pstmt2 = null;
        PreparedStatement pstmt3 = null;
        ResultSet res2 = null;
        ResultSet res1 = null;
		//boolean brmsFlag2 = false;
        try {
            stmt = con.createStatement();
            
			if(isNewVersion){
				status = "N";
			} else {
				status = "O";
			}
			if(!saveAsLocal){
				st= "insert into CHECKOUTPROCESSESTABLE (processdefid, processname, CheckOutIPAddress, CheckOutPath, ProcessStatus, userID) values (" + processDefId + ", " + TO_STRING(processName, true, dbType) + ", " +TO_STRING(checkOutIPAddress, true, dbType) + ", " + TO_STRING("PMWCheckOut" , true, dbType) + ", '" + status +"'" + "," + userID + ")";
				printOut(engine,"[WFSUtil]insertIntoPMW Query : " + st);
				stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
				st= "insert into PMWRegprocessmappingTable (localprocessdefid,registeredprocessdefid) values(" + targetProcessDefId + "," + processDefId + ")";
				printOut(engine,"[WFSUtil]insertIntoPMW Query : " + st);
				stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
			}
            Iterator itr = tMap.keySet().iterator();
            int flag = 0;
            StringBuffer pVarStr = null;
            while (itr.hasNext()) {
                pVarStr = new StringBuffer();
                String tablename = (String) itr.next();
                ColString = getColString(con, tablename, dbType).toUpperCase();
                String pmwTableName = (String) tMap.get(tablename);
                printOut(engine,"[WFSUtil]CheckOutProcess Tables:: "+tablename);
                //WFSUtil.printOut("ColString for PMW in CheckOUt PRocess before>>"+ColString);
                if(ColString.contains("PROCESSVARIANTID")){//Process Variant Support Changes
                    ColString = ColString.replace(",PROCESSVARIANTID", "");
                    pVarStr.append(" AND PROCESSVARIANTID = 0");
                }else{
                    pVarStr.append("");
                }
                if(ColString.indexOf(",") != -1)
                    wfColString = ColString.substring(ColString.indexOf(","));
                //WFSUtil.printOut("ColString for PMW in CheckOUt PRocess after>>"+ColString);
                
                //WFSUtil.printOut("[insertintoPMW] wfcolstring final>>"+wfColString+" and pvarString>>"+pVarStr);
                /*Bug 32902 fixed*/
                if(saveAsLocal){
                	//Bug 72265 copy TaskTableFlag as C in PMWTaskDefTable if doing save as Local
                	if("WFTaskDefTable".equalsIgnoreCase(tablename)){//WFTaskTemplateFieldDefTable
                		//Checking if this process is having any tasks with variables(condition to create the task table)
                		String updatedColumnList = wfColString.replace("TASKTABLEFLAG", "?");
                		updatedColumnList = updatedColumnList.replace("TASKID", "?");
                		pstmt3 = con.prepareStatement("insert into " + WFSUtil.TO_SANITIZE_STRING(pmwTableName,false) + " (" + ColString + ") select  "+targetProcessDefId+" " 
                									+ updatedColumnList + " from " + WFSUtil.TO_SANITIZE_STRING(tablename,false) + getTableLockHintStr(dbType) 
                									+ " where ProcessDefId=" + processDefId + pVarStr.toString() +" and TaskId=?");
                		
                		pstmt1 = con.prepareStatement("select taskid from wftaskdeftable " + getTableLockHintStr(dbType) + " where processdefid = ?");
                		pstmt1.setInt(1, processDefId);
                		res1 = pstmt1.executeQuery();
                		while(res1.next()){
                			int taskId = res1.getInt(1);
        					pstmt3.setInt(1, taskId);
                			pstmt2 = con.prepareStatement("select 1 from WFTaskTemplateFieldDefTable " + getTableLockHintStr(dbType) 
                										+ " where processdefid = ? and taskid = ?");
                			pstmt2.setInt(1, processDefId);
                			pstmt2.setInt(2, taskId);
                			res2 = pstmt2.executeQuery();
                			if(res2.next()){
                				int hasVarsInTask = res2.getInt(1);
                				if(hasVarsInTask == 1){
                					//pstmt3.setString(2, "C");
                					DB_SetString(2, "C", pstmt3, dbType);
                				}else{
                					DB_SetString(2, "N", pstmt3, dbType);
                				}
                			}else{
                				DB_SetString(2, "N", pstmt3, dbType);
                			}
                			pstmt3.setInt(3, taskId);
                			pstmt3.addBatch();
                			res2.close();
                			pstmt2.close();
                		}
            			int[] result = pstmt3.executeBatch();
            			pstmt3.close();
                		res1.close();
                		pstmt1.close();
                	}else if(!(tablename.equalsIgnoreCase("WFLaneQueueTable") || tablename.equalsIgnoreCase("QueueStreamTable"))){
                        st = "insert into " + WFSUtil.TO_SANITIZE_STRING(pmwTableName,false) + " (" + ColString + ") select  "+targetProcessDefId+"    " + wfColString + " from " + tablename + getTableLockHintStr(dbType) + " where ProcessDefId=" + processDefId + "";
                        st = st + pVarStr.toString();
                        printOut(engine,"[WFSUtil]CheckOutProcess Insert Query :: "+st);
                        stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
                    }else{
                        wfColString  = wfColString.toUpperCase().replace("QueueID".toUpperCase(),"-QueueID");
                        pmwTableName = (String) tMap.get(tablename); 
                        st = "insert into " + WFSUtil.TO_SANITIZE_STRING(pmwTableName,false) + " ("+ ColString + ") select "+targetProcessDefId+" " + wfColString + " from " + tablename + getTableLockHintStr(dbType) + " where ProcessDefId=" + processDefId + "";
                        st = st + pVarStr.toString();
                        printOut(engine,"[WFSUtil]CheckOutProcess Insert Query :: "+st);
                        /* 24/12/2012  Anwar Ali Danish Bug 36775 - Data inconsistency in JMS Producer tab*/
                        flag = stmt.executeUpdate(WFSUtil.TO_SANITIZE_STRING(st,true));
                        if("PMWJMSPublishTable".equalsIgnoreCase(pmwTableName) && flag > 0)
                                transferJMSData(con, true, targetProcessDefId, processDefId, dbType);
						// Bug 39613 - Fixed
						if("pmwjmssubscribetable".equalsIgnoreCase(pmwTableName) && flag > 0)
							transferJMSSubscriberData(con, true, targetProcessDefId, processDefId, dbType);
							
						if("PMWBRMSActivityAssocTable".equalsIgnoreCase(pmwTableName) && flag > 0){
							brmsFlag1 = true; 							
						}
						
//						if(pmwTableName.equalsIgnoreCase("PMWBRMSMappingTable") && flag > 0){
//							brmsFlag2 = true; 							
//						}
						
						
                                                if(tablename.equalsIgnoreCase("PMWRestActivityAssocTable") && flag > 0){
                                                    restFlag = true;						
                                                }
                                                if(tablename.equalsIgnoreCase("PMWWebserviceTable") && flag > 0){
                                                	soapWebServiceFlag = true;						
                                                }
						
							
                    }
                } else {
                    st = "insert into " + WFSUtil.TO_SANITIZE_STRING(pmwTableName,false) + " (" + ColString + ") select  "+targetProcessDefId+"    " + wfColString + " from " + tablename +  getTableLockHintStr(dbType) + " where ProcessDefId=" + processDefId + "";
                    st = st + pVarStr.toString();
                    printOut(engine,"[WFSUtil]CheckOutProcess Insert Query :: "+st);
                    //stmt.execute(st);
                    /* 24/12/2012  Anwar Ali Danish Bug 36775 - Data inconsistency in JMS Producer tab*/
                    flag = stmt.executeUpdate(WFSUtil.TO_SANITIZE_STRING(st,true));
                    if("PMWJMSPublishTable".equalsIgnoreCase(pmwTableName) && flag > 0)
                        transferJMSData(con, true, targetProcessDefId, processDefId, dbType);
						// Bug 39613 - Fixed
					if("pmwjmssubscribetable".equalsIgnoreCase(pmwTableName) && flag > 0)
						transferJMSSubscriberData(con, true, targetProcessDefId, processDefId, dbType);
						
					if("PMWBRMSActivityAssocTable".equalsIgnoreCase(pmwTableName) && flag > 0){
						brmsFlag1 = true; 							
					}
						
//					if(pmwTableName.equalsIgnoreCase("PMWBRMSMappingTable") && flag > 0){
//						brmsFlag2 = true; 							
//					}
                                        if("PMWRestActivityAssocTable".equalsIgnoreCase(pmwTableName) && flag > 0){
						restFlag = true; 							
					}
                      if("PMWWebserviceTable".equalsIgnoreCase(pmwTableName) && flag > 0){
                             soapWebServiceFlag = true;						
                        }
						
					
					
                }
            } 
            
            if(brmsFlag1){
				transferBRMSData(con, true, targetProcessDefId, processDefId, dbType,engine);
			}
            if(restFlag){
                transferRESTData(con, true, targetProcessDefId, processDefId, dbType,engine);
            }
            if(soapWebServiceFlag){
            	transferWebServiceData(con, true, targetProcessDefId, processDefId, dbType,engine);
            }
            transferExternalMethodData(con, true, targetProcessDefId, processDefId, dbType, engine);
            if(saveAsLocal) {
                qBuffer = new StringBuffer(200);
                ColString = getColString(con, "QueueDefTable", dbType);
                ColString = ColString.toUpperCase();
                printOut(engine,"<InsertIntoPMW>ColString::"+ColString);
                ColString = ColString.replace(",LASTMODIFIEDON".toUpperCase(),"");
                ColString = ColString.replace(",QUEUENAME".toUpperCase(),"");
                wfColString  = ColString.replace("QueueID".toUpperCase(),"-QueueID");
                ColString = "QUEUENAME," + ColString;
                //wfColString ="QUEUENAME," +wfColString.replace(",QUEUENAME".toUpperCase(),"");
                /*Bug 35523 Fixed*/
                qBuffer.append("insert into PMWQueueDefTable (ProcessDefId, "+ ColString + ") select "+targetProcessDefId+", replace(QueueName, "+TO_STRING(processName, true, dbType) + ", "+TO_STRING(newProcessName, true, dbType) + ") QueueName," + wfColString + " from QueueDefTable "+ getTableLockHintStr(dbType) + " where QueueId in (select QueueId from QueueStreamTable " +  getTableLockHintStr(dbType)  + " where ProcessDefId=" + processDefId + " UNION select QueueId from WFLaneQueueTable " + getTableLockHintStr(dbType) +" where ProcessDefId=" + processDefId + ")");

                printOut(engine,"[WFSUtil]CheckOutProcess Insert Query in PMWQueueDefTable:: "+qBuffer.toString());
                stmt.addBatch(qBuffer.toString());
                				
                qBuffer = new StringBuffer(200);
                ColString = getColString(con, "QueueUserTable", dbType);
                ColString = ColString.toUpperCase();
                wfColString  = ColString.replace("QueueID".toUpperCase(),"-QueueID");
                /*Bug 35523 Fixed*/
				/* 18/12/2012, BUG 36612 fixed.(extra bracket removed). - Sajid Khan */
                qBuffer.append("insert into PMWQueueUserTable (ProcessDefId, "+ ColString + ") select "+targetProcessDefId+", " + wfColString + " from QueueUserTable " + getTableLockHintStr(dbType) +" where QueueId in (select QueueId from QueueStreamTable "+ getTableLockHintStr(dbType) +" where ProcessDefId=" + processDefId + " UNION select QueueId from WFLaneQueueTable "+ getTableLockHintStr(dbType) + " where ProcessDefId=" + processDefId + ")");
                
                printOut(engine,"[WFSUtil]CheckOutProcess Insert Query in PMWQueueUserTable:: "+qBuffer.toString());
		stmt.addBatch(WFSUtil.TO_SANITIZE_STRING(qBuffer.toString(),true));
                int[] resArray = stmt.executeBatch();                
            } 
            
            try{
            	String pMValidateProcess="Y";
            	
            	if(validateFlag)
            	{
                String pMValidateProcessInput = "<?xml version=\"1.0\"?>"+
                        "<PMValidateProcess_Input><Option>PMValidateProcess</Option>" +
                        "<EngineName>"+engine+"</EngineName><UserDBId>"+sessionID+"</UserDBId>" +
                        "<UserId>"+userID+"</UserId><ProcessDefId>"+targetProcessDefId+"</ProcessDefId>"+
                     "<Action>RE</Action><ProcessVariantType>S</ProcessVariantType><CustomHook>N</CustomHook>"+
                "<AllowCaseInDistr>N</AllowCaseInDistr><ViewValidation>N</ViewValidation><DistincVolIdFlag>N</DistincVolIdFlag></PMValidateProcess_Input>";
                
                
                XMLParser parser1 = new XMLParser();
                parser1.setInputXML(pMValidateProcessInput);
                String pMValidateProcessOutput= WFFindClass.getReference().execute("PMValidateProcess", engine, con, parser1,gen);
                
                parser1.setInputXML(pMValidateProcessOutput);
                int errorCount = parser1.getIntOf("ErrorCount", 0, true);

                if(errorCount>0)
                {
                	pMValidateProcess  ="N" ;     	
                }
            	}
                
            	st= "update PMWRegprocessmappingTable set ProcessValidated ='"+pMValidateProcess+"' where registeredprocessdefid="+ processDefId;
    			printOut(engine,"[WFSUtil]insertIntoPMW Query : " + st);
    			stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
                }
            	catch(SQLException e)
            	{
            		printErr(engine,"Error in updating PMWRegprocessmappingTable" + e);
            	}
                catch(Exception e)
                {
                	printErr(engine,"Error in PMValidateProcess" + e);
                }
        } finally {
            try {
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
				//if (rs != null) {
                  //  rs.close();
                    //rs = null;
                //}
            } catch (Exception e) {
            }
        }
    }
	
	 /**
     * **********************************************************************************
     * Function Name      : createHashMap
     * Author             : Shweta Singhal
     * Date Written       : 24/08/2011
     * Input Parameters   : NONE
     * Output Parameters  : NONE
     * Return Value       : HashMap
     * Description        : Fetches data from web to the wftables.
     * **********************************************************************************
     */
    public static HashMap createHashMap(String engine) throws FileNotFoundException {
        WFConfigLocator configurationLocator = WFConfigLocator.getInstance();
        String filePath = configurationLocator.getPath(Location.IBPS_CONFIG) + File.separator + WFSConstant.CONST_DIRECTORY_CONFIG;
        filePath = filePath + File.separatorChar + WFSConstant.CONST_TABLEMAPPING;
        //WFSUtil.printOut("filepath:" + filePath);
        InputStream is = new FileInputStream(filePath);
        StringBuffer buffer = new StringBuffer();
        byte[] b = new byte[40000];
        HashMap tableMap = null;
        try {
            for (int n; (n = is.read(b)) != -1;) {
                buffer.append(new String(b, 0, n));
            }
            String str = buffer.toString();
            XMLParser inputMapping = new XMLParser(str);
            tableMap = new HashMap();
            int startex = inputMapping.getStartIndex("TableMappings", 0, 0);
            int deadendex = inputMapping.getEndIndex("TableMappings", startex, 0);
            int noOfAttEx = inputMapping.getNoOfFields("TableMapping", startex, deadendex);
            int endEx = 0;
            for (int i = 0; i < noOfAttEx; i++) {
                startex = inputMapping.getStartIndex("TableMapping", endEx, 0);
                endEx = inputMapping.getEndIndex("TableMapping", startex, 0);
                String wftname = inputMapping.getValueOf("WFTableName", startex, endEx);
                String pmwtname = inputMapping.getValueOf("PMWTableName", startex, endEx);
                tableMap.put(wftname, pmwtname);
            }
        } catch (IOException ie) {
            //ie.printStackTrace();
			printErr(engine,"WFSUtil>> createHashMap" + ie);
        } finally {
            try {
                if (is != null) {
                    is.close();
                }
            } catch (Exception e) {
            }
        }
        return tableMap;
    }
	
	 /**
     * ***************************************************************************
     * Function Name    : deleteFromWF
     * Author           : Shweta Singhal
     * Date Written     : 31/10/2011
     * Input Parameters : Connection con, HashMap tMap, int processDefId
     * Output Parameters: NONE
     * Return Value     : String
     * Description      : delete data from wftables.
     * ****************************************************************************
     */
    public static void deleteFromWF(Connection con, HashMap tMap, int processDefId,String engine) throws SQLException {
        PreparedStatement pstmt = null;
        Statement stmt = null;        
        String st= null;		
        try {
            Iterator itr = tMap.keySet().iterator();
			stmt = con.createStatement();
			while (itr.hasNext()) {
                String tablename = (String) itr.next();
                printOut(engine,"[WFSUtil]deleteFromWF Delete Query :: "+tablename);
                if (tablename.equalsIgnoreCase("WFUDTVarMappingTable")||tablename.equalsIgnoreCase("varmappingtable")||tablename.equalsIgnoreCase("ACTIVITYINTERFACEASSOCTABLE")||tablename.equalsIgnoreCase("ACTIVITYASSOCIATIONTABLE")||tablename.equalsIgnoreCase("extdbconftable")||tablename.equalsIgnoreCase("documenttypedeftable")||tablename.equalsIgnoreCase("WFTypeDefTable")||tablename.equalsIgnoreCase("WFTypeDescTable")||tablename.equalsIgnoreCase("wfvarrelationtable"))
                {
			        st = "delete from " + WFSUtil.TO_SANITIZE_STRING(tablename,false) + " where ProcessDefId=" + processDefId + "and ProcessVariantId= 0";
			        printOut(engine,"[WFSUtil]deleteFromWF Delete Query :: "+st);
                }  
			    else
                {	if(tablename.equalsIgnoreCase("WFTaskDefTable")){
                	st = "delete from " + WFSUtil.TO_SANITIZE_STRING(tablename,false) + " where ProcessDefId=" + processDefId + " and Scope='P'";
                	}
                else{
                    st = "delete from " + WFSUtil.TO_SANITIZE_STRING(tablename,false) + " where ProcessDefId=" + processDefId + "";
                	}
		            printOut(engine,"[WFSUtil]deleteFromWF Delete Query :: "+st);
                }
                stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
            }            
        }
		finally {
            try {
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
				if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
			} catch (Exception e) {
            }
        }
    }
	
	 /** ***************************************************************************
     * Function Name    : deleteFromCheckOutProcesses
     * Author           : Shweta Singhal
     * Date Written     : 31/10/2011
     * Input Parameters : Connection con, HashMap tMap, int processDefId
     * Output Parameters: NONE
     * Return Value     : String
     * Description      : delete data from pmwtables.
     * ****************************************************************************
     */
    public static void deleteFromCheckOutProcesses(Connection con, HashMap tMap, int processDefId) throws SQLException {
        PreparedStatement pstmt = null;
       // Statement stmt = null;        
       // String st= null;		
        try {
            pstmt = con.prepareStatement("delete from checkoutprocessestable where processdefid=?");
			pstmt.setInt(1,processDefId);
			pstmt.execute();
			pstmt.close();
			pstmt = con.prepareStatement("delete from PMWRegprocessmappingTable where registeredprocessdefid= ?");
			pstmt.setInt(1,processDefId);
			pstmt.execute();
		} finally {
            try {
//                if (stmt != null) {
//                    stmt.close();
//                    stmt = null;
//                }
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
			}catch (Exception e) {
            }
        }
    }

    /**
     * *************************************************************
     * Function Name    : insertIntoWF_CheckIn
     * Author           : Shweta Singhal
     * Date Written     : 02/11/2011
     * Input Parameters : Connection con, String processName, HashMap tMap,int pmwProcessDefId,int 	  wfProcessDefId, int dbType
     * Output Parameters: NONE
     * Return Value     : String
     * Description      : Insert data from web to the wftables against given processdefid.
     * *************************************************************
     */
    public static int[] insertIntoWF_CheckIn(Connection con, String processName, HashMap tMap, int pmwProcessDefId,int wfProcessDefId, int dbType, String processStatus, WFParticipant user, String engine,ArrayList<Integer> variantIdList,String createNewVersion) throws SQLException, Exception {
        PreparedStatement pstmt = null;
        Statement stmt = null;
        ResultSet rs = null;
        ResultSet rs_new = null;
        ResultSet rs1 = null;
        ResultSet rs2=null;
        String pmwColString = null;
        String ColString = null;
        String wfColString =null;
        int processdefid = 0;
        double versionNo = 1.0;
        ArrayList<Integer> processVariantIdList = new ArrayList<Integer>();
        ArrayList<Integer> formExtIdList = new ArrayList<Integer>();
        int processvariantid = 0;
        int formExtid = 0;
		int projectId = 0;
		boolean createProcessDocFlag = false;
		String isSecureFolder="N";
		String pmwIsSecureFolder="N";
		int regStartingNo = 0;
		int[] intArray = null;//bug 37632: Not able to differentiate between checkin of process as same or new version
		boolean brmsFlag1 = false;
		String pName=processName.replace(" ", "");
        boolean restFlag = false ;
        boolean soapWebServiceFlag=false;
        int routeFolderId=0;
        int scratchFolderId=0;
        int completedFolderId=0;
        int workFlowFolderId=0;
        int discardFolderId=0;
        String folderType="G";
        int volumeId=0;
        int pmwVolumeID=0;
        int siteid=1;
        int pmwSiteid=1;
        String processType="";
		//boolean brmsFlag2 = false;
		try {
			ColString = WFSUtil.getColString(con, "ProcessDefTable", dbType);
			printOut(engine,"[WFSUtil]insertIntoWF_CheckIn Insert Query :: "+ColString);
            if (ColString.indexOf(",") != -1) {
                pmwColString = ColString.substring(ColString.indexOf(","));
		    }
			 //Bug 40315
            String userName = user.getname();
            stmt = con.createStatement();
            String st = null;
			
			st= "select ProjectId, VersionNo,ISSecureFolder,volumeID,siteid from processdeftable  where ProcessDefId=" + Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(wfProcessDefId),false)) + "";
			printOut(engine,"[WFSUtil]insertIntoWF_CheckIn Select Query :: "+st);
			rs=stmt.executeQuery(WFSUtil.TO_SANITIZE_STRING(st,true));
			if(rs!= null &&  rs.next()){
				projectId = rs.getInt(1);
				versionNo= rs.getInt(2);
				isSecureFolder =rs.getString(3);
				volumeId=rs.getInt(4);
				siteid=rs.getInt(5);
				if(isSecureFolder==null||isSecureFolder==""){
					isSecureFolder="N";
				}
			}
			rs.close();
			rs = null;
			
			if(processStatus.equalsIgnoreCase("O"))
			{	
				processdefid = wfProcessDefId;
				st= "select * from pmwprocessdeftable where ProcessDefId="+Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(pmwProcessDefId),false))+"";
				rs=stmt.executeQuery(WFSUtil.TO_SANITIZE_STRING(st,true));
				/* Bug  31861 fixed */
				if(rs.next()){
					pmwIsSecureFolder=rs.getString("ISSecureFolder");
					pmwVolumeID=rs.getInt("VolumeId");
					pmwSiteid=rs.getInt("SiteID");
					processType=rs.getString("ProcessType");
					st = "update ProcessDefTable set ProcessName= " + TO_STRING(rs.getString("ProcessName"), true, dbType)+ ",ProcessTurnAroundTime= " +Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(rs.getInt("ProcessTurnAroundTime")),false))+ ", WSFont= " +TO_STRING(rs.getString("WSFont"), true, dbType) + ",WSColor= " +Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(rs.getInt("WSColor")),false))+ ",CommentsFont= " +TO_STRING(rs.getString("CommentsFont"), true, dbType)+ ",CommentsColor= " +Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(rs.getInt("CommentsColor")),false))+ ", Backcolor= " +Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(rs.getInt("Backcolor")),false))+ ",TATCalFlag= " +TO_STRING(rs.getString("TATCalFlag"), true, dbType)+ ",Description = ? ,CreatedBy= " +TO_STRING(rs.getString("CreatedBy"), true, dbType)+ ",LastModifiedBy= " +TO_STRING(userName, true, dbType)+ ",ProcessShared= " +TO_STRING(rs.getString("ProcessShared"), true, dbType)+ ", Cost=" + Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(rs.getInt("Cost")),false))+ ",Duration=" +TO_STRING( rs.getString("Duration"), true, dbType)+ ", FormViewerApp=" +TO_STRING( rs.getString("FormViewerApp"), true, dbType)+ ", LastModifiedOn =  " +WFSUtil.getDate(dbType) + ",ThresholdRoutingCount = "+Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(rs.getInt("ThresholdRoutingCount")),false))+",CreateWebService = "+TO_STRING(rs.getString("CreateWebService"), true, dbType)+ ", DisplayName = "+TO_STRING(rs.getString("DisplayName"), true, dbType)+",ISSecureFolder= " + TO_STRING(pmwIsSecureFolder, true, dbType)+", OWNEREMAILID = "+TO_STRING(rs.getString("OWNEREMAILID"), true, dbType)+", VolumeId = "+rs.getInt("VolumeId")+", SiteId = "+rs.getInt("SiteId")+" where ProcessDefId="+Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(processdefid),false))+" and VersionNo="+Double.parseDouble(WFSUtil.TO_SANITIZE_STRING(Double.toString(versionNo), false))+" ";
					printOut(engine,"[WFSUtil]insertIntoWF_CheckIn Update Query :: "+st);
					pstmt = con.prepareStatement(WFSUtil.TO_SANITIZE_STRING(st,true));
					if(dbType == JTSConstant.JTS_POSTGRES){
						String description =rs.getString("Description");
						pstmt.setCharacterStream(1, new java.io.StringReader(description ),description.length());
					}
					else{
                         pstmt.setClob(1, rs.getClob("Description"));
					}
                    pstmt.execute();
                    if((!(isSecureFolder.equalsIgnoreCase(pmwIsSecureFolder)))||
                    		((volumeId!=pmwVolumeID || siteid!=pmwSiteid)&&!"R".equalsIgnoreCase(processType))){
                    	if("Y".equalsIgnoreCase(pmwIsSecureFolder)){
                    		folderType="K";
                    	}
                    	//st="SELECT  RouteFolderId,ScratchFolderId,CompletedFolderId, WorkFlowFolderId, DiscardFolderId FROM RouteFolderDefTable "+WFSUtil.getTableLockHintStr(dbType)+" where ProcessDefId="+processdefid+" ";
                    	st="SELECT  RouteFolderId, WorkFlowFolderId FROM RouteFolderDefTable "+WFSUtil.getTableLockHintStr(dbType)+" where ProcessDefId="+processdefid+" ";
                    	rs=stmt.executeQuery(st);
                    	if(rs!= null &&  rs.next()){
                    		routeFolderId = rs.getInt(1);
                    		//scratchFolderId= rs.getInt(2);
                    	//	completedFolderId =rs.getInt(3);
                    		workFlowFolderId=rs.getInt(2);
                    		//discardFolderId=rs.getInt(5);
                    		//st="UPDATE PDBFolder SET FolderType = "+TO_STRING(folderType, true, dbType)+",Location = "+TO_STRING(folderType, true, dbType)+" WHERE (FolderIndex = "+routeFolderId+" OR ParentFolderIndex = "+routeFolderId+") OR (FolderIndex = "+scratchFolderId+" OR ParentFolderIndex = "+scratchFolderId+") OR (FolderIndex ="+ completedFolderId+" OR ParentFolderIndex = "+completedFolderId+") OR (FolderIndex = "+workFlowFolderId+" OR ParentFolderIndex = "+workFlowFolderId+") OR (FolderIndex = "+discardFolderId+" OR ParentFolderIndex = "+ discardFolderId+")";
                    		if(!(isSecureFolder.equalsIgnoreCase(pmwIsSecureFolder))){
                    			st="UPDATE PDBFolder SET FolderType = "+TO_STRING(folderType, true, dbType)+",Location = "+TO_STRING(folderType, true, dbType)+" WHERE (FolderIndex = "+routeFolderId+" OR ParentFolderIndex = "+routeFolderId+")  OR (FolderIndex = "+workFlowFolderId+" OR ParentFolderIndex = "+workFlowFolderId+")";
                    			pstmt = con.prepareStatement(st);
                    			pstmt.execute();
                    			if(pstmt!=null){
                    				pstmt.close();
                    				pstmt=null;
                    			}
                    		}
                    		if((volumeId!=pmwVolumeID || siteid!=pmwSiteid)&&!"R".equalsIgnoreCase(processType)){
                    			
                    		/*	st="select 1 from ISVOLUME" + WFSUtil.getTableLockHintStr(dbType) + " where VolumeId=? and HomeSite=?";
                    			pstmt=con.prepareStatement(st);
                    			pstmt.setInt(1, pmwVolumeID);
                    			pstmt.setInt(2, pmwSiteid);
                    			rs2 = pstmt.executeQuery();
                    			if(rs2==null || (rs2 != null && !rs2.next())){
                    				throw new WFSException(WFSError.WF_INVALID_VOLUME_ID, 0, WFSError.WF_TMP, WFSErrorMsg.getMessage(WFSError.WF_INVALID_VOLUME_ID), "");
                    			}
                    			if(rs2 != null){
                    				rs2.close();
                    				rs2 = null;
                    			}
                    			if(pstmt!=null){
                    				pstmt.close();
                    				pstmt=null;
                    			}
                    			*/
                    			
                    			st="UPDATE PDBFolder SET IMAGEVOLUMEINDEX=? where FolderIndex=?";
                    			pstmt=con.prepareStatement(st);
                    			pstmt.setInt(1, pmwVolumeID);
                    			pstmt.setInt(2,workFlowFolderId);
                    			pstmt.execute();
                    			if(pstmt!=null){
                    				pstmt.close();
                    				pstmt=null;
                    			}
                    		}
                    	}
                    	
                    }
				}
                                                                
			}else{
				/* Bug 31951 fixed*/
				st= "select max(versionNo) as version, processdefId from processdeftable " + WFSUtil.getLockPrefixStr(dbType) + " where processname = " + TO_STRING(processName, true, dbType)+ " group by processdefId order by version desc";
				printOut(engine,"[WFSUtil]insertIntoWF_CheckIn version select query in New version:: "+st);
				rs = stmt.executeQuery(WFSUtil.TO_SANITIZE_STRING(st,true)); 
				int tempProcessdefid = 0; 
				if(rs.next()){
					versionNo = rs.getInt("version");
					tempProcessdefid = rs.getInt("processdefId");					
				}
				
				//st= "select regstartingno from pmwprocessdeftable " + WFSUtil.getLockPrefixStr(dbType) + " where processdefid = " +pmwProcessDefId ;
				if (dbType == JTSConstant.JTS_MSSQL) {
					st = "select max(seqId) as regstartingno from IDE_Reg_"+WFSUtil.TO_SANITIZE_STRING(pName,true);
					rs_new = stmt.executeQuery(WFSUtil.TO_SANITIZE_STRING(st,true));
					if(rs_new.next()){
					regStartingNo = rs_new.getInt("regstartingno");
					}
					if (rs_new != null) {
						rs_new.close();
						rs_new = null;
					}
				}
				st = "update ProcessDefTable set ProcessState =" +TO_STRING("Disabled", true, dbType)+ " where ProcessName= " + TO_STRING(processName, true, dbType)+ " and VersionNo="+Double.parseDouble(WFSUtil.TO_SANITIZE_STRING(Double.toString(versionNo), false))+" ";
                printOut(engine,"[WFSUtil]insertIntoWF_CheckIn Update Query in NewVersion Case:: "+st);
				stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));   
				
				versionNo = versionNo + 1;
				
				ColString = WFSUtil.getColString(con, "ProcessDefTable", dbType).toUpperCase();
				ColString = ColString.replace("PROJECTID,", "");
				ColString = ColString.replace("CREATEDON,", "");
				ColString = ColString.replace("LASTMODIFIEDON,", "");
				ColString = ColString.replace("REGSTARTINGNO,", "");
				ColString = ColString.replace("LASTMODIFIEDBY,", "");
				if (ColString.indexOf(",") != -1) {
					pmwColString = ColString.substring(ColString.indexOf(","));
					if (pmwColString.indexOf(",") != -1) {
						pmwColString = pmwColString.substring(1);
						pmwColString = pmwColString.substring(pmwColString.indexOf(","));
					}				
				}
				if (dbType != JTSConstant.JTS_MSSQL) {
					processdefid =Integer.parseInt(WFSUtil.nextVal(con, "ProcessDefId", dbType));
				}
				//Bug 40315
				if (dbType == JTSConstant.JTS_MSSQL) {
					st = "insert into ProcessDefTable (VersionNo,ProcessName,ProcessState,RegPrefix,RegSuffix,RegStartingNo,ProcessTurnAroundTime,RegSeqLength,CreatedOn,LastModifiedOn,WSFont,WSColor,CommentsFont,CommentsColor,Backcolor,TATCalFlag,Description,CreatedBy,LastModifiedBy,ProcessShared,ProjectId,Cost,Duration,FormViewerApp, ProcessType,ThresholdRoutingCount,CreateWebService,DisplayName,ISSecureFolder,OWNEREMAILID,VolumeID,SiteId)"
							+"select  " + Double.parseDouble(WFSUtil.TO_SANITIZE_STRING(Double.toString(versionNo), false)) + " ,ProcessName,ProcessState,RegPrefix,RegSuffix,"+Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(regStartingNo), false))+", ProcessTurnAroundTime,RegSeqLength,"+WFSUtil.getDate(dbType)+","+WFSUtil.getDate(dbType)+",WSFont,WSColor,CommentsFont,CommentsColor,Backcolor,TATCalFlag,Description,CreatedBy," +TO_STRING(userName, true, dbType)+ ",ProcessShared," + Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(projectId), false)) + ",Cost,Duration, FormViewerApp,ProcessType,ThresholdRoutingCount,CreateWebService,DisplayName,ISSecureFolder,OWNEREMAILID,VolumeID,SiteId "
							+" from PMWProcessDefTable where ProcessDefId=" + Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(pmwProcessDefId), false)) + "";
				}else if (dbType == JTSConstant.JTS_ORACLE) {
					st = "insert into ProcessDefTable (" + ColString + ", ProjectId, CreatedOn, LastModifiedOn, RegStartingNo,LASTMODIFIEDBY) select  "+Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(processdefid), false))+", " + Double.parseDouble(WFSUtil.TO_SANITIZE_STRING(Double.toString(versionNo), false)) + " " + pmwColString  + ", " + Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(projectId), false)) + ", " +WFSUtil.getDate(dbType) +  ", " +WFSUtil.getDate(dbType) + ", "+Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(regStartingNo), false))+", " +TO_STRING(userName, true, dbType)+ "  from PMWProcessDefTable where ProcessDefId=" + Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(pmwProcessDefId), false)) + "";
				}else if (dbType == JTSConstant.JTS_POSTGRES) {
					st = "insert into ProcessDefTable (" + ColString + ", ProjectId, CreatedOn, LastModifiedOn, RegStartingNo,LASTMODIFIEDBY) select  "+Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(processdefid), false))+" ," + Double.parseDouble(WFSUtil.TO_SANITIZE_STRING(Double.toString(versionNo), false)) + " " + pmwColString + ", " + Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(projectId), false)) + ", " +WFSUtil.getDate(dbType) +  ", " +WFSUtil.getDate(dbType) + ","+Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(regStartingNo), false))+", " +TO_STRING(userName, true, dbType)+ "  from PMWProcessDefTable where ProcessDefId=" + Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(pmwProcessDefId), false)) + "";
				}
				printOut(engine,"[WFSUtil]insertIntoWF_CheckIn Query : " + st);
				stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
				if(dbType == JTSConstant.JTS_MSSQL){
					stmt.execute("Select @@IDENTITY");
					rs = stmt.getResultSet();
					if(rs != null && rs.next()) {
						processdefid = rs.getInt(1);
						rs.close();
					}
                                        String tableName="IDE_Reg_"+WFSUtil.TO_SANITIZE_STRING(pName,true);
                                        	StringBuffer createQuery = new StringBuffer(50);
                                        	createQuery.append(" Create Table ");;
                                        	createQuery.append(WFSUtil.TO_SANITIZE_STRING(tableName,false));
                                                regStartingNo = regStartingNo + 1;
                                        	createQuery.append(" (seqId	INT IDENTITY ("+Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(regStartingNo), false))+",1))");
                                        	String tableQuery = "Select * from sysobjects where name= N'"+WFSUtil.TO_SANITIZE_STRING(tableName, false)+"' and xtype = 'U' ";

                                        	rs1 = stmt.executeQuery(tableQuery);


                                            if(!rs1.next()){
                                                WFSUtil.printOut(engine,"registerationTable query >>"+createQuery);
                                                //stmt.execute(seqQuery);
                                                stmt.execute(createQuery.toString());

                                            }
                                            if(rs1 != null){
                                                rs1.close();
                                                rs1 = null;
                                            }
				} /*Bug 31877 fixed*/
				//Bug 40355
				if(dbType == JTSConstant.JTS_ORACLE || dbType == JTSConstant.JTS_POSTGRES){
					String seqName = "SEQ_Reg_"+WFSUtil.TO_SANITIZE_STRING(pName, true);
					regStartingNo = Integer.parseInt(WFSUtil.nextVal(con, "SEQ_Reg_" + pName ,dbType));
					String seqQuery = null;
                                        if(dbType == JTSConstant.JTS_ORACLE)
                                            seqQuery = "select 1 from user_sequences where sequence_name like UPPER("+TO_STRING(seqName, true, dbType)+")";
					else
                                            seqQuery = "select 1 from pg_class where Upper(relname) like UPPER("+TO_STRING(seqName, true, dbType)+")";
                                        rs = stmt.executeQuery(seqQuery);        
					if(dbType == JTSConstant.JTS_ORACLE)
                                            seqQuery = "CREATE SEQUENCE "+WFSUtil.TO_SANITIZE_STRING(seqName, false)+" INCREMENT BY 1 START WITH "+Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(regStartingNo), false))+" NOCACHE";//Bug 40727
					else
                                            seqQuery = "CREATE SEQUENCE "+WFSUtil.TO_SANITIZE_STRING(seqName, false)+" INCREMENT BY 1 START WITH "+Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(regStartingNo), false));
                                        if(!rs.next()){
						printOut(engine,"seqQuery>>"+seqQuery);
						stmt.execute(WFSUtil.TO_SANITIZE_STRING(seqQuery,true));        
					}
					if(rs != null){
						rs.close();
						rs = null;
					}
				}
				createProcessDocFlag = true;
			}
			//bug 37632: Not able to differentiate between checkin of process as same or new version
			intArray = new int[2];
        	intArray[0] = processdefid;
			intArray[1] = (int)versionNo;

                   for(int i=0; i<variantIdList.size() ; i++){
                       int variantId = variantIdList.get(i);
                                   if(dbType == JTSConstant.JTS_MSSQL){
                               st = "insert into WFProcessVariantDefTable (ProcessDefId,ProcessVariantName,ProcessVariantState,RegPrefix, RegSuffix, RegStartingNo, Label, Description, CreatedOn,CreatedBy,LastModifiedOn, LastModifiedBy)"
                                       +"select "+ processdefid + ",ProcessVariantName,ProcessVariantState,RegPrefix, RegSuffix, RegStartingNo, Label, Description," + WFSUtil.getDate(dbType)+"," +TO_STRING(userName, true, dbType)+","+WFSUtil.getDate(dbType)+","+TO_STRING(userName, true, dbType)+
                                             "from WFProcessVariantDefTable where processdefid = "+wfProcessDefId+  "and processvariantid =" + variantId;
                                                }
                                   else if(dbType == JTSConstant.JTS_ORACLE || dbType == JTSConstant.JTS_POSTGRES){
                                processvariantid =Integer.parseInt(WFSUtil.nextVal(con, "ProcessVariantId", dbType));
                                processVariantIdList.add(processvariantid);
                                WFSUtil.printOut(engine,"variantId in case of Oracle>>"+processvariantid);
                                st= "insert into WFProcessVariantDefTable (ProcessDefId,ProcessVariantId,ProcessVariantName,ProcessVariantState,"
                                                + "RegPrefix, RegSuffix, RegStartingNo, Label, Description, CreatedOn,CreatedBy, LastModifiedOn, LastModifiedBy)"
                                              +"select "+ processdefid + ","+processvariantid+",ProcessVariantName,ProcessVariantState,RegPrefix, RegSuffix, RegStartingNo, Label, Description," + WFSUtil.getDate(dbType)+"," +TO_STRING(userName, true, dbType)+","+WFSUtil.getDate(dbType)+","+TO_STRING(userName, true, dbType)+
                                             "from WFProcessVariantDefTable where processdefid = "+wfProcessDefId+  "and processvariantid =" + variantId;
                                   }
                                   stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
                                                if(dbType == JTSConstant.JTS_MSSQL){
					stmt.execute("Select @@IDENTITY");
					rs = stmt.getResultSet();
					if(rs != null && rs.next()) {
						processvariantid = rs.getInt(1);
                                                processVariantIdList.add(processvariantid);
						rs.close();
					}
				} 

                                       st ="Insert into WFVariantFieldInfoTable(ProcessDefid,ProcessVariantId,FieldId,VariableId,VarFieldId, Type,Length,DefaultValue,Methodname,PickListInfo, ControlType)"
                                               +"select "+ processdefid +","+processvariantid+ ",FieldId,VariableId,VarFieldId, Type,Length,DefaultValue,Methodname,PickListInfo, ControlType from WFVariantFieldInfoTable where processdefid = "+ wfProcessDefId + "and processvariantid =" + variantId ;
                                   stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));

                                       st ="Insert into WFVariantFieldAssociationTable (ProcessDefid, ProcessVariantId, VariableId, VarFieldId, ActivityId, Enable, Editable, Visible, Mandatory)"
                                               +"select "+ processdefid +","+processvariantid+ ",VariableId, VarFieldId, ActivityId, Enable, Editable, Visible, Mandatory from WFVariantFieldAssociationTable where processdefid = "+ wfProcessDefId + "and processvariantid =" + variantId ;
                                   stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));

                                    if(dbType == JTSConstant.JTS_MSSQL){
                                       st ="insert into WFVariantFormTable (ProcessDefid,ProcessVariantId,Columns,Width1,Width2,Width3)"
                                               +"select "+ processdefid +","+processvariantid+ ",Columns,Width1,Width2,Width3 from WFVariantFormTable where processdefid = "+ wfProcessDefId + "and processvariantid =" + variantId ;
                                   }
                                   else if(dbType == JTSConstant.JTS_ORACLE || dbType == JTSConstant.JTS_POSTGRES){
                                       formExtid =Integer.parseInt(WFSUtil.nextVal(con, "FormExtId", dbType));
                                       formExtIdList.add(formExtid);
                                       st ="insert into WFVariantFormTable (ProcessDefid,ProcessVariantId,Columns,Width1,Width2,Width3,FormExtId)"
                                               +"select "+ processdefid +","+processvariantid+ ",Columns,Width1,Width2,Width3,"+formExtid+" from WFVariantFormTable where processdefid = "+ wfProcessDefId + "and processvariantid =" + variantId ;
                                   }
                                   stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
                                   if(dbType == JTSConstant.JTS_MSSQL){
                                                stmt.execute("Select @@IDENTITY");
                                                rs = stmt.getResultSet();
                                                if(rs != null && rs.next()) {
                                                    formExtid = rs.getInt(1);
                                                    formExtIdList.add(formExtid);
                                                    rs.close();
                                                }
                                            }

                                         st ="Insert into WFVariantFormListenerTable (ProcessDefId, ProcessVariantId, VariableId, VarFieldId, FormExtId, "
                                                + "ActivityId, CodeSnippet, LanguageType, FieldListener, ObjectForListener, FunctionName)"
                                                +"select "+ processdefid +","+processvariantid+ ",VariableId, VarFieldId,"+formExtid+ ", "
                                                + "ActivityId, CodeSnippet, LanguageType, FieldListener, ObjectForListener, FunctionName from WFVariantFormListenerTable where processdefid = "+ wfProcessDefId + "and processvariantid =" + variantId ;

                                         stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));

                   }

                 Iterator itr = tMap.keySet().iterator();
                 int flag = 0;
			while (itr.hasNext()) {
                String tablename = (String) itr.next();
                String pmwTableName = (String) tMap.get(tablename);
				printOut(engine,"TableName at line 14340: " + tablename);
                ColString = getColString(con, tablename, dbType);
                printOut(engine,"<InsertintoWF> ColString>>"+ColString);
				/* Bug 31606 fixed*/
				/*if(tablename.equalsIgnoreCase("IMPORTEDPROCESSDEFTABLE")){
					String str = null;
					printOut("Into if block");
					str = "select ProcessType, ImportedProcessName from " + pmwTableName + " where CallerProcessDefId=" + pmwProcessDefId + "";
					rs= stmt.executeQuery(str);
					if(rs.next()){
						String processTye = rs.getString("ProcessType");
						if(processTye.equalsIgnoreCase("R")){
							ColString = ColString.replace("CallerProcessDefID,", "");
							
							st = "insert into " + tablename + " (CallerProcessDefId, " + ColString + ") select " + processdefid + ", " + ColString + " from " + pmwTableName + " where CallerProcessDefId=" + pmwProcessDefId + "";
						}else{
							String iProcessName = rs.getString("ImportedProcessName");
							str = "select max(ProcessDefId) processdefid from processdeftable where ProcessName = "+ TO_STRING(iProcessName, true, dbType) + "";
							rs= stmt.executeQuery(str);
							if(rs.next()){
								int iProcessDefId = rs.getInt("processdefid");
								ColString = ColString.replace("CallerProcessDefID,", "");
								ColString = ColString.replace("ProcessDefID,", "");
								
								st = "insert into " + tablename + " (CallerProcessDefId, ProcessDefId, " + ColString + ") select " + processdefid + " , " + iProcessDefId + ", " + ColString + " from " + pmwTableName + " where CallerProcessDefId=" + pmwProcessDefId + "";
							}
						}
						printOut("print line : " + st);
						stmt.execute(st);
					}
				}*/
                //ProcessDefId will be identity type only in ProcessDefTable not in others.
//                else 
                if(tablename.equalsIgnoreCase("QueueStreamTable")) {
					st = "insert into queuestreamtable (processdefid,queueid,activityid, streamid) select "+processdefid+",queueid,activityid, streamid from pmwqueuestreamtable where processdefid = "+ pmwProcessDefId +" and queueid >0";
					printOut(engine,"print line : " + st);
					stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
					
				} else if (tablename.equalsIgnoreCase("WFLaneQueueTable")){
					st = "insert into wflanequeuetable (processdefid,queueid,swimlaneid,DefaultQueue) select "+processdefid+",queueid,swimlaneid,DefaultQueue from pmwlanequeuetable where processdefid = "+ pmwProcessDefId +" and queueid >0";
					printOut(engine,"print line : " + st);
					stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
				}else{
				
					if (ColString.indexOf(",") != -1) {
						pmwColString = ColString.substring(ColString.indexOf(","));
                                                wfColString = ColString.substring(ColString.indexOf(","),ColString.lastIndexOf(","));
					}
					if(pmwColString.toUpperCase().contains("PROCESSVARIANTID")){//Bug 42580
						pmwColString = pmwColString.toUpperCase().replace("PROCESSVARIANTID", "0");
					}
					if(tablename.equalsIgnoreCase("WFSectionsTable")){
						pmwColString = pmwColString.substring(pmwColString.indexOf(",",1));
						pmwColString=","+projectId+pmwColString;
					}
		 			if(tablename.equalsIgnoreCase("WFTaskDefTable") && createNewVersion.equalsIgnoreCase("N")){
		 				st = "insert into " + tablename + " (" + ColString + ") select " + processdefid + " " + pmwColString + " from " + WFSUtil.TO_SANITIZE_STRING(pmwTableName,false) + " where ProcessDefId=" + pmwProcessDefId + " and Scope='P'";	
		 			}
		 			else{
		 			st = "insert into " + tablename + " (" + ColString + ") select " + processdefid + " " + pmwColString + " from " + WFSUtil.TO_SANITIZE_STRING(pmwTableName,false) + " where ProcessDefId=" + pmwProcessDefId + "";
		 			}
					printOut(engine,"print line : " + st);
					//stmt.execute(st);
                                        flag = stmt.executeUpdate(WFSUtil.TO_SANITIZE_STRING(st,true));
                                       for(int i=0; i<variantIdList.size() ; i++){
                                           int variantId = variantIdList.get(i);
                                          processvariantid = processVariantIdList.get(i);
                                          formExtid=formExtIdList.get(i);
                                        if (tablename.equalsIgnoreCase("WFUDTVarMappingTable")||tablename.equalsIgnoreCase("varmappingtable")||tablename.equalsIgnoreCase("ACTIVITYASSOCIATIONTABLE")||tablename.equalsIgnoreCase("extdbconftable")||tablename.equalsIgnoreCase("documenttypedeftable")||tablename.equalsIgnoreCase("WFTypeDefTable")||tablename.equalsIgnoreCase("WFTypeDescTable")||tablename.equalsIgnoreCase("wfvarrelationtable")){   	
                                        	if("WFUDTVarMappingTable".equalsIgnoreCase(tablename) || "varmappingtable".equalsIgnoreCase(tablename)){
                                        		wfColString = ColString.replaceFirst("ProcessVariantId", Integer.toString(processvariantid));
                                        		wfColString = wfColString.replaceFirst("ProcessDefId", Integer.toString(processdefid));
                                        		st = "insert into " + tablename + " (" + ColString + ") select " + wfColString + " from " + tablename + " where processdefid = "+ wfProcessDefId + "and processvariantid =" + variantId + "";
                                        	}else{
                                        		st = "insert into " + tablename + " (" + ColString + ") select " + processdefid + " " + wfColString + ","+processvariantid+" from " + tablename + " where processdefid = "+ wfProcessDefId + "and processvariantid =" + variantId + "";
                                        	}
                                        	stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
                                        }
                                        else if(tablename.equalsIgnoreCase("ACTIVITYINTERFACEASSOCTABLE")){
                                         st = "insert into " + tablename + " (" + ColString + ") select "+ processdefid +",ActivityId, ActivityName," +formExtid+",InterfaceType,Attribute, TriggerName,"+processvariantid+" from " + tablename + " where processdefid = "+ wfProcessDefId + " and processvariantid =" + variantId + " and InterfaceType = 'F'";
                                        stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
                                         st = "insert into " + tablename + " (" + ColString + ") select "+ processdefid +",ActivityId, ActivityName,InterfaceElementId,InterfaceType,Attribute, TriggerName,"+processvariantid+" from " + tablename + " where processdefid = "+ wfProcessDefId + " and processvariantid =" + variantId + " and InterfaceType = 'D'";
                                        stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
                                        }
                                        }
					if(tablename.equalsIgnoreCase("wfJMSPublishTable") && flag > 0){
						transferJMSData(con, false, pmwProcessDefId, processdefid, dbType);
					}
						// Bug 39613 - Fixed
					if(tablename.equalsIgnoreCase("wfjmssubscribetable") && flag > 0){
						transferJMSSubscriberData(con, false, pmwProcessDefId, processdefid, dbType);
					}
					// Changes Done for BRMS	
					if(tablename.equalsIgnoreCase("WFBRMSActivityAssocTable") && flag > 0){
						brmsFlag1 = true; 							
					}
						
//					if(tablename.equalsIgnoreCase("WFBRMSMappingTable") && flag > 0){
//						brmsFlag2 = true; 							
//					}
						
						
                                        
                                        if(tablename.equalsIgnoreCase("WFRestActivityAssocTable") && flag > 0){
						restFlag = true; 							
					}
                    if("WFWebserviceTable".equalsIgnoreCase(tablename) && flag > 0){
                        soapWebServiceFlag=true;
                    }
					
				}
            }
                        if(restFlag){
						transferRESTData(con, false, pmwProcessDefId, processdefid, dbType,engine);
					}
             if(soapWebServiceFlag)   {     
            	 transferWebServiceData(con, false, pmwProcessDefId, processdefid, dbType,engine);
             }
             if(brmsFlag1){
					transferBRMSData(con, false, pmwProcessDefId, processdefid, dbType,engine);
				}
             transferExternalMethodData(con, false, pmwProcessDefId, processdefid, dbType, engine);
			st = "update IMPORTEDPROCESSDEFTABLE set ProcessType =" + TO_STRING("R", true, dbType) + " where ProcessDefId = "+processdefid+" ";
			printOut(engine,"print IMPORTEDPROCESSDEFTABLE : " + st);
			stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
			
			/*Bug 31825 fixed*/
			
			//Create Procesfolders and other info
			if(createProcessDocFlag){
	            /**
	             * Changes for sharepoint related support (insertion of sharepoint folder IDs into RouteFolderDefTable)
	             */
				String vers= "V"+ (int)versionNo;
				stmt = con.createStatement();
	            rs = stmt.executeQuery("select 1 from WFUnderlyingDMS " + getTableLockHintStr(dbType) + " where DMSType = 2 AND UPPER(DMSName) = 'SHAREPOINT'");
	            if(rs.next()){
	            	int libraryId = 0;
	    			if (rs != null) {
	                    rs.close();
	                    rs = null;
	                }
	                if (stmt != null) {
	                    stmt.close();
	                    stmt = null;
	                }
	            	stmt = con.createStatement();
	                rs = stmt.executeQuery("select LibraryId from  WFprocesssharepointassoc " + getTableLockHintStr(dbType) + " where ProcessDefId = " + processdefid);
	            	if(rs.next()){
	            		libraryId = rs.getInt(1);
	            	}
	            	int updateRetVal = createProcessDocsForSharepoint(con, user, processName, vers, processdefid, engine, dbType, libraryId);
	            	printOut(engine, "Return value of createProcessDocsForSharepoint : " + updateRetVal);
	            }else{
	            	WFTMSUtil.createProcessDocument(con, processdefid, processName, vers, user, dbType, engine, false);
	            	//WFTMSUtil.createOTMSDocument(con, processdefid, "OTMS", user, dbType, engine);
	            	WFTMSUtil.insertRouteFolderInfo(con, processdefid, processName, vers, engine, dbType);	
	            }
			}
            if (rs != null) {
				rs.close();
				rs = null;
			}
			if (stmt != null) {
				stmt.close();
				stmt = null;
			}			
        } finally {
        	 try {
                 if (rs != null) {
                     rs.close();
                     rs = null;
                 }
 			} catch (Exception e) {
 				 WFSUtil.printErr(engine,"", e);
             }
        	 try {
                 if (rs1 != null) {
                     rs1.close();
                     rs1 = null;
                 }
 			} catch (Exception e) {
 				 WFSUtil.printErr(engine,"", e);
             }
        	 try {
                 if (rs2 != null) {
                     rs2.close();
                     rs2 = null;
                 }
 			} catch (Exception e) {
 				 WFSUtil.printErr(engine,"", e);
             }
        	 try {
                 if (rs_new != null) {
                	 rs_new.close();
                	 rs_new = null;
                 }
 			} catch (Exception e) {
 				 WFSUtil.printErr(engine,"", e);
             }
            try {
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
			} catch (Exception e) {
				 WFSUtil.printErr(engine,"", e);
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
			} catch (Exception e) {
				 WFSUtil.printErr(engine,"", e);
            }
        }
		//return processdefid;
		return intArray;//bug 37632: Not able to differentiate between checkin of process as same or new version
    }	
	
		public static void insertAutoGenInfo(Connection con, int dbType, int processDefId) throws SQLException{
		PreparedStatement pstmt = null;
        PreparedStatement pstmt1 = null;
		Statement stmt = null;
		ResultSet rs = null;
		ResultSet rs1 = null;
        String parentObject = null;
		String fKey = null;
		boolean fAutoGen = false;
		String childObject = null;
		String rKey = null;
		boolean rAutoGen = false;
		String query = null;
		
		try{
			stmt = con.createStatement();
			pstmt = con.prepareStatement("select ParentObject, ForeignKey, FautoGen, ChildObject, RefKey, RautoGen from WFVarRelationTable where processdefid = ? Order by RelationId");
			pstmt.setInt(1,processDefId);
			rs = pstmt.executeQuery();
			if(rs != null){
				while(rs.next()){
					parentObject = rs.getString(1);	
					fKey = rs.getString(2);
					fAutoGen = rs.getString(3).equalsIgnoreCase("Y");
					childObject = rs.getString(4);
					rKey = rs.getString(5);
					rAutoGen = rs.getString(6).equalsIgnoreCase("Y");

					if(fAutoGen){
						//parentObject fKey into AutoGenTable
						//1st check for the existance	
						//Select 1 from WFAutoGenInfoTable where TableName = 'QueueDataTable' and ColumnName = 'VAR_INT1'
						// if found
						// do not insert else insert
						query = "Select 1 from WFAutoGenInfoTable where TableName = " + TO_STRING(parentObject, true, dbType) + " and ColumnName = " + TO_STRING(fKey, true, dbType) + "";
						
						//printOut("<insertAutoGenInfo> Query 11:::" + query);
						rs1 = stmt.executeQuery(query);
						if(!rs1.next()){
                            rs1.close();
                            if(dbType == JTSConstant.JTS_ORACLE ||dbType == JTSConstant.JTS_POSTGRES){
                                int id = Integer.parseInt(nextVal(con, "MapIdSeqGenerator", dbType));
                                String seqName = "WFS_SEQ_"+id;
                                if(dbType == JTSConstant.JTS_ORACLE){
                                    query = "select 1 from user_sequences where sequence_name = upper(?) order by 1 desc";
                                }else{ //Postgres 
                                    query = "select 1 from pg_class where Upper(relname) = Upper(?) order by 1 desc";
                                }
                                pstmt1 = con.prepareStatement(query);
                                WFSUtil.DB_SetString(1, seqName.trim(), pstmt1, dbType);
                                rs1 = pstmt1.executeQuery();
                                if(!rs1.next()){
                                    rs1.close();
                                    query = "Insert into WFAutoGenInfoTable (TableName, ColumnName, SeqName)  values ("+TO_STRING(parentObject, true, dbType)+", "+TO_STRING(fKey, true, dbType)+", "+TO_STRING(seqName, true, dbType)+")";
                                    pstmt1 = con.prepareStatement(query);
                                    pstmt1.execute();
                                    pstmt1.close();
                                    if(dbType == JTSConstant.JTS_ORACLE)
                                        query = "CREATE SEQUENCE "+seqName+" INCREMENT BY 1 START WITH 1 NOCACHE";
                                    else
                                        query = "CREATE SEQUENCE "+seqName+" INCREMENT BY 1 START WITH 1";
                                    pstmt1 = con.prepareStatement(query);
                                    pstmt1.execute();
                                }
                                if(rs1 != null){
                                    rs1.close();
                                    rs1 = null;
                                }
                                if(pstmt1 != null){
                                    pstmt1.close();
                                    pstmt1 = null;
                                }
                            }else if(dbType == JTSConstant.JTS_MSSQL){
                                query = "Insert into WFAutoGenInfoTable (TableName, ColumnName, SeqName)  values ("+TO_STRING(parentObject, true, dbType)+", "+TO_STRING(fKey, true, dbType)+", null)";
                                pstmt1 = con.prepareStatement(query);
                                pstmt1.execute();
                                if(pstmt1 != null){
                                    pstmt1.close();
                                    pstmt1 = null;
                                }
                            }
							
//							printOut("<insertAutoGenInfo> Query 12:::" + query);
//							stmt.execute(query);
						}
						if (rs1 != null) {
							rs1.close();
							rs1 = null;
						}
					}
					
					if(rAutoGen){
						//childObject rKey into AutoGenTable
						//1st check for the existance	
						//Select 1 from WFAutoGenInfoTable where TableName = 'QueueDataTable' and ColumnName = 'VAR_INT1'
						// if found
						// do not insert else insert
						query = "Select 1 from WFAutoGenInfoTable where TableName = " + TO_STRING(childObject, true, dbType) + " and ColumnName = " + TO_STRING(rKey, true, dbType) + "";
						
						// printOut("<insertAutoGenInfo> Query 21:::" + query);
						rs1 = stmt.executeQuery(query);
						if(!rs1.next()){
                            rs1.close();
//							query = "Insert into WFAutoGenInfoTable (TableName, ColumnName, Seed, IncrementBy, CurrentSeqNo) values ("+TO_STRING(childObject, true, dbType)+", "+TO_STRING(rKey, true, dbType)+", 1,1, 0)";
//							printOut("<insertAutoGenInfo> Query 22:::" + query);
//							stmt.execute(query);
                            if(dbType == JTSConstant.JTS_ORACLE || dbType == JTSConstant.JTS_POSTGRES ){
                                int id = Integer.parseInt(nextVal(con, "MapIdSeqGenerator", dbType));
                                String seqName = "WFS_SEQ_"+id;
                                if(dbType == JTSConstant.JTS_ORACLE){ 
                                    query = "select sequence_name from user_sequences where sequence_name = upper(?) order by 1 desc";
                                }else{
                                    query = "select relname from pg_class where Upper(relname) = upper(?) order by 1 desc";
                                }
                                pstmt1 = con.prepareStatement(query);
                                WFSUtil.DB_SetString(1, seqName.trim(), pstmt1, dbType);
                                rs1 = pstmt1.executeQuery();
                                if(!rs1.next()){
                                    rs1.close();
                                    
                                    query = "Insert into WFAutoGenInfoTable (TableName, ColumnName, SeqName)  values ("+TO_STRING(childObject, true, dbType)+", "+TO_STRING(rKey, true, dbType)+", "+TO_STRING(seqName, true, dbType)+")";
                                    pstmt1 = con.prepareStatement(query);
                                    pstmt1.execute();
                                    pstmt1.close();
                                    if(dbType == JTSConstant.JTS_ORACLE)
                                        query = "CREATE SEQUENCE "+seqName+" INCREMENT BY 1 START WITH 1 NOCACHE";
                                    else
                                        query = "CREATE SEQUENCE "+seqName+" INCREMENT BY 1 START WITH 1";
                                    pstmt1 = con.prepareStatement(query);
                                    pstmt1.execute();
                                }
                                if(rs1 != null){
                                    rs1.close();
                                    rs1 = null;
                                }
                                if(pstmt1 != null){
                                    pstmt1.close();
                                    pstmt1 = null;
                                }
                            }else if(dbType == JTSConstant.JTS_MSSQL){
                                query = "Insert into WFAutoGenInfoTable (TableName, ColumnName, SeqName)  values ("+TO_STRING(childObject, true, dbType)+", "+TO_STRING(rKey, true, dbType)+", null)";
                                pstmt1 = con.prepareStatement(query);
                                pstmt1.execute();
                                if(pstmt1 != null){
                                    pstmt1.close();
                                    pstmt1 = null;
                                }
                            }
						}
						if (rs1 != null) {
							rs1.close();
							rs1 = null;
						}
					}
				}
			}
		} finally {
			try {
				if (rs != null) {
					rs.close();
					rs = null;
				}
			} catch (Exception e) {
				 WFSUtil.printErr("","", e);
			}
			try {
				if (rs1 != null) {
					rs1.close();
					rs1 = null;
				}
			} catch (Exception e) {
				 WFSUtil.printErr("","", e);
			}
			try {
				if (stmt != null) {
					stmt.close();
					stmt = null;
				}
			} catch (Exception e) {
				 WFSUtil.printErr("","", e);
			}
			try {
				if(pstmt != null) {
					pstmt.close();
					pstmt = null;
				}
			} catch (Exception e) {
				 WFSUtil.printErr("","", e);
			}
			try {
				if(pstmt1 != null) {
					pstmt1.close();
					pstmt1 = null;
				}
			} catch (Exception e) {
				 WFSUtil.printErr("","", e);
			}
		}
		
	}

		/**
     * *******************************************************************************
     *                  Function Name       : getPDBFolderQuery
     * 					Author				:   Mandeep Kaur
     *					 Date Written    	:   27/09/2011
     *                  Input Parameters    : Connection con, String folderName, String parentFolderIndex, int dbType, WFParticipant participant
     *                  Output Parameters   : String(PDBFolder Query )
     *                  Return Values       : Query
     *                  Description         : To create ProcessFolder and Process document
     * *******************************************************************************
     */

	/*public static void createReportFolders(Connection con, int dbType) throws SQLException, Exception{
		
		//check if workflow Reports folder exists or not
		boolean isFoldExists = false;
		int iWorkFlowFolderID = -1;
		int iParentFolderIndex = -1;
		int iIndexOf = -1;
		String FolderName = "";
		String strDocumentName = "";
		String strURL = "";
		int iStatus = -1;
		iWorkFlowFolderID = getFolderIndex(con,0,null,dbType);
		LinkedHashMap worflowReport = (LinkedHashMap) WFFindClass.wfGetServerPropertyMap().get(WFSConstant.CONST_WORKFLOW_REPORT);
		Iterator iterator = worflowReport.keySet().iterator();
		 while ( iterator.hasNext() ){
			 FolderName = ( String ) iterator.next();
			 iParentFolderIndex =  getFolderIndex(con,iWorkFlowFolderID,FolderName,dbType);
			 ArrayList value = ( ArrayList ) worflowReport.get( FolderName );
			 for(int i=0 ; i< value.size(); i++ )
			 {
				 String strValue =(String) value.get(i);
				 iIndexOf = strValue.indexOf(string21);
				// if(iIndexOf != -1){
					 strDocumentName = strValue.substring(0, iIndexOf);
					 //System.out.println( strDocumentName );
					 strURL = strValue.substring(iIndexOf+1);
					 //System.out.println( strURL );
					 iStatus =  getDocumentIndex(con,iParentFolderIndex,strDocumentName,dbType,strURL);
				 //}
			 }
		 }
		 
		
	}
*/

	
	
	/**
	 * *************************************************************
	 * Function Name    : checkSQLInjectionForIntList
	 * Author			: Saurabh Kamal
	 * Date Written     : 27/07/2011
	 * Input Parameters : String
	 * Output Parameters: NONE
	 * Return Value     : String -> true is valid Integer List
	 * Description      : to avoid SQL INjection in IntegerList used in the query
	 * *************************************************************
	 */
	
	public static boolean checkSQLInjectionForIntList(String str){
        boolean isValid = true;
        StringTokenizer strToken = new StringTokenizer(str, ",");
        while(strToken.hasMoreElements()){
            String token = strToken.nextToken();            
            try{
                int i =Integer.parseInt(token.trim());
            } catch(NumberFormatException ne){                
                isValid = false;
                break;
            }
        }
        return isValid;
    }

	/**
     * *******************************************************************************
     *                  Function Name       : getPDBFolderQuery
     * 					Author				:   Mandeep Kaur
     *					 Date Written    	:   27/09/2011
     *                  Input Parameters    : Connection con, String folderName, String parentFolderIndex, int dbType, WFParticipant participant
     *                  Output Parameters   : String(PDBFolder Query )
     *                  Return Values       : Query
     *                  Description         : To create ProcessFolder and Process document
     * *******************************************************************************
     */

	/*public static void createReportFolders(Connection con, int dbType, String engineName) throws SQLException, Exception{
		
		//check if workflow Reports folder exists or not
		boolean isFoldExists = false;
		int iWorkFlowFolderID = -1;
		int iParentFolderIndex = -1;
		int iIndexOf = -1;
		String FolderName = "";
		String strDocumentName = "";
		String strURL = "";
		int iStatus = -1;
		iWorkFlowFolderID = getFolderIndex(con,0,null,dbType);
        LinkedHashMap worflowReport = (LinkedHashMap) WFFindClass.wfGetServerPropertyMap().get(WFSConstant.CONST_WORKFLOW_REPORT);
        Iterator iterator = worflowReport.keySet().iterator();
		 while ( iterator.hasNext() ){
             FolderName = ( String ) iterator.next();
             iParentFolderIndex =  getFolderIndex(con,iWorkFlowFolderID,FolderName,dbType);
			 ArrayList value = ( ArrayList ) worflowReport.get( FolderName );
			 for(int i=0 ; i< value.size(); i++ )
			 {
				 String strValue =(String) value.get(i);
				 iIndexOf = strValue.indexOf(string21);
				// if(iIndexOf != -1){
					 strDocumentName = strValue.substring(0, iIndexOf);
					 //System.out.println( strDocumentName );
					 strURL = strValue.substring(iIndexOf+1);
					 //System.out.println( strURL );
					 iStatus =  getDocumentIndex(con,iParentFolderIndex,strDocumentName,dbType,strURL, engineName);
				 //}
			 }
		 }
		 
		
	}*/
	
	/**
     * *******************************************************************************
     *                  Function Name       : getFolderIndex
     * 					Author				:   Mandeep Kaur
     *					 Date Written    	:   27/09/2011
     *                  Input Parameters    : Connection con, String folderName, String parentFolderIndex, int dbType, WFParticipant participant
     *                  Output Parameters   : String(PDBFolder Query )
     *                  Return Values       : Query
     *                  Description         : To create ProcessFolder and Process document
     * *******************************************************************************
     */

	public static int getFolderIndex(Connection con, int ParentFolderIndex, String FolderName,int dbType) throws SQLException, Exception{
		
		String strFolderName = "";
		int iFolderIndex = -1;
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		String strQuery = null ;
		//StringBuffer query = new StringBuffer();
		try{
		strFolderName = FolderName;
		
		if(strFolderName == null)
			strFolderName = "WorkFlow Reports";
	
		if(dbType == JTSConstant.JTS_MSSQL){
			strQuery = "SELECT FolderIndex FROM PDBFolder WHERE parentfolderindex = ? and name = ? ";
		}else if(dbType == JTSConstant.JTS_ORACLE || dbType == JTSConstant.JTS_POSTGRES ){
			strQuery = "SELECT FolderIndex FROM PDBFolder WHERE parentfolderindex = ? and UPPER(name) = UPPER(?) ";
		} 
		pstmt = con.prepareStatement(strQuery);
	   	pstmt.setInt(1, ParentFolderIndex);
		pstmt.setString(2,strFolderName);
		pstmt.execute();
		rs = pstmt.getResultSet();
		if(rs != null && rs.next()) {
			iFolderIndex = Integer.parseInt(rs.getString(1));
				
			}
		}finally{
			try {  
				if(rs!=null){
					rs.close();
					rs = null;
				}
			}catch(Exception e){
				WFSUtil.printErr("","", e);
			}
			try{
				if(pstmt!=null){
					pstmt.close();
					pstmt = null;
				} 
			}catch(Exception e){
				WFSUtil.printErr("","", e);
			}
		}
		if(iFolderIndex <= 0)
			iFolderIndex = getPDBFolderQuery(con,strFolderName,ParentFolderIndex,dbType);
		return iFolderIndex;
	}
	
		/**
     * *******************************************************************************
     *                  Function Name       : getDocumentIndex
     * 					Author				:   Mandeep Kaur
     *					 Date Written    	:   27/09/2011
     *                  Input Parameters    : Connection con, String folderName, String parentFolderIndex, int dbType, WFParticipant participant
     *                  Output Parameters   : String(PDBFolder Query )
     *                  Return Values       : Query
     *                  Description         : To create ProcessFolder and Process document
     * *******************************************************************************
     */

	public static int getDocumentIndex(Connection con, int ParentFolderIndex, String DocumentName,int dbType,String strComment) throws SQLException, Exception{
		
		String strDocumentName = "";
		int iDocumentIndex = -1;
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		String strQuery = null ;
		//StringBuffer query = new StringBuffer();
		strDocumentName = DocumentName;
	
		if(dbType == JTSConstant.JTS_MSSQL){
			strQuery = "SELECT d.documentIndex FROM PDBDocument d, PDBDocumentContent c WHERE c.parentFolderindex = ? and d.name = ? and d.documentindex = c.documentindex ";
		}else if(dbType == JTSConstant.JTS_ORACLE || dbType == JTSConstant.JTS_POSTGRES ){
			strQuery = "SELECT d.documentIndex FROM PDBDocument d, PDBDocumentContent c WHERE c.parentFolderindex = ? and UPPER(d.name) = UPPER(?) and d.documentindex = c.documentindex ";
		} 
		pstmt = con.prepareStatement(strQuery);
	   	pstmt.setInt(1, ParentFolderIndex);
		pstmt.setString(2,strDocumentName);
		pstmt.execute();
		rs = pstmt.getResultSet();
		if(rs != null && rs.next()) {
			iDocumentIndex = Integer.parseInt(rs.getString(1));
				
			}
		rs.close();
		rs = null;
		pstmt.close();
		pstmt = null;
		if(iDocumentIndex <= 0)
			iDocumentIndex = getPDBDocQuery(con,dbType,ParentFolderIndex,strDocumentName,strComment);
		return iDocumentIndex;
	}

	
	public static String dbDateTime(Connection con,int dbType) throws SQLException{
		    String dateStr = null;
		    String dateQry = "";
		    PreparedStatement pstmt = null;
		    ResultSet rs = null;
		    try{
		        switch (dbType) {
		                case JTSConstant.JTS_MSSQL:
		                    dateQry = "select convert(varchar(24), getdate(), 20)";
		                    break;
		                case JTSConstant.JTS_ORACLE:
		                    dateQry = "SELECT to_char(SYSDATE,'YYYY-MM-DD HH24:MI:SS') FROM dual";
		                    break;
                                 case JTSConstant.JTS_POSTGRES: 
                                     dateQry = "SELECT to_char(CURRENT_TIMESTAMP,'YYYY-MM-DD HH24:MI:SS') ";
                                    break;
		              /*case JTSConstant.JTS_POSTGRES:
		                    dateStr = " CURRENT_TIMESTAMP ";
		                    break;
		                case JTSConstant.JTS_DB2:
		                    dateStr = " CURRENT TIMESTAMP ";
		                    break;
		                default:
		                    dateStr = "	getDate() ";
		                    break;*/
		        }
		        pstmt = con.prepareStatement(dateQry);
		        pstmt.execute();
				rs = pstmt.getResultSet();
		        if(rs!=null && rs.next()){
		            dateStr = rs.getString(1);
		        }
		        
		    } catch (SQLException e) {
		            printErr("","", e);
		    } catch (Exception e) {
		            printErr("","", e);
		    }finally{
		    	try {  
					if(rs!=null){
						rs.close();
						rs = null;
					}
				}catch(Exception e){
					WFSUtil.printErr("","", e);
				}
		    	try{
					if(pstmt!=null){
						pstmt.close();
						pstmt = null;
					} 
				}catch(Exception e){
					WFSUtil.printErr("","", e);
				}
		    } 
		      return WFSUtil.TO_SANITIZE_STRING(dateStr, true);

	}
	
	
	
	
	
	
	
	
	/**
     * *******************************************************************************
     *                  Function Name       : getDocumentIndex
     * 					Author				:   Mandeep Kaur
     *					 Date Written    	:   27/09/2011
     *                  Input Parameters    : Connection con, String folderName, String parentFolderIndex, int dbType, WFParticipant participant
     *                  Output Parameters   : String(PDBFolder Query )
     *                  Return Values       : Query
     *                  Description         : To create ProcessFolder and Process document
     * *******************************************************************************
     */

	public static int getDocumentIndex(Connection con, int ParentFolderIndex, String DocumentName,int dbType,String strComment, String engineName) throws SQLException, Exception{
		
		String strDocumentName = "";
		int iDocumentIndex = -1;
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		String strQuery = null ;
		//StringBuffer query = new StringBuffer();
		strDocumentName = DocumentName;
	
		if(dbType == JTSConstant.JTS_MSSQL){
			strQuery = "SELECT d.documentIndex FROM PDBDocument d, PDBDocumentContent c WHERE c.parentFolderindex = ? and d.name = ? and d.documentindex = c.documentindex ";
		}else if(dbType == JTSConstant.JTS_ORACLE || dbType == JTSConstant.JTS_POSTGRES ){
			strQuery = "SELECT d.documentIndex FROM PDBDocument d, PDBDocumentContent c WHERE c.parentFolderindex = ? and UPPER(d.name) = UPPER(?) and d.documentindex = c.documentindex ";
		} 
		pstmt = con.prepareStatement(strQuery);
	   	pstmt.setInt(1, ParentFolderIndex);
		pstmt.setString(2,strDocumentName);
		pstmt.execute();
		rs = pstmt.getResultSet();
		if(rs != null && rs.next()) {
			iDocumentIndex = Integer.parseInt(rs.getString(1));
				
			}
		rs.close();
		rs = null;
		pstmt.close();
		pstmt = null;
		if(iDocumentIndex <= 0)
			iDocumentIndex = getPDBDocQuery(con,dbType,ParentFolderIndex,strDocumentName,strComment, engineName);
		return iDocumentIndex;
	}
	/**
	/**
     * *******************************************************************************
     *                  Function Name       : getPDBFolderQuery
     * 					Author				:   Mandeep Kaur
     *					 Date Written    	:   27/09/2011
     *                  Input Parameters    : Connection con, String folderName, String parentFolderIndex, int dbType, WFParticipant participant
     *                  Output Parameters   : String(PDBFolder Query )
     *                  Return Values       : Query
     *                  Description         : To create ProcessFolder and Process document
     * *******************************************************************************
     */

	public static int getPDBFolderQuery(Connection con, String folderName, int parentFolderIndex,  int dbType) throws SQLException, Exception{
		Statement stmt = null;
		ResultSet rs = null;
		StringBuffer query = new StringBuffer();
		int userID = 1 ;
		String folderIndex = "";
		int folderId = 0;
		String imageVolIndex = "0";	
		stmt = con.createStatement();
		stmt.execute("select imageVolumeindex from pdbcabinet");
		rs = stmt.getResultSet();
		if(rs != null && rs.next()){
			imageVolIndex = rs.getString(1);
		}
		if(rs != null){
			rs.close();
			rs = null;
		}
		
		if(dbType != JTSConstant.JTS_MSSQL){
			folderIndex = WFSUtil.nextVal(con, "FolderId", dbType);
		}
		stmt = con.createStatement();
		if(dbType == JTSConstant.JTS_MSSQL){
				query.append("Insert Into PDBFolder (ParentFolderIndex,Name,Owner,CreatedDatetime,RevisedDateTime,");
				query.append("AccessedDateTime,DataDefinitionIndex,AccessType,ImageVolumeIndex,FolderType,");
				query.append("FolderLock,Location,DeletedDateTime,EnableVersion,ExpiryDateTime,Comment,");
				query.append("ACL,FinalizedFlag,FinalizedDateTime,FinalizedBy,ACLMoreFlag,MainGroupId,EnableFTS,");
				query.append("FolderLevel,Hierarchy,OwnerInheritance )");
				query.append(" values(");
				query.append(Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(parentFolderIndex), false))+", ");
                                query.append(WFSUtil.TO_STRING(folderName, true, dbType));
				//query.append(WFSUtil.replace(folderName, "'", "''"));
				query.append(", " + userID + ", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append("0, 'S',");
				query.append(WFSUtil.TO_SANITIZE_STRING(imageVolIndex, true));
				query.append(", 'G', 'N', 'G',");
				query.append("'2099-12-12 00:00:00.000', 'N', '2099-12-12 00:00:00.000', 'Not Defined', 'G1#001111,', 'N', '2099-12-12 00:00:00.000', ");
				query.append("0, 'N', 0, 'N', 2, '0.', 'N')");
			}else if(dbType == JTSConstant.JTS_ORACLE){
				query.append("Insert Into PDBFolder (FolderIndex, ParentFolderIndex,Name,Owner,CreatedDatetime,RevisedDateTime,");
				query.append("AccessedDateTime,DataDefinitionIndex,AccessType,ImageVolumeIndex,FolderType,");
				query.append("FolderLock,Location,DeletedDateTime,EnableVersion,ExpiryDateTime,Commnt,");
				query.append("ACL,FinalizedFlag,FinalizedDateTime,FinalizedBy,ACLMoreFlag,MainGroupId,EnableFTS,");
				query.append("FolderLevel,OwnerInheritance )");
				query.append(" values(" + WFSUtil.TO_SANITIZE_STRING(folderIndex, true) + ", ");
				query.append(Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(parentFolderIndex), false)) + ", ");
                                query.append(WFSUtil.TO_STRING(folderName, true, dbType));
				//query.append(WFSUtil.replace(folderName, "'", "''"));
				query.append(", " + userID + ", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append("0, 'S', ");
				query.append(WFSUtil.TO_SANITIZE_STRING(imageVolIndex,  true));
				query.append(", 'G', 'N', 'G',");
				query.append(WFSUtil.TO_DATE("2099-12-12 00:00:00", true, dbType)).append(", 'N', ").append(WFSUtil.TO_DATE("2099-12-12 00:00:00", true, dbType));
				query.append(", 'Not Defined', 'G1#001111,', 'N', ").append(WFSUtil.TO_DATE("2099-12-12 00:00:00", true, dbType));
				query.append(",0, 'N', 0, 'N', 2, 'N')");
			} else if(dbType == JTSConstant.JTS_POSTGRES){
				query.append("Insert Into PDBFolder (FolderIndex, ParentFolderIndex,Name,Owner,CreatedDatetime,RevisedDateTime,");
				query.append("AccessedDateTime,DataDefinitionIndex,AccessType,ImageVolumeIndex,FolderType,");
				query.append("FolderLock,Location,DeletedDateTime,EnableVersion,ExpiryDateTime,Comment,");
				query.append("ACL,FinalizedFlag,FinalizedDateTime,FinalizedBy,ACLMoreFlag,MainGroupId,EnableFTS,");
				query.append("FolderLevel,OwnerInheritance )");
				query.append(" values(" + WFSUtil.TO_SANITIZE_STRING(folderIndex, true) + ", ");
				query.append(Integer.parseInt(WFSUtil.TO_SANITIZE_STRING(Integer.toString(parentFolderIndex), false)) + ", '");
				query.append(WFSUtil.replace(folderName, "'", "''"));
				query.append("', " + userID + ", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append("0, 'S',");
				query.append(WFSUtil.TO_SANITIZE_STRING(imageVolIndex, true));
				query.append(", 'G', 'N', 'G',");
				query.append(WFSUtil.TO_DATE("2099-12-12 00:00:00", true, dbType)).append(", 'N', ").append(WFSUtil.TO_DATE("2099-12-12 00:00:00", true, dbType));
				query.append(", 'Not Defined', 'G1#001111,', 'N', ").append(WFSUtil.TO_DATE("2099-12-12 00:00:00", true, dbType));
				query.append(",0, 'N', 0, 'N', 2, 'N')");
			}
		stmt.execute(query.toString());
		if(dbType == JTSConstant.JTS_MSSQL){	
			stmt.execute("Select @@IDENTITY");
			rs = stmt.getResultSet();

			if(rs != null && rs.next()) {
				folderIndex = rs.getString(1);
				rs.close();
			}
			rs = null;
		}
		folderId = Integer.parseInt(folderIndex);
		return folderId;
	}
	
		/**
     * *************************************************************
     * Function Name    :   getPDBDocQuery
     * Author			:   Mandeep Kaur
     * Date Written     :   27/09/2011
     * Input Parameters :   Connection con, int dbType, WFParticipant participant, String queueName
     * Output Parameters:   String
     * Return Value     :   Query for PDBDocument table entry
     * Description      :   Method to create query for PDBDocument table entry while generating queues.
     * *************************************************************
     */
	
	private static int getPDBDocQuery(Connection con,int dbType,int iParentFolderIndex,String strDocumentName, String strComment) throws SQLException, Exception{
		StringBuffer sbAddDoc = new StringBuffer();
		Statement stmt = null;
		ResultSet rs = null;
		int userID = 1 ;
		String strDocumentIndex = "" ;
		int iDocumentIndex = -1;
		try{		
			if(dbType != JTSConstant.JTS_MSSQL){
				strDocumentIndex = WFSUtil.nextVal(con, "DocumentId", dbType);
			}
			stmt = con.createStatement();
			if(dbType == JTSConstant.JTS_MSSQL){
				sbAddDoc.append("Insert Into PDBDocument (VersionNumber, VersionComment, Name, Owner, CreatedDateTime,");
				sbAddDoc.append("RevisedDateTime, AccessedDateTime, DataDefinitionIndex,Versioning, AccessType, DocumentType, CreatedbyApplication,");
				sbAddDoc.append("CreatedbyUser, ImageIndex, VolumeId, NoOfPages, DocumentSize,FTSDocumentIndex, ODMADocumentIndex, HistoryEnableFlag,");
				sbAddDoc.append("DocumentLock, LockByUser, Comment, Author, TextImageIndex,TextVolumeId, FTSFlag, DocStatus, ExpiryDateTime,FinalizedFlag,");
				sbAddDoc.append("FinalizedDateTime, FinalizedBy, CheckOutstatus,CheckOutbyUser, UseFulData, ACL, PhysicalLocation, ACLMoreFlag,AppName, MainGroupId,");
				sbAddDoc.append("PullPrintFlag, ThumbNailFlag,LockMessage )");
				sbAddDoc.append(" values(1.0, 'Original',");
                                sbAddDoc.append(WFSUtil.TO_STRING(strDocumentName, true, dbType));
				//sbAddDoc.append(WFSUtil.replace(strDocumentName, "'", "''"));
				sbAddDoc.append(", " + userID + ", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append("0,'N', 'S', 'N', 0, 1, -1, -1, 0, 0,0, 'not defined', 'N',");
	//										sbAddDoc.append("'N', null, '', 'supervisor', 0, 0, 'XX', 'A', '2099-12-12 00:00:00.000', 'N', '2099-12-12 00:00:00.000', 0, 'N',0, null, 'G1#000000,', 'not defined',");
				sbAddDoc.append("'N', null, "+ WFSUtil.TO_STRING(strComment, true, dbType)+", 'supervisor', 0, 0, 'XX', 'A', '2099-12-12 00:00:00.000', 'N', '2099-12-12 00:00:00.000', 0, 'N',0, null, 'G1#000000,', 'not defined',");
				sbAddDoc.append("'N','txt', 0, 'N', 'N', null)");
			} else if(dbType == JTSConstant.JTS_ORACLE){
				sbAddDoc.append("Insert Into PDBDocument (DocumentIndex, VersionNumber, VersionComment, Name, Owner, CreatedDateTime,");
				sbAddDoc.append("RevisedDateTime, AccessedDateTime, DataDefinitionIndex,Versioning, AccessType, DocumentType, CreatedbyApplication,");
				sbAddDoc.append("CreatedbyUser, ImageIndex, VolumeId, NoOfPages, DocumentSize,FTSDocumentIndex, ODMADocumentIndex, HistoryEnableFlag,");
				sbAddDoc.append("DocumentLock, LockByUser, Commnt, Author, TextImageIndex,TextVolumeId, FTSFlag, DocStatus, ExpiryDateTime,FinalizedFlag,");
				sbAddDoc.append("FinalizedDateTime, FinalizedBy, CheckOutstatus,CheckOutbyUser, UseFulData, ACL, PhysicalLocation, ACLMoreFlag,AppName, MainGroupId,");
				sbAddDoc.append("PullPrintFlag, ThumbNailFlag,LockMessage )");
				sbAddDoc.append(" values(" + strDocumentIndex + ", 1.0, 'Original',");
                                sbAddDoc.append(WFSUtil.TO_STRING(strDocumentName, true, dbType));
				//sbAddDoc.append(WFSUtil.replace(strDocumentName, "'", "''"));
	//										sbAddDoc.append(", "+userID+", getDate(),getDate(), getDate(), 0,'N', 'S', 'N', 0, 1, -1, -1, 0, 0,0, 'not defined', 'N',");
				sbAddDoc.append(", " + userID + ", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append("0,'N', 'S', 'N', 0, 1, -1, -1, 0, 0,0, 'not defined', 'N',");
	//										sbAddDoc.append("'N', null, '', 'supervisor', 0, 0, 'XX', 'A', ").append(WFSUtil.TO_DATE("2099-12-12 00:00:00",true,dbType)).append(", 'N', ").append(WFSUtil.TO_DATE("2099-12-12 00:00:00",true,dbType)).append(", 0, 'N',0, null, 'G1#000000,', 'not defined',");
				sbAddDoc.append("'N', null, "+ WFSUtil.TO_STRING(strComment, true, dbType)+", 'supervisor', 0, 0, 'XX', 'A', ").append(WFSUtil.TO_DATE("2099-12-12 00:00:00", true, dbType)).append(", 'N', ").append(WFSUtil.TO_DATE("2099-12-12 00:00:00", true, dbType)).append(", 0, 'N',0, null, 'G1#000000,', 'not defined',");
				sbAddDoc.append("'N','txt', 0, 'N', 'N', null)");
			} else if(dbType == JTSConstant.JTS_DB2){
				sbAddDoc.append("Insert Into PDBDocument (DocumentIndex, VersionNumber, VersionComment, Name, Owner, CreatedDateTime,");
				sbAddDoc.append("RevisedDateTime, AccessedDateTime, DataDefinitionIndex,Versioning, AccessType, DocumentType, CreatedbyApplication,");
				sbAddDoc.append("CreatedbyUser, ImageIndex, VolumeId, NoOfPages, DocumentSize,FTSDocumentIndex, ODMADocumentIndex, HistoryEnableFlag,");
				sbAddDoc.append("DocumentLock, LockByUser, comment, Author, TextImageIndex,TextVolumeId, FTSFlag, DocStatus, ExpiryDateTime,FinalizedFlag,");
				sbAddDoc.append("FinalizedDateTime, FinalizedBy, CheckOutstatus,CheckOutbyUser, UseFulData, ACL, PhysicalLocation, ACLMoreFlag,AppName, MainGroupId,");
				sbAddDoc.append("PullPrintFlag, ThumbNailFlag,LockMessage )");
				sbAddDoc.append(" values( " + strDocumentIndex + ", 1.0, 'Original','");
				sbAddDoc.append(WFSUtil.replace(strDocumentName, "'", "''"));
				sbAddDoc.append("', " + userID + ", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append("0,'N', 'S', 'N', 0, 1, -1, -1, 0, 0,0, 'not defined', 'N',");
				sbAddDoc.append("'N', null, '"+ WFSUtil.TO_STRING(strComment, true, dbType)+"', 'supervisor', 0, 0, 'XX', 'A', '2099-12-12 00:00:00.000', 'N', '2099-12-12 00:00:00.000', 0, 'N',0, null, 'G1#000000,', 'not defined',");
				sbAddDoc.append("'N','txt', 0, 'N', 'N', null)");
			} else if(dbType == JTSConstant.JTS_POSTGRES){
				sbAddDoc.append("Insert Into PDBDocument (DocumentIndex, VersionNumber, VersionComment, Name, Owner, CreatedDateTime,");
				sbAddDoc.append("RevisedDateTime, AccessedDateTime, DataDefinitionIndex,Versioning, AccessType, DocumentType, CreatedbyApplication,");
				sbAddDoc.append("CreatedbyUser, ImageIndex, VolumeId, NoOfPages, DocumentSize,FTSDocumentIndex, ODMADocumentIndex, HistoryEnableFlag,");
				sbAddDoc.append("DocumentLock, LockByUser, comment, Author, TextImageIndex,TextVolumeId, FTSFlag, DocStatus, ExpiryDateTime,FinalizedFlag,");
				sbAddDoc.append("FinalizedDateTime, FinalizedBy, CheckOutstatus,CheckOutbyUser, UseFulData, ACL, PhysicalLocation, ACLMoreFlag,AppName, MainGroupId,");
				sbAddDoc.append("PullPrintFlag, ThumbNailFlag,LockMessage )");
				sbAddDoc.append(" values(" + strDocumentIndex + ", 1.0, 'Original',");
				sbAddDoc.append(WFSUtil.TO_STRING(strDocumentName, true, dbType));
				sbAddDoc.append(", " + userID + ", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append("0,'N', 'S', 'N', 0, 1, -1, -1, 0, 0,0, 'not defined', 'N',");
				sbAddDoc.append("'N', null, "+ WFSUtil.TO_STRING(strComment, true, dbType)+", 'supervisor', 0, 0, 'XX', 'A', '2099-12-12 00:00:00.000', 'N', '2099-12-12 00:00:00.000', 0, 'N',0, null, 'G1#000000,', 'not defined',");
				sbAddDoc.append("'N','txt', 0, 'N', 'N', null)");
			}
			WFSUtil.printOut("","[WFSUtil]getPDBDocQuery :: "+sbAddDoc.toString());
			stmt.execute(sbAddDoc.toString());
			if(dbType == JTSConstant.JTS_MSSQL){
				stmt.execute("Select @@IDENTITY");
				rs = stmt.getResultSet();

				if(rs != null && rs.next()) {
					iDocumentIndex = Integer.parseInt(rs.getString(1));
					rs.close();
				}
				rs = null;
			}
		//add entry in pdbdocumentcontent
		stmt.execute("select " + WFSUtil.isnull("max(DocumentOrderNo)", "0", dbType) + " + 1 from PDBDocumentcontent where ParentFolderIndex= " + iParentFolderIndex);

		rs = stmt.getResultSet();
		int order = 0;
		if(rs.next())
			order = rs.getInt(1);
		sbAddDoc = new StringBuffer(100);
		sbAddDoc.append("Insert Into PDBDocumentContent	(ParentFolderIndex, DocumentIndex, FiledBy, FiledDatetime,DocumentOrderNo, RefereceFlag, DocStatus ) ");
		sbAddDoc.append("values(" + iParentFolderIndex);
		sbAddDoc.append("," + iDocumentIndex);
		sbAddDoc.append(", 1, ").append(WFSUtil.getDate(dbType)).append(",");
		sbAddDoc.append(order);
		sbAddDoc.append(", 'O', 'A')");
		stmt.execute(sbAddDoc.toString());
			
		} finally{
			try {  
				if(rs!=null){
					rs.close();
					rs = null;
				}
			}catch(Exception e){
				WFSUtil.printErr("", e);
			}
			try{
				if(stmt!=null){
					stmt.close();
					stmt = null;
				} 
			}catch(Exception e){
				WFSUtil.printErr("", e);
			}
		}
		return iDocumentIndex ;
	}
	
	/**
     * *************************************************************
     * Function Name    :   getAssignableRightsForAnObject
     * Author			:   Saurabh Kamal
     * Date Written     :   09/08/2012
     * Input Parameters :   Connection con, int objectTypeId
     * Output Parameters:   String
     * Return Value     :   
     * Description      :   
     * *************************************************************
     */
	
	public static String getAssignableRightsForAnObject(Connection con, int objectTypeId) throws SQLException{
		String strGetAssignableRightsForAnObject = WFRMSUtil.getAssignableRightsForAnObject(con,objectTypeId);
		return strGetAssignableRightsForAnObject;
		/*StringBuffer strBuff = new StringBuffer(500);
		PreparedStatement pstmt= null;
        ResultSet rs = null;
		pstmt = con.prepareStatement("select RightFlag, RightName from WFAssignableRightsTable where ObjectTypeId = ?");
		pstmt.setInt(1, objectTypeId);
		rs = pstmt.executeQuery();
		strBuff.append("<AssignableRights>");
		while(rs.next()){
			strBuff.append("<AssignableRight>");
			strBuff.append("<RightFlag>" + rs.getString("RightFlag") + "</RightFlag>");
			strBuff.append("<RightName>" + rs.getString("RightName") + "</RightName>");
			strBuff.append("</AssignableRight>");
		}
		strBuff.append("</AssignableRights>");
		return strBuff.toString();*/
	}
	/*
	public static String getObjectNameForObjectId(Connection con, int objectTypeId, String inputXml, String key) throws SQLException, Exception{
        String outputXml = executeGetObjectList(con, objectTypeId, inputXml, key);
		XMLParser parser = new XMLParser(outputXml);		
        return parser.getValueOf("ObjectName");
	}
	*/

	/**
     * *************************************************************
     * Function Name    :   getPDBDocQuery
     * Author			:   Mandeep Kaur
     * Date Written     :   27/09/2011
     * Input Parameters :   Connection con, int dbType, WFParticipant participant, String queueName
     * Output Parameters:   String
     * Return Value     :   Query for PDBDocument table entry
     * Description      :   Method to create query for PDBDocument table entry while generating queues.
     * *************************************************************
     */
	
	private static int getPDBDocQuery(Connection con,int dbType,int iParentFolderIndex,String strDocumentName, String strComment, String engineName) throws SQLException, Exception{
		StringBuffer sbAddDoc = new StringBuffer();
		Statement stmt = null;
		ResultSet rs = null;
		int userID = 1 ;
		String strDocumentIndex = "" ;
		int iDocumentIndex = -1;
		try{		
			if(dbType != JTSConstant.JTS_MSSQL){
				strDocumentIndex = WFSUtil.nextVal(con, "DocumentId", dbType);
			}
			stmt = con.createStatement();
			if(dbType == JTSConstant.JTS_MSSQL){
				sbAddDoc.append("Insert Into PDBDocument (VersionNumber, VersionComment, Name, Owner, CreatedDateTime,");
				sbAddDoc.append("RevisedDateTime, AccessedDateTime, DataDefinitionIndex,Versioning, AccessType, DocumentType, CreatedbyApplication,");
				sbAddDoc.append("CreatedbyUser, ImageIndex, VolumeId, NoOfPages, DocumentSize,FTSDocumentIndex, ODMADocumentIndex, HistoryEnableFlag,");
				sbAddDoc.append("DocumentLock, LockByUser, Comment, Author, TextImageIndex,TextVolumeId, FTSFlag, DocStatus, ExpiryDateTime,FinalizedFlag,");
				sbAddDoc.append("FinalizedDateTime, FinalizedBy, CheckOutstatus,CheckOutbyUser, UseFulData, ACL, PhysicalLocation, ACLMoreFlag,AppName, MainGroupId,");
				sbAddDoc.append("PullPrintFlag, ThumbNailFlag,LockMessage )");
				sbAddDoc.append(" values(1.0, 'Original',");
                                sbAddDoc.append(WFSUtil.TO_STRING(strDocumentName, true, dbType));
				//sbAddDoc.append(WFSUtil.replace(strDocumentName, "'", "''"));
				sbAddDoc.append(", " + userID + ", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append("0,'N', 'S', 'N', 0, 1, -1, -1, 0, 0,0, 'not defined', 'N',");
	//										sbAddDoc.append("'N', null, '', 'supervisor', 0, 0, 'XX', 'A', '2099-12-12 00:00:00.000', 'N', '2099-12-12 00:00:00.000', 0, 'N',0, null, 'G1#000000,', 'not defined',");
				sbAddDoc.append("'N', null, "+ WFSUtil.TO_STRING(strComment, true, dbType)+", 'supervisor', 0, 0, 'XX', 'A', '2099-12-12 00:00:00.000', 'N', '2099-12-12 00:00:00.000', 0, 'N',0, null, 'G1#000000,', 'not defined',");
				sbAddDoc.append("'N','txt', 0, 'N', 'N', null)");
			} else if(dbType == JTSConstant.JTS_ORACLE){
				sbAddDoc.append("Insert Into PDBDocument (DocumentIndex, VersionNumber, VersionComment, Name, Owner, CreatedDateTime,");
				sbAddDoc.append("RevisedDateTime, AccessedDateTime, DataDefinitionIndex,Versioning, AccessType, DocumentType, CreatedbyApplication,");
				sbAddDoc.append("CreatedbyUser, ImageIndex, VolumeId, NoOfPages, DocumentSize,FTSDocumentIndex, ODMADocumentIndex, HistoryEnableFlag,");
				sbAddDoc.append("DocumentLock, LockByUser, Commnt, Author, TextImageIndex,TextVolumeId, FTSFlag, DocStatus, ExpiryDateTime,FinalizedFlag,");
				sbAddDoc.append("FinalizedDateTime, FinalizedBy, CheckOutstatus,CheckOutbyUser, UseFulData, ACL, PhysicalLocation, ACLMoreFlag,AppName, MainGroupId,");
				sbAddDoc.append("PullPrintFlag, ThumbNailFlag,LockMessage )");
				sbAddDoc.append(" values(" + WFSUtil.TO_SANITIZE_STRING(strDocumentIndex, false) + ", 1.0, 'Original',");
                                sbAddDoc.append(WFSUtil.TO_STRING(strDocumentName, true, dbType));
				//sbAddDoc.append(WFSUtil.replace(strDocumentName, "'", "''"));
	//										sbAddDoc.append(", "+userID+", getDate(),getDate(), getDate(), 0,'N', 'S', 'N', 0, 1, -1, -1, 0, 0,0, 'not defined', 'N',");
				sbAddDoc.append("', " + userID + ", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append("0,'N', 'S', 'N', 0, 1, -1, -1, 0, 0,0, 'not defined', 'N',");
	//										sbAddDoc.append("'N', null, '', 'supervisor', 0, 0, 'XX', 'A', ").append(WFSUtil.TO_DATE("2099-12-12 00:00:00",true,dbType)).append(", 'N', ").append(WFSUtil.TO_DATE("2099-12-12 00:00:00",true,dbType)).append(", 0, 'N',0, null, 'G1#000000,', 'not defined',");
				sbAddDoc.append("'N', null, "+ WFSUtil.TO_STRING(strComment, true, dbType)+", 'supervisor', 0, 0, 'XX', 'A', ").append(WFSUtil.TO_DATE("2099-12-12 00:00:00", true, dbType)).append(", 'N', ").append(WFSUtil.TO_DATE("2099-12-12 00:00:00", true, dbType)).append(", 0, 'N',0, null, 'G1#000000,', 'not defined',");
				sbAddDoc.append("'N','txt', 0, 'N', 'N', null)");
			} else if(dbType == JTSConstant.JTS_DB2){
				sbAddDoc.append("Insert Into PDBDocument (DocumentIndex, VersionNumber, VersionComment, Name, Owner, CreatedDateTime,");
				sbAddDoc.append("RevisedDateTime, AccessedDateTime, DataDefinitionIndex,Versioning, AccessType, DocumentType, CreatedbyApplication,");
				sbAddDoc.append("CreatedbyUser, ImageIndex, VolumeId, NoOfPages, DocumentSize,FTSDocumentIndex, ODMADocumentIndex, HistoryEnableFlag,");
				sbAddDoc.append("DocumentLock, LockByUser, comment, Author, TextImageIndex,TextVolumeId, FTSFlag, DocStatus, ExpiryDateTime,FinalizedFlag,");
				sbAddDoc.append("FinalizedDateTime, FinalizedBy, CheckOutstatus,CheckOutbyUser, UseFulData, ACL, PhysicalLocation, ACLMoreFlag,AppName, MainGroupId,");
				sbAddDoc.append("PullPrintFlag, ThumbNailFlag,LockMessage )");
				sbAddDoc.append(" values( " + WFSUtil.TO_SANITIZE_STRING(strDocumentIndex, false) + ", 1.0, 'Original','");
				sbAddDoc.append(WFSUtil.replace(strDocumentName, "'", "''"));
				sbAddDoc.append("', " + userID + ", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append("0,'N', 'S', 'N', 0, 1, -1, -1, 0, 0,0, 'not defined', 'N',");
				sbAddDoc.append("'N', null, '"+ WFSUtil.TO_STRING(strComment, true, dbType)+"', 'supervisor', 0, 0, 'XX', 'A', '2099-12-12 00:00:00.000', 'N', '2099-12-12 00:00:00.000', 0, 'N',0, null, 'G1#000000,', 'not defined',");
				sbAddDoc.append("'N','txt', 0, 'N', 'N', null)");
			} else if(dbType == JTSConstant.JTS_POSTGRES){
				sbAddDoc.append("Insert Into PDBDocument (DocumentIndex, VersionNumber, VersionComment, Name, Owner, CreatedDateTime,");
				sbAddDoc.append("RevisedDateTime, AccessedDateTime, DataDefinitionIndex,Versioning, AccessType, DocumentType, CreatedbyApplication,");
				sbAddDoc.append("CreatedbyUser, ImageIndex, VolumeId, NoOfPages, DocumentSize,FTSDocumentIndex, ODMADocumentIndex, HistoryEnableFlag,");
				sbAddDoc.append("DocumentLock, LockByUser, comment, Author, TextImageIndex,TextVolumeId, FTSFlag, DocStatus, ExpiryDateTime,FinalizedFlag,");
				sbAddDoc.append("FinalizedDateTime, FinalizedBy, CheckOutstatus,CheckOutbyUser, UseFulData, ACL, PhysicalLocation, ACLMoreFlag,AppName, MainGroupId,");
				sbAddDoc.append("PullPrintFlag, ThumbNailFlag,LockMessage )");
				sbAddDoc.append(" values(" + WFSUtil.TO_SANITIZE_STRING(strDocumentIndex, false) + ", 1.0, 'Original',");
				sbAddDoc.append(WFSUtil.TO_STRING(strDocumentName, true, dbType));
				sbAddDoc.append(", " + userID + ", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append(WFSUtil.getDate(dbType)).append(", ").append("0,'N', 'S', 'N', 0, 1, -1, -1, 0, 0,0, 'not defined', 'N',");
				sbAddDoc.append("'N', null, "+ WFSUtil.TO_STRING(strComment, true, dbType)+", 'supervisor', 0, 0, 'XX', 'A', '2099-12-12 00:00:00.000', 'N', '2099-12-12 00:00:00.000', 0, 'N',0, null, 'G1#000000,', 'not defined',");
				sbAddDoc.append("'N','txt', 0, 'N', 'N', null)");
			}
			WFSUtil.printOut(engineName,"[WFSUtil]getPDBDocQuery :: "+sbAddDoc.toString());
			stmt.execute(sbAddDoc.toString());
			if(dbType == JTSConstant.JTS_MSSQL){
				stmt.execute("Select @@IDENTITY");
				rs = stmt.getResultSet();

				if(rs != null && rs.next()) {
					iDocumentIndex = Integer.parseInt(rs.getString(1));
					rs.close();
				}
				rs = null;
			}
		//add entry in pdbdocumentcontent
		stmt.execute("select " + WFSUtil.isnull("max(DocumentOrderNo)", "0", dbType) + " + 1 from PDBDocumentcontent where ParentFolderIndex= " + iParentFolderIndex);

		rs = stmt.getResultSet();
		int order = 0;
		if(rs.next())
			order = rs.getInt(1);
		sbAddDoc = new StringBuffer(100);
		sbAddDoc.append("Insert Into PDBDocumentContent	(ParentFolderIndex, DocumentIndex, FiledBy, FiledDatetime,DocumentOrderNo, RefereceFlag, DocStatus ) ");
		sbAddDoc.append("values(" + iParentFolderIndex);
		sbAddDoc.append("," + iDocumentIndex);
		sbAddDoc.append(", 1, ").append(WFSUtil.getDate(dbType)).append(",");
		sbAddDoc.append(order);
		sbAddDoc.append(", 'O', 'A')");
		stmt.execute(sbAddDoc.toString());
			
		} finally{
			try{
			if(stmt != null){
				stmt.close();
				stmt = null;
			}}catch(Exception e){
				 WFSUtil.printErr(engineName,"", e);
			}
			try{
			if(rs != null){
				rs.close();
				rs = null;
			}}catch(Exception e){
				 WFSUtil.printErr(engineName,"", e);
			}
				
		}
		return iDocumentIndex ;
	}
	
	/*
	public static String getObjectNameForObjectId(Connection con, int objectTypeId, String inputXml, String key) throws SQLException, Exception{
        String outputXml = executeGetObjectList(con, objectTypeId, inputXml, key);
		XMLParser parser = new XMLParser(outputXml);		
        return parser.getValueOf("ObjectName");
	}
	*/
	
	/**
     * *************************************************************
     * Function Name    :   executeGetObjectList
     * Author			:   Saurabh Kamal
     * Date Written     :   09/08/2012
     * Input Parameters :   Connection con, XMLParser parser, XMLGenerator gen, int objectTypeId
     * Output Parameters:   String
     * Return Value     :   
     * Description      :   
     * *************************************************************
     */
	
	public static String executeGetObjectList(Connection con, XMLParser parser, XMLGenerator gen, int objectTypeId) throws SQLException, Exception{
	/*
        //System.out.println("within executeGetObjectList ");
        String outputXml = null;
		Statement stmt = null;
		stmt = con.createStatement();
        ResultSet rs = null;
        String className = null;
        rs = stmt.executeQuery("select classname from WFObjectListTable where ObjectTypeId = " + objectTypeId);
        if(rs.next())
            className = rs.getString(1);
			
		if(stmt != null){
			stmt.close();
			stmt = null;
		}
		if(rs != null){
			rs.close();
			rs = null;
		}			
        Class clazz = Class.forName(className);
        Method method = clazz.getMethod("getObjectList", new Class[]{Connection.class, XMLParser.class, XMLGenerator.class});
        outputXml = (String)method.invoke(clazz.newInstance(), new Object[]{con, parser, gen});
        //System.out.println("within executeGetObjectList :: output :: " + outputXml);
        return outputXml;*/
		String strExecuteGetObjectList = WFRMSUtil.executeGetObjectList(con,parser,gen,objectTypeId);
		return strExecuteGetObjectList;
	}
	
	/**
     * *************************************************************
     * Function Name    :   executeGetQueryParam
     * Author			:   Saurabh Kamal
     * Date Written     :   09/08/2012
     * Input Parameters :   Connection con, int objectTypeId
     * Output Parameters:   String[]
     * Return Value     :   
     * Description      :   
     * *************************************************************
     */
	
	public static String[] executeGetQueryParam(Connection con, int objectTypeId) throws SQLException, Exception{
        //System.out.println("within executeGetObjectList ");
       /* String outputXml = null;
		Statement stmt = null;
		stmt = con.createStatement();
        ResultSet rs = null;
        String className = null;
		
        rs = stmt.executeQuery("select classname from WFObjectListTable where ObjectTypeId = "+objectTypeId);
        if(rs.next())
            className = rs.getString(1);
			
		if(stmt != null){
			stmt.close();
			stmt = null;
		}
		if(rs != null){
			rs.close();
			rs = null;
		}
        Class clazz = Class.forName(className);
        Method method = clazz.getMethod("getQueryParameters", (Class[]) null);
        String[] queryParam = (String[])method.invoke(clazz.newInstance(), (Object[]) null);
        //System.out.println("within executeGetObjectList :: output :: " + outputXml);
        return queryParam;*/
		  String[] strExecuteGetQueryParam = WFRMSUtil.executeGetQueryParam(con,objectTypeId);
		  return strExecuteGetQueryParam;
    }
	
	/**
     * *************************************************************
     * Function Name    :   executeGetQueryParam
     * Author			:   Shweta Singhal
     * Date Written     :   03/09/2012
     * Input Parameters :   Connection con, int dbType, int objectType
     * Output Parameters:   String[]
     * Return Value     :   
     * Description      :   
     * *************************************************************
     */
	public static String[] executeGetQueryParam(Connection con, int dbType, String objectType) throws SQLException, Exception{
		/*	printOut("within executeGetObjectList ");
        String outputXml = null;
		Statement stmt = null;
		stmt = con.createStatement();
        ResultSet rs = null;
        String className = null;
		
        rs = stmt.executeQuery("select classname from WFObjectListTable where ObjectType = "+TO_STRING(objectType,true,dbType)+"");
        if(rs.next())
            className = rs.getString(1);
		printOut("className::"+className);
		if(stmt != null){
			stmt.close();
			stmt = null;
		}
		if(rs != null){
			rs.close();
			rs = null;
		}
        Class clazz = Class.forName(className);
        Method method = clazz.getMethod("getQueryParameters", (Class[]) null);
        String[] queryParam = (String[])method.invoke(clazz.newInstance(), (Object[]) null);
        //System.out.println("within executeGetObjectList :: output :: " + outputXml);
		printOut("within queryParam :: " + queryParam[0]+""+queryParam[1]+""+queryParam[2]);
        return queryParam;*/
		String[] strExecuteGetQueryParam = WFRMSUtil.executeGetQueryParam(con,dbType,objectType);
		return strExecuteGetQueryParam;
    }
	/*
	public static String executeGetObjectList1(Connection con, int objectTypeId, String inputXml, String key) throws SQLException, Exception{
        System.out.println("within executeGetObjectList ");
        String outputXml = null;
        Statement stmt = con.createStatement();
        ResultSet rs = null;
        String className = null;
        rs = stmt.executeQuery("select classname from WFObjectListTable where ObjectTypeId = " + objectTypeId);
        if(rs.next())
            className = rs.getString(1);
        Class clazz = Class.forName(className);        
        Method method = clazz.getMethod("getObjectList", new Class[]{Connection.class, String.class, String.class});
        outputXml = (String) method.invoke(clazz.newInstance(), new Object[]{con, inputXml, key});
        System.out.println("within executeGetObjectList :: output :: " + outputXml);        
        return outputXml;
	}*/
	
	
	 /**
     * *************************************************************
     * Function Name    :   transferJMSData
     * Author			:   Anwar Danish
     * Date Written     :   13/08/2012
     * Input Parameters :   Connection con, boolean isCheckOut, int pmwProcessDefId, int processDefId
     * Output Parameters:   NONE
     * Return Value     :   NONE
     * Description      :   Transfers data to/from JMS tables for PMWeb to workflow.
     * *************************************************************
     */
    
	public static void transferJMSData(Connection con, boolean isCheckOut, int pmwProcessDefId, int processDefId, int dbType) throws SQLException{
        
        Statement stmt = con.createStatement();
        String insertString = null;
        String updateString = null;
        String selectQuery = null;
        int destinationId = 0;
        ResultSet rs1 = null;
        ResultSet rs2 = null;
        int activityId = 0;
        String template = null;
        int wfDestinationId = 0;
        ResultSet rs3 = null;
        ResultSet rs4 = null;
        String sourceJmsPublishTable = "PMWJMSPublishTable";
        String sourceJmsDestInfo = "PMWJMSDestInfo";
        String targetJmsPublishTable = "WFJMSPublishTable";
        String targetJmsDestInfo = "WFJMSDestInfo";
        PreparedStatement pstmt1 = null;
        PreparedStatement  pstmt2 = null;
        PreparedStatement pstmt3 = null;
        PreparedStatement pstmt4 = null;
        PreparedStatement pstmt5 = null;
        
        if(isCheckOut)
        {
            sourceJmsPublishTable = "WFJMSPublishTable";
            sourceJmsDestInfo = "WFJMSDestInfo";
            targetJmsPublishTable = "PMWJMSPublishTable";
            targetJmsDestInfo = "PMWJMSDestInfo";
            int temp;
            temp = pmwProcessDefId;
            pmwProcessDefId = processDefId;
            processDefId = temp;
        }  
        try{       
              
            selectQuery = "select activityId,destinationId,Template from "+sourceJmsPublishTable+" where processDefId = ?";
            pstmt1 = con.prepareStatement(selectQuery);
            pstmt1.setInt(1, pmwProcessDefId);
            pstmt1.execute();
            rs1 = pstmt1.getResultSet();

            while(rs1 != null && rs1.next()){
                activityId = rs1.getInt(1);
                destinationId = rs1.getInt(2);
                template = rs1.getString(3);
                selectQuery = "select appServerIP,appServerPort,appServerType,jmsDestName,jmsDestType from "+sourceJmsDestInfo+" where destinationId = ?";
                pstmt2 = con.prepareStatement(selectQuery);
                pstmt2.setInt(1, destinationId);
                pstmt2.execute();
                rs2 = pstmt2.getResultSet();
                if(rs2 != null && rs2.next()){
                    selectQuery = "select destinationId from "+targetJmsDestInfo+" where appServerIP =? and appServerPort =? and appServerType = ? and jmsDestName =? and jmsDestType =?";
                    pstmt3 = con.prepareStatement(selectQuery);                    
					WFSUtil.DB_SetString(1, rs2.getString(1), pstmt3, dbType);
                    pstmt3.setInt(2, rs2.getInt(2));                    
					WFSUtil.DB_SetString(3, rs2.getString(3), pstmt3, dbType);                    
					WFSUtil.DB_SetString(4, rs2.getString(4), pstmt3, dbType);                    
					WFSUtil.DB_SetString(5, rs2.getString(5), pstmt3, dbType);
                    pstmt3.execute();
                    rs3 = pstmt3.getResultSet();
                    if(rs3 != null && rs3.next()){
                        wfDestinationId = rs3.getInt("DestinationId");
                        updateString = "update "+targetJmsPublishTable+" set destinationId = ? where processDefId =? and activityId =?";
                        pstmt4 = con.prepareStatement(updateString);
                        pstmt4.setInt(1, wfDestinationId);
                        pstmt4.setInt(2, processDefId);
                        pstmt4.setInt(3, activityId);
                        //pstmt.setString(4, template);
                        if(pstmt4.executeUpdate() > 0)
                            printOut("",targetJmsPublishTable+" table updated successfully");
                        else
                            printOut("",targetJmsPublishTable+" table not updated successfully");

                    }else{
                        rs4 = stmt.executeQuery("select max(destinationId) from "+targetJmsDestInfo);
                        if(rs4 != null && rs4.next())
                        {
                            wfDestinationId = rs4.getInt(1) + 1;
                            insertString = "insert into "+targetJmsDestInfo+"(DestinationId,appServerIP,appServerPort,appServerType,jmsDestName,jmsDestType) values(?,?,?,?,?,?)";
                            pstmt4 = con.prepareStatement(insertString);
                            pstmt4.setInt(1, wfDestinationId);                            
							WFSUtil.DB_SetString(2, rs2.getString(1), pstmt4, dbType);
                            pstmt4.setInt(3, rs2.getInt(2));                            
							WFSUtil.DB_SetString(4, rs2.getString(3), pstmt4, dbType);
							WFSUtil.DB_SetString(5, rs2.getString(4), pstmt4, dbType);                            
							WFSUtil.DB_SetString(6, rs2.getString(5), pstmt4, dbType);
                            if(pstmt4.executeUpdate() > 0){
                                //System.out.println("Data inserted in "+targetJmsDestInfo+" successfully");

                                updateString = "update "+targetJmsPublishTable+" set destinationId = ? where processDefId =? and activityId =?";
                                pstmt5 = con.prepareStatement(updateString);
                                pstmt5.setInt(1, wfDestinationId);
                                pstmt5.setInt(2, processDefId);
                                pstmt5.setInt(3, activityId);
                                //pstmt.setString(4, template);
                                if(pstmt5.executeUpdate() > 0)
                                    printOut("",targetJmsPublishTable+" table updated successfully");
                                else
                                    printOut("",targetJmsPublishTable+" table not updated successfully");
                            }
                            else
                                printOut("","Data insertion in "+targetJmsDestInfo+" failed");


                        }
                    }
                }
                if(pstmt2 != null)
                {
                    pstmt2.close();
                    pstmt2 = null;
                }
                if(pstmt3 != null)
                {
                    pstmt3.close();
                    pstmt3 = null;
                }
                if(pstmt4 != null)
                {
                    pstmt4.close();
                    pstmt4 = null;
                }
                if(pstmt5 != null)
                {
                    pstmt5.close();
                    pstmt5 = null;
                }
                if(rs2 != null)
                {
                    rs2.close();
                    rs2 = null;
                }
                if(rs3 != null)
                {
                    rs3.close();
                    rs3 = null;
                }
                if(rs4 != null)
                {
                    rs4.close();
                    rs4 = null;
                }
            }
        } 
        finally{
            try{         
                if(rs1 != null)
                {
                    rs1.close();
                    rs1 = null;
                }
            }
            catch(Exception ex)
            {
				printErr("","WFSUtil>> transferJMSData" + ex);
            }
            try{         
                if(rs2 != null)
                {
                    rs2.close();
                    rs2 = null;
                }
            }
            catch(Exception ex)
            {
				printErr("","WFSUtil>> transferJMSData" + ex);
            }
            try{         
                if(rs3 != null)
                {
                    rs3.close();
                    rs3 = null;
                }
            }
            catch(Exception ex)
            {
				printErr("","WFSUtil>> transferJMSData" + ex);
            }
            try{         
                if(rs4 != null)
                {
                    rs4.close();
                    rs4 = null;
                }
            }
            catch(Exception ex)
            {
				printErr("","WFSUtil>> transferJMSData" + ex);
            }
            try{         
                if(stmt != null)
                {
                	stmt.close();
                	stmt = null;
                }
            }
            catch(Exception ex)
            {
				printErr("","WFSUtil>> transferJMSData" + ex);
            }
            try{         
                if(pstmt1 != null)
                {
                	pstmt1.close();
                	pstmt1 = null;
                }
            }
            catch(Exception ex)
            {
				printErr("","WFSUtil>> transferJMSData" + ex);
            }
            try{         
                if(pstmt2 != null)
                {
                	pstmt2.close();
                	pstmt2 = null;
                }
            }
            catch(Exception ex)
            {
				printErr("","WFSUtil>> transferJMSData" + ex);
            }
            try{         
                if(pstmt3 != null)
                {
                	pstmt3.close();
                	pstmt3 = null;
                }
            }
            catch(Exception ex)
            {
				printErr("","WFSUtil>> transferJMSData" + ex);
            }
            try{         
                if(pstmt4 != null)
                {
                	pstmt4.close();
                	pstmt4 = null;
                }
            }
            catch(Exception ex)
            {
				printErr("","WFSUtil>> transferJMSData" + ex);
            }
            try{         
                if(pstmt5 != null)
                {
                	pstmt5.close();
                	pstmt5 = null;
                }
            }
            catch(Exception ex)
            {
				printErr("","WFSUtil>> transferJMSData" + ex);
            }
        }
    
    }
	
	/**
     * *************************************************************
     * Function Name    :   transferJMSSubscriberData
     * Author			:   Anwar Danish
     * Date Written     :   28/05/2013
     * Input Parameters :   Connection con, boolean isCheckOut, int pmwProcessDefId, int processDefId
     * Output Parameters:   NONE
     * Return Value     :   NONE
     * Description      :   Transfers data to/from JMSSubscribe tables for PMWeb to workflow.
     * *************************************************************
     */
	 
	 public static void transferJMSSubscriberData(Connection con, boolean isCheckOut, int pmwProcessDefId, int processDefId, int dbType) throws SQLException{
        
        Statement stmt = con.createStatement();
        String insertString = null;
        String updateString = null;
        String selectQuery = null;
        int destinationId = 0;        
        int activityId = 0;        
        int targetDestinationId = 0;        
        String sourceJmsSubscribeTable = "PMWJMSSubscribeTable";
        String sourceJmsDestInfo = "PMWJMSDestInfo";
        String targetJmsSubscribeTable = "WFJMSSubscribeTable";
        String targetJmsDestInfo = "WFJMSDestInfo";
        PreparedStatement pstmt = null;
        PreparedStatement pstmt1 = null;
        PreparedStatement pstmt2 = null;
        PreparedStatement pstmt3 = null;
        PreparedStatement pstmt4 = null;
        ResultSet rs = null;
        ResultSet rs1 = null;
        ResultSet rs2 = null;
        ResultSet rs3 = null;
        boolean updateFlag = false ;
        
        if(isCheckOut){
            sourceJmsSubscribeTable = "WFJMSSubscribeTable";
            sourceJmsDestInfo = "WFJMSDestInfo";
            targetJmsSubscribeTable = "PMWJMSSubscribeTable";
            targetJmsDestInfo = "PMWJMSDestInfo";
            int temp;
            temp = pmwProcessDefId;
            pmwProcessDefId = processDefId;
            processDefId = temp;
        }  
        try{       
              
            selectQuery = "select distinct activityid, destinationid  from "+sourceJmsSubscribeTable+" where processDefId = ?";
            pstmt = con.prepareStatement(selectQuery);            
            pstmt.setInt(1, pmwProcessDefId);
            pstmt.execute();
            rs = pstmt.getResultSet();
            while(rs != null && rs.next()){
                activityId = rs.getInt(1);
                destinationId = rs.getInt(2);                 
                selectQuery = "select jmsDestName, jmsDestType from " + sourceJmsDestInfo + " where destinationId = ?";
                pstmt1 = con.prepareStatement(selectQuery);
                pstmt1.setInt(1, destinationId);
                pstmt1.execute();
                rs1 = pstmt1.getResultSet();
                if(rs1 != null && rs1.next()){
                    selectQuery = "select destinationId from "+targetJmsDestInfo+" where jmsDestName =? and jmsDestType =?";
                    pstmt2 = con.prepareStatement(selectQuery);                    
					WFSUtil.DB_SetString(1, rs1.getString(1), pstmt2, dbType);                                      
					WFSUtil.DB_SetString(2, rs1.getString(2), pstmt2, dbType); 
                    pstmt2.execute();
                    rs2 = pstmt2.getResultSet();
                    if(rs2 != null && rs2.next()){
                        targetDestinationId = rs2.getInt("DestinationId");                        
                        updateFlag = true;
                    }else{
                        rs3 = stmt.executeQuery("select max(destinationId) from " + targetJmsDestInfo);
                        if(rs3 != null && rs3.next()){
                            targetDestinationId = rs3.getInt(1) + 1;
                            insertString = "insert into " + targetJmsDestInfo + "(DestinationId, jmsDestName, jmsDestType) values(?,?,?)";
                            pstmt3 = con.prepareStatement(insertString);
                            pstmt3.setInt(1, targetDestinationId);                            
							WFSUtil.DB_SetString(2, rs1.getString(1), pstmt3, dbType);
							WFSUtil.DB_SetString(3, rs1.getString(2), pstmt3, dbType);
                            
                            pstmt3.setString(2, rs1.getString(1));
                            pstmt3.setString(3, rs1.getString(2));
							
                            if(pstmt3.executeUpdate() > 0){  
                                updateFlag = true;
                            }else{
                                updateFlag = false;
                            }
                        }
                    }
                    if(updateFlag){                        
                        updateString = "update " + targetJmsSubscribeTable + " set destinationId = ? where processDefId =? and activityId =?";
                        pstmt4 = con.prepareStatement(updateString);
                        pstmt4.setInt(1, targetDestinationId);
                        pstmt4.setInt(2, processDefId);
                        pstmt4.setInt(3, activityId);                        
                        if(pstmt4.executeUpdate() > 0)
                            WFSUtil.printOut("",targetJmsSubscribeTable + " table updated successfully");
                        else
                            WFSUtil.printOut("",targetJmsSubscribeTable + " table not updated successfully");
                    }
                }
                if(pstmt2 != null)
                {
                    pstmt2.close();
                    pstmt2 = null;
                }
                if(pstmt3 != null)
                {
                    pstmt3.close();
                    pstmt3 = null;
                }
                if(pstmt4 != null)
                {
                    pstmt4.close();
                    pstmt4 = null;
                }
                
                if(rs2 != null)
                {
                    rs2.close();
                    rs2 = null;
                }
                if(rs3 != null)
                {
                    rs3.close();
                    rs3 = null;
                }
                
            }
        } 
        finally{
            try{         
                if(rs!= null)
                {
                    rs.close();
                    rs = null;
                }   
            }
            catch(SQLException ex)
            {
				WFSUtil.printErr("","WFSUtil>> transferJMSSubscriberData" + ex);
            }
            try{         
                if(rs1!= null)
                {
                    rs1.close();
                    rs1 = null;
                }   
            }
            catch(SQLException ex)
            {
				WFSUtil.printErr("","WFSUtil>> transferJMSSubscriberData" + ex);
            }
            try{         
                if(rs2!= null)
                {
                    rs2.close();
                    rs2 = null;
                }   
            }
            catch(SQLException ex)
            {
				WFSUtil.printErr("","WFSUtil>> transferJMSSubscriberData" + ex);
            }
            try{         
                if(rs3!= null)
                {
                    rs3.close();
                    rs3 = null;
                }   
            }
            catch(SQLException ex)
            {
				WFSUtil.printErr("","WFSUtil>> transferJMSSubscriberData" + ex);
            }
            try{         
                if(stmt!= null)
                {
                    stmt.close();
                    stmt = null;
                }   
            }
            catch(SQLException ex)
            {
				WFSUtil.printErr("","WFSUtil>> transferJMSSubscriberData" + ex);
            }
            try{         
                if(pstmt!= null)
                {
                    pstmt.close();
                    pstmt = null;
                }   
            }
            catch(SQLException ex)
            {
				WFSUtil.printErr("","WFSUtil>> transferJMSSubscriberData" + ex);
            }
            try{         
                if(pstmt1!= null)
                {
                    pstmt1.close();
                    pstmt1 = null;
                }   
            }
            catch(SQLException ex)
            {
				WFSUtil.printErr("","WFSUtil>> transferJMSSubscriberData" + ex);
            }
            try{         
                if(pstmt2!= null)
                {
                    pstmt2.close();
                    pstmt2 = null;
                }   
            }
            catch(SQLException ex)
            {
				WFSUtil.printErr("","WFSUtil>> transferJMSSubscriberData" + ex);
            }
            try{         
                if(pstmt3!= null)
                {
                    pstmt3.close();
                    pstmt3 = null;
                }   
            }
            catch(SQLException ex)
            {
				WFSUtil.printErr("","WFSUtil>> transferJMSSubscriberData" + ex);
            }
            try{         
                if(pstmt4!= null)
                {
                    pstmt4.close();
                    pstmt4 = null;
                }   
            }
            catch(SQLException ex)
            {
				WFSUtil.printErr("","WFSUtil>> transferJMSSubscriberData" + ex);
            }
        }
    }
	
	/**
     * *************************************************************
     * Function Name    :   transferBRMSData
     * Author			:   Anwar Danish
     * Date Written     :   20/01/2014
     * Input Parameters :   Connection con, boolean isCheckOut, int pmwProcessDefId, int processDefId
     * Output Parameters:   NONE
     * Return Value     :   NONE
     * Description      :   Transfers data to/from BRMS tables for PMWeb to workflow.
     * *************************************************************
     */	 
	 
 /*public static void transferBRMSData(Connection con, boolean isCheckOut, int pmwProcessDefId, int processDefId, int dbType,String engine) throws SQLException{
        
        Statement stmt = null;
        String insertString = null;
        String updateString = null;        
        String selectQuery = null;
        int ruleSetId = 0; 
        int targetRuleSetId = 0;         
        PreparedStatement pstmt = null;
        PreparedStatement pstmt1 = null;
        PreparedStatement pstmt2 = null;
        PreparedStatement pstmt3 = null;
        PreparedStatement pstmt4 = null;
        ResultSet rs = null;
        ResultSet rs1 = null;
        ResultSet rs2 = null;
        ResultSet rs3 = null;
        boolean updateFlag = false ;
        int ruleSetIdBkp = 0;        
        StringBuffer ruleSetIdList = new StringBuffer(200);        
	StringBuffer targetRuleSetIdList = new StringBuffer(200);  
        boolean isFirstIter = true;
	boolean isFirstIterTrgt = true;
        int extMethodIndex = 0;
        
        try{                   
            selectQuery = "select distinct BRMSRuleSetId from " + (isCheckOut ? "WFBRMSActivityAssocTable" : "PMWBRMSActivityAssocTable") + " where processDefId = ?";
            pstmt = con.prepareStatement(selectQuery);            
            pstmt.setInt(1, (isCheckOut ? processDefId : pmwProcessDefId));
            rs = pstmt.executeQuery();
            
            while(rs != null && rs.next()){
                ruleSetId = rs.getInt(1);                
                ruleSetIdBkp = ruleSetId ;
                if(isFirstIter){
                    ruleSetIdList.append("(").append(ruleSetId);   
                    isFirstIter = false;
                }else{
                    ruleSetIdList.append(",").append(ruleSetId);
                }              
                
                selectQuery = "select ServerIdentifier, RuleSetName , VersionNo , InvocationMode , ExtMethodIndex from " + (isCheckOut ? "WFBRMSRuleSetInfo" : "PMWBRMSRuleSetInfo") + " where BRMSRuleSetId = ? ";                
                pstmt1 = con.prepareStatement(selectQuery);
                pstmt1.setInt(1, ruleSetId);                
                rs1 = pstmt1.executeQuery();
                
                if(rs1 != null && rs1.next()){
                    selectQuery = "select BRMSRuleSetId from " + (isCheckOut ? "PMWBRMSRuleSetInfo" : "WFBRMSRuleSetInfo") + " where RuleSetName = ? and VersionNo = ? and InvocationMode = ?  ";                    
                    pstmt2 = con.prepareStatement(selectQuery);                    
                    WFSUtil.DB_SetString(1, rs1.getString(2), pstmt2, dbType);                                      
                    pstmt2.setFloat(2, rs1.getFloat(3));                    
                    WFSUtil.DB_SetString(3, rs1.getString(4), pstmt2, dbType);                    
                    rs2 = pstmt2.executeQuery();
                    extMethodIndex = rs1.getInt(5);
                    
                    if(rs2 != null && rs2.next()){
                        targetRuleSetId = rs2.getInt("BRMSRuleSetId");                        
                        updateFlag = true;
                    }else{ 
                        stmt = con.createStatement();
                        rs3 = stmt.executeQuery("select max(BRMSRuleSetId) from " + (isCheckOut ? "PMWBRMSRuleSetInfo" : "WFBRMSRuleSetInfo"));
                        
                        if(rs3 != null && rs3.next()){  
                            
                            targetRuleSetId = rs3.getInt(1) + 1;                             
                            insertString = "insert into " + (isCheckOut ? "PMWBRMSRuleSetInfo" : "WFBRMSRuleSetInfo") + "(BRMSRuleSetId , ServerIdentifier , RuleSetName , VersionNo , InvocationMode , ExtMethodIndex) values(?,?,?,?,?,?)";

                            pstmt3 = con.prepareStatement(insertString);
                            pstmt3.setInt(1, targetRuleSetId);  
                            pstmt3.setInt(2, rs1.getInt(1));
                            WFSUtil.DB_SetString(3, rs1.getString(2), pstmt3, dbType);
                            pstmt3.setFloat(4, rs1.getFloat(3));                            
                            WFSUtil.DB_SetString(5, rs1.getString(4), pstmt3, dbType); 
                            pstmt3.setInt(6, extMethodIndex);
                            
                            if(pstmt3.executeUpdate() > 0){  
                                updateFlag = true;
                            }else{
                                updateFlag = false;
                            }
                        }                        
                    }
                    if(isFirstIterTrgt){
                            targetRuleSetIdList.append("(").append(targetRuleSetId);   
                            isFirstIterTrgt = false;
                    }else{
                            targetRuleSetIdList.append(",").append(targetRuleSetId);
                    } 					
                    if(updateFlag){                        
                        updateString = "update " + (isCheckOut ? "PMWBRMSActivityAssocTable" : "WFBRMSActivityAssocTable") + " set BRMSRuleSetId = ? where processDefId = ? and BRMSRuleSetId = ? ";
                        pstmt4 = con.prepareStatement(updateString);
                        pstmt4.setInt(1, targetRuleSetId);
                        pstmt4.setInt(2, (isCheckOut ? pmwProcessDefId : processDefId));                                               
                        pstmt4.setInt(3, ruleSetIdBkp); 
                        int res1 = pstmt4.executeUpdate();                        
                        
//                        updateString = "update " + (isCheckOut ? "PMWBRMSMappingTable" : "WFBRMSMappingTable") + " set BRMSRuleSetId = ? where processDefId = ? and BRMSRuleSetId = ? ";
//                        pstmt4 = con.prepareStatement(updateString);
//                        pstmt4.setInt(1, targetRuleSetId);
//                        pstmt4.setInt(2, (isCheckOut ? pmwProcessDefId : processDefId));                                               
//                        pstmt4.setInt(3, ruleSetIdBkp); 
//                        int res2 = pstmt4.executeUpdate();
                        ResultSet tempRs = null;
                        if(pstmt4 != null){
                            pstmt4.close();
                            pstmt4 = null;
                        }                        
                        selectQuery = "Select 1 from " + (isCheckOut ? "PMWEXTMETHODDEFTABLE" : "EXTMETHODDEFTABLE") + " where ExtMethodIndex = ? and processdefid = 0 ";
                        pstmt4 = con.prepareStatement(selectQuery);
                        pstmt4.setInt(1, extMethodIndex);
                        tempRs = pstmt4.executeQuery();
                        if (tempRs == null || !tempRs.next()){
                            insertString = "Insert into " + (isCheckOut ? "PMWEXTMETHODDEFTABLE" : "EXTMETHODDEFTABLE") + " (ProcessDefId, ExtMethodIndex, ExtAppName, ExtAppType, ExtMethodName, SearchMethod, SearchCriteria, ReturnType, MappingFile, ConfigurationID) select ProcessDefId, ExtMethodIndex, ExtAppName, ExtAppType, ExtMethodName, SearchMethod, SearchCriteria, ReturnType, MappingFile, ConfigurationID from " + (isCheckOut ? "EXTMETHODDEFTABLE" : "PMWEXTMETHODDEFTABLE") +" where processdefid = 0 and ExtMethodIndex = ? ";
                            pstmt4 = con.prepareStatement(insertString);
                            pstmt4.setInt(1, extMethodIndex);
                            pstmt4.executeUpdate();
                        }
                        
                        if(pstmt4 != null){
                            pstmt4.close();
                            pstmt4 = null;
                        }                        
                        if(tempRs != null){
                            tempRs.close();
                            tempRs = null;
                        } 
                        
                        selectQuery = "Select 1 from " + (isCheckOut ? "PMWEXTMETHODPARAMDEFTABLE" : "EXTMETHODPARAMDEFTABLE") + " where ExtMethodIndex = ? and processdefid = 0 ";
                        pstmt4 = con.prepareStatement(selectQuery);
                        pstmt4.setInt(1, extMethodIndex);
                        tempRs = pstmt4.executeQuery();
                        if (tempRs == null || !tempRs.next()){
                            insertString = "Insert into " + (isCheckOut ? "PMWEXTMETHODPARAMDEFTABLE" : "EXTMETHODPARAMDEFTABLE") + " (ProcessDefId, ExtMethodParamIndex, ExtMethodIndex, ParameterName, ParameterType, ParameterOrder, DataStructureId, ParameterScope, Unbounded) select ProcessDefId, ExtMethodParamIndex, ExtMethodIndex, ParameterName, ParameterType, ParameterOrder, DataStructureId, ParameterScope, Unbounded from " + (isCheckOut ? "EXTMETHODPARAMDEFTABLE" : "PMWEXTMETHODPARAMDEFTABLE") +" where processdefid = 0 and ExtMethodIndex = ? ";
                            pstmt4 = con.prepareStatement(insertString);
                            pstmt4.setInt(1, extMethodIndex);
                            pstmt4.executeUpdate();
                        }
                        
                        if(pstmt4 != null){
                            pstmt4.close();
                            pstmt4 = null;
                        }                        
                        if(tempRs != null){
                            tempRs.close();
                            tempRs = null;
                        } 
                        
                        selectQuery = "Select 1 from " + (isCheckOut ? "PMWDataStructureTable" : "WFDataStructureTable") + " where ExtMethodIndex = ? and processdefid = 0 ";
                        pstmt4 = con.prepareStatement(selectQuery);
                        pstmt4.setInt(1, extMethodIndex);
                        tempRs = pstmt4.executeQuery();
                        if (tempRs == null || !tempRs.next()){
                            insertString = "Insert into " + (isCheckOut ? "PMWDataStructureTable" : "WFDataStructureTable") + " (DataStructureId, ProcessDefId, ActivityId, ExtMethodIndex, Name, Type, ParentIndex, ClassName, Unbounded) select DataStructureId, ProcessDefId, ActivityId, ExtMethodIndex, Name, Type, ParentIndex, ClassName, Unbounded from " + (isCheckOut ? "WFDataStructureTable" : "PMWDataStructureTable") +" where processdefid = 0 and ExtMethodIndex = ? ";
                            pstmt4 = con.prepareStatement(insertString);
                            pstmt4.setInt(1, extMethodIndex);
                            pstmt4.executeUpdate();
                        }  
                        
                        if(pstmt4 != null){
                            pstmt4.close();
                            pstmt4 = null;
                        }                        
                        if(tempRs != null){
                            tempRs.close();
                            tempRs = null;
                        }
                        
                        if(res1 > 0){
                            WFSUtil.printOut(engine,"Table updated successfully ");
                        }else{
                            WFSUtil.printErr(engine,"Table not updated successfully ");
                        }                        
                    }
                }               
                
                if(pstmt2 != null)
                {
                    pstmt2.close();
                    pstmt2 = null;
                }
                if(pstmt3 != null)
                {
                    pstmt3.close();
                    pstmt3 = null;
                }
                if(pstmt4 != null)
                {
                    pstmt4.close();
                    pstmt4 = null;
                }
                
                if(rs2 != null)
                {
                    rs2.close();
                    rs2 = null;
                }
                if(rs3 != null)
                {
                    rs3.close();
                    rs3 = null;
                }
                
            }
            ruleSetIdList.append(")");
			targetRuleSetIdList.append(")");            
            transferBRMSConnectTableData(con , isCheckOut , ruleSetIdList.toString() , dbType,engine , targetRuleSetIdList.toString());
            
        }catch(SQLException ex){
            //System.out.println(ex.printStackTrace());
            WFSUtil.printErr(engine,"WFSUtil>> transferBRMSData" + ex);
        }
        
        finally{
            try{         
                if(pstmt1 != null)
                {
                    pstmt1.close();
                    pstmt1 = null;
                }
                if(pstmt2 != null)
                {
                    pstmt2.close();
                    pstmt2 = null;
                }
                if(pstmt3 != null)
                {
                    pstmt3.close();
                    pstmt3 = null;
                }
                if(pstmt4 != null)
                {
                    pstmt4.close();
                    pstmt4 = null;
                }                
                if(rs1 != null)
                {
                    rs1.close();
                    rs1 = null;
                }
                if(rs2 != null)
                {
                    rs2.close();
                    rs2 = null;
                }
                if(rs3 != null)
                {
                    rs3.close();
                    rs3 = null;
                }   
            }catch(Exception e){
                
            }
        }
    }*/
    
    public static void transferBRMSData(Connection con, boolean isCheckOut, int pmwProcessDefId, int processDefId, int dbType,String engine) throws SQLException{
        
        Statement stmt = null;
        String insertString = null;
        String updateString = null;        
        String selectQuery = null;  
        String deleteQuery=null;
        int targetRuleSetId = 0;         
        PreparedStatement pstmt = null;
        PreparedStatement pstmt1 = null;
        PreparedStatement pstmt2 = null; 
        PreparedStatement pstmt3 = null;   
        ResultSet rs = null;
        ResultSet rs1 = null;
        ResultSet rs2 = null;        
        boolean updateFlag = false ;         
        StringBuffer extMethodIndexList = new StringBuffer(200); 
        boolean isFirstIter = true;	
        int extMethodIndex = 0;
        
        try{                   
            selectQuery = "select distinct ExtMethodIndex from " + (isCheckOut ? "WFBRMSActivityAssocTable" : "PMWBRMSActivityAssocTable") + " where processDefId = ?";
            pstmt = con.prepareStatement(selectQuery);            
            pstmt.setInt(1, (isCheckOut ? processDefId : pmwProcessDefId));
            rs = pstmt.executeQuery();           
            while(rs != null && rs.next()){
                extMethodIndex = rs.getInt(1); 
                
                if(isFirstIter){
                    extMethodIndexList.append("(").append(extMethodIndex);   
                    isFirstIter = false;
                }else{
                    extMethodIndexList.append(",").append(extMethodIndex);
                }              
                
                selectQuery = "select 1 from " + (isCheckOut ? "WFBRMSRuleSetInfo" : "PMWBRMSRuleSetInfo") + " where ExtMethodIndex = ? ";                
                pstmt1 = con.prepareStatement(selectQuery);
                pstmt1.setInt(1, extMethodIndex);                
                rs1 = pstmt1.executeQuery();
                
                if(rs1 != null && rs1.next()){
                    selectQuery = "select 1 from " + (isCheckOut ? "PMWBRMSRuleSetInfo" : "WFBRMSRuleSetInfo") + " where ExtMethodIndex = ?  ";                    
                    pstmt2 = con.prepareStatement(selectQuery);                    
                    pstmt2.setInt(1, extMethodIndex);                  
                    rs2 = pstmt2.executeQuery(); 
                    if(rs2 == null || !rs2.next()){
                        insertString = "Insert into " + (isCheckOut ? "PMWBRMSRuleSetInfo" : "WFBRMSRuleSetInfo") + " (ExtMethodIndex, ServerIdentifier, RuleSetName, VersionNo, InvocationMode,RuleType,isEncrypted,RuleSetId) select ExtMethodIndex, ServerIdentifier, RuleSetName, VersionNo, InvocationMode,RuleType,isEncrypted,RuleSetId from " + (isCheckOut ? "WFBRMSRuleSetInfo" : "PMWBRMSRuleSetInfo") +" where ExtMethodIndex = ? ";
                        pstmt2 = con.prepareStatement(insertString);
                        pstmt2.setInt(1, extMethodIndex);
                        pstmt2.executeUpdate();
                        
                    }else if(!isCheckOut){
                    	deleteQuery="DELETE from WFBRMSRuleSetInfo where ExtMethodIndex=? ";
                    	pstmt3=con.prepareStatement(deleteQuery);
                    	pstmt3.setInt(1, extMethodIndex);
                    	pstmt3.executeUpdate();
                    	if(pstmt3!=null)
                    	{
                    		pstmt3.close();
                    		pstmt3=null;
                    	}
                    	 insertString = "Insert into " + (isCheckOut ? "PMWBRMSRuleSetInfo" : "WFBRMSRuleSetInfo") + " (ExtMethodIndex, ServerIdentifier, RuleSetName, VersionNo, InvocationMode,RuleType,isEncrypted,RuleSetId) select ExtMethodIndex, ServerIdentifier, RuleSetName, VersionNo, InvocationMode,RuleType,isEncrypted,RuleSetId from " + (isCheckOut ? "WFBRMSRuleSetInfo" : "PMWBRMSRuleSetInfo") +" where ExtMethodIndex = ? ";
                         pstmt2 = con.prepareStatement(insertString);
                         pstmt2.setInt(1, extMethodIndex);
                         pstmt2.executeUpdate();
                    }                   
                    
                    if(pstmt2 != null){
                        pstmt2.close();
                        pstmt2 = null;
                    }                        
                    if(rs2 != null){
                        rs2.close();
                        rs2 = null;
                    }                    
                    selectQuery = "Select 1 from " + (isCheckOut ? "PMWEXTMETHODDEFTABLE" : "EXTMETHODDEFTABLE") + " where ExtMethodIndex = ? and processdefid = 0 ";
                    pstmt2 = con.prepareStatement(selectQuery);
                    pstmt2.setInt(1, extMethodIndex);
                    rs2 = pstmt2.executeQuery();
                    if (rs2 == null || !rs2.next()){
                        insertString = "Insert into " + (isCheckOut ? "PMWEXTMETHODDEFTABLE" : "EXTMETHODDEFTABLE") + " (ProcessDefId, ExtMethodIndex, ExtAppName, ExtAppType, ExtMethodName, SearchMethod, SearchCriteria, ReturnType, MappingFile, ConfigurationID,AliasName,DomainName,Description,ServiceScope,IsBRMSService) select ProcessDefId, ExtMethodIndex, ExtAppName, ExtAppType, ExtMethodName, SearchMethod, SearchCriteria, ReturnType, MappingFile, ConfigurationID ,AliasName,DomainName,Description,ServiceScope,IsBRMSService from " + (isCheckOut ? "EXTMETHODDEFTABLE" : "PMWEXTMETHODDEFTABLE") +" where processdefid = 0 and ExtMethodIndex = ? ";
                        pstmt2 = con.prepareStatement(insertString);
                        pstmt2.setInt(1, extMethodIndex);
                        pstmt2.executeUpdate();
                    }else if(!isCheckOut){
                    	deleteQuery="DELETE from EXTMETHODDEFTABLE where ExtMethodIndex=? and processdefid=0";
                    	pstmt3=con.prepareStatement(deleteQuery);
                    	pstmt3.setInt(1, extMethodIndex);
                    	pstmt3.executeUpdate();
                    	if(pstmt3!=null)
                    	{
                    		pstmt3.close();
                    		pstmt3=null;
                    	}
                    	insertString = "Insert into " + (isCheckOut ? "PMWEXTMETHODDEFTABLE" : "EXTMETHODDEFTABLE") + " (ProcessDefId, ExtMethodIndex, ExtAppName, ExtAppType, ExtMethodName, SearchMethod, SearchCriteria, ReturnType, MappingFile, ConfigurationID ,AliasName,DomainName,Description,ServiceScope,IsBRMSService) select ProcessDefId, ExtMethodIndex, ExtAppName, ExtAppType, ExtMethodName, SearchMethod, SearchCriteria, ReturnType, MappingFile, ConfigurationID,AliasName,DomainName,Description,ServiceScope ,IsBRMSService from " + (isCheckOut ? "EXTMETHODDEFTABLE" : "PMWEXTMETHODDEFTABLE") +" where processdefid = 0 and ExtMethodIndex = ? ";
                        pstmt2 = con.prepareStatement(insertString);
                        pstmt2.setInt(1, extMethodIndex);
                        pstmt2.executeUpdate();
                    }

                    if(pstmt2 != null){
                        pstmt2.close();
                        pstmt2 = null;
                    }                        
                    if(rs2 != null){
                        rs2.close();
                        rs2 = null;
                    } 

                    selectQuery = "Select 1 from " + (isCheckOut ? "PMWEXTMETHODPARAMDEFTABLE" : "EXTMETHODPARAMDEFTABLE") + " where ExtMethodIndex = ? and processdefid = 0 ";
                    pstmt2 = con.prepareStatement(selectQuery);
                    pstmt2.setInt(1, extMethodIndex);
                    rs2 = pstmt2.executeQuery();
                    if (rs2 == null || !rs2.next()){
                        insertString = "Insert into " + (isCheckOut ? "PMWEXTMETHODPARAMDEFTABLE" : "EXTMETHODPARAMDEFTABLE") + " (ProcessDefId, ExtMethodParamIndex, ExtMethodIndex, ParameterName, ParameterType, ParameterOrder, DataStructureId, ParameterScope, Unbounded) select ProcessDefId, ExtMethodParamIndex, ExtMethodIndex, ParameterName, ParameterType, ParameterOrder, DataStructureId, ParameterScope, Unbounded from " + (isCheckOut ? "EXTMETHODPARAMDEFTABLE" : "PMWEXTMETHODPARAMDEFTABLE") +" where processdefid = 0 and ExtMethodIndex = ? ";
                        pstmt2 = con.prepareStatement(insertString);
                        pstmt2.setInt(1, extMethodIndex);
                        pstmt2.executeUpdate();
                    }else if(!isCheckOut){
                    	deleteQuery="DELETE from EXTMETHODPARAMDEFTABLE where ExtMethodIndex=? and processdefid=0";
                    	pstmt3=con.prepareStatement(deleteQuery);
                    	pstmt3.setInt(1, extMethodIndex);
                    	pstmt3.executeUpdate();
                    	if(pstmt3!=null)
                    	{
                    		pstmt3.close();
                    		pstmt3=null;
                    	}
                    	 insertString = "Insert into " + (isCheckOut ? "PMWEXTMETHODPARAMDEFTABLE" : "EXTMETHODPARAMDEFTABLE") + " (ProcessDefId, ExtMethodParamIndex, ExtMethodIndex, ParameterName, ParameterType, ParameterOrder, DataStructureId, ParameterScope, Unbounded) select ProcessDefId, ExtMethodParamIndex, ExtMethodIndex, ParameterName, ParameterType, ParameterOrder, DataStructureId, ParameterScope, Unbounded from " + (isCheckOut ? "EXTMETHODPARAMDEFTABLE" : "PMWEXTMETHODPARAMDEFTABLE") +" where processdefid = 0 and ExtMethodIndex = ? ";
                         pstmt2 = con.prepareStatement(insertString);
                         pstmt2.setInt(1, extMethodIndex);
                         pstmt2.executeUpdate();
                    }

                    if(pstmt2 != null){
                        pstmt2.close();
                        pstmt2 = null;
                    }                        
                    if(rs2 != null){
                        rs2.close();
                        rs2 = null;
                    } 

                    selectQuery = "Select 1 from " + (isCheckOut ? "PMWDataStructureTable" : "WFDataStructureTable") + " where ExtMethodIndex = ? and processdefid = 0 ";
                    pstmt2 = con.prepareStatement(selectQuery);
                    pstmt2.setInt(1, extMethodIndex);
                    rs2 = pstmt2.executeQuery();
                    if (rs2 == null || !rs2.next()){
                        insertString = "Insert into " + (isCheckOut ? "PMWDataStructureTable" : "WFDataStructureTable") + " (DataStructureId, ProcessDefId, ActivityId, ExtMethodIndex, Name, Type, ParentIndex, ClassName, Unbounded) select DataStructureId, ProcessDefId, ActivityId, ExtMethodIndex, Name, Type, ParentIndex, ClassName, Unbounded from " + (isCheckOut ? "WFDataStructureTable" : "PMWDataStructureTable") +" where processdefid = 0 and ExtMethodIndex = ? ";
                        pstmt2 = con.prepareStatement(insertString);
                        pstmt2.setInt(1, extMethodIndex);
                        pstmt2.executeUpdate();
                    }else if(!isCheckOut){
                    	deleteQuery="DELETE from WFDataStructureTable where ExtMethodIndex=? and processdefid=0";
                    	pstmt3=con.prepareStatement(deleteQuery);
                    	pstmt3.setInt(1, extMethodIndex);
                    	pstmt3.executeUpdate();
                    	if(pstmt3!=null)
                    	{
                    		pstmt3.close();
                    		pstmt3=null;
                    	}
                    	 insertString = "Insert into " + (isCheckOut ? "PMWDataStructureTable" : "WFDataStructureTable") + " (DataStructureId, ProcessDefId, ActivityId, ExtMethodIndex, Name, Type, ParentIndex, ClassName, Unbounded) select DataStructureId, ProcessDefId, ActivityId, ExtMethodIndex, Name, Type, ParentIndex, ClassName, Unbounded from " + (isCheckOut ? "WFDataStructureTable" : "PMWDataStructureTable") +" where processdefid = 0 and ExtMethodIndex = ? ";
                         pstmt2 = con.prepareStatement(insertString);
                         pstmt2.setInt(1, extMethodIndex);
                         pstmt2.executeUpdate();
                    }

                    if(pstmt2 != null){
                        pstmt2.close();
                        pstmt2 = null;
                    }                        
                    if(rs2 != null){
                        rs2.close();
                        rs2 = null;
                    }                   
                    
                }               
                
                if(pstmt2 != null)
                {
                    pstmt2.close();
                    pstmt2 = null;
                }                                
                
                if(rs2 != null)
                {
                    rs2.close();
                    rs2 = null;
                }     
                if(rs1 != null && !rs1.isClosed())
                {
                    rs1.close();
                    rs1 = null;
                }   
                
                if(pstmt1 != null && !pstmt1.isClosed())
                {
                    pstmt1.close();
                    pstmt1 = null;
                }                                
                
                         
                
            }
			extMethodIndexList.append(")");     
			if(!isCheckOut)
			{
            transferBRMSConnectTableData(con , isCheckOut , extMethodIndexList.toString() , dbType,engine);
			}
        }catch(SQLException ex){
            //System.out.println(ex.printStackTrace());
            WFSUtil.printErr(engine,"WFSUtil>> transferBRMSData" + ex);
        }
        
        finally{
            try{         
                if(rs!= null)
                {
                    rs.close();
                    rs = null;
                }                   
            }catch(Exception e){
            	WFSUtil.printErr(engine,"" + e);
            }
            try{         
                if(rs1!= null)
                {
                    rs1.close();
                    rs1 = null;
                }                   
            }catch(Exception e){
            	WFSUtil.printErr(engine,"" + e);
            }
            try{         
                if(rs2!= null)
                {
                    rs2.close();
                    rs2 = null;
                }                   
            }catch(Exception e){
            	WFSUtil.printErr(engine,"" + e);
            }
            try{         
                if(stmt!= null)
                {
                    stmt.close();
                    stmt = null;
                }                   
            }catch(Exception e){
            	WFSUtil.printErr(engine,"" + e);
            }
            try{         
                if(pstmt!= null)
                {
                    pstmt.close();
                    pstmt = null;
                }                   
            }catch(Exception e){
            	WFSUtil.printErr(engine,"" + e);
            }
            try{         
                if(pstmt1!= null)
                {
                    pstmt1.close();
                    pstmt1 = null;
                }                   
            }catch(Exception e){
            	WFSUtil.printErr(engine,"" + e);
            }
            try{         
                if(pstmt2!= null)
                {
                    pstmt2.close();
                    pstmt2 = null;
                }                   
            }catch(Exception e){
            	WFSUtil.printErr(engine,"" + e);
            }try{
            	if(pstmt3!=null){
            		pstmt3.close();
            		pstmt3=null;
            	}
            }catch(Exception e){
                
            }
        }
    }    
         
     
	// =========================================================================
     
    /* public static void transferBRMSConnectTableData(Connection con , boolean isCheckOut , String ruleSetIdList , int dbType,String engine , String targetRuleSetIdList) throws SQLException{
        
        Statement stmt = null;
        String insertString = null;
        String updateString = null;        
        String selectQuery = null;
        int serverIdentifier = 0; 
        int targetserverIdentifier = 0;         
        PreparedStatement pstmt = null;
        PreparedStatement pstmt1 = null;
        PreparedStatement pstmt2 = null;
        PreparedStatement pstmt3 = null;
        PreparedStatement pstmt4 = null;
        ResultSet rs = null;
        ResultSet rs1 = null;
        ResultSet rs2 = null;
        ResultSet rs3 = null;
        boolean updateFlag = false;
        int serverIdentifierBkp = 0;      
        
        
       try{       
              
            selectQuery = "select distinct ServerIdentifier from " + (isCheckOut ? "WFBRMSRuleSetInfo" : "PMWBRMSRuleSetInfo") + " where BRMSRuleSetId in " + ruleSetIdList;
            pstmt = con.prepareStatement(selectQuery); 
            rs = pstmt.executeQuery();
            
            while(rs != null && rs.next()){
                serverIdentifier = rs.getInt(1);                
                serverIdentifierBkp = serverIdentifier ;
                              
                
                selectQuery = "select ConfigName, ServerHostName , ServerPort , ServerProtocol , URLSuffix , UserName , Password , ProxyEnabled from " + (isCheckOut ? "WFBRMSConnectTable" : "PMWBRMSConnectTable") + " where ServerIdentifier = ? ";
                pstmt1 = con.prepareStatement(selectQuery);
                pstmt1.setInt(1, serverIdentifier);                
                rs1 = pstmt1.executeQuery();
                
                if(rs1 != null && rs1.next()){
                    selectQuery = "select ServerIdentifier from " + (isCheckOut ? "PMWBRMSConnectTable" : "WFBRMSConnectTable") + " where ConfigName = ? and ServerHostName = ? and ServerPort = ?  and ServerProtocol = ? and URLSuffix = ? ";
                    pstmt2 = con.prepareStatement(selectQuery);                    
					WFSUtil.DB_SetString(1, rs1.getString(1), pstmt2, dbType);                                      
					WFSUtil.DB_SetString(2, rs1.getString(2), pstmt2, dbType); 
                    pstmt2.setInt(3, rs1.getInt(3));
                    WFSUtil.DB_SetString(4, rs1.getString(4), pstmt2, dbType);                    
                    WFSUtil.DB_SetString(5, rs1.getString(5), pstmt2, dbType);                    
                    rs2 = pstmt2.executeQuery();
                    
                    if(rs2 != null && rs2.next()){
                        targetserverIdentifier = rs2.getInt("ServerIdentifier");                        
                        updateFlag = true;
                    }else{ 
                        stmt = con.createStatement();
                        rs3 = stmt.executeQuery("select max(ServerIdentifier) from " + (isCheckOut ? "PMWBRMSConnectTable" : "WFBRMSConnectTable"));
                        
                        if(rs3 != null && rs3.next()){                           
                            targetserverIdentifier = rs3.getInt(1) + 1;
                            insertString = "insert into " + (isCheckOut ? "PMWBRMSConnectTable" : "WFBRMSConnectTable") + "(ConfigName , ServerIdentifier , ServerHostName , ServerPort , ServerProtocol , URLSuffix , UserName , Password , ProxyEnabled) values(?,?,?,?,?,?,?,?,?)";

                            pstmt3 = con.prepareStatement(insertString);
                            WFSUtil.DB_SetString(1, rs1.getString(1), pstmt3, dbType); 
                            pstmt3.setInt(2, targetserverIdentifier);
                            WFSUtil.DB_SetString(3, rs1.getString(2), pstmt3, dbType);
                            pstmt3.setInt(4, rs1.getInt(3));
                            WFSUtil.DB_SetString(5, rs1.getString(4), pstmt3, dbType);
                            WFSUtil.DB_SetString(6, rs1.getString(5), pstmt3, dbType);
                            WFSUtil.DB_SetString(7, rs1.getString(6), pstmt3, dbType);
                            WFSUtil.DB_SetString(8, rs1.getString(7), pstmt3, dbType);
                            WFSUtil.DB_SetString(9, rs1.getString(8), pstmt3, dbType); 
                            
                            if(pstmt3.executeUpdate() > 0){  
                                updateFlag = true;
                            }else{
                                updateFlag = false;
                            }                            
                        }                        
                    }
                    if(updateFlag){                        
                        updateString = "update " + (isCheckOut ? "PMWBRMSRuleSetInfo" : "WFBRMSRuleSetInfo") + " set ServerIdentifier = ? where ServerIdentifier = ? and BRMSRuleSetId in " + targetRuleSetIdList;
                        pstmt4 = con.prepareStatement(updateString);
                        pstmt4.setInt(1, targetserverIdentifier);                                                                       
                        pstmt4.setInt(2, serverIdentifierBkp); 
                        int res = pstmt4.executeUpdate();
                        
                        if(res > 0){
                            WFSUtil.printOut(engine,"Table updated successfully ");
                        }else{
                            WFSUtil.printErr(engine,"Table not updated successfully ");
                        }                        
                    }
                }               
                
                if(pstmt2 != null)
                {
                    pstmt2.close();
                    pstmt2 = null;
                }
                if(pstmt3 != null)
                {
                    pstmt3.close();
                    pstmt3 = null;
                }
                if(pstmt4 != null)
                {
                    pstmt4.close();
                    pstmt4 = null;
                }
                
                if(rs2 != null)
                {
                    rs2.close();
                    rs2 = null;
                }
                if(rs3 != null)
                {
                    rs3.close();
                    rs3 = null;
                }
                
            }
        }catch(SQLException ex){
            //System.out.println(ex.printStackTrace());
            WFSUtil.printErr(engine,"WFSUtil>> transferBRMSData" + ex);
        }
        
        finally{
            try{         
                if(pstmt1 != null)
                {
                    pstmt1.close();
                    pstmt1 = null;
                }
                if(pstmt2 != null)
                {
                    pstmt2.close();
                    pstmt2 = null;
                }
                if(pstmt3 != null)
                {
                    pstmt3.close();
                    pstmt3 = null;
                }
                if(pstmt4 != null)
                {
                    pstmt4.close();
                    pstmt4 = null;
                }                
                if(rs1 != null)
                {
                    rs1.close();
                    rs1 = null;
                }
                if(rs2 != null)
                {
                    rs2.close();
                    rs2 = null;
                }
                if(rs3 != null)
                {
                    rs3.close();
                    rs3 = null;
                }   
            }catch(Exception e){
                
            }
        }
    }*/
    
    public static void transferBRMSConnectTableData(Connection con , boolean isCheckOut , String extMethodIndexList , int dbType, String engine ) throws SQLException{
        
        Statement stmt = null;
        String insertString = null;
        String updateString = null;        
        String selectQuery = null;
        int serverIdentifier = 0; 
        int targetserverIdentifier = 0;         
        PreparedStatement pstmt = null;
        PreparedStatement pstmt1 = null;
        PreparedStatement pstmt2 = null;
        PreparedStatement pstmt3 = null;
        PreparedStatement pstmt4 = null;
        ResultSet rs = null;
        ResultSet rs1 = null;
        ResultSet rs2 = null;
        ResultSet rs3 = null;
        boolean updateFlag = false;
        int serverIdentifierBkp = 0;      
        
        
       try{       
              
            selectQuery = "select distinct ServerIdentifier from " + (isCheckOut ? "WFBRMSRuleSetInfo" : "PMWBRMSRuleSetInfo") + " where ExtMethodIndex in " + extMethodIndexList ;
            pstmt = con.prepareStatement(selectQuery); 
            rs = pstmt.executeQuery();
            
            while(rs != null && rs.next()){
                serverIdentifier = rs.getInt(1);                
                serverIdentifierBkp = serverIdentifier ;
                              
                
                selectQuery = "select ConfigName, ServerHostName , ServerPort , ServerProtocol , URLSuffix , UserName , Password , ProxyEnabled ,RESTServerHostName , RESTServerPort , RESTServerProtocol from " + (isCheckOut ? "WFBRMSConnectTable" : "PMWBRMSConnectTable") + " where ServerIdentifier = ? ";
                pstmt1 = con.prepareStatement(selectQuery);
                pstmt1.setInt(1, serverIdentifier);                
                rs1 = pstmt1.executeQuery();
                
                if(rs1 != null && rs1.next()){
                    selectQuery = "select ServerIdentifier from " + (isCheckOut ? "PMWBRMSConnectTable" : "WFBRMSConnectTable") + " where ConfigName = ? and ServerHostName = ? and ServerPort = ?  and ServerProtocol = ? and URLSuffix = ? ";
                    pstmt2 = con.prepareStatement(selectQuery);                    
					WFSUtil.DB_SetString(1, rs1.getString(1), pstmt2, dbType);                                      
					WFSUtil.DB_SetString(2, rs1.getString(2), pstmt2, dbType); 
                    pstmt2.setInt(3, rs1.getInt(3));
                    WFSUtil.DB_SetString(4, rs1.getString(4), pstmt2, dbType);                    
                    WFSUtil.DB_SetString(5, rs1.getString(5), pstmt2, dbType);                    
                    rs2 = pstmt2.executeQuery();
                    
                    if(rs2 != null && rs2.next()){
                        targetserverIdentifier = rs2.getInt("ServerIdentifier");                        
                        updateFlag = true;
                        updateString = "update " + (isCheckOut ? "PMWBRMSConnectTable" : "WFBRMSConnectTable") + " set  RESTServerHostName=? , RESTServerPort=? , RESTServerProtocol=? where ServerIdentifier = ?  " ;
                        pstmt4 = con.prepareStatement(updateString);
                        WFSUtil.DB_SetString(1, rs1.getString(9), pstmt4, dbType);
                        pstmt4.setInt(2, rs1.getInt(10));
                        WFSUtil.DB_SetString(3, rs1.getString(11), pstmt4, dbType);
                        pstmt4.setInt(4, targetserverIdentifier); 
                        int res = pstmt4.executeUpdate();
                        
                        if(res > 0){
                            WFSUtil.printOut(engine,"Table WFBRMSConnectTable updated successfully ");
                        }else{
                            WFSUtil.printErr(engine,"Table WFBRMSConnectTable not updated successfully ");
                        }
                        if(pstmt4!=null){
                        	pstmt4.close();
                        	pstmt4=null;
                        }
                    }else{ 
                        stmt = con.createStatement();
                        rs3 = stmt.executeQuery("select max(ServerIdentifier) from " + (isCheckOut ? "PMWBRMSConnectTable" : "WFBRMSConnectTable"));
                        
                        if(rs3 != null && rs3.next()){                           
                            targetserverIdentifier = rs3.getInt(1) + 1;
                            insertString = "insert into " + (isCheckOut ? "PMWBRMSConnectTable" : "WFBRMSConnectTable") + "(ConfigName , ServerIdentifier , ServerHostName , ServerPort , ServerProtocol , URLSuffix , UserName , Password , ProxyEnabled, RESTServerHostName , RESTServerPort , RESTServerProtocol) values(?,?,?,?,?,?,?,?,?,?,?,?)";

                            pstmt3 = con.prepareStatement(insertString);
                            WFSUtil.DB_SetString(1, rs1.getString(1), pstmt3, dbType); 
                            pstmt3.setInt(2, targetserverIdentifier);
                            WFSUtil.DB_SetString(3, rs1.getString(2), pstmt3, dbType);
                            pstmt3.setInt(4, rs1.getInt(3));
                            WFSUtil.DB_SetString(5, rs1.getString(4), pstmt3, dbType);
                            WFSUtil.DB_SetString(6, rs1.getString(5), pstmt3, dbType);
                            WFSUtil.DB_SetString(7, rs1.getString(6), pstmt3, dbType);
                            WFSUtil.DB_SetString(8, rs1.getString(7), pstmt3, dbType);
                            WFSUtil.DB_SetString(9, rs1.getString(8), pstmt3, dbType); 
                            WFSUtil.DB_SetString(10, rs1.getString(9), pstmt3, dbType);
                            pstmt3.setInt(11, rs1.getInt(10));
                            WFSUtil.DB_SetString(12, rs1.getString(11), pstmt3, dbType);
                            
                            if(pstmt3.executeUpdate() > 0){  
                                updateFlag = true;
                            }else{
                                updateFlag = false;
                            }                            
                        }                        
                    }
                    if(updateFlag){                        
                        updateString = "update " + (isCheckOut ? "PMWBRMSRuleSetInfo" : "WFBRMSRuleSetInfo") + " set ServerIdentifier = ? where ServerIdentifier = ? and ExtMethodIndex in " + extMethodIndexList;
                        pstmt4 = con.prepareStatement(updateString);
                        pstmt4.setInt(1, targetserverIdentifier);    
                        pstmt4.setInt(2, serverIdentifierBkp); 
                        int res = pstmt4.executeUpdate();
                        
                        if(res > 0){
                            WFSUtil.printOut(engine,"Table updated successfully ");
                        }else{
                            WFSUtil.printErr(engine,"Table not updated successfully ");
                        }                        
                    }
                }               
                
                if(pstmt2 != null)
                {
                    pstmt2.close();
                    pstmt2 = null;
                }
                if(pstmt3 != null)
                {
                    pstmt3.close();
                    pstmt3 = null;
                }
                if(pstmt4 != null)
                {
                    pstmt4.close();
                    pstmt4 = null;
                }
                
                if(rs2 != null)
                {
                    rs2.close();
                    rs2 = null;
                }
                if(rs3 != null)
                {
                    rs3.close();
                    rs3 = null;
                }
                
            }
        }catch(SQLException ex){
            //System.out.println(ex.printStackTrace());
            WFSUtil.printErr(engine,"WFSUtil>> transferBRMSData" + ex);
        }
        
        finally{
            try{         
                if(rs != null)
                {
                    rs.close();
                    rs = null;
                }   
            }catch(Exception e){
            	WFSUtil.printErr(engine,"" + e);
            }
            try{         
                if(rs1 != null)
                {
                    rs1.close();
                    rs1 = null;
                }   
            }catch(Exception e){
            	WFSUtil.printErr(engine,"" + e);
            }
            try{         
                if(rs2 != null)
                {
                    rs2.close();
                    rs2 = null;
                }   
            }catch(Exception e){
            	WFSUtil.printErr(engine,"" + e);
            }
            try{         
                if(rs3 != null)
                {
                    rs3.close();
                    rs3 = null;
                }   
            }catch(Exception e){
            	WFSUtil.printErr(engine,"" + e);
            }
            try{         
                if(stmt != null)
                {
                	stmt.close();
                	stmt = null;
                }   
            }catch(Exception e){
            	WFSUtil.printErr(engine,"" + e);
            }
            try{         
                if(pstmt != null)
                {
                	pstmt.close();
                	pstmt = null;
                }   
            }catch(Exception e){
            	WFSUtil.printErr(engine,"" + e);
            }
            try{         
                if(pstmt1 != null)
                {
                	pstmt1.close();
                	pstmt1 = null;
                }   
            }catch(Exception e){
            	WFSUtil.printErr(engine,"" + e);
            }
            try{         
                if(pstmt2 != null)
                {
                	pstmt2.close();
                	pstmt2 = null;
                }   
            }catch(Exception e){
            	WFSUtil.printErr(engine,"" + e);
            }
            try{         
                if(pstmt3 != null)
                {
                	pstmt3.close();
                	pstmt3 = null;
                }   
            }catch(Exception e){
            	WFSUtil.printErr(engine,"" + e);
            }
            try{         
                if(pstmt4 != null)
                {
                	pstmt4.close();
                	pstmt4 = null;
                }   
            }catch(Exception e){
            	WFSUtil.printErr(engine,"" + e);
            }
        }
    }
	
	public static void transferWebServiceData(Connection con,boolean isCheckOut,int  pmwProcessDefId, int processDefId,int dbType,String engine) throws SQLException{
		PreparedStatement pstmt=null;
		ResultSet rs=null;
		PreparedStatement pstmt1=null;
		ResultSet rs1=null;
		PreparedStatement pstmt2=null;
		PreparedStatement pstmt3=null;
		ResultSet rs2=null;
		String insertString=null;
		String selectQuery=null;
		Integer extMethodIndex=0;
		Integer searchCriteria=0;
		try{
			selectQuery = "select distinct ExtMethodIndex from " + (isCheckOut ? "WFWebserviceTable" : "PMWWebserviceTable") + " where processDefId = ?";
            pstmt = con.prepareStatement(selectQuery);            
            pstmt.setInt(1, (isCheckOut ? processDefId : pmwProcessDefId));
            rs = pstmt.executeQuery();
            while(rs != null && rs.next()){
                extMethodIndex = rs.getInt(1);
                selectQuery = "select * from " + (isCheckOut ? "ExtMethodDefTable" : "PMWExtMethodDefTable") + " where ExtMethodIndex = ? AND ProcessDefId = 0";                
                pstmt1 = con.prepareStatement(selectQuery);
                pstmt1.setInt(1, extMethodIndex);                
                rs1 = pstmt1.executeQuery();
                if(rs1 != null && rs1.next()){                    
                	searchCriteria=rs1.getInt("SearchCriteria");
					selectQuery = "select * from " + (isCheckOut ? "PMWWebServiceInfoTable" : "WfWebServiceInfoTable") + " where WSDLURLId = ? and processdefId=0 ";
					pstmt2 = con.prepareStatement(selectQuery); 	
					pstmt2.setInt(1, searchCriteria);
					rs2 = pstmt2.executeQuery();
					if(rs2 != null && rs2.next()){
						WFSUtil.printErr(engine,"ResourceId already exist ....");					
					}else{
						insertString = "INSERT INTO " + (isCheckOut ? " PMWWebServiceInfoTable" : " WfWebServiceInfoTable") + " ( ProcessDefId , WSDLURLId , WSDLURL , USERId , PWD , SecurityFlag ) SELECT ProcessDefId , WSDLURLId ,WSDLURL , USERId ,PWD	,SecurityFlag FROM "+ (isCheckOut ? " WfWebServiceInfoTable " : " PMWWebServiceInfoTable ") +" WHERE WSDLURLId = ? and processdefId=0";
						
						pstmt3 = con.prepareStatement(insertString); 	
						pstmt3.setInt(1, searchCriteria);
						pstmt3.executeUpdate();	
					}
					
					if(rs2 != null){
						rs2.close();
						rs2 = null;
					}
					if(pstmt3 != null){
						pstmt3.close();
						pstmt3 = null;
					}
					if(pstmt2 != null){
						pstmt2.close();
						pstmt2 = null;
					}					
					
					selectQuery = "select * from " + (isCheckOut ? " PMWExtMethodDefTable" : " ExtMethodDefTable") + " where ExtMethodIndex = ? and processdefid=0 ";
					pstmt2 = con.prepareStatement(selectQuery); 	
					pstmt2.setInt(1, extMethodIndex);
					rs2 = pstmt2.executeQuery();
					if(rs2 != null && rs2.next()){
						WFSUtil.printErr(engine, "Data already exist in table :: " + (isCheckOut ? " PMWExtMethodDefTable" : " ExtMethodDefTable "));					
					}else{
						insertString = "INSERT INTO " + (isCheckOut ? " PMWExtMethodDefTable" : " ExtMethodDefTable") + " ( ProcessDefId ,ExtMethodIndex ,ExtAppName , ExtAppType , ExtMethodName ,SearchMethod	, SearchCriteria , ReturnType ,MappingFile , ConfigurationID , AliasName , DomainName , Description , ServiceScope , IsBRMSService )  SELECT ProcessDefId ,ExtMethodIndex ,ExtAppName , ExtAppType , ExtMethodName ,SearchMethod	, SearchCriteria , ReturnType ,MappingFile , ConfigurationID , AliasName , DomainName , Description , ServiceScope , IsBRMSService  FROM "+ (isCheckOut ? " ExtMethodDefTable " : " PMWExtMethodDefTable ") +" WHERE ExtMethodIndex = ? and processdefId=0";
						
						pstmt3 = con.prepareStatement(insertString); 	
						pstmt3.setInt(1, extMethodIndex);
						pstmt3.executeUpdate();						
						
					}
					
					if(rs2 != null){
						rs2.close();
						rs2 = null;
					}
					if(pstmt3 != null){
						pstmt3.close();
						pstmt3 = null;
					}
					if(pstmt2 != null){
						pstmt2.close();
						pstmt2 = null;
					}
					
					
					selectQuery = "select * from " + (isCheckOut ? " PMWEXTMETHODPARAMDEFTABLE " : " EXTMETHODPARAMDEFTABLE ") + " where ExtMethodIndex = ? and processdefID=0 ";
					pstmt2 = con.prepareStatement(selectQuery); 	
					pstmt2.setInt(1, extMethodIndex);
					rs2 = pstmt2.executeQuery();
					if(rs2 != null && rs2.next()){
						WFSUtil.printErr(engine, "Data already exist in table :: " +(isCheckOut ? " PMWEXTMETHODPARAMDEFTABLE" : " EXTMETHODPARAMDEFTABLE"));					
	
					}else{
						
						insertString = "INSERT INTO " + (isCheckOut ? " PMWEXTMETHODPARAMDEFTABLE " : " EXTMETHODPARAMDEFTABLE") + " ( ProcessDefId , ExtMethodParamIndex , ExtMethodIndex	, ParameterName ,ParameterType , ParameterOrder	, DataStructureId, ParameterScope ,Unbounded ) SELECT ProcessDefId , ExtMethodParamIndex , ExtMethodIndex	, ParameterName ,ParameterType , ParameterOrder	, DataStructureId, ParameterScope ,Unbounded FROM "+ (isCheckOut ? " EXTMETHODPARAMDEFTABLE " : " PMWEXTMETHODPARAMDEFTABLE ") +" WHERE ExtMethodIndex = ? and processdefId=0";
						
						pstmt3 = con.prepareStatement(insertString); 	
						pstmt3.setInt(1, extMethodIndex);
						pstmt3.executeUpdate();						
						
					}
					
					if(rs2 != null){
						rs2.close();
						rs2 = null;
					}
					if(pstmt3 != null){
						pstmt3.close();
						pstmt3 = null;
					}
					if(pstmt2 != null){
						pstmt2.close();
						pstmt2 = null;
					}
					
					
					
					selectQuery = "select * from " + (isCheckOut ? " PMWDataStructureTable" : " WFDataStructureTable") + " where ExtMethodIndex = ? and processdefId=0 ";
					pstmt2 = con.prepareStatement(selectQuery); 	
					pstmt2.setInt(1, extMethodIndex);
					rs2 = pstmt2.executeQuery();
					if(rs2 != null && rs2.next()){
						WFSUtil.printErr(engine, "Data already exist in table :: " +(isCheckOut ? " PMWDataStructureTable" : " WFDataStructureTable"));					
	
					}else{
						
						insertString = "INSERT INTO " + (isCheckOut ? " PMWDataStructureTable" : " WFDataStructureTable") + " ( DataStructureId	, ProcessDefId , ActivityId , ExtMethodIndex , Name	, Type, ParentIndex	, ClassName	,Unbounded	) SELECT DataStructureId	, ProcessDefId , ActivityId , ExtMethodIndex , Name	, Type, ParentIndex	, ClassName	,Unbounded	 FROM "+ (isCheckOut ? " WFDataStructureTable " : " PMWDataStructureTable ") +" WHERE ExtMethodIndex = ? and processdefId=0";
						
						pstmt3 = con.prepareStatement(insertString); 	
						pstmt3.setInt(1, extMethodIndex);
						pstmt3.executeUpdate();						
						
					}
					
					if(rs2 != null){
						rs2.close();
						rs2 = null;
					}
					if(pstmt3 != null){
						pstmt3.close();
						pstmt3 = null;
					}
					if(pstmt2 != null){
						pstmt2.close();
						pstmt2 = null;
					}
                    
                }
            }       
		}catch(SQLException ex){            
            WFSUtil.printErr(engine,"WFSUtil>> transferWebServiceData" , ex);
        }catch(Exception ex){            
            WFSUtil.printErr(engine,"WFSUtil>> transferWebServiceData" , ex);
        } finally{
            try{
                if(rs != null)
                {
                    rs.close();
                    rs = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
            try{
                if(rs1 != null)
                {
                    rs1.close();
                    rs1 = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
            try{
                if(rs2 != null)
                {
                    rs2.close();
                    rs2 = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
    
            try{
                if(pstmt != null)
                {
                	pstmt.close();
                	pstmt = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
            try{
                if(pstmt1 != null)
                {
                	pstmt1.close();
                	pstmt1 = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
            try{
                if(pstmt2 != null)
                {
                	pstmt2.close();
                	pstmt2 = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
            try{
                if(pstmt3 != null)
                {
                	pstmt3.close();
                	pstmt3 = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
     
        }
	}
	
	public static void transferExternalMethodData(Connection con, boolean isCheckOut, int pmwProcessDefId, int processDefId, int dbType,String engine) throws SQLException{
        
        String insertString = null;      
        String selectQuery = null;
        String deleteQuery=null;        
        PreparedStatement pstmt = null;
        PreparedStatement pstmt2 = null;   
		PreparedStatement pstmt3 = null;
		PreparedStatement pstmt4=null;
        ResultSet rs = null;
        ResultSet rs2 = null;
        int extMethodIndex = 0;
        List extList=new ArrayList<Integer>();
        Integer extId=0;
        String extIndex=null;
        String param2="";
        int count=0;
        try{                   
            selectQuery = "select distinct Param2 from " + (isCheckOut ? "RULEOPERATIONTABLE" : "PMWRULEOPERATIONTABLE") + " where processDefId = ? and OperationType=23 ";
            pstmt = con.prepareStatement(selectQuery);            
            pstmt.setInt(1, (isCheckOut ? processDefId : pmwProcessDefId));
            rs = pstmt.executeQuery();
            while(rs!=null && rs.next()){
            	extIndex=rs.getString(1);
            	extIndex=TO_SANITIZE_STRING(extIndex, true);
            	try{
            		extId=Integer.parseInt(extIndex);
            		if(extId>=WFSConstant.EXTERNAL_METHOD_START_INDEX && extId<=WFSConstant.EXTERNAL_METHOD_END_INDEX){
            			extList.add(extId);
            			if(count==0){
            				param2=extIndex;
            				count++;
            			}
            			else
            				param2=param2+","+extIndex;
            		}
            	}catch(Exception e){
            		WFSUtil.printErr(engine,"" , e);
            	}
            }
            if(rs!=null){
            	rs.close();
            	rs=null;
            }
            if(pstmt!=null){
            	pstmt.close();
            	pstmt=null;
            }
            selectQuery = "select distinct Param1 from " + (isCheckOut ? "RULEOPERATIONTABLE" : "PMWRULEOPERATIONTABLE") + " where processDefId = ? and OperationType=22 ";
            if(count>0){
            	selectQuery=selectQuery+" and param1 not in ("+param2+" ) ";
            }
            pstmt = con.prepareStatement(selectQuery);            
            pstmt.setInt(1, (isCheckOut ? processDefId : pmwProcessDefId));
            rs = pstmt.executeQuery();
            while(rs!=null && rs.next()){
            	extIndex=rs.getString(1);
            	try{
            		extId=Integer.parseInt(extIndex);
            		if(extId>=WFSConstant.EXTERNAL_METHOD_START_INDEX && extId<=WFSConstant.EXTERNAL_METHOD_END_INDEX)
            			extList.add(extId);
            	}catch(Exception e){
            		WFSUtil.printErr(engine,"" , e);
            	}
            }
            if(rs!=null){
            	rs.close();
            	rs=null;
            }
            if(pstmt!=null){
            	pstmt.close();
            	pstmt=null;
            }
            
            Iterator it=extList.iterator();
            while(it.hasNext()){
                extMethodIndex = (Integer) it.next();                  
				selectQuery = "select * from " + (isCheckOut ? " PMWExtMethodDefTable" : " ExtMethodDefTable") + " where ExtMethodIndex = ? and processdefid=0 ";
				pstmt2 = con.prepareStatement(selectQuery); 	
				pstmt2.setInt(1, extMethodIndex);
				rs2 = pstmt2.executeQuery();
				if(rs2 != null && rs2.next()){
					WFSUtil.printErr(engine, "Data already exist in table :: " + (isCheckOut ? " PMWExtMethodDefTable" : " ExtMethodDefTable "));					
					if(!isCheckOut){
						WFSUtil.printErr(engine,"Deleting the Resources for ResourceId "+extMethodIndex);
						deleteQuery="delete from ExtMethodDefTable where ExtMethodIndex=? and processdefId=0";
						pstmt4=con.prepareStatement(deleteQuery);
						pstmt4.setInt(1, extMethodIndex);
						pstmt4.executeUpdate();
						if(pstmt4!=null){
							pstmt4.close();
							pstmt4=null;
						}
						insertString = "INSERT INTO  ExtMethodDefTable ( ProcessDefId ,ExtMethodIndex ,ExtAppName , ExtAppType , ExtMethodName ,SearchMethod	, SearchCriteria , ReturnType ,MappingFile , ConfigurationID , AliasName , DomainName , Description , ServiceScope , IsBRMSService ) SELECT ProcessDefId ,ExtMethodIndex ,ExtAppName , ExtAppType , ExtMethodName ,SearchMethod	, SearchCriteria , ReturnType ,MappingFile , ConfigurationID , AliasName , DomainName , Description , ServiceScope , IsBRMSService  FROM  PMWExtMethodDefTable  WHERE ExtMethodIndex = ? and processdefId=0";
							
						pstmt3 = con.prepareStatement(insertString); 	
						pstmt3.setInt(1, extMethodIndex);
						pstmt3.executeUpdate();
					}
				}else{
						
					insertString = "INSERT INTO " + (isCheckOut ? " PMWExtMethodDefTable" : " ExtMethodDefTable") + " ( ProcessDefId ,ExtMethodIndex ,ExtAppName , ExtAppType , ExtMethodName ,SearchMethod	, SearchCriteria , ReturnType ,MappingFile , ConfigurationID , AliasName , DomainName , Description , ServiceScope , IsBRMSService ) SELECT ProcessDefId ,ExtMethodIndex ,ExtAppName , ExtAppType , ExtMethodName ,SearchMethod	, SearchCriteria , ReturnType ,MappingFile , ConfigurationID , AliasName , DomainName , Description , ServiceScope , IsBRMSService FROM "+ (isCheckOut ? " ExtMethodDefTable " : " PMWExtMethodDefTable ") +" WHERE ExtMethodIndex = ? and processdefId=0";
						
					pstmt3 = con.prepareStatement(insertString); 	
					pstmt3.setInt(1, extMethodIndex);
					pstmt3.executeUpdate();						
						
				}
					
				if(rs2 != null){
					rs2.close();
					rs2 = null;
				}
				if(pstmt3 != null){
					pstmt3.close();
					pstmt3 = null;
				}
				if(pstmt2 != null){
					pstmt2.close();
					pstmt2 = null;
				}
					
					
				selectQuery = "select * from " + (isCheckOut ? " PMWEXTMETHODPARAMDEFTABLE " : " EXTMETHODPARAMDEFTABLE ") + " where ExtMethodIndex = ? and processdefID=0 ";
				pstmt2 = con.prepareStatement(selectQuery); 	
				pstmt2.setInt(1, extMethodIndex);
				rs2 = pstmt2.executeQuery();
				if(rs2 != null && rs2.next()){
					WFSUtil.printErr(engine, "Data already exist in table :: " +(isCheckOut ? " PMWEXTMETHODPARAMDEFTABLE" : " EXTMETHODPARAMDEFTABLE"));					
					if(!isCheckOut){
						WFSUtil.printErr(engine,"Deleting the Resources for ResourceId "+extMethodIndex);
						deleteQuery="delete from EXTMETHODPARAMDEFTABLE where ExtMethodIndex=? and processdefId=0";
						pstmt4=con.prepareStatement(deleteQuery);
						pstmt4.setInt(1, extMethodIndex);
						pstmt4.executeUpdate();
						if(pstmt4!=null){
							pstmt4.close();
							pstmt4=null;
						}
						insertString = "INSERT INTO  EXTMETHODPARAMDEFTABLE ( ProcessDefId , ExtMethodParamIndex , ExtMethodIndex	, ParameterName ,ParameterType , ParameterOrder	, DataStructureId, ParameterScope ,Unbounded ) SELECT ProcessDefId , ExtMethodParamIndex , ExtMethodIndex	, ParameterName ,ParameterType , ParameterOrder	, DataStructureId, ParameterScope ,Unbounded FROM  PMWEXTMETHODPARAMDEFTABLE  WHERE ExtMethodIndex = ? and processdefId=0";
							
						pstmt3 = con.prepareStatement(insertString); 	
						pstmt3.setInt(1, extMethodIndex);
						pstmt3.executeUpdate();	
					}
				}else{
						
					insertString = "INSERT INTO " + (isCheckOut ? " PMWEXTMETHODPARAMDEFTABLE " : " EXTMETHODPARAMDEFTABLE") + " ( ProcessDefId , ExtMethodParamIndex , ExtMethodIndex	, ParameterName ,ParameterType , ParameterOrder	, DataStructureId, ParameterScope ,Unbounded ) SELECT ProcessDefId , ExtMethodParamIndex , ExtMethodIndex	, ParameterName ,ParameterType , ParameterOrder	, DataStructureId, ParameterScope ,Unbounded FROM "+ (isCheckOut ? " EXTMETHODPARAMDEFTABLE " : " PMWEXTMETHODPARAMDEFTABLE ") +" WHERE ExtMethodIndex = ? and processdefId=0";
						
					pstmt3 = con.prepareStatement(insertString); 	
					pstmt3.setInt(1, extMethodIndex);
					pstmt3.executeUpdate();						
						
				}
					
				if(rs2 != null){
					rs2.close();
					rs2 = null;
				}
				if(pstmt3 != null){
					pstmt3.close();
					pstmt3 = null;
				}
				if(pstmt2 != null){
					pstmt2.close();
					pstmt2 = null;
				}
                    
            }       
        }catch(SQLException ex){            
            WFSUtil.printErr(engine,"WFSUtil>> transferExternalMethodData" , ex);
        }catch(Exception ex){            
            WFSUtil.printErr(engine,"WFSUtil>> transferExternalMethodData" , ex);
        }        
        
        finally{
            try{
                if(rs != null)
                {
                    rs.close();
                    rs = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
            try{
                if(rs2 != null)
                {
                    rs2.close();
                    rs2 = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
            try{
                if(pstmt != null)
                {
                	pstmt.close();
                	pstmt = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
            try{
                if(pstmt2 != null)
                {
                	pstmt2.close();
                	pstmt2 = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
            try{
                if(pstmt3 != null)
                {
                	pstmt3.close();
                	pstmt3 = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
            try{
                if(pstmt4 != null)
                {
                	pstmt4.close();
                	pstmt4 = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
        }
    }   

    
    public static void transferRESTData(Connection con, boolean isCheckOut, int pmwProcessDefId, int processDefId, int dbType,String engine) throws SQLException{
        
        Statement stmt = null;
        String insertString = null;
        String updateString = null;        
        String selectQuery = null;
        String deleteQuery=null;
        int targetRuleSetId = 0;         
        PreparedStatement pstmt = null;
        PreparedStatement pstmt1 = null;
        PreparedStatement pstmt2 = null;   
		PreparedStatement pstmt3 = null;
		PreparedStatement pstmt4=null;
        ResultSet rs = null;
        ResultSet rs1 = null;
        ResultSet rs2 = null;        
        boolean updateFlag = false ;
        boolean isFirstIter = true;	
        int extMethodIndex = 0;
        HashMap methodIndexMap = new HashMap();
        int newExtMethodIndex = 0;
        
        try{                   
            selectQuery = "select distinct ExtMethodIndex from " + (isCheckOut ? "WFRestActivityAssocTable" : "PMWRestActivityAssocTable") + " where processDefId = ?";
            pstmt = con.prepareStatement(selectQuery);            
            pstmt.setInt(1, (isCheckOut ? processDefId : pmwProcessDefId));
            rs = pstmt.executeQuery();
            
            while(rs != null && rs.next()){
                extMethodIndex = rs.getInt(1);  
                
                selectQuery = "select ProcessDefId,ResourceId,ResourceName,BaseURI,ResourcePath ,ResponseType,ContentType,OperationType,AuthenticationType,AuthUser,AuthPassword,AuthenticationDetails,AuthToken,ProxyEnabled,SecurityFlag from " + (isCheckOut ? "WFRestServiceInfoTable" : "PMWRestServiceInfoTable") + " where ResourceId = ? AND ProcessDefId = 0";                
                pstmt1 = con.prepareStatement(selectQuery);
                pstmt1.setInt(1, extMethodIndex);                
                rs1 = pstmt1.executeQuery();
                
                if(rs1 != null && rs1.next()){                    
                    String resourceName = rs1.getString("ResourceName"); 
                    String baseURI = rs1.getString("BaseURI");
                    String resourcePath = rs1.getString("ResourcePath");
                    String responseType = rs1.getString("ResponseType");
                    String contentType = rs1.getString("ContentType");
                    String operationType = rs1.getString("OperationType");
                    String authenticationType = rs1.getString("AuthenticationType");
					String authUser = rs1.getString("AuthUser");
					String authPass_word = rs1.getString("AuthPassword");
					String authenticationDetails = rs1.getString("AuthenticationDetails");
					String authToken = rs1.getString("AuthToken");
					String proxyEnabled = rs1.getString("ProxyEnabled");					
					String securityFlag = rs1.getString("SecurityFlag"); 

					selectQuery = "select * from " + (isCheckOut ? "PMWRestServiceInfoTable" : "WFRestServiceInfoTable") + " where ResourceId = ? and processdefId=0 ";
					pstmt2 = con.prepareStatement(selectQuery); 	
					pstmt2.setInt(1, extMethodIndex);
					rs2 = pstmt2.executeQuery();
					if(rs2 != null && rs2.next()){
						WFSUtil.printErr(engine,"ResourceId already exist ....");
						if(!isCheckOut){
							WFSUtil.printErr(engine,"Deleting the Resources for ResourceId "+extMethodIndex);
							deleteQuery="delete from WFRestServiceInfoTable where ResourceId=? and processdefID=0";
							pstmt4=con.prepareStatement(deleteQuery);
							pstmt4.setInt(1, extMethodIndex);
							pstmt4.executeUpdate();
							if(pstmt4!=null){
								pstmt4.close();
								pstmt4=null;
							}
							insertString = "insert into WFRestServiceInfoTable (ProcessDefId,ResourceId,ResourceName,BaseURI,ResourcePath,ResponseType,ContentType,OperationType,AuthenticationType,AuthUser,AuthPassword,AuthenticationDetails,AuthToken,ProxyEnabled,SecurityFlag) values(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?) ";
							
							pstmt3 = con.prepareStatement(insertString);
	                        pstmt3.setInt(1,  0);
							pstmt3.setInt(2, extMethodIndex);						
							WFSUtil.DB_SetString(3, resourceName, pstmt3, dbType);
							WFSUtil.DB_SetString(4, baseURI, pstmt3, dbType);
							WFSUtil.DB_SetString(5, resourcePath, pstmt3, dbType);
							WFSUtil.DB_SetString(6, responseType, pstmt3, dbType);
							WFSUtil.DB_SetString(7, contentType, pstmt3, dbType);
							WFSUtil.DB_SetString(8, operationType, pstmt3, dbType);
							WFSUtil.DB_SetString(9, authenticationType, pstmt3, dbType);
							WFSUtil.DB_SetString(10, authUser, pstmt3, dbType);
							WFSUtil.DB_SetString(11, authPass_word, pstmt3, dbType);
							WFSUtil.DB_SetString(12, authenticationDetails, pstmt3, dbType);
							WFSUtil.DB_SetString(13, authToken, pstmt3, dbType);
							WFSUtil.DB_SetString(14, proxyEnabled, pstmt3, dbType);
							WFSUtil.DB_SetString(15, securityFlag, pstmt3, dbType);
							pstmt3.executeUpdate();
						}
						
					}else{
						insertString = "insert into "+ (isCheckOut ? "PMWRestServiceInfoTable" : "WFRestServiceInfoTable") + "(ProcessDefId,ResourceId,ResourceName,BaseURI,ResourcePath,ResponseType,ContentType,OperationType,AuthenticationType,AuthUser,AuthPassword,AuthenticationDetails,AuthToken,ProxyEnabled,SecurityFlag) values(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?) ";
							
						pstmt3 = con.prepareStatement(insertString);
                        pstmt3.setInt(1,  0);
						pstmt3.setInt(2, extMethodIndex);						
						WFSUtil.DB_SetString(3, resourceName, pstmt3, dbType);
						WFSUtil.DB_SetString(4, baseURI, pstmt3, dbType);
						WFSUtil.DB_SetString(5, resourcePath, pstmt3, dbType);
						WFSUtil.DB_SetString(6, responseType, pstmt3, dbType);
						WFSUtil.DB_SetString(7, contentType, pstmt3, dbType);
						WFSUtil.DB_SetString(8, operationType, pstmt3, dbType);
						WFSUtil.DB_SetString(9, authenticationType, pstmt3, dbType);
						WFSUtil.DB_SetString(10, authUser, pstmt3, dbType);
						WFSUtil.DB_SetString(11, authPass_word, pstmt3, dbType);
						WFSUtil.DB_SetString(12, authenticationDetails, pstmt3, dbType);
						WFSUtil.DB_SetString(13, authToken, pstmt3, dbType);
						WFSUtil.DB_SetString(14, proxyEnabled, pstmt3, dbType);
						WFSUtil.DB_SetString(15, securityFlag, pstmt3, dbType);
						pstmt3.executeUpdate();
						
					}
					
					if(rs2 != null){
						rs2.close();
						rs2 = null;
					}
					if(pstmt3 != null){
						pstmt3.close();
						pstmt3 = null;
					}
					if(pstmt2 != null){
						pstmt2.close();
						pstmt2 = null;
					}					
					
					selectQuery = "select * from " + (isCheckOut ? " PMWExtMethodDefTable" : " ExtMethodDefTable") + " where ExtMethodIndex = ? and processdefid=0 ";
					pstmt2 = con.prepareStatement(selectQuery); 	
					pstmt2.setInt(1, extMethodIndex);
					rs2 = pstmt2.executeQuery();
					if(rs2 != null && rs2.next()){
						WFSUtil.printErr(engine, "Data already exist in table :: " + (isCheckOut ? " PMWExtMethodDefTable" : " ExtMethodDefTable "));					
						if(!isCheckOut){
							WFSUtil.printErr(engine,"Deleting the Resources for ResourceId "+extMethodIndex);
							deleteQuery="delete from ExtMethodDefTable where ExtMethodIndex=? and processdefId=0";
							pstmt4=con.prepareStatement(deleteQuery);
							pstmt4.setInt(1, extMethodIndex);
							pstmt4.executeUpdate();
							if(pstmt4!=null){
								pstmt4.close();
								pstmt4=null;
							}
							insertString = "INSERT INTO  ExtMethodDefTable ( ProcessDefId ,ExtMethodIndex ,ExtAppName , ExtAppType , ExtMethodName ,SearchMethod	, SearchCriteria , ReturnType ,MappingFile , ConfigurationID , AliasName , DomainName , Description , ServiceScope , IsBRMSService ) SELECT ProcessDefId ,ExtMethodIndex ,ExtAppName , ExtAppType , ExtMethodName ,SearchMethod	, SearchCriteria , ReturnType ,MappingFile , ConfigurationID , AliasName , DomainName , Description , ServiceScope , IsBRMSService FROM  PMWExtMethodDefTable  WHERE ExtMethodIndex = ? and processdefId=0";
							
							pstmt3 = con.prepareStatement(insertString); 	
							pstmt3.setInt(1, extMethodIndex);
							pstmt3.executeUpdate();	
						}
					}else{
						
						insertString = "INSERT INTO " + (isCheckOut ? " PMWExtMethodDefTable" : " ExtMethodDefTable") + " ( ProcessDefId ,ExtMethodIndex ,ExtAppName , ExtAppType , ExtMethodName ,SearchMethod	, SearchCriteria , ReturnType ,MappingFile , ConfigurationID , AliasName , DomainName , Description , ServiceScope , IsBRMSService ) SELECT ProcessDefId ,ExtMethodIndex ,ExtAppName , ExtAppType , ExtMethodName ,SearchMethod	, SearchCriteria , ReturnType ,MappingFile , ConfigurationID , AliasName , DomainName , Description , ServiceScope , IsBRMSService FROM "+ (isCheckOut ? " ExtMethodDefTable " : " PMWExtMethodDefTable ") +" WHERE ExtMethodIndex = ? and processdefId=0";
						
						pstmt3 = con.prepareStatement(insertString); 	
						pstmt3.setInt(1, extMethodIndex);
						pstmt3.executeUpdate();						
						
					}
					
					if(rs2 != null){
						rs2.close();
						rs2 = null;
					}
					if(pstmt3 != null){
						pstmt3.close();
						pstmt3 = null;
					}
					if(pstmt2 != null){
						pstmt2.close();
						pstmt2 = null;
					}
					
					
					selectQuery = "select * from " + (isCheckOut ? " PMWEXTMETHODPARAMDEFTABLE " : " EXTMETHODPARAMDEFTABLE ") + " where ExtMethodIndex = ? and processdefID=0 ";
					pstmt2 = con.prepareStatement(selectQuery); 	
					pstmt2.setInt(1, extMethodIndex);
					rs2 = pstmt2.executeQuery();
					if(rs2 != null && rs2.next()){
						WFSUtil.printErr(engine, "Data already exist in table :: " +(isCheckOut ? " PMWEXTMETHODPARAMDEFTABLE" : " EXTMETHODPARAMDEFTABLE"));					
						if(!isCheckOut){
							WFSUtil.printErr(engine,"Deleting the Resources for ResourceId "+extMethodIndex);
							deleteQuery="delete from EXTMETHODPARAMDEFTABLE where ExtMethodIndex=? and processdefId=0";
							pstmt4=con.prepareStatement(deleteQuery);
							pstmt4.setInt(1, extMethodIndex);
							pstmt4.executeUpdate();
							if(pstmt4!=null){
								pstmt4.close();
								pstmt4=null;
							}
							insertString = "INSERT INTO  EXTMETHODPARAMDEFTABLE ( ProcessDefId , ExtMethodParamIndex , ExtMethodIndex	, ParameterName ,ParameterType , ParameterOrder	, DataStructureId, ParameterScope ,Unbounded ) SELECT ProcessDefId , ExtMethodParamIndex , ExtMethodIndex	, ParameterName ,ParameterType , ParameterOrder	, DataStructureId, ParameterScope ,Unbounded FROM  PMWEXTMETHODPARAMDEFTABLE  WHERE ExtMethodIndex = ? and processdefId=0";
							
							pstmt3 = con.prepareStatement(insertString); 	
							pstmt3.setInt(1, extMethodIndex);
							pstmt3.executeUpdate();	
						}
					}else{
						
						insertString = "INSERT INTO " + (isCheckOut ? " PMWEXTMETHODPARAMDEFTABLE " : " EXTMETHODPARAMDEFTABLE") + " ( ProcessDefId , ExtMethodParamIndex , ExtMethodIndex	, ParameterName ,ParameterType , ParameterOrder	, DataStructureId, ParameterScope ,Unbounded ) SELECT ProcessDefId , ExtMethodParamIndex , ExtMethodIndex	, ParameterName ,ParameterType , ParameterOrder	, DataStructureId, ParameterScope ,Unbounded FROM "+ (isCheckOut ? " EXTMETHODPARAMDEFTABLE " : " PMWEXTMETHODPARAMDEFTABLE ") +" WHERE ExtMethodIndex = ? and processdefId=0";
						
						pstmt3 = con.prepareStatement(insertString); 	
						pstmt3.setInt(1, extMethodIndex);
						pstmt3.executeUpdate();						
						
					}
					
					if(rs2 != null){
						rs2.close();
						rs2 = null;
					}
					if(pstmt3 != null){
						pstmt3.close();
						pstmt3 = null;
					}
					if(pstmt2 != null){
						pstmt2.close();
						pstmt2 = null;
					}
					
					
					
					selectQuery = "select * from " + (isCheckOut ? " PMWDataStructureTable" : " WFDataStructureTable") + " where ExtMethodIndex = ? and processdefId=0 ";
					pstmt2 = con.prepareStatement(selectQuery); 	
					pstmt2.setInt(1, extMethodIndex);
					rs2 = pstmt2.executeQuery();
					if(rs2 != null && rs2.next()){
						WFSUtil.printErr(engine, "Data already exist in table :: " +(isCheckOut ? " PMWDataStructureTable" : " WFDataStructureTable"));					
						if(!isCheckOut){
							WFSUtil.printErr(engine,"Deleting the Resources for ResourceId "+extMethodIndex);
							deleteQuery="delete from WFDataStructureTable where ExtMethodIndex=? and processdefId=0";
							pstmt4=con.prepareStatement(deleteQuery);
							pstmt4.setInt(1, extMethodIndex);
							pstmt4.executeUpdate();
							if(pstmt4!=null){
								pstmt4.close();
								pstmt4=null;
							}
							insertString = "INSERT INTO  WFDataStructureTable ( DataStructureId	, ProcessDefId , ActivityId , ExtMethodIndex , Name	, Type, ParentIndex	, ClassName	,Unbounded ) SELECT DataStructureId	, ProcessDefId , ActivityId , ExtMethodIndex , Name	, Type, ParentIndex	, ClassName	,Unbounded FROM  PMWDataStructureTable  WHERE ExtMethodIndex = ? and processdefId=0";
							
							pstmt3 = con.prepareStatement(insertString); 	
							pstmt3.setInt(1, extMethodIndex);
							pstmt3.executeUpdate();	
						}
					}else{
						
						insertString = "INSERT INTO " + (isCheckOut ? " PMWDataStructureTable" : " WFDataStructureTable") + " ( DataStructureId	, ProcessDefId , ActivityId , ExtMethodIndex , Name	, Type, ParentIndex	, ClassName	,Unbounded ) SELECT DataStructureId	, ProcessDefId , ActivityId , ExtMethodIndex , Name	, Type, ParentIndex	, ClassName	,Unbounded FROM "+ (isCheckOut ? " WFDataStructureTable " : " PMWDataStructureTable ") +" WHERE ExtMethodIndex = ? and processdefId=0";
						
						pstmt3 = con.prepareStatement(insertString); 	
						pstmt3.setInt(1, extMethodIndex);
						pstmt3.executeUpdate();						
						
					}
					
					if(rs2 != null){
						rs2.close();
						rs2 = null;
					}
					if(pstmt3 != null){
						pstmt3.close();
						pstmt3 = null;
					}
					if(pstmt2 != null){
						pstmt2.close();
						pstmt2 = null;
					}
                    
                }
            }       
        }catch(SQLException ex){            
            WFSUtil.printErr(engine,"WFSUtil>> transferBRMSData" , ex);
        }catch(Exception ex){            
            WFSUtil.printErr(engine,"WFSUtil>> transferBRMSData" , ex);
        }        
        
        finally{
            try{
                if(rs != null)
                {
                    rs.close();
                    rs = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
            try{
                if(rs1 != null)
                {
                    rs1.close();
                    rs1 = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
            try{
                if(rs2 != null)
                {
                    rs2.close();
                    rs2 = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
            try{
                if(stmt != null)
                {
                	stmt.close();
                	stmt = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
            try{
                if(pstmt != null)
                {
                	pstmt.close();
                	pstmt = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
            try{
                if(pstmt1 != null)
                {
                	pstmt1.close();
                	pstmt1 = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
            try{
                if(pstmt2 != null)
                {
                	pstmt2.close();
                	pstmt2 = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
            try{
                if(pstmt3 != null)
                {
                	pstmt3.close();
                	pstmt3 = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
            try{
                if(pstmt4 != null)
                {
                	pstmt4.close();
                	pstmt4 = null;
                }                   
            }catch(Exception e){
            	 WFSUtil.printErr(engine,"" , e);
            }
        }
    }   
	
	
	 /**
     * *************************************************************
     * Function Name    :   getProfileList
     * Author			:   Saurabh Kamal
     * Date Written     :   16/08/2012
     * Input Parameters :   Statement stmt, int profileId, int associationType
     * Output Parameters:   ArrayList
     * Return Value     :   profileList
     * Description      :   Return profileList associated with one User/Group
     * *************************************************************
     */
   
   public static HashMap getProfileList(Statement stmt, int profileId, int associationType) throws SQLException{
		/*String strQuery = null;
		ResultSet rs = null;
		//ArrayList<Integer> profileList = null;
		HashMap profileMap = null;
		try{
			//profileList = new ArrayList<Integer>();
			profileMap = new HashMap();
			printOut("Select UserId, AssignedTillDateTime, AssociationFlag from WFUserObjAssocTable where ProfileId = " + profileId + " AND AssociationType = " + associationType);
			rs = stmt.executeQuery("Select UserId, AssignedTillDateTime, AssociationFlag from WFUserObjAssocTable where ProfileId = " + profileId + " AND AssociationType = " + associationType);
			while(rs.next()){
				//profileList.add(rs.getInt(1));
				profileMap.put(rs.getInt(1),rs.getString(2)+"#"+rs.getString(3));
			}
			if(rs != null){
				rs.close();
				rs = null;
			}
		} finally{
			if(rs != null){
				rs.close();
				rs = null;
			}
		}
		//return profileList;
		return profileMap;*/
		HashMap mapGetProfileList = new HashMap();
		mapGetProfileList = WFRMSUtil.getProfileList(stmt,profileId,associationType);
		return mapGetProfileList;
	}
	
	 /**
     * *************************************************************
     * Function Name    :   getRoleList
     * Author			:   Sajid Khan
     * Date Written     :   26/11/2013
     * Input Parameters :   Statement stmt, int profileId, int associationType
     * Output Parameters:   ArrayList
     * Return Value     :   profileList
     * Description      :   Return profileList associated with one User/Group
     * *************************************************************
     */
   
   public static HashMap getRoleList(Statement stmt, int profileId, int associationType) throws SQLException{
		/*String strQuery = null;
		ResultSet rs = null;
		HashMap roleMap = null;
		try{
			roleMap = new HashMap();
			printOut("Select UserId, AssignedTillDateTime, AssociationFlag from WFUserObjAssocTable where ProfileId = " + profileId + " AND AssociationType = " + associationType);
			rs = stmt.executeQuery("Select UserId, AssignedTillDateTime, AssociationFlag from WFUserObjAssocTable where ProfileId = " + profileId + " AND AssociationType = " + associationType);
			while(rs.next()){
				roleMap.put(rs.getInt(1),rs.getString(2)+"#"+rs.getString(3));
				printOut("RoleMap>>>>WFSUtil>>getRoleList>>>>"+roleMap);
			}
			if(rs != null){
				rs.close();
				rs = null;
			}
		 }finally{
			if(rs != null){
				rs.close();
				rs = null;
			}
		}

		return roleMap;*/
		HashMap roleMap = roleMap = new HashMap();
		roleMap = WFRMSUtil.getRoleList(stmt,profileId,associationType);
		return roleMap;
	}
	/**
     * *************************************************************
     * Function Name    :   getRightsOnObject
     * Author			:   Shweta Singhal
     * Date Written     :   30/08/2012
     * Input Parameters :   Connection con, int dbType, String objectType, int objectId, int sessionID
     * Output Parameters:   String
     * Return Value     :   String
     * Description      :   Return Rights on a given ObjectId for a given ObjectType
     * *************************************************************
     */
	public static String getRightsOnObject(Connection con, int dbType, String objectType, int objectId, int sessionID) throws SQLException, Exception{
		/*PreparedStatement pstmt = null;
		ResultSet rs = null;
		String rights = null;
		try{
			WFParticipant user = WFSUtil.WFCheckSession(con, sessionID);
            int userId = 0;
            /* Bug 38083 fixed, WFSException will be returned in case of user = null*/
           /* if(user != null)
                userId = user.getid();
            else{   
                int mainCode = WFSError.WM_INVALID_SESSION_HANDLE;
                int subCode = 0;
                String subject = WFSErrorMsg.getMessage(mainCode);
                String descr = WFSErrorMsg.getMessage(subCode);
                String errType = WFSError.WF_TMP;
                throw new WFSException(mainCode, subCode, errType, subject, descr);
            }    
			String userName = user.getname();
			int noOfRecToFetch = 1;
			String sortOrder = "A";
			String lastValue = "";
			//String filterString = null;
			boolean isRightCheck = false;
			
			pstmt = con.prepareStatement("select 1 from PROFILEUSERGROUPVIEW A, WFProfileTable B where A.ProfileId = B.ProfileId AND A.UserId = ? and B.ProfileName = ?");
            pstmt.setInt(1, userId);
            WFSUtil.DB_SetString(2, "SYSADMIN",pstmt,dbType);
            rs = pstmt.executeQuery();
            if(rs.next()){
                rights = WFSConstant.CONST_DEFAULT_RIGHTSTR;
            }else{
                pstmt = con.prepareStatement("Select DefaultRight from WFObjectListTable where ObjectType = ?");
                pstmt.setString(1, objectType);
                rs = pstmt.executeQuery();
                String defaultString = null;
                if(rs.next()){
                    defaultString = rs.getString("DefaultRight");
                }
                //rights = getRightsOnObject(con, dbType, objectType, objectId, sessionID, defaultString);
                rights = returnRightsForObjectType(con, dbType, userId, objectType, objectId, sortOrder, noOfRecToFetch, lastValue, isRightCheck, defaultString);
			}
			StringBuffer logProp= new StringBuffer("UserId::"+userId+" UserName::"+userName+" ObjectId::"+objectId+" ObjectType::"+objectType+" RightString: "+rights);
			WFLogger.writeLog('x', logProp);
		}finally{
			if(rs != null){
				rs.close();
				rs = null;
			}
			if(pstmt != null){
				pstmt.close();
				pstmt = null;
			}
		}
		return rights;*/
		String strGetRightsOnObject = WFRMSUtil.getRightsOnObject(con,dbType,objectType,objectId,sessionID);
		return strGetRightsOnObject;
	}
	
	/**
     * *************************************************************
     * Function Name    :   getRightsOnObject
     * Author			:   Shweta Singhal
     * Date Written     :   30/08/2012
     * Input Parameters :   Connection con, int dbType, String objectType, int objectId, int sessionID, String defaultRights
     * Output Parameters:   String
     * Return Value     :   String
     * Description      :   Return Rights on a given ObjectId for a given ObjectType
     * *************************************************************
     */
	 
	/*public static String getRightsOnObject(Connection con, int dbType, String objectType, int objectId, int sessionID, String defaultRights) throws SQLException, Exception{
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		ArrayList<String> objectRightString = new ArrayList<String>();
		String rights = null;
		try{
			WFParticipant user = WFSUtil.WFCheckSession(con, sessionID);
			int userId = user.getid();
			pstmt = con.prepareStatement("select rightstring from WFObjectProfileAssocTable A,WFObjectListTable  B where A.objecttypeid = B.objecttypeid and B.objecttype = ? and associationtype = 0 and userid = ? and ObjectId = ?");
			printOut("select rightstring from WFObjectProfileAssocTable A,WFObjectListTable  B where A.objecttypeid = B.objecttypeid and B.objecttype = "+TO_STRING(objectType, true, dbType) + " and associationtype = 0 and userid = "+userId+" and ObjectId = "+objectId+"");
			WFSUtil.DB_SetString(1, objectType, pstmt, dbType);
			pstmt.setInt(2,userId);
			pstmt.setInt(3,objectId);
			rs = pstmt.executeQuery();
			int i=0;
			int j=0;
			boolean found = false;
			if(rs.next()){
				found = true;
			}else{
				if(rs != null){
					rs.close();
					rs = null;
				}
				if(pstmt != null){
					pstmt.close();
					pstmt = null;
				}
				pstmt = con.prepareStatement("select rightstring from WFObjectProfileAssocTable A,WFObjectListTable  B where A.objecttypeid = B.objecttypeid and B.objecttype = ? and associationtype = 1 and userid in (select groupindex from wfgroupmemberview where userindex = ?) and ObjectId = ?");
				
				printOut("select rightstring from WFObjectProfileAssocTable A,WFObjectListTable  B where A.objecttypeid = B.objecttypeid and B.objecttype = "+TO_STRING(objectType, true, dbType) +" and associationtype = 1 and userid in (select groupindex from wfgroupmemberview where userindex = "+userId+") and ObjectId = "+objectId+"");
				
				WFSUtil.DB_SetString(1, objectType, pstmt, dbType);
				pstmt.setInt(2,userId);
				pstmt.setInt(3,objectId);
				rs = pstmt.executeQuery();
				if(rs.next()){
					found = true;
				}else{
					if(rs != null){
						rs.close();
						rs = null;
					}
					if(pstmt != null){
						pstmt.close();
						pstmt = null;
					}
					pstmt = con.prepareStatement("select rightstring from WFObjectProfileAssocTable A,WFObjectListTable  B where A.objecttypeid = B.objecttypeid and B.objecttype = ? and associationtype = 2 and userid in (select profileid from profileusergroupview where userid = ?) and ObjectId = ?");
					
					printOut("select rightstring from WFObjectProfileAssocTable A,WFObjectListTable  B where A.objecttypeid = B.objecttypeid and B.objecttype = "+TO_STRING(objectType, true, dbType) +" and associationtype = 2 and userid in (select profileid from profileusergroupview where userid = "+userId+") and ObjectId = "+objectId+"");
					
					WFSUtil.DB_SetString(1, objectType, pstmt, dbType);
					pstmt.setInt(2,userId);
					pstmt.setInt(3,objectId);
					rs = pstmt.executeQuery();
					if(rs.next()){
						found = true;
					}
				}
			}
			if(found){
				objectRightString.add(rs.getString(1));
				while(rs.next()){
					i++;
					objectRightString.add(rs.getString(1));
				}
				BitSet bs1 = createBitset(objectRightString.get(0));
				if(i>0){
					for(j=1; j<=i;j++){
						BitSet bs2 = createBitset(objectRightString.get(j)); 
						bs1.or(bs2);
					}
					rights = bitToString(bs1);
				}else
					rights = objectRightString.get(0);
			}else{
				rights = defaultRights;
			}
			
			if(rs != null){
				rs.close();
				rs = null;
			}
			if(pstmt != null){
				pstmt.close();
				pstmt = null;
			}
		}finally{
			if(rs != null){
				rs.close();
				rs = null;
			}
			if(pstmt != null){
				pstmt.close();
				pstmt = null;
			}
		}
		return rights;
	}*/
	
	/**
     * *************************************************************
     * Function Name    :   getOrderIndex
     * Author			:   Shweta Singhal
     * Date Written     :   30/08/2012
     * Input Parameters :   Connection con, int dbType, String objectType, String rightFlag
     * Output Parameters:   int
     * Return Value     :   int
     * Description      :   Return orderIndex of given rightFlag from WFAssignableRightTable 
     * *************************************************************
     */
	public static int getOrderIndex(Connection con, int dbType, String objectType, String rightFlag) throws SQLException, Exception{
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		int orderBy = 0; 
		try{
			pstmt = con.prepareStatement("select orderby from WFAssignableRightsTable A, WFObjectListTable B where A.ObjectTypeId = B.ObjectTypeId and rightflag = ? and objectType = ?");
			WFSUtil.DB_SetString(1, rightFlag, pstmt, dbType);
			WFSUtil.DB_SetString(2, objectType, pstmt, dbType);
			rs = pstmt.executeQuery();
			if(rs.next())
				orderBy = rs.getInt(1);
		}finally{
			if(rs != null){
				rs.close();
				rs = null;
			}
			if(pstmt != null){
				pstmt.close();
				pstmt = null;
			}
		}
		return orderBy;
	}

	/**
     * *************************************************************
     * Function Name    :   checkRights
     * Author			:   Shweta Singhal
     * Date Written     :   30/08/2012
     * Input Parameters :   Connection con, int dbType, String objectType, int objectId, int sessionID, int rightOrderIndex
     * Output Parameters:   boolean
     * Return Value     :   
     * Description      :   
     * *************************************************************
     */
	public static boolean checkRights(Connection con, int dbType, String objectType, int objectId, int sessionID, int rightOrderIndex) throws SQLException, Exception{
		/*PreparedStatement pstmt = null;
		ResultSet rs = null;
		boolean isRight = false;
		try{		
			String objectRightString = getRightsOnObject(con, dbType, objectType, objectId, sessionID);
			//int orderIndex = getOrderIndex(con, dbType, objectType, rightFlag);
			if(objectRightString.charAt(rightOrderIndex-1) == '1'){
				isRight = true;
			}
		}finally{
			if(rs != null){
				rs.close();
				rs = null;
			}
			if(pstmt != null){
				pstmt.close();
				pstmt = null;
			}
		}
		return isRight;*/
		boolean bCheckRights = WFRMSUtil.checkRights(con,dbType,objectType,objectId,sessionID,rightOrderIndex);
		return bCheckRights;
	}
	
	public static String bitToString(final BitSet bs){
		 int length = bs.length();
		 final char[] arr = new char[length];
		 for(int i = 0; i < length; i++){
			arr[length-1-i] = bs.get(i) ? '1' : '0';
		 }
		 String s= String.valueOf(arr);
         
         while(length != 100){
             s= "0"+s;
			 length = s.length();
		 }
         return s;
	}

    public static BitSet createBitset(final String input){
		int length = input.length();
		final BitSet bitSet = new BitSet(length);
		for(int i = 0; i < length; i++){
     	// anything that's not a 1 is a zero, per convention
            bitSet.set(i, input.charAt(length - (i + 1)) == '1');
		}
		return bitSet;
	}
	
	/**
     * *************************************************************
     * Function Name    :   getIdForName
     * Author			:   Sajid Khan
     * Date Written     :   03/09/2012
     * Input Parameters :   Connection con, int dbType, String objectName, String objectType
     * Output Parameters:   String[]
     * Return Value     :   String[]
     * Description      :   Return Id of Given ObjectName and tagName of given ObjectType
     * *************************************************************
     */
	public static String[] getIdForName(Connection con, int dbType, String objectName, String objectType)throws SQLException, Exception{  
        XMLParser parser = new XMLParser();
		PreparedStatement pstmt = null;        
        ResultSet rs = null;        
        int mainCode = 0;
        int subCode = 0;
        String subject = null;
        String descr = null;
        String errType = WFSError.WF_TMP;
		int id =0; 
		String[] strArray = null;
		try {            
			String exeStr = "";                                                
			String tag = "";
			if (objectType.startsWith("Q")) {
				exeStr = "select queueid from queuedeftable where queuename=?";
				pstmt = con.prepareStatement(exeStr);
				WFSUtil.DB_SetString(1, objectName, pstmt, dbType);
				tag = "QueueId";
			} else if (objectType.startsWith("A")) {
				exeStr = "select Activityid from Activitytable where ActivityName=? and ProcessDefId = ? ";
				pstmt = con.prepareStatement(exeStr);
				WFSUtil.DB_SetString(1, objectName, pstmt, dbType);
				pstmt.setInt(2, parser.getIntOf("ProcessDefID", 0, false));
				tag = "ActivityId";
			} else if (objectType.startsWith("P")) {
				exeStr = "select ProcessDefId from ProcessDefTable "+ getTableLockHintStr(dbType) + " where ProcessName = ? order by VersionNo desc ";
				pstmt = con.prepareStatement(exeStr);
				WFSUtil.DB_SetString(1, objectName, pstmt, dbType);
				tag = "ProcessDefId";
			} else if (objectType.startsWith("O")) {
				exeStr = "Select ObjectTypeId from WFObjectListTable where ObjectType = ?";
				pstmt = con.prepareStatement(exeStr);
				WFSUtil.DB_SetString(1, objectName, pstmt, dbType);
				tag = "ObjectTypeId";
		    } else if (objectType.startsWith("U")) {
		        exeStr = " Select UserIndex from WFUserView  where Upper(UserName) = ?";
		        pstmt = con.prepareStatement(exeStr);
		        WFSUtil.DB_SetString(1, objectName.toUpperCase(), pstmt, dbType);
		        tag = "UserId";
			}
			if(pstmt!=null){
				pstmt.execute();
				rs = pstmt.getResultSet();
				if (rs.next()) {
					strArray = new String[2];
					strArray[0] = tag;
					strArray[1] = String.valueOf(rs.getInt(1));
				}
			}
		} finally {            
			if(rs != null){
				rs.close();
				rs = null;
			}
			if(pstmt != null){
				pstmt.close();
				pstmt = null;
			}
		} 
		return strArray;
    } 
	
	public static String[] getIdForName(Connection con, int dbType, String objectName, String objectType, XMLParser parser )throws SQLException, Exception{  
		PreparedStatement pstmt = null;        
        ResultSet rs = null;        
        int mainCode = 0;
        int subCode = 0;
        String subject = null;
        String descr = null;
        String errType = WFSError.WF_TMP;
		int id =0; 
		String[] strArray = null;
		try {            
			String exeStr = "";                                                
			String tag = "";
			if (objectType.startsWith("Q")) {
				exeStr = "select queueid from queuedeftable where queuename=?";
				pstmt = con.prepareStatement(exeStr);
				WFSUtil.DB_SetString(1, objectName, pstmt, dbType);
				tag = "QueueId";
			} else if (objectType.startsWith("A")) {
				exeStr = "select Activityid from Activitytable where ActivityName=? and ProcessDefId = ? ";
				pstmt = con.prepareStatement(exeStr);
				WFSUtil.DB_SetString(1, objectName, pstmt, dbType);
				pstmt.setInt(2, parser.getIntOf("ProcessDefID", 0, false));
				tag = "ActivityId";
			} else if (objectType.startsWith("P")) {
				exeStr = "select ProcessDefId from ProcessDefTable "+ getTableLockHintStr(dbType) + " where ProcessName = ? order by VersionNo desc ";
				pstmt = con.prepareStatement(exeStr);
				WFSUtil.DB_SetString(1, objectName, pstmt, dbType);
				tag = "ProcessDefId";
			} else if (objectType.startsWith("O")) {
				exeStr = "Select ObjectTypeId from WFObjectListTable where ObjectType = ?";
				pstmt = con.prepareStatement(exeStr);
				WFSUtil.DB_SetString(1, objectName, pstmt, dbType);
				tag = "ObjectTypeId";
			} else if (objectType.startsWith("U")) {
		        exeStr = " Select UserIndex from WFUserView  where Upper(UserName) = ?";
		        pstmt = con.prepareStatement(exeStr);
		        WFSUtil.DB_SetString(1, objectName.toUpperCase(), pstmt, dbType);
		        tag = "UserId";
			}
			if(pstmt!=null){
				pstmt.execute();
				rs = pstmt.getResultSet();
				if (rs.next()) {
					strArray = new String[2];
					strArray[0] = tag;
					strArray[1] = String.valueOf(rs.getInt(1));
				}
			}
		} finally {            
			if(rs != null){
				rs.close();
				rs = null;
			}
			if(pstmt != null){
				pstmt.close();
				pstmt = null;
			}
		} 
		return strArray;
    } 

	/**
     * *************************************************************
     * Function Name    :   createTempXML
     * Author			:   Shweta Singhal
     * Date Written     :   04/09/2012
     * Input Parameters :   HashMap hMap, int objId
     * Output Parameters:   String
     * Return Value     :   String
     * Description      :   create temporary XML of Object Rights
     * *************************************************************
     */
	public static String createTempXML(HashMap hMap, int objId){
		/*StringBuffer tempXML = new StringBuffer(200);
		tempXML.append("<Object>");
		//objId = Integer.parseInt(iterator.next().toString());
		tempXML.append("<ObjectId>");
        tempXML.append(String.valueOf(objId));
        tempXML.append("</ObjectId>");
        String value =(String) hMap.get(objId);
        int index = value.indexOf("#");
        String objName = value.substring(0,index);
		// Change for Bug 39726
		if(objName.indexOf(";&hash") != -1) 
            objName = objName.replace(";&hash", "#");
        String rightString = value.substring(index+1);
        tempXML.append("<ObjectName>");
        tempXML.append(objName);
        tempXML.append("</ObjectName>");
        tempXML.append("<RightString>");
        tempXML.append(rightString);
        tempXML.append("</RightString>");
        tempXML.append("</Object>");
		
		return tempXML.toString();*/
		String strCreateTempXML = WFRMSUtil.createTempXML(hMap,objId);
		return strCreateTempXML;
	}
	
	/**
     * *************************************************************
     * Function Name    :   getRights
     * Author			:   Shweta Singhal
     * Date Written     :   04/09/2012
     * Input Parameters :   ResultSet rs, HashMap hMap
     * Output Parameters:   String
     * Return Value     :   HashMap<Integer, String> 
     * Description      :   get Rights For Objects fetched from given resultset
     * *************************************************************
     */
	public static HashMap<Integer, String> getRights(ResultSet rs, HashMap hMap) throws SQLException{
        /*
		int objectId = rs.getInt("ObjectId");
        String rightString = null;
        String objectName = null;
        String right = null;
		if(hMap.get(objectId)==null){
            rightString = rs.getString("RightString");
			objectName = rs.getString("ObjectName");
			// Change for Bug 39726
			if(objectName.indexOf("#") != -1)
				objectName = objectName.replace("#", ";&hash");
			hMap.put(objectId, objectName+"#"+rightString);
		}
		else{
            right = (String)hMap.get(objectId);
			right = right.substring(right.indexOf("#"));
			BitSet bs1 = createBitset(right);
			rightString = rs.getString("RightString");
			objectName = rs.getString("ObjectName");
			BitSet bs2 = createBitset(rightString); 
			bs1.or(bs2);
			rightString = bitToString(bs1);
			hMap.put(objectId, objectName+"#"+rightString);
		}
		return hMap;*/
		  HashMap mapGetRights = new HashMap();
		  mapGetRights = WFRMSUtil.getRights(rs,hMap);
	      return mapGetRights;
	}
	
	/**
     * *************************************************************
     * Function Name    :   returnRightsForObjectType
     * Author			:   Shweta Singhal
     * Date Written     :   04/09/2012
     * Input Parameters :   Connection con, int dbType, int userId, String objType,String sortOrder, int batchSize, String lastVal
     * Output Parameters:   String
     * Return Value     :   String 
     * Description      :   return right xml of given objectType
     * *************************************************************
     */
    public static String returnRightsForObjectType(Connection con, int dbType, int userId, String objType,String sortOrder, int batchSize, String lastVal,int projectId) throws SQLException, Exception{
		return returnRightsForObjectType(con, dbType, userId, objType, sortOrder, batchSize, lastVal, null,projectId);
	}
	 
	 /**
     * *************************************************************
     * Function Name    :   returnRightsForObjectType
     * Author		:   Shweta Singhal
     * Date Written     :   04/09/2012
     * Input Parameters :   Connection con, int dbType, int userId, String objType,String sortOrder, int batchSize, String lastVal
     * Output Parameters:   String
     * Return Value     :   String 
     * Description      :   return right xml of given objectType
     * *************************************************************
     */
    public static String returnRightsForObjectType(Connection con, int dbType, int userId, String objType,String sortOrder, int batchSize, String lastVal, String filterString, int projectId) throws SQLException, Exception{
  //private static String getRights(Connection con, int dbType, int sessionId, String objType,String sortOrder, int batchSize, String lastVal) throws SQLException{
       /* ArrayList<HashMap> arrList = new ArrayList<HashMap>();
		HashMap<Integer, String> userMap = null;
		HashMap<Integer, String> groupMap = null;
		HashMap<Integer, String> profileMap = null;
		HashMap<Integer, String> roleMap = null;
        HashMap<Integer, String> hMap = null;
        StringBuffer tempXML = null;
        CallableStatement cstmt = null;
        ResultSet rs = null;
        String tempRightTable = null;
        Statement stmt = null;
       try{
			int objectId = 0;
			tempRightTable = getTempTableName(con, "TempObjectRightsTable", dbType);
            String[] qParam = executeGetQueryParam(con, dbType, objType); 
            //String[] qParam = {"ProcessName", "ProcessDefTable", " AND ProcessDefId = ObjectId "};
            String typeNVARCHAR = WFSUtil.getNVARCHARType(dbType);
			
			printOut("tempRightTable " + tempRightTable);
			stmt = con.createStatement();
			createTempTable(stmt, tempRightTable, "AssociationType INT, ObjectId INT, ObjectName " + typeNVARCHAR + "(64), RightString " + typeNVARCHAR + "(100) " , dbType); /*Bug 40277*/
           /* 
			if (dbType == JTSConstant.JTS_MSSQL) {
				cstmt = con.prepareCall("{call WFReturnRightsForObjType(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)}");
			} else if (dbType == JTSConstant.JTS_ORACLE) {
				cstmt = con.prepareCall("{call WFReturnRightsForObjType(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)}");
			}
			cstmt.setInt(1, userId);
            //cstmt.setInt(2, 2);
            cstmt.setString(2, objType);
            cstmt.setString(3, qParam[0]);
            cstmt.setString(4, qParam[1]);
            cstmt.setString(5, qParam[2]);
            cstmt.setString(6, tempRightTable);
            cstmt.setString(7, sortOrder);
            cstmt.setInt(8, batchSize);
            if(lastVal == null || lastVal.equals(""))
                cstmt.setNull(9, java.sql.Types.VARCHAR);
            else
                cstmt.setString(9, lastVal);
			
			if(filterString == null || filterString.equals(""))
                cstmt.setNull(10, java.sql.Types.VARCHAR);
            else
                cstmt.setString(10, filterString);
			
			cstmt.setInt(11, 0);
			if (dbType == JTSConstant.JTS_ORACLE) {				
				cstmt.registerOutParameter(12, oracle.jdbc.OracleTypes.CURSOR);
				cstmt.registerOutParameter(13, oracle.jdbc.OracleTypes.CURSOR);				
			}	

            cstmt.execute();
			if (dbType == JTSConstant.JTS_MSSQL) /* ResultSet 1 -> User' Preferences  {*/
			/*	rs = cstmt.getResultSet();
			} else if (dbType == JTSConstant.JTS_ORACLE) {
				rs = (ResultSet) cstmt.getObject(12);			
			}             
			
            int assocType =0;
			userMap = new HashMap<Integer, String>();
			groupMap = new HashMap<Integer, String>();
			profileMap = new HashMap<Integer, String>();
			roleMap = new HashMap<Integer, String>();
            
			while(rs.next()){
                assocType = rs.getInt("AssociationType");
                if(assocType == 0){
                    userMap.putAll(getRights(rs, userMap));			
                }else if(assocType == 1){
                    groupMap.putAll(getRights(rs, groupMap));			
                }else if(assocType == 2){
                    profileMap.putAll(getRights(rs, profileMap));			
                }else if(assocType == 3){
                    roleMap.putAll(getRights(rs, roleMap));			
                }
            }
            if (rs != null) {
                rs.close();
                rs = null;
            }
			
            arrList.add(0, userMap);
            arrList.add(1, groupMap);
            arrList.add(2, profileMap);
			arrList.add(3, roleMap);
            
			tempXML = new StringBuffer(200);
            tempXML.append("<Objects>");
            
            int objId = 0;  
            int retCount = 0;
            int totalCount = 0;
            hMap = new HashMap<Integer, String>();
            if ((dbType == JTSConstant.JTS_MSSQL && cstmt.getMoreResults()) || dbType == JTSConstant.JTS_ORACLE || dbType == JTSConstant.JTS_POSTGRES) {
                if (dbType == JTSConstant.JTS_ORACLE) {
					rs = (ResultSet) cstmt.getObject(13);
				} else if (dbType == JTSConstant.JTS_MSSQL) {
					rs = cstmt.getResultSet();				
				} 
                while(retCount < batchSize && rs.next()){                   
                    objId = rs.getInt("ObjectId");
                    if(arrList.get(0).containsKey(objId)){
                        hMap = arrList.get(0);
                        tempXML.append(createTempXML(hMap,objId));
					}else if(arrList.get(1).containsKey(objId)){
                        hMap = arrList.get(1);
                        tempXML.append(createTempXML(hMap,objId));
                    }else if(arrList.get(2).containsKey(objId)){
                        hMap = arrList.get(2);
                        tempXML.append(createTempXML(hMap,objId));
                    }else if(arrList.get(3).containsKey(objId)){
                        hMap = arrList.get(3);
                        tempXML.append(createTempXML(hMap,objId));
                    }		
                    retCount++;
					totalCount++;
                }
                if(rs.next())
					totalCount++;
				if (rs != null) {
                    rs.close();
					rs = null;
                }
            }
            tempXML.append("</Objects>");*/
			//tempXML.append(gen.writeValueOf("RetrievedCount", String.valueOf(retCount)));
			//tempXML.append(gen.writeValueOf("TotalCount", String.valueOf(totalCount)));
           /* tempXML.append("<RetrievedCount>");
            tempXML.append(String.valueOf(retCount));
            tempXML.append("</RetrievedCount>");
            tempXML.append("<TotalCount>");
            tempXML.append(String.valueOf(totalCount));
            tempXML.append("</TotalCount>");
			
			printOut("tempXML::"+tempXML.toString());
        }finally{
           if(stmt != null){                
				try{
					dropTempTable(stmt, tempRightTable, dbType);
				} catch(Exception excp){}
	        }
			try{
				if(rs != null){
					rs.close();
					rs = null;
				}
			}catch(Exception ignored){}
            
			try{
				if(stmt != null){
					stmt.close();
					stmt = null;
				}
                if(cstmt != null){
					cstmt.close();
					cstmt = null;
				}
			}catch(Exception ignored){}
       }
    return tempXML.toString();*/
		String strReturnRightsForObjectType = WFRMSUtil.returnRightsForObjectType(con,dbType,userId,objType,sortOrder,batchSize,lastVal,filterString,projectId);
		return strReturnRightsForObjectType;
	}
	
	/**
     * *************************************************************
     * Function Name    :   compareRightsOnObject
     * Author			:   Saurabh Kamal
     * Date Written     :   05/09/2012
     * Input Parameters :   String ObjectRightString, Int RightOrderIndex
     * Output Parameters:   boolean
     * Return Value     :   
     * Description      :   
     * *************************************************************
     */	
	public static boolean compareRightsOnObject(String objectRightString, int rightOrderIndex) {  
		/*boolean isRight = false;
		if(objectRightString.charAt(rightOrderIndex-1)=='1'){
			isRight = true;
		}
		return isRight;*/
		boolean bCompareRightsOnObject = WFRMSUtil.compareRightsOnObject(objectRightString,rightOrderIndex);
		return bCompareRightsOnObject;
	}
	
	/**
     * *************************************************************
     * Function Name    :   associateObjectsWithUser
     * Author			:   Saurabh Kamal
     * Date Written     :   13/09/2012
     * Input Parameters :   Statement stmt, 
							int dbType, 
							int userId, 
							int assocType, 
							int objectId, 
							int objectTypeId, 
							int parentObjectId, 
							String rightStr, 
							String filterStr, 
							char objOper
     * Output Parameters:   int
     * Return Value     :   
     * Description      :   
     * *************************************************************
     */	
	
	public static int associateObjectsWithUser(Statement stmt, int dbType, int userId, int assocType, int objectId, int objectTypeId, int parentObjectId, String rightStr,String filterStr, char objOper,String engine) throws SQLException, Exception {
		ResultSet rs = null;
		int res = 0;
		try{
			
			StringBuffer qBuffer1 = new StringBuffer(100);
			StringBuffer qBuffer = new StringBuffer(100);
			StringBuffer qBuffer2 = new StringBuffer(100);
			/*Bug 37636 fixed*/
			switch(objOper){
				case 'I':{
					rs = stmt.executeQuery("select 1 from WFProfileObjTypeTable where Userid = "+userId+" and AssociationType = 0 and ObjectTypeId = "+objectTypeId+"");
					if(!rs.next())
						qBuffer1.append("Insert into WFProfileObjTypeTable (Userid, AssociationType, ObjectTypeId, RightString, Filter) values ("+userId+", "+assocType+", "+objectTypeId+", " + WFSUtil.TO_STRING(rightStr, true, dbType) + ", "+WFSUtil.TO_STRING(filterStr, true, dbType)+")");
                    if(rs != null){
                        rs.close();
                        rs = null;
                    }   
                    /*If AuthorizationFlag is Y then in case of addqueue Queueid will be 0 which is already in table there needs to restrict from insertion*/
                    //Bug 38207, Registered process rights are not returned
                    if(objectId == 0){
                        rs = stmt.executeQuery("select 1 from WFUserObjAssocTable where Userid = "+userId+" and AssociationType = 0 and ObjectTypeId = "+objectTypeId+" and objectId = 0");
                        if(!rs.next())
                            qBuffer.append("Insert into WFUserObjAssocTable (ObjectId, ObjectTypeId, ProfileId,  UserId, AssociationType, AssignedTillDateTime, AssociationFlag, RightString, Filter) values ("+objectId+", "+objectTypeId+", 0, " + userId + ", " + assocType + ", null, null, " + WFSUtil.TO_STRING(rightStr, true, dbType) + ", "+WFSUtil.TO_STRING(filterStr, true, dbType) + " )");
                    }else{
                    	
                    	 rs = stmt.executeQuery("select 1 from WFUserObjAssocTable where Userid = "+userId+" and AssociationType = "+assocType+" and ObjectTypeId = "+objectTypeId+" and objectId = "+objectId);
                    	 if(!rs.next()){
                    		 qBuffer.append("Insert into WFUserObjAssocTable (ObjectId, ObjectTypeId, ProfileId,  UserId, AssociationType, AssignedTillDateTime, AssociationFlag, RightString, Filter) values ("+objectId+", "+objectTypeId+", 0, " + userId + ", " + assocType + ", null, null, " + WFSUtil.TO_STRING(rightStr, true, dbType) + ", "+WFSUtil.TO_STRING(filterStr, true, dbType) + " )");
                    	 }
                    }   
					break;
				}
				case 'D':{
					qBuffer.append("Delete WFUserObjAssocTable where UserId = "+userId+" and AssociationType = " +  assocType + " and ObjectId = "+objectId+" and ObjectTypeId = "+objectTypeId+"");
					break;
				}
				case 'U':{
					qBuffer.append("update WFProfileObjTypeTable set RightString = "+(rightStr.equals("") ? " NULL" : WFSUtil.TO_STRING(rightStr, true, dbType))+", Filter = "+(filterStr.equals("") ? " NULL" : WFSUtil.TO_STRING(filterStr, true, dbType))+" where UserId = "+userId+" and AssociationType = " + assocType + " and ObjectTypeId = "+objectTypeId+"");
					qBuffer2.append("update WFUserObjAssocTable set RightString = "+(rightStr.equals("") ? " NULL" : WFSUtil.TO_STRING(rightStr, true, dbType))+", Filter = "+(filterStr.equals("") ? " NULL" : WFSUtil.TO_STRING(filterStr, true, dbType))+" where UserId = "+userId+" and AssociationType = " + assocType + " and ObjectTypeId = "+objectTypeId+" and ObjectId = "+objectId+"");
					break;
				}
			}
			WFSUtil.printOut(engine,"Query created::"+qBuffer.toString());
            /*Bug 36519 fixed*/
            //in case of association of queues created after swimlane checkout if queueid is 0 it was throwing error
			if(qBuffer != null && !qBuffer.toString().trim().equals(""))
                res = stmt.executeUpdate(qBuffer.toString());
			if(qBuffer1 != null && !qBuffer1.toString().trim().equals("")){
				WFSUtil.printOut(engine,"Query created::"+qBuffer1.toString());
				res = stmt.executeUpdate(qBuffer1.toString());
			}	
			if(qBuffer2 != null && !qBuffer2.toString().trim().equals("")){
				WFSUtil.printOut(engine,"Query created::"+qBuffer2.toString());
				res = stmt.executeUpdate(qBuffer2.toString());
			}	
		}finally{
			if(rs != null){
				rs.close();
				rs = null;
			}
		}	
		return res;
		
	}
	
	public static void getSwimLaneList(Connection con, int dbType, int userID, int procDefId)throws SQLException, Exception{
		ArrayList<Integer> arrList = new ArrayList<Integer>();
		Statement stmt = con.createStatement();
		ResultSet rs = null;
		int swimlaneId = 0;
		try{
		String st = "select SwimlaneId from WFSwimLaneTable where ProcessDefId=" + procDefId + " and SWIMLANEID > 0 ";
		rs = stmt.executeQuery(WFSUtil.TO_SANITIZE_STRING(st,true));
		while(rs.next())
			arrList.add(rs.getInt(1));
		
		
		String[] objectTypeStr = getIdForName(con, dbType, WFSConstant.CONST_OBJTYPE_SWIMLANE, "O");	
		int objTypeId = Integer.parseInt(objectTypeStr[1]);
		
		st = "delete from WFObjectProfileAssocTable where objectTypeId = "+objTypeId+" and ParentObjectId = "+procDefId+"";
		stmt.execute(WFSUtil.TO_SANITIZE_STRING(st,true));
		
		for(int j = 0; j < arrList.size(); j++)	{
			swimlaneId = arrList.get(j);
			associateObjectsWithUser(stmt, dbType, userID, 0, swimlaneId, objTypeId, procDefId, WFSConstant.CONST_DEFAULT_RIGHTSTR, null, 'I',"");
		}
		} finally {
			try{
				if(rs != null){
					rs.close();
					rs = null;
				}}catch(Exception e){
					 WFSUtil.printErr("","", e);
				}
			try{
			if(stmt != null){
				stmt.close();
				stmt = null;
			}}catch(Exception e){
				 WFSUtil.printErr("","", e);
			}
			
				
		}	
	}
	
    
	/**
     * *************************************************************
     * Function Name    :   createChildWorkitem
     * Programmer' Name :   Saurabh Kamal
     * Date Written     :   03/09/2010
     * Input Parameters :   con			-> SQL Connection,
        dbType					-> Database Type,
        processInstanceId                       -> To identify the WI,
        workItemId                              -> To identify the WI,
        processDefId                            -> Process Def. Id
        activityId                              -> Activity Id
        userIndex                               -> User Index
        strActivityName                         -> Activity Name
        parentWIPropBuffer                      -> Parent WI query buffer.
     * Description      :   createChildWorkitem method overloaded
     * *************************************************************
     */
	 
	 public static int createChildWorkitem(Connection con, String engineName, String processInstanceId, 
                int parentWIId, String strActivityName, int iProcessDefId, int dbType,
                String parentWIPropBuffer) throws SQLException, Exception {
					return createChildWorkitem(con, engineName, processInstanceId, 
                parentWIId, strActivityName, iProcessDefId, dbType,
                parentWIPropBuffer, null, null);
				}
         
     public static int createChildWorkitem(Connection con, String engineName, String processInstanceId, 
                int parentWIId, String strActivityName, int iProcessDefId, int dbType,
                String parentWIPropBuffer, String attributeXml, WFParticipant participant, int procVarId) throws SQLException, Exception {
     
        return createChildWorkitem(con, engineName, processInstanceId, parentWIId, strActivityName, iProcessDefId, dbType,
                parentWIPropBuffer, attributeXml, participant, procVarId, false, 0);
     }
         /**
     * *************************************************************
     * Function Name    :   createChildWorkitem
     * Programmer' Name :   Shweta Singhal
     * Date Written     :   22/05/2013
     * Input Parameters :   Connection con, String engineName, String processInstanceId, 
                int parentWIId, String strActivityName, int iProcessDefId, int dbType,
                String parentWIPropBuffer, String attributeXml, WFParticipant participant, int procVarId
     * Description      :   createChildWorkitem method overloaded for process variant support
     * *************************************************************
     */
	 public static int createChildWorkitem(Connection con, String engineName, String processInstanceId, 
                int parentWIId, String strActivityName, int iProcessDefId, int dbType,
                String parentWIPropBuffer, String attributeXml, WFParticipant participant, int procVarId, boolean debug, int sessionId) throws SQLException, Exception {
            int nWrkItemId = 0;
            int qId = 0;
            int iActivityId = 0;
            ResultSet rs = null;
			XMLGenerator gen = new XMLGenerator();
            Statement stmt = con.createStatement();
            PreparedStatement pstmt = null;
			boolean internalServiceFlag = false;
            StringBuffer insertDataBuffer = new StringBuffer();
            int userId = participant.getid();
            String userName = participant.getname();
            String prevActName = null;
            ArrayList parameters = new ArrayList();
            long startTime = 0l;
            long endTime = 0l;
            //OF Optimization
            String queryStr = null;
            queryStr = "Select "
                  + " VAR_INT1, VAR_INT2, VAR_INT3, VAR_INT4, VAR_INT5, VAR_INT6, VAR_INT7,"
+ "VAR_INT8,VAR_FLOAT1, VAR_FLOAT2, VAR_DATE1, VAR_DATE2, VAR_DATE3, VAR_DATE4,VAR_DATE5, VAR_DATE6, VAR_LONG1, VAR_LONG2, VAR_LONG3, VAR_LONG4,VAR_LONG5, VAR_LONG6, VAR_STR1, VAR_STR2, VAR_STR3, VAR_STR4, "
+ "VAR_STR5, VAR_STR6, VAR_STR7, VAR_STR8,VAR_STR9, VAR_STR10, VAR_STR11, VAR_STR12, VAR_STR13, VAR_STR14, VAR_STR15, VAR_STR16, VAR_STR17, VAR_STR18, VAR_STR19, VAR_STR20, VAR_REC_1, VAR_REC_2,VAR_REC_3, VAR_REC_4, VAR_REC_5,"
                    + " INSTRUMENTSTATUS, CHECKLISTCOMPLETEFLAG, SAVESTAGE, "
                    +"HOLDSTATUS, STATUS, REFERREDTO, REFERREDTONAME, REFERREDBY, REFERREDBYNAME, "
                    +"CHILDPROCESSINSTANCEID, CHILDWORKITEMID, locale, " + parentWIId
                    +" from WFInstrumentTable where ProcessInstanceID = " + WFSUtil.TO_STRING(processInstanceId, true, dbType)
                    + " and WorkItemID="+ parentWIId;
            rs = jdbcExecuteQuery(processInstanceId, sessionId, userId, queryStr, stmt, null, debug, engineName);
//            rs = stmt.executeQuery("Select VAR_INT1, VAR_INT2, VAR_INT3, "
//                    +"VAR_INT4, VAR_INT5, VAR_INT6, VAR_INT7, VAR_INT8, VAR_FLOAT1, VAR_FLOAT2, VAR_DATE1, "
//                    +"VAR_DATE2, VAR_DATE3, VAR_DATE4, VAR_LONG1, VAR_LONG2, VAR_LONG3, VAR_LONG4, VAR_STR1, "
//                    +"VAR_STR2, VAR_STR3, VAR_STR4, VAR_STR5, VAR_STR6, VAR_STR7, VAR_STR8, VAR_REC_1, VAR_REC_2,"
//                    +"VAR_REC_3, VAR_REC_4, VAR_REC_5, INSTRUMENTSTATUS, CHECKLISTCOMPLETEFLAG, SAVESTAGE, "
//                    +"HOLDSTATUS, STATUS, REFERREDTO, REFERREDTONAME, REFERREDBY, REFERREDBYNAME, "
//                    +"CHILDPROCESSINSTANCEID, CHILDWORKITEMID, " + parentWIId
//                    +" from WFInstrumentTable where ProcessInstanceID = " + WFSUtil.TO_STRING(processInstanceId, true, dbType)
//                    + " and WorkItemID="+ parentWIId);

                    if(rs != null && rs.next()) {
                            for(int i = 1; i <= 60; i++) {
                                    String strValue = rs.getString(i);
                                    if(rs.wasNull()) {
                                            insertDataBuffer.append(", null ");
                                    }
                                    else {
                                            if(i >= 11 && i <= 16)
                                                    insertDataBuffer.append(", " + WFSUtil.TO_DATE(strValue, true, dbType));
                                            else
                                                insertDataBuffer.append(", " + TO_STRING(strValue.trim(), true, dbType));    
                                                //insertDataBuffer.append(", '" + strValue.trim() + "'");
                                    }
                            }
                    }

                    rs = stmt.executeQuery("Select ActivityId from ActivityTable " +
                            "where ProcessDefId = " + iProcessDefId + " and " +
                            "ActivityName = N'" + strActivityName + "'");
                    if(rs != null && rs.next()) {
                        iActivityId = rs.getInt("ActivityId");
                    }
                    queryStr = "SELECT MAX(WorkItemID)+1 FROM WFInstrumentTable "+getLockPrefixStr(dbType)+" WHERE ProcessInstanceid = " + WFSUtil.TO_STRING(processInstanceId, true, dbType); //changes for Bug 59184 , For update can't be used along with max .
                    rs = WFSUtil.jdbcExecuteQuery(processInstanceId, sessionId, userId, queryStr, stmt, null, debug, engineName);
                    //rs = stmt.executeQuery(queryStr); //bug 3912
                    if (rs.next()) {
                            nWrkItemId = rs.getInt(1);
                    }
                    if (rs != null){
                        rs.close();
                        rs = null;
                    }
                    queryStr = "select activityid from WFInstrumentTable where processinstanceid =? and workitemid =?";
                    pstmt = con.prepareStatement(queryStr);
                    WFSUtil.DB_SetString(1, processInstanceId, pstmt, dbType);
                    pstmt.setInt(2, parentWIId);
                    parameters.add(processInstanceId);
                    parameters.add(parentWIId);
                    rs = WFSUtil.jdbcExecuteQuery(processInstanceId, sessionId, userId, queryStr, pstmt, parameters, debug, engineName);
                    parameters.clear();
                    if(rs.next())
                        prevActName = rs.getString(1);
                    if (rs != null){
                        rs.close();
                        rs = null;
                    }
                    queryStr = "Insert into WFInstrumentTable(ProcessInstanceId,WorkItemId,AssignmentType,ActivityName,ActivityId,ProcessName,ProcessVersion,ProcessDefID,LastProcessedBy,ProcessedBy,EntryDateTime,CollectFlag,PriorityLevel,ValidTill,Q_StreamId,Q_QueueId,Q_UserId,AssignedUser,FilterValue,CreatedDateTime,WorkItemState,StateName,ExpectedWorkitemDelay,PreviousStage,LockedByName,LockStatus,LockedTime, ProcessVariantId,RoutingStatus, "
                           + " VAR_INT1, VAR_INT2, VAR_INT3, VAR_INT4, VAR_INT5, VAR_INT6, VAR_INT7,"
                            + "VAR_INT8,VAR_FLOAT1, VAR_FLOAT2, VAR_DATE1, VAR_DATE2, VAR_DATE3, VAR_DATE4,VAR_DATE5, VAR_DATE6, VAR_LONG1, VAR_LONG2, VAR_LONG3, VAR_LONG4,VAR_LONG5, VAR_LONG6, VAR_STR1, VAR_STR2, VAR_STR3, VAR_STR4, "
                            + "VAR_STR5, VAR_STR6, VAR_STR7, VAR_STR8,VAR_STR9, VAR_STR10, VAR_STR11, VAR_STR12, VAR_STR13, VAR_STR14, VAR_STR15, VAR_STR16, VAR_STR17, VAR_STR18, VAR_STR19, VAR_STR20, VAR_REC_1, VAR_REC_2,VAR_REC_3, VAR_REC_4, VAR_REC_5,"
                            + " INSTRUMENTSTATUS, CHECKLISTCOMPLETEFLAG, SAVESTAGE, HOLDSTATUS, STATUS, REFERREDTO, REFERREDTONAME, REFERREDBY, REFERREDBYNAME, CHILDPROCESSINSTANCEID, CHILDWORKITEMID, locale, PARENTWORKITEMID, CREATEDBY, INTRODUCEDAT, ProcessInstanceState) values (" + WFSUtil.TO_STRING(processInstanceId, true, dbType) + ", " + nWrkItemId+ "," + WFSUtil.TO_STRING("D", true, dbType) + ","+ WFSUtil.TO_STRING(strActivityName, true, dbType) + "," + iActivityId+ parentWIPropBuffer.toString() +","+ procVarId +", " + WFSUtil.TO_STRING("Y", true, dbType) + insertDataBuffer.toString() + ", " + userId + ", " + WFSUtil.TO_STRING(prevActName, true, dbType) + ", 2)";;
                    int res1 = jdbcExecuteUpdate(processInstanceId, sessionId, userId, queryStr, stmt, null, debug, engineName);
//                    int res1 = stmt.executeUpdate("Insert into WorkDonetable(ProcessInstanceId,"
//                    + "WorkItemId,ParentWorkItemId,AssignmentType,ActivityName,ActivityId,ProcessName,"
//                    + "ProcessVersion,ProcessDefID,LastProcessedBy,ProcessedBy,EntryDateTime,"
//                    + "CollectFlag,PriorityLevel,ValidTill,Q_StreamId,Q_QueueId,Q_UserId,"
//                    + "AssignedUser,FilterValue,CreatedDateTime,WorkItemState,StateName,"
//                    + "ExpectedWorkitemDelay,PreviousStage,LockedByName,LockStatus,LockedTime, ProcessVariantId) "
//                    + "Values ( " + WFSUtil.TO_STRING(processInstanceId, true, dbType) + ", " + nWrkItemId
//                    + "," + parentWIId + "," + WFSUtil.TO_STRING("D", true, dbType) + ","
//                    + WFSUtil.TO_STRING(strActivityName, true, dbType) + "," + iActivityId
//                    + parentWIPropBuffer.toString() +","+ procVarId +" )");
//
//                    int res2 = stmt.executeUpdate(
//                    "Insert into QueueDataTable ( PROCESSINSTANCEID, WORKITEMID, VAR_INT1, VAR_INT2, VAR_INT3, "
//                    +"VAR_INT4, VAR_INT5, VAR_INT6, VAR_INT7, VAR_INT8, VAR_FLOAT1, VAR_FLOAT2, VAR_DATE1, "
//                    +"VAR_DATE2, VAR_DATE3, VAR_DATE4, VAR_LONG1, VAR_LONG2, VAR_LONG3, VAR_LONG4, VAR_STR1, "
//                    +"VAR_STR2, VAR_STR3, VAR_STR4, VAR_STR5, VAR_STR6, VAR_STR7, VAR_STR8, VAR_REC_1, VAR_REC_2,"
//                    +"VAR_REC_3, VAR_REC_4, VAR_REC_5, INSTRUMENTSTATUS, CHECKLISTCOMPLETEFLAG, SAVESTAGE, "
//                    +"HOLDSTATUS, STATUS, REFERREDTO, REFERREDTONAME, REFERREDBY, REFERREDBYNAME, "
//                    +"CHILDPROCESSINSTANCEID, CHILDWORKITEMID, PARENTWORKITEMID) Values ( "
//                    + WFSUtil.TO_STRING(processInstanceId, true, dbType) + ", " + nWrkItemId
//                    + insertDataBuffer.toString() + ")");
					
					if(attributeXml != null && !attributeXml.equals("")){
						if(participant.gettype() == 'P'){
							internalServiceFlag = true;							
						}
						attributeXml = "<Attributes>" + attributeXml + "</Attributes>";
						ArrayList attribList = WFXMLUtil.convertXMLToObject(attributeXml, engineName);
                        if(debug){
                            startTime = System.currentTimeMillis();
                        }
						WFSUtil.setAttributesExt(con, participant, attribList, engineName, processInstanceId, nWrkItemId, gen, null, internalServiceFlag, debug, false, sessionId,null,false);
                        if(debug){
                            endTime = System.currentTimeMillis();
                            WFSUtil.writeLog("CreateWIInternal", "[CreateWIInternal]_createChildWI_setAttributeExt", startTime, endTime, 0, "", "", engineName,(endTime-startTime),0, 0);  
                        }
						//WFSUtil.setAttributesExt(con, participant, attributeXml, engineName, processInstanceId, nWrkItemId, gen, null, internalServiceFlag, false, false);
					}					

                    if (res1 > 0 ) {
                    //if ((res1 > 0 && res1 == res2)) {
                        WFSUtil.generateLog(engineName, con,
                            WFSConstant.WFL_ChildProcessInstanceCreated, processInstanceId, nWrkItemId,
                            iProcessDefId, iActivityId, strActivityName, qId, 
                            0, "", iActivityId, strActivityName, null, null, null, null);
                    }
                    
                    if (stmt != null) {
                        stmt.close();
                        stmt = null;
                    }                    
                    return nWrkItemId;
        }
     
     public static int createChildWorkitem(Connection con, String engineName, String processInstanceId, 
                int parentWIId, String strActivityName, int iProcessDefId, int dbType,
                String parentWIPropBuffer, String attributeXml, WFParticipant participant) throws SQLException, Exception {
     
     return createChildWorkitem(con, engineName, processInstanceId, parentWIId, strActivityName, iProcessDefId, dbType,
                parentWIPropBuffer, attributeXml, participant, false,0);
     }
    /**
     * *************************************************************
     * Function Name    :   createChildWorkitem
     * Programmer' Name :   Abhishek Gupta
     * Date Written     :   20/08/2010
     * Input Parameters :   con			-> SQL Connection,
        dbType					-> Database Type,
        processInstanceId                       -> To identify the WI,
        workItemId                              -> To identify the WI,
        processDefId                            -> Process Def. Id
        activityId                              -> Activity Id
        userIndex                               -> User Index
        strActivityName                         -> Activity Name
        parentWIPropBuffer                      -> Parent WI query buffer.
     * Description      :   Creates exntries for newly created Child workitem
                              in QueueDataTable and WorkDoneTable.
     * *************************************************************
     */

     public static int createChildWorkitem(Connection con, String engineName, String processInstanceId, 
             int parentWIId, String strActivityName, int iProcessDefId, int dbType,
             String parentWIPropBuffer, String attributeXml, WFParticipant participant, boolean debug, int sessionId) throws SQLException, Exception {
    	 return createChildWorkitem(con, engineName, processInstanceId, 
                 parentWIId, strActivityName, null,iProcessDefId, dbType,
                 parentWIPropBuffer, attributeXml, participant, debug, sessionId);
     }
     ////MOHNISH.......NEED TO CHANGE METHOD SIGNATURE
        public static int createChildWorkitem(Connection con, String engineName, String processInstanceId, 
                int parentWIId, String strActivityName,String strActivityId, int iProcessDefId, int dbType,
                String parentWIPropBuffer, String attributeXml, WFParticipant participant, boolean debug, int sessionId) throws SQLException, Exception {
            int nWrkItemId = 0;
            int qId = 0;
            int iActivityId = 0;
            int introducedById = 0;
            String introducedBy = null;
            ResultSet rs = null;
			XMLGenerator gen = new XMLGenerator();
            Statement stmt = con.createStatement();
            PreparedStatement pstmt = null;
			boolean internalServiceFlag = true;
            StringBuffer insertDataBuffer = new StringBuffer();
            String query = null;
            ArrayList parameters = new ArrayList();
            int userId = participant.getid();
            String userName = participant.getname();
            String prevActName = null;
            long startTime =0l;
            long endTime =0l;
            try{//Bug 40704
                //OF Optimization
                query = "Select ProcessVariantId, "
                       + " VAR_INT1, VAR_INT2, VAR_INT3, VAR_INT4, VAR_INT5, VAR_INT6, VAR_INT7,"
+ "VAR_INT8,VAR_FLOAT1, VAR_FLOAT2, VAR_DATE1, VAR_DATE2, VAR_DATE3, VAR_DATE4,VAR_DATE5, VAR_DATE6, VAR_LONG1, VAR_LONG2, VAR_LONG3, VAR_LONG4,VAR_LONG5, VAR_LONG6, VAR_STR1, VAR_STR2, VAR_STR3, VAR_STR4, "
+ "VAR_STR5, VAR_STR6, VAR_STR7, VAR_STR8,VAR_STR9, VAR_STR10, VAR_STR11, VAR_STR12, VAR_STR13, VAR_STR14, VAR_STR15, VAR_STR16, VAR_STR17, VAR_STR18, VAR_STR19, VAR_STR20, VAR_REC_1, VAR_REC_2,VAR_REC_3, VAR_REC_4, VAR_REC_5,"
                        + " INSTRUMENTSTATUS, CHECKLISTCOMPLETEFLAG, SAVESTAGE, "
                    +"HOLDSTATUS, STATUS, REFERREDTO, REFERREDTONAME, REFERREDBY, REFERREDBYNAME, "
                    +"CHILDPROCESSINSTANCEID, CHILDWORKITEMID " + ",IntroducedAt,IntroductionDateTime,NotifyStatus,Q_DivertedByUserId,URN,SecondaryDBFlag, locale, INTRODUCEDBY, INTRODUCEDBYID  "
                    + " from WFInstrumentTable where ProcessInstanceID = ? and WorkItemID = ?";
                 pstmt = con.prepareStatement(query);
                 
                 // Commented by SHWETA for NEWTABLE
//                pstmt = con.prepareStatement("Select VAR_INT1, VAR_INT2, VAR_INT3, "
//                    +"VAR_INT4, VAR_INT5, VAR_INT6, VAR_INT7, VAR_INT8, VAR_FLOAT1, VAR_FLOAT2, VAR_DATE1, "
//                    +"VAR_DATE2, VAR_DATE3, VAR_DATE4, VAR_LONG1, VAR_LONG2, VAR_LONG3, VAR_LONG4, VAR_STR1, "
//                    +"VAR_STR2, VAR_STR3, VAR_STR4, VAR_STR5, VAR_STR6, VAR_STR7, VAR_STR8, VAR_REC_1, VAR_REC_2,"
//                    +"VAR_REC_3, VAR_REC_4, VAR_REC_5, INSTRUMENTSTATUS, CHECKLISTCOMPLETEFLAG, SAVESTAGE, "
//                    +"HOLDSTATUS, STATUS, REFERREDTO, REFERREDTONAME, REFERREDBY, REFERREDBYNAME, "
//                    +"CHILDPROCESSINSTANCEID, CHILDWORKITEMID, ?"
//                    + " from QueueDataTable where ProcessInstanceID = ? and WorkItemID = ?");
                DB_SetString(1, processInstanceId, pstmt, dbType);
                pstmt.setInt(2, parentWIId);
                parameters.add(processInstanceId);
                parameters.add(parentWIId);
                rs = jdbcExecuteQuery(processInstanceId, sessionId, userId, query, pstmt, parameters, debug, engineName);
                parameters.clear();
                //rs = pstmt.executeQuery();
//                rs = stmt.executeQuery("Select VAR_INT1, VAR_INT2, VAR_INT3, "
//                    +"VAR_INT4, VAR_INT5, VAR_INT6, VAR_INT7, VAR_INT8, VAR_FLOAT1, VAR_FLOAT2, VAR_DATE1, "
//                    +"VAR_DATE2, VAR_DATE3, VAR_DATE4, VAR_LONG1, VAR_LONG2, VAR_LONG3, VAR_LONG4, VAR_STR1, "
//                    +"VAR_STR2, VAR_STR3, VAR_STR4, VAR_STR5, VAR_STR6, VAR_STR7, VAR_STR8, VAR_REC_1, VAR_REC_2,"
//                    +"VAR_REC_3, VAR_REC_4, VAR_REC_5, INSTRUMENTSTATUS, CHECKLISTCOMPLETEFLAG, SAVESTAGE, "
//                    +"HOLDSTATUS, STATUS, REFERREDTO, REFERREDTONAME, REFERREDBY, REFERREDBYNAME, "
//                    +"CHILDPROCESSINSTANCEID, CHILDWORKITEMID, " + parentWIId
//                    +" from QueueDataTable where ProcessInstanceID = " + WFSUtil.TO_STRING(processInstanceId, true, dbType)
//                    + " and WorkItemID="+ parentWIId);

                    if(rs != null && rs.next()) {
                    	introducedBy = rs.getString("INTRODUCEDBY");
                    	introducedById = rs.getInt("INTRODUCEDBYID");
                            for(int i = 1; i <= 68; i++) {
                                    String strValue = rs.getString(i);
                                    if(rs.wasNull()) {
                                            insertDataBuffer.append(", null ");
                                    }
                                    else {
                                            if(i >= 12 && i <= 17|| (i == 61))  //i = 61 for IntroductionDateTime in the above select query
                                                    insertDataBuffer.append(", " + WFSUtil.TO_DATE(strValue, true, dbType));
                                            else
                                                    insertDataBuffer.append(", " + TO_STRING(strValue.trim(), true, dbType));
                                    }
                            }
                    }
                    if (strActivityId == null || strActivityId.equals("")  || Integer.parseInt(strActivityId) == 0) {
                    	rs = stmt.executeQuery("Select ActivityId from ActivityTable " +
                            "where ProcessDefId = " + iProcessDefId + " and " +
                            "ActivityName = N'" + strActivityName + "'");
                    if(rs != null && rs.next()) {
                        iActivityId = rs.getInt("ActivityId");
                    }
                    } else {
                        iActivityId = Integer.parseInt(strActivityId);
                    }
                    
                    pstmt = con.prepareStatement("SELECT MAX(WorkItemID)+1 FROM WFInstrumentTable WHERE ProcessInstanceid = ?");
                    DB_SetString(1, processInstanceId, pstmt, dbType);
                    rs = pstmt.executeQuery();
                    //rs = stmt.executeQuery("SELECT MAX(WorkItemID)+1 FROM queuedatatable WHERE ProcessInstanceid = " + WFSUtil.TO_STRING(processInstanceId, true, dbType) ); //bug 3912
                    if (rs.next()) {
                            nWrkItemId = rs.getInt(1);
                    }
                    if (rs != null){
                        rs.close();
                        rs = null;
                    }
                    //insert into NEWTABLE with assignmenttype as D, new workitemid and remaining will be the same as parent 
                   /* query = "select activityid from WFInstrumentTable where processinstanceid =? and workitemid =?";
                    pstmt = con.prepareStatement(query);
                    WFSUtil.DB_SetString(1, processInstanceId, pstmt, dbType);
                    pstmt.setInt(2, parentWIId);
                    parameters.add(processInstanceId);
                    parameters.add(parentWIId);
                    rs = WFSUtil.jdbcExecuteQuery(processInstanceId, sessionId, userId, query, pstmt, parameters, debug, engineName);
                    parameters.clear();
                    if(rs.next())
                        prevActName = rs.getString(1);
                    if (rs != null){
                        rs.close();
                        rs = null;
                    }*/
                    query = "Insert into WFInstrumentTable(ProcessInstanceId,"
                    + "WorkItemId,ParentWorkItemId,AssignmentType,ActivityName,ActivityId,ProcessName,"
                    + "ProcessVersion,ProcessDefID,LastProcessedBy,ProcessedBy,EntryDateTime,"
                    + "CollectFlag,PriorityLevel,ValidTill,Q_StreamId,Q_QueueId,Q_UserId,"
                    + "AssignedUser,FilterValue,CreatedDateTime,WorkItemState,StateName,"
                    + "ExpectedWorkitemDelay,PreviousStage,LockedByName,LockStatus,LockedTime, ProcessVariantId, "
                       + " VAR_INT1, VAR_INT2, VAR_INT3, VAR_INT4, VAR_INT5, VAR_INT6, VAR_INT7,"
+ "VAR_INT8,VAR_FLOAT1, VAR_FLOAT2, VAR_DATE1, VAR_DATE2, VAR_DATE3, VAR_DATE4,VAR_DATE5, VAR_DATE6, VAR_LONG1, VAR_LONG2, VAR_LONG3, VAR_LONG4,VAR_LONG5, VAR_LONG6, VAR_STR1, VAR_STR2, VAR_STR3, VAR_STR4, "
+ "VAR_STR5, VAR_STR6, VAR_STR7, VAR_STR8,VAR_STR9, VAR_STR10, VAR_STR11, VAR_STR12, VAR_STR13, VAR_STR14, VAR_STR15, VAR_STR16, VAR_STR17, VAR_STR18, VAR_STR19, VAR_STR20, VAR_REC_1, VAR_REC_2,VAR_REC_3, VAR_REC_4, VAR_REC_5,"
                            + " INSTRUMENTSTATUS, CHECKLISTCOMPLETEFLAG, SAVESTAGE, "
                    +"HOLDSTATUS, STATUS, REFERREDTO, REFERREDTONAME, REFERREDBY, REFERREDBYNAME, "
                    +"CHILDPROCESSINSTANCEID, CHILDWORKITEMID,IntroducedAt,IntroductionDateTime,NotifyStatus,Q_DivertedByUserId,URN,SecondaryDBFlag,locale,IntroducedBy,IntroducedById,Createdby, RoutingStatus,ProcessInstanceState,CreatedByName) "
                    + "Values ( " + WFSUtil.TO_STRING(processInstanceId, true, dbType) + ", " + nWrkItemId
                    + "," + parentWIId + "," + WFSUtil.TO_STRING("D", true, dbType) + ","
                    + WFSUtil.TO_STRING(strActivityName, true, dbType) + "," + iActivityId
                    + parentWIPropBuffer.toString() + insertDataBuffer.toString() + ","+(participant.gettype()=='P' ? 0 : userId )+",'Y', 2,"+( participant.gettype()=='P' ? WFSUtil.TO_STRING("SYSTEM", true, dbType) : WFSUtil.TO_STRING(userName, true, dbType) )+")";
                    int res1 = jdbcExecuteUpdate(processInstanceId, sessionId, userId, query, stmt, null, debug, engineName);
                    // Commented by SHWETA for NEWTABLE
//                    int res1 = stmt.executeUpdate("Insert into WorkDonetable(ProcessInstanceId,"
//                    + "WorkItemId,ParentWorkItemId,AssignmentType,ActivityName,ActivityId,ProcessName,"
//                    + "ProcessVersion,ProcessDefID,LastProcessedBy,ProcessedBy,EntryDateTime,"
//                    + "CollectFlag,PriorityLevel,ValidTill,Q_StreamId,Q_QueueId,Q_UserId,"
//                    + "AssignedUser,FilterValue,CreatedDateTime,WorkItemState,StateName,"
//                    + "ExpectedWorkitemDelay,PreviousStage,LockedByName,LockStatus,LockedTime, ProcessVariantId) "
//                    + "Values ( " + WFSUtil.TO_STRING(processInstanceId, true, dbType) + ", " + nWrkItemId
//                    + "," + parentWIId + "," + WFSUtil.TO_STRING("D", true, dbType) + ","
//                    + WFSUtil.TO_STRING(strActivityName, true, dbType) + "," + iActivityId
//                    + parentWIPropBuffer.toString() + ")");

//                    int res2 = stmt.executeUpdate(
//                    "Insert into QueueDataTable ( PROCESSINSTANCEID, WORKITEMID, VAR_INT1, VAR_INT2, VAR_INT3, "
//                    +"VAR_INT4, VAR_INT5, VAR_INT6, VAR_INT7, VAR_INT8, VAR_FLOAT1, VAR_FLOAT2, VAR_DATE1, "
//                    +"VAR_DATE2, VAR_DATE3, VAR_DATE4, VAR_LONG1, VAR_LONG2, VAR_LONG3, VAR_LONG4, VAR_STR1, "
//                    +"VAR_STR2, VAR_STR3, VAR_STR4, VAR_STR5, VAR_STR6, VAR_STR7, VAR_STR8, VAR_REC_1, VAR_REC_2,"
//                    +"VAR_REC_3, VAR_REC_4, VAR_REC_5, INSTRUMENTSTATUS, CHECKLISTCOMPLETEFLAG, SAVESTAGE, "
//                    +"HOLDSTATUS, STATUS, REFERREDTO, REFERREDTONAME, REFERREDBY, REFERREDBYNAME, "
//                    +"CHILDPROCESSINSTANCEID, CHILDWORKITEMID, PARENTWORKITEMID) Values ( "
//                    + WFSUtil.TO_STRING(processInstanceId, true, dbType) + ", " + nWrkItemId
//                    + insertDataBuffer.toString() + ")");
					
					if(attributeXml != null && !attributeXml.equals("")){
						attributeXml = "<Attributes>" + attributeXml + "</Attributes>";
						ArrayList attribList = WFXMLUtil.convertXMLToObject(attributeXml, engineName);
						
                        if(debug){
                            startTime = System.currentTimeMillis();
                        }
						WFSUtil.setAttributesExt(con, participant, attribList, engineName, processInstanceId, nWrkItemId, gen, null, internalServiceFlag, debug, false, sessionId,null,false);
                        if(debug){
                            endTime = System.currentTimeMillis();
                            WFSUtil.writeLog("CreateWIInternal", "[CreateWIInternal]_createChildWI_setAttributeExt", startTime, endTime, 0, "", "", engineName,(endTime-startTime),0, 0);  
                        }
                        //WFSUtil.setAttributesExt(con, participant, attributeXml, engineName, processInstanceId, nWrkItemId, gen, null, internalServiceFlag, false, false);
					}					
                    if ((res1 > 0)) {
                     // Commented by SHWETA for NEWTABLE   
                    //if ((res1 > 0 && res1 == res2)) {
                        WFSUtil.generateLog(engineName, con,
                            WFSConstant.WFL_ChildProcessInstanceCreated, processInstanceId, nWrkItemId,
                            iProcessDefId, iActivityId, strActivityName, qId,
                            0, "", iActivityId, strActivityName, null, null, null, null);
                    }
			}catch(SQLException e){//Bug 40704
                throw new Exception(e);
            }finally{
            	try{
            		if (rs != null) {
                         rs.close();
                         rs = null;
                     }
            	}catch(Exception e){
            		 WFSUtil.printErr(engineName,"", e);
            	}
            	try{
            		if (stmt != null) {
                        stmt.close();
                        stmt = null;
                    }
            	}catch(Exception e){
            		 WFSUtil.printErr(engineName,"", e);
            	}
            	try{
            		if (pstmt != null) {
                        pstmt.close();
                        pstmt = null;
                    }
            	}catch(Exception e){
            		 WFSUtil.printErr(engineName,"", e);
            	}
            }
            
            return nWrkItemId;
        }

    /**
     * *************************************************************
     * Function Name    :   appendDBString
     * Programmer' Name :   Abhishek Gupta
     * Date Written     :   20/08/2010
     * Input Parameters :   inputString			-> String,
     * Description      :   Creates formatted String for database, if not null.
     * *************************************************************
     */
        public static String appendDBString(String inputString){
            if(inputString != null)
                return "N'" + inputString + "'";
            else return inputString;
        }
		
		public static String handleSpecialCharInXml(String strXml){
        String  excludeChars = CachedObjectCollection.getReference().getExcludeCatalog();
        //excludeChars="";
        if(excludeChars != null){
            for (int counter1 = 0; counter1 < excludeChars.length(); counter1++) {
                strXml = strXml.replace(excludeChars.charAt(counter1), ' ');
            }
        }
    	if(strXml != null){
	        strXml = strXml.replace("&", "&amp;");
	        strXml = strXml.replace( "<", "&lt;");
	        strXml = strXml.replace( ">", "&gt;");
	        strXml = strXml.replace( "\"", "&quot;");
	        strXml = strXml.replace("'", "&apos;");
    	}

        return strXml;
    }
		
		
		public static String handleSpecialCharInJson(String strXml){
			if(strXml != null){
				strXml = strXml.replace( "&quot;", "\\\"");
			}
			return strXml;
		}
		
	static String generateSQL(Node orgnode, int dbType) throws WFSException  {
		return generateSQL(orgnode, dbType, false);
	}
	static String generateSQL(Node orgnode, int dbType, boolean isCriteriaCase) throws WFSException  {
		return generateSQL(orgnode, dbType, isCriteriaCase,false);
	}
	static String generateSQL(Node orgnode, int dbType, boolean isCriteriaCase,boolean isDoubleQuotes) throws WFSException  {
		int noOffields = 0;
		Node node = null;
		String querystr = "";
		String strOperator = "";
		int dataType = 0;
		String strLength = "";
		String strJoinCondition = "";
		String nodeName = "";
		String childNodeName = "";
		String aliasName = "";
		StringBuffer queryadd = new StringBuffer(50);
		NodeList searchVariableList = WFXMLUtil.getChildListByName(orgnode, "Condition");
		Node childNode;
		noOffields = searchVariableList.getLength();
		for (int i = 0;i< noOffields;i++ ){
			node = (Node) searchVariableList.item(i);
			nodeName = node.getNodeName();
			if (node instanceof Element && node.hasAttributes()) {
				if (!nodeName.equalsIgnoreCase("Condition")) {
					querystr = querystr + nodeName + strOperator;
				}
				NamedNodeMap attrs = node.getAttributes();
				for (int j = 0; j < attrs.getLength(); j++) {
					Attr attribute = (Attr) attrs.item(j);
					String attributeName = attribute.getName();
					String attributeVal = attribute.getValue();
					if (attributeName.equalsIgnoreCase("Operator"))
						strOperator = getOperator(Integer.parseInt(attribute.getValue().trim())) + " ";
					else if (attributeName.equalsIgnoreCase("JoinCondition"))
						strJoinCondition =  attributeVal ;
				}
			}

			childNode = (Node) node.getFirstChild();
			childNodeName = childNode.getNodeName();
			//if( (WFXMLUtil.getValueOf(childNode) !=null && !WFXMLUtil.getValueOf(childNode).equals("")) || (isCriteriaCase) ){
				Boolean nullChildValue = false;
				if (childNode instanceof Element && childNode.hasAttributes()) {
					if(isCriteriaCase){
						NamedNodeMap attrs = childNode.getAttributes();
						String variableType="";
						for (int j = 0; j < attrs.getLength(); j++) {
							Attr attribute = (Attr) attrs.item(j);
							String attributeName = attribute.getName();
							String attributeVal = attribute.getValue();
							if (attributeName.equalsIgnoreCase("Type"))
								dataType = Integer.parseInt(attributeVal);
							else if (attributeName.equalsIgnoreCase("Length"))
								strLength = attributeVal;
							else if (attributeName.equalsIgnoreCase("SystemDefinedName"))
								aliasName = attributeVal;
							else if (attributeName.equalsIgnoreCase("VariableType"))
								variableType = attributeVal;
						}
						if(dbType==JTSConstant.JTS_ORACLE && aliasName!=null && "I".equalsIgnoreCase(variableType)){
							aliasName=aliasName.toUpperCase();
						}
					}else{
						NamedNodeMap attrs = childNode.getAttributes();
						for (int j = 0; j < attrs.getLength(); j++) {
							Attr attribute = (Attr) attrs.item(j);
							String attributeName = attribute.getName();
							String attributeVal = attribute.getValue();
							if (attributeName.equalsIgnoreCase("Type"))
								dataType = Integer.parseInt(attributeVal);
							else if (attributeName.equalsIgnoreCase("Length"))
								strLength = attributeVal;
							else if (attributeName.equalsIgnoreCase("Name"))
								aliasName = attributeVal;
						}
					}
				}
				if(WFXMLUtil.getValueOf(childNode) ==null)
					nullChildValue=true;
				
				if(dataType==WFSConstant.WF_DAT){
					String tempValue=WFXMLUtil.getValueOf(childNode).trim();
					Pattern WF_DATE_PATTERN = Pattern.compile("\\d{1,4}-\\d{1,2}-\\d{1,2}(\\s+(([0-9])&&([0-1][0-9])&&(2[0-3]))(:([0-9]&&([0-5][0-9]))(:([0-9]&&([0-5][0-9])))?)?)?");
					Matcher m = null;
					m = WF_DATE_PATTERN.matcher(tempValue);
					boolean testMatch = m.matches();
					if(testMatch || (isCriteriaCase && ( "CreatedDateTime".equalsIgnoreCase(aliasName) || "EntryDateTime".equalsIgnoreCase(aliasName) 
							|| "ValidTill".equalsIgnoreCase(aliasName) || "IntroductionDateTime".equalsIgnoreCase(aliasName) || "ExpectedWorkitemDelay".equalsIgnoreCase(aliasName) )) ){
						dataType = WFSConstant.WF_SHORT_DAT;
					}
				}
				
				boolean doubleQuotesNotApplicable=true;
				
				if((isDoubleQuotes && dbType==JTSConstant.JTS_ORACLE && aliasName.contains(" "))||dbType!=JTSConstant.JTS_ORACLE||!isDoubleQuotes){
					doubleQuotesNotApplicable=false;
				}
				if(nullChildValue)
				{
					querystr = querystr + "(";
				}
				//querystr = querystr + " " +strJoinCondition + " " + childNodeName + " " + strOperator;
				//querystr = querystr + "\""+aliasName +"\""+ " " + strOperator; /*38564 */
				if(!("ProcessDefID".equalsIgnoreCase(aliasName)||"ProcessName".equalsIgnoreCase(aliasName)||"ActivityId".equalsIgnoreCase(aliasName)||"ActivityName".equalsIgnoreCase(aliasName)||
						"ProcessInstanceID".equalsIgnoreCase(aliasName)||"PriorityLevel".equalsIgnoreCase(aliasName)||"InstrumentStatus".equalsIgnoreCase(aliasName)||"LockStatus".equalsIgnoreCase(aliasName)
						||"IntroducedByUser".equalsIgnoreCase(aliasName)||"LockedByName".equalsIgnoreCase(aliasName)||"AssignedUser".equalsIgnoreCase(aliasName)||
						"ReferredByName".equalsIgnoreCase(aliasName)||"Entrydatetime".equalsIgnoreCase(aliasName)||"CreatedDateTime".equalsIgnoreCase(aliasName)
							||"ProcessInstanceState".equalsIgnoreCase(aliasName)||"URN".equalsIgnoreCase(aliasName)||"CheckListCompleteFlag".equalsIgnoreCase(aliasName)
							||"ValidTill".equalsIgnoreCase(aliasName)||"IntroductionDateTime".equalsIgnoreCase(aliasName)||"IntroducedBy".equalsIgnoreCase(aliasName)
							||"Status".equalsIgnoreCase(aliasName) || "WorkItemState".equalsIgnoreCase(aliasName)||doubleQuotesNotApplicable)){
						if(dataType == WFSConstant.WF_SHORT_DAT){
							if(!isCriteriaCase){
							aliasName="\""+aliasName +"\"";
							}
							querystr=querystr+WFSUtil.TO_SHORT_DATE(aliasName, false, dbType)+strOperator;
						}
						else if(dbType==JTSConstant.JTS_ORACLE && dataType == WFSConstant.WF_STR){
							querystr = querystr + "upper(\""+aliasName +"\")"+ " " + strOperator; /*38564 */
						}else if(dbType==JTSConstant.JTS_POSTGRES && isCriteriaCase){
							if(dataType == WFSConstant.WF_BOOLEAN)
								querystr = querystr + "upper("+aliasName +")"+ strOperator;
							else
							querystr = querystr + aliasName + " " + strOperator;
						}else{
							querystr = querystr + "\""+aliasName +"\""+ " " + strOperator; 
						}
				}else{
					if(dataType == WFSConstant.WF_SHORT_DAT){
							querystr=querystr+WFSUtil.TO_SHORT_DATE(aliasName, false, dbType)+strOperator;
					}
					else if(dbType==JTSConstant.JTS_ORACLE && dataType == WFSConstant.WF_STR){
						querystr = querystr +"upper("+aliasName +")" +" " + strOperator; /*38564 */
					}else {
						querystr = querystr +aliasName + " " + strOperator; 
					}
				}
				if (dataType == WFSConstant.WF_DAT) {
					String tmpVarValue =TO_DATE(WFXMLUtil.getValueOf(childNode).trim(), true, dbType);
					querystr = querystr  + " " + tmpVarValue + " ";
				}
				else if (dataType == WFSConstant.WF_SHORT_DAT) {
					String tmpVarValue = WFSUtil.TO_SHORT_DATE(WFXMLUtil.getValueOf(childNode).trim(), true, dbType);
					querystr = querystr  + " " + tmpVarValue + " ";
				}
				else if (dataType == WFSConstant.WF_INT || dataType == WFSConstant.WF_LONG) {
					if(!nullChildValue)
					{
					querystr = querystr + WFXMLUtil.getValueOf(childNode) + " ";
					}
					else
					{
						strOperator = strOperator.trim();
						if( strOperator.equalsIgnoreCase("=") ){
							querystr = querystr+ "'' or ";
						}
						else
						{
							querystr = querystr+ "'' AND ";
						}
						if(dbType==JTSConstant.JTS_POSTGRES && isCriteriaCase){
							querystr = querystr + aliasName ;
						}
						else{
						querystr = querystr+ "\""+aliasName +"\"";
						}
						
						if( strOperator.equalsIgnoreCase("=") ){
							querystr = querystr+ " IS NULL ";
						}
						else
						{
							querystr = querystr+ " IS NOT NULL ";
						}
					}
				}
				else {
					if (strLength == null || strLength.equals("")) {
						String childNodeValue = WFXMLUtil.getValueOf(childNode);
						if ( (! "\n".equals(childNodeValue)) || (isCriteriaCase && childNodeValue == null) ){
							String tempStr=" ";
							if (childNodeValue != null) {
								tempStr=TO_STRING(WFXMLUtil.getValueOf(childNode),true, dbType); /* Bug38565 */
								if(dbType==JTSConstant.JTS_ORACLE && tempStr!=null){
									tempStr=tempStr.toUpperCase(); /*38564 */
								}
								if(dbType==JTSConstant.JTS_POSTGRES && tempStr!=null && dataType == WFSConstant.WF_BOOLEAN){
									tempStr=tempStr.toUpperCase(); /*38564 */
								}
								strOperator = strOperator.trim();
								if( strOperator.equalsIgnoreCase("LIKE") ){
										tempStr = WFSUtil.replace(tempStr, "*", "%");		/* Bug38564 */
								}
							}
							else
							{
								strOperator = strOperator.trim();
								if( strOperator.equalsIgnoreCase("=") ){
									tempStr = "'' or ";
								}
								else
								{
									tempStr = "'' AND ";
								}
									
								if(dbType==JTSConstant.JTS_ORACLE && dataType == WFSConstant.WF_STR){
									tempStr = tempStr + "upper(\""+aliasName +"\")"; /*38564 */
								}else if(dbType==JTSConstant.JTS_POSTGRES && isCriteriaCase){
									tempStr = tempStr + aliasName ;
								}else{
								tempStr = tempStr +"\""+aliasName +"\""; 
								}
								
								if( strOperator.equalsIgnoreCase("=") ){
									tempStr = tempStr+ " IS NULL ";
								}
								else
								{
									tempStr = tempStr+ " IS NOT NULL ";
								}
							}
							querystr = querystr + tempStr;
							
						}
					} 
					else if (WFXMLUtil.getValueOf(childNode) != null && !WFXMLUtil.getValueOf(childNode).equals("")) {
						querystr = querystr + TO_STRING(WFXMLUtil.getValueOf(childNode).substring(0, Integer.parseInt(strLength)),true, dbType);
					}
				}
				if(nullChildValue)
				{
					querystr = querystr + ")";
				}
				if((i+1)!=noOffields){
					querystr = querystr + " " +strJoinCondition + " "; /*38564 */
				}
			//}
		}
		return querystr;
	}
	
	/*Bug 34322 fixed*/
	public static String getReminderDetails(Connection con, String engineName, int userId) {
		Statement stmt = null;
		ResultSet rs = null;
		String reminderFlag = "N";
		try {
			stmt = con.createStatement();
			String str = "Select 1 from WFLASTREMINDERTABLE where UserId = "+userId+" and LASTREMINDERTIME < (select max(RemDateTime) from wfremindertable where ToIndex = "+userId+")";
			printOut(engineName,"d-"+str);
			rs = stmt.executeQuery(str);
			if(rs != null && rs.next()){
				reminderFlag = "Y";
				rs.close();
				rs = null;
			}
			stmt.close();
			stmt = null;
		}
		catch(Exception ex) {
			printErr(engineName,"", ex);
		}
		finally{
			try {  
				if(rs!=null){
					rs.close();
					rs = null;
				}
			}catch(Exception e){
				WFSUtil.printErr(engineName,"", e);
			}
			try {
				if(stmt!=null){
					stmt.close();
					stmt = null;
				}
			}
			catch (Exception e) {
				WFSUtil.printErr(engineName,"", e);
			}
		}
		return reminderFlag;
	}
	
	   /**
     * *************************************************************
     * Function Name    :   getAssignedRightOnObjType
     * Programmer' Name :   Shweta Singhal
     * Date Written     :   20/11/2012
     * Input Parameters :   Connection con, int objectTypeId, int userid, int assocType
     * Description      :   Give Assigned Rights of a user on ObjectType
     * *************************************************************
     */
	public static String getAssignedRightOnObjType(Connection con, int objectTypeId, int userid, int assocType) throws SQLException{
		/*StringBuffer strBuff = new StringBuffer(500);
		PreparedStatement pstmt= null;
		ResultSet rs = null;
		String rights = null;
		try{
			pstmt = con.prepareStatement("Select ObjectType, DefaultRight from WFObjectListTable where ObjectTypeId = ?");
			pstmt.setInt(1, objectTypeId);
			
			rs = pstmt.executeQuery();
			String defaultRights = null;
			String objectType = null;
			if(rs.next()){
				objectType = rs.getString("ObjectType");
				defaultRights = rs.getString("DefaultRight");
			}
			
			//pstmt = con.prepareStatement("select distinct rightstring, filter from WFProfileObjTypeTable A,WFUserObjAssocTable C where A.objecttypeid = C.objecttypeid and C.objecttypeid = ? and C.associationtype = A.associationtype and C.associationtype = ? and C.UserId = A.userid and C.userid = ? ");
			pstmt = con.prepareStatement("select rightstring, filter from WFProfileObjTypeTable where objecttypeid = ? and Associationtype = ? and Userid = ? ");
			pstmt.setInt(1, objectTypeId);
			pstmt.setInt(2, assocType);
			pstmt.setInt(3, userid);
			
			rs = pstmt.executeQuery();
			String filter = null;
			if(rs.next()){
				//found = true;
				rights = rs.getString(1);
				filter = rs.getString("Filter");
			}
			else 
				rights = defaultRights;
			
			strBuff.append("<RightString>" + rights + "</RightString>");
			Bug 37094 fixed, null check is inserted 
			if(filter != null && !filter.trim().equals(""))
				strBuff.append("<FilterString>" + filter + "</FilterString>");
			printOut("strBuff::"+strBuff.toString());
		}finally{
			if(rs != null){
				rs.close();
				rs = null;
			}
			if(pstmt != null){
				pstmt.close();
				pstmt = null;
			}
		}
                return strBuff.toString();*/
				String strGetAssignedRightOnObjType = WFRMSUtil.getAssignedRightOnObjType(con,objectTypeId,userid,assocType);
				return strGetAssignedRightOnObjType;
	}
	
	  /**
     * *************************************************************
     * Function Name    :   getRightsOnObjectType
     * Programmer' Name :   Shweta Singhal
     * Date Written     :   20/11/2012
     * Input Parameters :   Connection con, int dbType, String objectType, int sessionID
     * Description      :   Give Rights of a user on ObjectType
     * *************************************************************
     */
	public static String getRightsOnObjectType(Connection con, int dbType, String objectType, int sessionID) throws SQLException, Exception{
		/*PreparedStatement pstmt = null;
		ResultSet rs = null;
		String rights = null;
		try{
			pstmt = con.prepareStatement("Select DefaultRight from WFObjectListTable where ObjectType = ?");
			pstmt.setString(1, objectType);
			rs = pstmt.executeQuery();
			String defaultString = null;
			if(rs.next()){
				defaultString = rs.getString("DefaultRight");
			}
			
			rights = getRightsOnObjectType(con, dbType, objectType, sessionID, defaultString);
			
		}finally{
			if(rs != null){
				rs.close();
				rs = null;
			}
			if(pstmt != null){
				pstmt.close();
				pstmt = null;
			}
		}
		return rights;*/
		String strGetRightsOnObjectType = WFRMSUtil.getRightsOnObjectType(con,dbType,objectType,sessionID);
		return strGetRightsOnObjectType;
		
	}
	
	/**
     * *************************************************************
     * Function Name    :   getRightsOnObjectType
     * Author			:   Shweta Singhal
     * Date Written     :   30/08/2012
     * Input Parameters :   Connection con, int dbType, String objectType, int objectId, int sessionID, String defaultRights
     * Output Parameters:   String
     * Return Value     :   String
     * Description      :   Return Rights on a given ObjectId for a given ObjectType
     * *************************************************************
     */
	 
	 public static String getRightsOnObjectType(Connection con, int dbType, String objectType, int sessionID, String defaultRights) throws SQLException, Exception{
		/*PreparedStatement pstmt = null;
		ResultSet rs = null;
		ArrayList<String> objTypeRightString = new ArrayList<String>();
		String rights = null;
		try{
			WFParticipant user = WFSUtil.WFCheckSession(con, sessionID);
			int userId = 0;
            // Bug 38083 fixed, WFSException will be returned in case of user = null
            if(user != null)
                userId = user.getid();
            else{   
                int mainCode = WFSError.WM_INVALID_SESSION_HANDLE;
                int subCode = 0;
                String subject = WFSErrorMsg.getMessage(mainCode);
                String descr = WFSErrorMsg.getMessage(subCode);
                String errType = WFSError.WF_TMP;
                throw new WFSException(mainCode, subCode, errType, subject, descr);
            }
			String userName = user.getname();
			
			pstmt = con.prepareStatement("select 1 from PROFILEUSERGROUPVIEW A, WFProfileTable B where A.ProfileId = B.ProfileId AND A.UserId = ? and B.ProfileName = ?");
            pstmt.setInt(1, userId);
            WFSUtil.DB_SetString(2, "SYSADMIN",pstmt,dbType);
            rs = pstmt.executeQuery();
            if(rs.next()){
                rights = WFSConstant.CONST_DEFAULT_RIGHTSTR;
            }else{
                //Bug 37558 fixed
                Bug 37625 fixed
                pstmt = con.prepareStatement("select distinct RightString from WFProfileObjTypeTable A,WFObjectListTable  B where A.objecttypeid = B.objecttypeid and B.objecttype = ? and Associationtype = 0 and A.userid = ? ");
                
                WFSUtil.DB_SetString(1, objectType, pstmt, dbType);
                pstmt.setInt(2,userId);
                rs = pstmt.executeQuery();
                boolean found = false;
                while(rs.next()){
                    objTypeRightString.add(rs.getString("RightString"));
                    found = true;
                }	
                //Bug 37625 fixed
                pstmt = con.prepareStatement("select distinct rightstring from  WFProfileObjTypeTable A, WFObjectListTable  B, WFGROUPMEMBERVIEW  C where A.objecttypeid = B.objecttypeid and B.objecttype = ? and Associationtype = 1  and C.groupindex > 0 and C.groupindex= A.userid and C.userindex = ? ");
                
                WFSUtil.DB_SetString(1, objectType, pstmt, dbType);
                pstmt.setInt(2,userId);
                rs = pstmt.executeQuery();
                while(rs.next()){
                    objTypeRightString.add(rs.getString("RightString"));
                    found = true;
                }
				
				pstmt = con.prepareStatement("select distinct rightstring from  WFProfileObjTypeTable A, WFObjectListTable  B, PDBGroupRoles  C where A.objecttypeid = B.objecttypeid and B.objecttype = ? and Associationtype = 3  and C.roleindex > 0 and C.roleindex= A.userid and C.userindex = ? ");
                
                DB_SetString(1, objectType, pstmt, dbType);
                pstmt.setInt(2,userId);
                rs = pstmt.executeQuery();
                while(rs.next()){
                    objTypeRightString.add(rs.getString("RightString"));
                    found = true;
                }
				
				pstmt = con.prepareStatement("select distinct rightstring from WFProfileObjTypeTable A,WFObjectListTable  B, PROFILEUSERGROUPVIEW C where A.objecttypeid = B.objecttypeid and B.objecttype = ? and Associationtype = 2 and C.profileId > 0 and C.profileId = A.userid and C.userid = ? ");
                DB_SetString(1, objectType, pstmt, dbType);
                pstmt.setInt(2,userId);
                rs = pstmt.executeQuery();
                while(rs.next()){
                    objTypeRightString.add(rs.getString("RightString"));
                    found = true;
                }
			   
				
                pstmt = con.prepareStatement("select distinct rightstring from WFProfileObjTypeTable A,WFObjectListTable  B, PROFILEUSERGROUPVIEW C, WFGROUPMEMBERVIEW  D ,PDBGroupRoles E where A.objecttypeid = B.objecttypeid and B.objecttype = ? and Associationtype = 2 and D.groupindex > 0 and C.profileId > 0 and C.profileId = A.UserId and D.groupindex = C.groupid and D.userindex = C.userid and E.roleindex = C.RoleId and D.userindex =  ? ");
                WFSUtil.DB_SetString(1, objectType, pstmt, dbType);
                pstmt.setInt(2,userId);
                rs = pstmt.executeQuery();
                while(rs.next()){
                    objTypeRightString.add(rs.getString("RightString"));
                    found = true;
                }
                
                pstmt = con.prepareStatement("select distinct rightstring from WFProfileObjTypeTable A,WFObjectListTable  B, PROFILEUSERGROUPVIEW C, WFGROUPMEMBERVIEW  D where A.objecttypeid = B.objecttypeid and B.objecttype = ? and Associationtype = 2 and D.groupindex > 0 and C.profileId > 0 and C.profileId = A.UserId and D.groupindex = C.groupid and D.userindex = C.userid and D.userindex =  ? ");
                WFSUtil.DB_SetString(1, objectType, pstmt, dbType);
                pstmt.setInt(2,userId);
                rs = pstmt.executeQuery();
                String rightString = null;
                while(rs.next()){
                    rightString = rs.getString("RightString");
                    printOut("rightString::"+rightString);
                    objTypeRightString.add(rightString);
                    found = true;
                }
                int size = objTypeRightString.size();
                printOut("<GetRightsOnObjectType> size::"+size);
                if(found){
                    BitSet bs1 = createBitset(objTypeRightString.get(0));	
                    for(int j=1; j < size;j++){
                        BitSet bs2 = createBitset(objTypeRightString.get(j)); 
                        bs1.or(bs2);
                    }
                    printOut("bs1::"+bs1);
                    rights = bitToString(bs1);
                    printOut("rights::"+rights);
                }else{
                    rights = defaultRights;
                }
            }    
                //Enhancement 37672 
            StringBuffer logProp= new StringBuffer("UserId::"+userId+" UserName::"+userName+" ObjectType::"+objectType+" RightString: "+rights);
            WFLogger.writeLog('x', logProp);
			
			if(rs != null){
				rs.close();
				rs = null;
			}
			if(pstmt != null){
				pstmt.close();
				pstmt = null;
			}
		}finally{
			if(rs != null){
				rs.close();
				rs = null;
			}
			if(pstmt != null){
				pstmt.close();
				pstmt = null;
			}
		}
		return rights;*/
		String strGetRightsOnObjectType = WFRMSUtil.getRightsOnObjectType(con,dbType,objectType,sessionID,defaultRights);
		return strGetRightsOnObjectType;
	}
	
	/**
     * *************************************************************
     * Function Name    :   returnRightsForObjectType
     * Author			:   Shweta Singhal
     * Date Written     :   30/08/2012
     * Input Parameters :   Connection con, int dbType, int userId, String objType, int objectId, String sortOrder, int batchSize, String lastVal, boolean isRightCheck, String defaultString
     * Output Parameters:   String
     * Return Value     :   String
     * Description      :   Return Rights on a given ObjectId for a given ObjectType
     * *************************************************************
     */
	
	public static String returnRightsForObjectType(Connection con, int dbType, int userId, String objType, int objectId, String sortOrder, int batchSize, String lastVal, boolean isRightCheck, String defaultString) throws SQLException, Exception{
		/*PreparedStatement pstmt = null;
		CallableStatement cstmt = null;
		Statement stmt = null;
		ResultSet rs = null;
		String rights = null;
		String filterString = null;
		String tempRightTable = null;
		ArrayList<String> objTypeRightString = new ArrayList<String>();
		try{
			/*Avoid using equals() to compare against null--Shweta Singhal
            if("".equals(defaultString) || defaultString == null){
			//if(defaultString.equals("") || defaultString.equals(null)){
				pstmt = con.prepareStatement("Select DefaultRight from WFObjectListTable where ObjectType = ?");
				pstmt.setString(1, objType);
				rs = pstmt.executeQuery();
				if(rs.next()){
					defaultString = rs.getString("DefaultRight");
				}
			}
			tempRightTable = getTempTableName(con, "TempObjectRightsTable", dbType);
			//createTempRightTable(con, dbType);
			String typeNVARCHAR = WFSUtil.getNVARCHARType(dbType);
			
			printOut("tempRightTable " + tempRightTable);
			stmt = con.createStatement();
			createTempTable(stmt, tempRightTable, "AssociationType INT, ObjectId INT, ObjectName " + typeNVARCHAR + "(64), RightString " + typeNVARCHAR + "(100) " , dbType); /*Bug 40277
			String[] qParam = executeGetQueryParam(con, dbType, objType); 
			
			if (dbType == JTSConstant.JTS_MSSQL) {
				cstmt = con.prepareCall("{call WFReturnRightsForObjType(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)}");
			} else if (dbType == JTSConstant.JTS_ORACLE) {
				cstmt = con.prepareCall("{call WFReturnRightsForObjType(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)}");
			}
			cstmt.setInt(1, userId);
            //cstmt.setInt(2, 2);
            cstmt.setString(2, objType);
            cstmt.setString(3, qParam[0]);
			cstmt.setString(4, qParam[1]);
            cstmt.setString(5, qParam[2]);
            cstmt.setString(6, tempRightTable);
            cstmt.setString(7, sortOrder);
            cstmt.setInt(8, batchSize);
            if(lastVal == null || lastVal.equals(""))
                cstmt.setNull(9, java.sql.Types.VARCHAR);
            else
                cstmt.setString(9, lastVal);
			if(filterString == null || filterString.equals(""))
                cstmt.setNull(10, java.sql.Types.VARCHAR);
            else
                cstmt.setString(10, filterString);
			cstmt.setInt(11, objectId);
			
			if (dbType == JTSConstant.JTS_ORACLE) {				
				cstmt.registerOutParameter(12, oracle.jdbc.OracleTypes.CURSOR);
				cstmt.registerOutParameter(13, oracle.jdbc.OracleTypes.CURSOR);				
			}	
			
			cstmt.execute();
			if (dbType == JTSConstant.JTS_MSSQL) /* ResultSet 1 -> User' Preferences  {
				rs = cstmt.getResultSet();
			} else if (dbType == JTSConstant.JTS_ORACLE) {
				rs = (ResultSet) cstmt.getObject(12);			
			}
			
			boolean found = false;
			String rightString = null;
			while(rs.next()){
				rightString = rs.getString("RightString");
				objTypeRightString.add(rightString);
				//objTypeRightString.add(rs.getString("RightString"));
				found = true;
			}
			
			int size = objTypeRightString.size();
			printOut("size::"+size);
			if(found){
				BitSet bs1 = createBitset(objTypeRightString.get(0));	
				for(int j=1; j < size;j++){
					BitSet bs2 = createBitset(objTypeRightString.get(j)); 
					bs1.or(bs2);
				}
				printOut("rights bs1::"+bs1);
				rights = bitToString(bs1);
				//printOut("rights::"+rights);
			}else{
				rights = defaultString;
			}
		}finally{
			if(stmt != null){                
				try{
					dropTempTable(stmt, tempRightTable, dbType);
				} catch(Exception excp){}
	        }
			try{
				if(rs != null){
					rs.close();
					rs = null;
				}
			}catch(Exception ignored){}
            try{
				if(pstmt != null){
					pstmt.close();
					pstmt = null;
				}
                if(cstmt != null){
					cstmt.close();
					cstmt = null;
				}
			}catch(Exception ignored){}
		}
		
		return rights;*/
		String strReturnRightsForObjectType = WFRMSUtil.returnRightsForObjectType(con,dbType,userId,objType,objectId,sortOrder,batchSize,lastVal,isRightCheck,defaultString);
		return strReturnRightsForObjectType;
	}
	
	/**
     * *************************************************************
     * Function Name    :   getFilter()
     * Author			:   Shweta Singhal
     * Date Written     :   02/01/2013
     * Input Parameters :   Connection con, int objTypeId
     * Output Parameters:   String
     * Return Value     :   String
     * Description      :   Return filter XML for a given ObjectType
     * *************************************************************
     */
	public static String getFilter(Connection con, int objTypeId) throws SQLException{
		/*PreparedStatement pstmt = null;
		CallableStatement cstmt = null;
		Statement stmt = null;
		ResultSet rs = null;
		String rights = null;
		StringBuffer tempXML = new StringBuffer(200);
		try{		
			pstmt = con.prepareStatement("Select TagName,FilterName from WFFilterListTable where ObjectTypeId = ?");
			pstmt.setInt(1, objTypeId);
			rs = pstmt.executeQuery();
			tempXML.append("<Filters>");
			while(rs.next()){
				tempXML.append("<Filter>");					
				tempXML.append("<TagName>" + rs.getString("TagName") + "</TagName>");
				tempXML.append("<FilterName>" + rs.getString("FilterName") + "</FilterName>");
				tempXML.append("</Filter>");
			}
			tempXML.append("</Filters>");
		}finally{
			if(pstmt != null){
				pstmt.close();
				pstmt = null;
			}
			if(rs != null){
				rs.close();
				rs = null;
			}
		}
		return tempXML.toString();*/
		String strGetFilter = WFRMSUtil.getFilter(con,objTypeId);
		return strGetFilter;
	}
	
	public static Object getDBDataTypeForWFType(int wfType, int dbType, String fieldName){
        Object type = null;
        switch(wfType){
            case WFSConstant.WF_INT :
            case WFSConstant.WF_LONG:
                type = "INT";
                break;
            case WFSConstant.WF_FLT:
                if(dbType == JTSConstant.JTS_MSSQL || dbType==JTSConstant.JTS_POSTGRES){
                    type = "Numeric(15,2)";
                }else if(dbType==JTSConstant.JTS_ORACLE )
                    type = "Number(15,2)";
                break;
            case WFSConstant.WF_DAT:
                if(dbType == JTSConstant.JTS_MSSQL){
                    type = "DATETIME";
                }else if(dbType==JTSConstant.JTS_ORACLE){
                    type = "DATE";
                }else if(dbType==JTSConstant.JTS_POSTGRES){
                    type = "TIMESTAMP";
                }
               break;  
            case WFSConstant.WF_STR:
                type = getNVARCHARType(dbType);
               break;
            case WFSConstant.WF_TIME:
                if(dbType == JTSConstant.JTS_MSSQL){
                   type = "DATETIME";
               }else if(dbType==JTSConstant.JTS_ORACLE || dbType==JTSConstant.JTS_POSTGRES){
                   type = "TIMESTAMP";
               }
               break;
            case WFSConstant.WF_SHORT_DAT:                
               if(dbType == JTSConstant.JTS_MSSQL){
                    type = "DATETIME";
                }else if(dbType==JTSConstant.JTS_ORACLE){
                    type = "DATE";
                }else if(dbType==JTSConstant.JTS_POSTGRES){
                    type = "TIMESTAMP";
                }
               break;   
            case WFSConstant.WF_BOOLEAN:
               if(dbType == JTSConstant.JTS_MSSQL){
                   type = "NVARCHAR(10)";
               }else if(dbType==JTSConstant.JTS_ORACLE){
                   type = "NVARCHAR2(5)";
               }else if(dbType==JTSConstant.JTS_POSTGRES){
                   type = "VARCHAR(10)";
               }
               break;
            case WFSConstant.WF_NTEXT:
                if(dbType == JTSConstant.JTS_MSSQL){
                   type = "NTEXT";
               }else if(dbType==JTSConstant.JTS_ORACLE){
                   type = "NCLOB";
               }else if(dbType==JTSConstant.JTS_POSTGRES){
                   type = "TEXT";
               }
               break;
			   
            default :
               break;
            }
        return type;
    }
		/**
     * *************************************************************
     * Function Name    :   createTableForFileUpload()
     * Author			:   Kahkeshan
     * Date Written     :   31/05/2013
     * Input Parameters :   Connection con, XMLParser parser,int dbType
     * Output Parameters:   none
     * Return Value     :   none
     * Description      :   Creates a Table in DataBase for File Uploader Utility 
	                        when the Unique Field is true at the time of Registering the Utility.
     * *************************************************************
     */
	public static void createTableForFileUpload(Connection con,XMLParser parser,int dbType){
		Statement stmt =null ;
		ResultSet rs = null;
		int pDefId =0;
		int actId = 0;
		DatabaseMetaData dbmt  = null;
		StringBuffer qStr = new StringBuffer(200);
                String engine = parser.getValueOf("EngineName");
		try{
			pDefId = parser.getIntOf("ProcessDefId",0,false);
			actId = parser.getIntOf("ActivityId",0,false);
			String TableName = "WFIMPORTFILEDATA_" + pDefId + "_" + actId;
			dbmt = con.getMetaData();
			rs = dbmt.getTables(null, null, TableName, null);
			if(!rs.next()) {
					//table does not exist. 
				qStr.append("CREATE TABLE ");
				qStr.append(TableName);
				if(dbType == JTSConstant.JTS_MSSQL){
						qStr.append(" (FILEINDEX INTEGER, FILENAME NVARCHAR(256), UPLOADTIME DATETIME)");
				}else if(dbType == JTSConstant.JTS_ORACLE){
						qStr.append(" (FILEINDEX INTEGER, FILENAME NVARCHAR2(256), UPLOADTIME DATE)");
				}else if(dbType == JTSConstant.JTS_POSTGRES){
						qStr.append(" (FILEINDEX INTEGER, FILENAME VARCHAR(256), UPLOADTIME TIMESTAMP)");
				}     
			}
			stmt = con.createStatement();
			stmt.execute(qStr.toString());
		}catch(Exception ex){
                    printErr(engine,"",ex);
                }
		finally{
                    try{
			if(stmt != null){
				stmt.close();
				stmt = null;
			}
			if(rs != null){
				rs.close();
				rs = null;
			}                   
                    }catch(SQLException exp){
                        printErr(engine,"",exp);
                    }
                        
                }
		
	}
	
	
	/**
     * *************************************************************
     * Function Name    :   getQueueInfoXMLForQueueId()
     * Author			:   Mohnish Chopra
     * Date Written     :   05/06/2013
     * Input Parameters :   int queueId,char dataFlag,Connection con,int dbType,XMLGenerator gen,String engine
     * Output Parameters:   none
     * Return Value     :   none
     * Description      :   returns QueueInfo XML tag for provided queue id.
     * *************************************************************
     */
	public static String getQueueInfoXMLForQueueId(int queueId,char dataFlag,Connection con,int dbType,XMLGenerator gen,String engine, boolean countDataFlag,String workListConfigFlag, String inputXml) throws SQLException, WFSException {

		Statement stmt1=null;
		ResultSet rs=null;
		//OF MOBILE SUPPORT
		Statement stmtWListConfig=null;
    	ResultSet rsWListConfig = null;
		String queueName = null;
		String qProcessName = null;
		int qProcessId = 0;
		boolean bIsSingleProcessQueue = false;
		PreparedStatement pstmt=null;
		String exeStr = "";
		StringBuffer tempXml = new StringBuffer();		
		StringBuffer tempXml1 = new StringBuffer(100);
        StringBuffer strTemp=new StringBuffer();		
		StringBuffer wListConfigXml = new StringBuffer();
		int orderBy = 0;
		Statement stmt=null;
		WFVariabledef attribs = null;
		LinkedHashMap cacheMap = new LinkedHashMap();
		WFFieldInfo fieldInfo = null;		
		
		String filterString=" ";
		String filterStringForUser=" ";
		String filterStringForGroup=" ";
		int nextRecords=0;
		XMLParser parser = new XMLParser(inputXml);
		
		int i = 0;        
		
		//OF MOBILE SUPPORT
		StringBuffer varStr = new StringBuffer();
		StringBuffer varStr1 = new StringBuffer();
		String varType ="" ;
		int varId = 0;
		String varName = "";
		ResultSet rs1 = null;

		try{
			int noOfRecordsToFetch = parser.getIntOf("NoOfRecordsToFetch", ServerProperty.getReference().getBatchSize(), true);
			if(noOfRecordsToFetch > ServerProperty.getReference().getBatchSize()){
				noOfRecordsToFetch = ServerProperty.getReference().getBatchSize();
			}
			String sortOrder = parser.getValueOf("SortOrder","D",true);
			String lastValueIndex = parser.getValueOf("LastValueIndex", "0", true);
			String lastValueType = parser.getValueOf("LastValueType", "DEFAULT", true);
			String operator = sortOrder.equalsIgnoreCase("D")? (operator = "<"):(operator = ">");
			String sortOrderString = sortOrder.equalsIgnoreCase("A")? (sortOrderString = "ASC"):(sortOrderString = "DESC");	
			String UGPrefix=parser.getValueOf("UGPrefix", "", true);
            String UGPrefixForUser=" ";
            String UGPrefixForGroup=" ";
			String displayName = "";
			String mobileDisplay = "";
			stmt1 = con.createStatement();
			//OF MOBILE SUPPORT
			stmtWListConfig =con.createStatement();
			rsWListConfig = stmtWListConfig.executeQuery("select   distinct  wlct.variableid,vmt.SystemDefinedName,wlct.aliasid,wlct.variabletype,vat.Alias as AliasName,wlct.ViewCategory, wlct.DisplayName,wlct.MobileDisplay from WFWorkListConfigTable wlct  " +  WFSUtil.getTableLockHintStr(dbType) + " LEFT OUTER JOIN  Varmappingtable vmt " +  WFSUtil.getTableLockHintStr(dbType) + " ON  wlct.variableid = vmt.VariableId LEFT OUTER JOIN VARALIASTABLE vat " +  WFSUtil.getTableLockHintStr(dbType) + "  ON wlct.queueId = vat.QueueId and wlct.aliasid = vat.Id WHERE wlct.queueid = "+queueId);

			varStr.append("\n<WorkListConfigFields>\n");
			while(rsWListConfig.next()){
				//varStr.append(gen.writeValue("ViewCategory", rsWListConfig.getString(6)));
				varType = rsWListConfig.getString(4);
				if(varType.equalsIgnoreCase("A")){
					varId = rsWListConfig.getInt(3);
					varName = rsWListConfig.getString(5);
				}else{
					varId = rsWListConfig.getInt(1);
					varName = rsWListConfig.getString(2);
				}
				displayName = rsWListConfig.getString("DisplayName");
				mobileDisplay = rsWListConfig.getString("MobileDisplay");
				if(varId == 31){
					varName = "ProcessInstanceId";
				}else if(varId == 32){
					varName = "CreatedByPersonalName";
				}else if(varId == 46){
					varName = "LockedByUserName";
				}
				varStr.append("<Variable>");
				varStr.append(gen.writeValueOf("VariableId", String.valueOf(varId)));
				varStr.append(gen.writeValueOf("VariableType", varType));
				varStr.append(gen.writeValueOf("VariableName", varName));
				varStr.append(gen.writeValueOf("DisplayName", displayName));			
				varStr.append(gen.writeValueOf("MobileDisplay", mobileDisplay));
				varStr.append("</Variable>");
			}
			varStr.append("\n</WorkListConfigFields>\n");
			if(queueId!=0){         
				rs = stmt1.executeQuery(" Select QueueName, ProcessName from QueueDefTable " + WFSUtil.getTableLockHintStr(dbType)
						+ " where QueueId = " + queueId + WFSUtil.getQueryLockHintStr(dbType));
				if(rs.next()){
					queueName = rs.getString(1).trim();
					qProcessName = rs.getString(2);
					rs.close();
				} else
					throw new WFSException(WFSError.WF_OPERATION_FAILED, WFSError.WFS_NOQ, WFSError.WF_TMP, WFSErrorMsg.getMessage(WFSError.WF_OPERATION_FAILED), WFSErrorMsg.getMessage(WFSError.WFS_NOQ));

				if(qProcessName != null){
					rs = stmt1.executeQuery(" Select ProcessDefId from ProcessDefTable " + WFSUtil.getTableLockHintStr(dbType)
							+ " where ProcessName = " + WFSUtil.TO_STRING(qProcessName, true, dbType) + WFSUtil.getQueryLockHintStr(dbType));
					if(rs != null && rs.next()){
						qProcessId = rs.getInt(1);
						if(qProcessId != 0)
							bIsSingleProcessQueue = true;
						rs.close();
					}
				}
				/* UserCount,StreamCount,NoOfWorkitems,NoOfActiveUsers,NoOfInActiveUsers are not required in WebDesktop now but may be used from Client code--Shweta Singhal*/
				//if(dataFlag == 'Y' || dataFlag == 'y'){
				if(countDataFlag){
					//WFS_8.0_038	 WFS_8.0_047
					exeStr = "select queuename,queuetype,comments,filterOption,filterValue,OrderBy,allowreassignment, QueueFilter,RefreshInterval,SortOrder, ProcessName,"
						+ " (select count(distinct(userid)) from qusergroupview " + WFSUtil.getTableLockHintStr(dbType)
						+ " where qusergroupview.queueid=queuedeftable.queueid ) as count1, "
						+ " (select count(distinct(streamid)) from queuestreamtable " + WFSUtil.getTableLockHintStr(dbType)
						+ " where queuestreamtable.queueid=queuedeftable.queueid) as count2,"
						//				+ " (select (select count(*) from worklisttable where worklisttable.q_queueid = queuedeftable.queueid)+" + " (select count(*) from workinprocesstable where workinprocesstable.q_queueid = queuedeftable.queueid)+" + " (select count(*) from pendingworklisttable where pendingworklisttable.q_queueid = queuedeftable.queueid)"+(dbType==JTSConstant.JTS_MSSQL?"":" from dual")+"),"
						+ " (select ((select count(*) from WFINSTRUMENTTABLE " + WFSUtil.getTableLockHintStr(dbType) + " where WFINSTRUMENTTABLE.q_queueid = queuedeftable.queueid AND RoutingStatus in ('N','R'))) "						
						+ WFSUtil.getDummyTableName(dbType) + "),"
						+ " (Select count(distinct(Q_UserId)) from WFINSTRUMENTTABLE " + WFSUtil.getTableLockHintStr(dbType) + " where WFINSTRUMENTTABLE.Q_QueueID = queuedeftable.QueueID AND RoutingStatus = 'N' AND LockStatus = 'Y'),"
						+ " (select count(distinct(userid)) from qusergroupview " + WFSUtil.getTableLockHintStr(dbType)
						+ " where qusergroupview.queueid=queuedeftable.queueid and qusergroupview.userid not in " + " (select distinct(Q_userID) from WFINSTRUMENTTABLE " + WFSUtil.getTableLockHintStr(dbType) + " where  WFINSTRUMENTTABLE.Q_QueueID = queuedeftable.QueueID AND RoutingStatus = 'N' AND LockStatus = 'Y') ) from "
						+ " queuedeftable " + WFSUtil.getTableLockHintStr(dbType) + "where queuedeftable.queueid=" + queueId;					
						
				} else
					exeStr = "select queuename,queuetype,comments,filterOption,filterValue,OrderBy,allowreassignment, QueueFilter,RefreshInterval,SortOrder, ProcessName from  queuedeftable" + WFSUtil.getTableLockHintStr(dbType) + " where queuedeftable.queueid=" + queueId;
				exeStr += WFSUtil.getQueryLockHintStr(dbType);
				pstmt = con.prepareStatement(exeStr);
				pstmt.execute();
				rs = pstmt.getResultSet();
				//WFS_8.0_038
				int iRefreshInterval = 0;
				if(rs.next()){
					/*tempXml.append("\n<QueueInfo>\n");
					tempXml.append(gen.writeValueOf("Name", rs.getString(1)));
					tempXml.append(gen.writeValueOf("Type", rs.getString(2)));
					tempXml.append(gen.writeValueOf("Comments", rs.getString(3)));
					tempXml.append(gen.writeValueOf("FilterOption", rs.getString(4)));
					tempXml.append(gen.writeValueOf("FilterValue", rs.getString(5)));
					tempXml.append(gen.writeValueOf("OrderBy", rs.getString(6)));
					if(workListConfigFlag.equalsIgnoreCase("Y"))
						tempXml.append(varStr);
					if(rs.getString(6) != null)
						orderBy = Integer.parseInt(rs.getString(6));
					if((orderBy > 0) && bIsSingleProcessQueue) {
						//                    if(orderBy >= 157){     //  For external variables.
						//ToDo    --  Case not handled for OrderBy values(1 - 19). These cases handled at front end currently.
						attribs = (WFVariabledef) CachedObjectCollection.getReference().getCacheObject(con, engine, qProcessId, WFSConstant.CACHE_CONST_Variable, "0").getData();
						cacheMap = attribs.getAttribMap();
						Iterator itr = cacheMap.entrySet().iterator();
						while (itr.hasNext()) {
							Map.Entry entries = (Map.Entry) itr.next();
							fieldInfo = (WFFieldInfo) entries.getValue();
							if(fieldInfo.getVariableId() == (orderBy - 100)) {
								tempXml.append(gen.writeValueOf("OrderByName", fieldInfo.getMappedColumn()));
								break;
							}
						}
						//                }
					}                            
					tempXml.append(gen.writeValueOf("AllowReassignment", rs.getString(7)));
					tempXml.append(gen.writeValueOf("QueueFilter", rs.getString(8)));
					iRefreshInterval=rs.getInt(9);//WFS_8.0_038
					if(iRefreshInterval>=5)
						tempXml.append(gen.writeValueOf("RefreshInterval", String.valueOf(iRefreshInterval)));//WFS_8.0_038
					tempXml.append(gen.writeValueOf("SortOrder", rs.getString(10)));
					//WFS_8.0_047
					tempXml.append(gen.writeValueOf("QProcessName", rs.getString("ProcessName")));	////WFS_8.0_136
					// Below Provided data is not used in WebDesktop now but may be used from Client code--Shweta Singhal
					//if(dataFlag == 'Y' || dataFlag == 'y'){
					 if(countDataFlag){
						tempXml.append(gen.writeValueOf("UserCount", String.valueOf(rs.getInt(12))));
						tempXml.append(gen.writeValueOf("StreamCount", String.valueOf(rs.getInt(13))));
						tempXml.append(gen.writeValueOf("NoofWorkItems", String.valueOf(rs.getInt(14))));
						tempXml.append(gen.writeValueOf("NoofActiveUsers", String.valueOf(rs.getInt(15))));
						tempXml.append(gen.writeValueOf("NoofInActiveUsers", String.valueOf(rs.getInt(16))));
					}
					if(rs != null)
						rs.close();
					pstmt.close();				
					if(dataFlag == 'Y' || dataFlag == 'y'){
					
					*/
					
					if(lastValueIndex.equalsIgnoreCase("0")) {
						tempXml.append("\n<QueueInfo>\n");
						tempXml.append("<StatusInfo>\n");
						tempXml.append(gen.writeValueOf("StatusCode", "0"));
						tempXml.append(gen.writeValueOf("Description", "SUCCESS"));
						tempXml.append("\n</StatusInfo>\n");
						tempXml.append(gen.writeValueOf("QueueId", queueId+""));
						tempXml.append(gen.writeValueOf("Name", rs.getString(1)));
						tempXml.append(gen.writeValueOf("Type", rs.getString(2)));
						tempXml.append(gen.writeValueOf("Comments", rs.getString(3)));
						tempXml.append(gen.writeValueOf("FilterOption", rs.getString(4)));
						tempXml.append(gen.writeValueOf("FilterValue", rs.getString(5)));
						tempXml.append(gen.writeValueOf("OrderBy", rs.getString(6)));
                                                if(workListConfigFlag.equalsIgnoreCase("Y"))
                                                    tempXml.append(varStr);
						if(rs.getString(6) != null)
							orderBy = Integer.parseInt(rs.getString(6));
						if((orderBy > 0) && bIsSingleProcessQueue) {
	//                                if(orderBy >= 157){     //  For external variables.
	//      ToDo    --  Case not handled for OrderBy values(1 - 19). These cases handled at front end currently.
								attribs = (WFVariabledef) CachedObjectCollection.getReference().getCacheObject(con, engine, qProcessId, WFSConstant.CACHE_CONST_Variable, "0").getData();
								cacheMap = attribs.getAttribMap();
								Iterator itr = cacheMap.entrySet().iterator();
								while (itr.hasNext()) {
									Map.Entry entries = (Map.Entry) itr.next();
									fieldInfo = (WFFieldInfo) entries.getValue();
									if(fieldInfo.getVariableId() == (orderBy - 100)) {
										tempXml.append(gen.writeValueOf("OrderByName", fieldInfo.getMappedColumn()));
										break;
									}
								}
	//                            }
						}
						tempXml.append(gen.writeValueOf("AllowReassignment", rs.getString(7)));
						tempXml.append(gen.writeValueOf("QueueFilter", rs.getString(8)));
						iRefreshInterval=rs.getInt(9);//WFS_8.0_038
						if(iRefreshInterval>=1)
							tempXml.append(gen.writeValueOf("RefreshInterval", String.valueOf(iRefreshInterval)));//WFS_8.0_038
												tempXml.append(gen.writeValueOf("SortOrder", rs.getString(10)));
												//WFS_8.0_047
												tempXml.append(gen.writeValueOf("QProcessName", rs.getString("ProcessName")));	////WFS_8.0_136
						if(countDataFlag){
							tempXml.append(gen.writeValueOf("UserCount", String.valueOf(rs.getInt(12))));
							tempXml.append(gen.writeValueOf("StreamCount", String.valueOf(rs.getInt(13))));
							tempXml.append(gen.writeValueOf("NoofWorkItems", String.valueOf(rs.getInt(14))));
							tempXml.append(gen.writeValueOf("NoofActiveUsers", String.valueOf(rs.getInt(15))));
							tempXml.append(gen.writeValueOf("NoofInActiveUsers", String.valueOf(rs.getInt(16))));
						}
						if(rs != null)
							rs.close();
						pstmt.close();
                    }
					
					if(dbType==JTSConstant.JTS_ORACLE) {
						UGPrefix=UGPrefix.toUpperCase();
					}

					if(UGPrefix.equalsIgnoreCase("")) {
						if(!lastValueIndex.equalsIgnoreCase("0"))
							filterString="AND B.userId "+operator+" "+lastValueIndex;
						if(lastValueType.equalsIgnoreCase("U"))
								filterStringForUser=filterString;
						if(lastValueType.equalsIgnoreCase("G"))
								filterStringForGroup=filterString;
					}
					else {
						if(UGPrefix.contains("*")) {
							if(dbType==JTSConstant.JTS_ORACLE){
								UGPrefixForUser="AND Upper(A.UserName) like '"+UGPrefix.replace('*', '%')+"'";
								UGPrefixForGroup="AND Upper(A.GroupName) like '"+UGPrefix.replace('*', '%')+"'";
							}
							else{
							UGPrefixForUser="AND A.UserName like '"+UGPrefix.replace('*', '%')+"'";
							UGPrefixForGroup="AND A.GroupName like '"+UGPrefix.replace('*', '%')+"'";
						}
						}
						else {
							if(dbType==JTSConstant.JTS_ORACLE){
								UGPrefixForUser="AND Upper(A.UserName)='"+UGPrefix+"'";
								UGPrefixForGroup="AND Upper(A.GroupName)='"+UGPrefix+"'";
							}
							else{
							UGPrefixForUser="AND A.UserName='"+UGPrefix+"'";
							UGPrefixForGroup="AND A.GroupName='"+UGPrefix+"'";
						}
						}
						if(!lastValueIndex.equalsIgnoreCase("0"))
							filterString="AND B.userId "+operator+" "+lastValueIndex;
						if(lastValueType.equalsIgnoreCase("U"))
								filterStringForUser=filterString;
						if(lastValueType.equalsIgnoreCase("G"))
								filterStringForGroup=filterString;
					}
					
					if(sortOrder.equalsIgnoreCase("D") && dataFlag == 'Y' || dataFlag == 'y'){	
						tempXml.append("\n<Data>\n");
						stmt = con.createStatement();		
						/*tempXml.append("\n<UserList>\n");
						rs = stmt.executeQuery(" SELECT A.Userindex, A.Username, B.QueryFilter,B.QueryPreview FROM wfuserview A, QueueUserTable B" + WFSUtil.getTableLockHintStr(dbType)
						+" where A.Userindex = B.UserId And AssociationType = 0 AND Queueid=" + queueId); //SRNo-1//WFS_8.0_054
						while(rs.next()){
							tempXml.append("\n<UserInfo>\n");
							tempXml.append(gen.writeValueOf("Id", String.valueOf(rs.getInt(1))));
							tempXml.append(gen.writeValueOf("Name", rs.getString(2)));
							tempXml.append(gen.writeValueOf("QueryFilter", rs.getString("QueryFilter"))); //SRNo-1
							tempXml.append(gen.writeValueOf("QueryPreview", rs.getString("QueryPreview"))); //WFS_8.0_054
							tempXml.append("\n</UserInfo>\n");
						}
						tempXml.append("\n</UserList>\n");
						if(rs != null)
							rs.close();*/
						
						tempXml.append("\n<GroupList>\n");
						String queryForGroup="SELECT "+WFSUtil.getFetchPrefixStr(dbType, noOfRecordsToFetch+1)+ " A.Groupindex,A.Groupname, B.QueryFilter,B.QueryPreview, B.EditableonQuery FROM Wfgroupview A, QueueUserTable B Where A.Groupindex = B.Userid And AssociationType = 1 And Queueid = " + queueId+" "+filterStringForGroup+" "+UGPrefixForGroup+ " ORDER BY B.UserId "+sortOrderString;                            
						rs = stmt.executeQuery(queryForGroup); //SRNo-1//WFS_8.0_054
						
						if(lastValueType.equalsIgnoreCase("DEFAULT") || lastValueType.equalsIgnoreCase("G")) {
							while(i<noOfRecordsToFetch && rs.next()){
								tempXml.append("\n<GroupInfo>\n");
								tempXml.append(gen.writeValueOf("Id", String.valueOf(rs.getInt(1))));
								tempXml.append(gen.writeValueOf("Name", rs.getString(2)));
								tempXml.append(gen.writeValueOf("QueryFilter", handleSpecialCharInXml(rs.getString("QueryFilter")))); //SRNo-1
								tempXml.append(gen.writeValueOf("QueryPreview", rs.getString("QueryPreview"))); //WFS_8.0_054
								tempXml.append(gen.writeValueOf("EditWorkItem", rs.getString("EditableonQuery")));
								tempXml.append("\n</GroupInfo>\n");
								i++;
							}
						}
						tempXml.append("\n</GroupList>\n");
						tempXml.append("\n<UserList>\n");
						String queryForUser="SELECT "+WFSUtil.getFetchPrefixStr(dbType, noOfRecordsToFetch+1)+ " A.Userindex, A.Username, B.QueryFilter,B.QueryPreview , B.EditableonQuery FROM wfuserview A, QueueUserTable B where A.Userindex = B.UserId And AssociationType = 0 AND Queueid=" + queueId+" "+filterStringForUser+ " "+UGPrefixForUser+ " ORDER BY B.UserId "+sortOrderString;                          
						rs1 = stmt1.executeQuery(queryForUser);//SRNo-1//WFS_8.0_054                            
						while(i<noOfRecordsToFetch && rs1.next()){
							tempXml.append("\n<UserInfo>\n");
							tempXml.append(gen.writeValueOf("Id", String.valueOf(rs1.getInt(1))));
							tempXml.append(gen.writeValueOf("Name", rs1.getString(2)));
							tempXml.append(gen.writeValueOf("QueryFilter", handleSpecialCharInXml(rs1.getString("QueryFilter")))); //SRNo-1
							tempXml.append(gen.writeValueOf("QueryPreview", rs1.getString("QueryPreview"))); //WFS_8.0_054
							tempXml.append(gen.writeValueOf("EditWorkItem", rs1.getString("EditableonQuery")));
							tempXml.append("\n</UserInfo>\n");
							i++;
							rs=rs1;
						}						
						tempXml.append("\n</UserList>\n");
						nextRecords = (i == noOfRecordsToFetch) && rs.next() ? i + 1 : i;
						if(rs != null)
							rs.close();						
						if(rs1 != null)
							rs1.close();	
						/*tempXml.append("\n<GroupList>\n");
						rs = stmt.executeQuery("SELECT A.Groupindex,A.Groupname, B.QueryFilter,B.QueryPreview FROM Wfgroupview A, QueueUserTable B " + WFSUtil.getTableLockHintStr(dbType) + " Where A.Groupindex = B.Userid And AssociationType = 1 And Queueid = " + queueId); //SRNo-1//WFS_8.0_054
						while(rs.next()){
							tempXml.append("\n<GroupInfo>\n");
							tempXml.append(gen.writeValueOf("Id", String.valueOf(rs.getInt(1))));
							tempXml.append(gen.writeValueOf("Name", rs.getString(2)));
							tempXml.append(gen.writeValueOf("QueryFilter", rs.getString("QueryFilter"))); //SRNo-1
							tempXml.append(gen.writeValueOf("QueryPreview", rs.getString("QueryPreview"))); //WFS_8.0_054
							tempXml.append("\n</GroupInfo>\n");
						}
						tempXml.append("\n</GroupList>\n");
						if(rs != null)
							rs.close();*/					
						
							
							
						/*tempXml.append("\n<StreamList>\n");
						String str = " Select distinct streamdeftable.streamid,streamname, "
							+ " queuestreamtable.processdefid,queuestreamtable.activityid, "
							+ " activitytable.activityname,processdeftable.processname, "
							+ " streamdeftable.streamcondition, processdeftable.versionno "
							+ " from streamdeftable " + WFSUtil.getTableLockHintStr(dbType) + ",queuestreamtable " + WFSUtil.getTableLockHintStr(dbType) + ",processdeftable " + WFSUtil.getTableLockHintStr(dbType) + ",activitytable " + WFSUtil.getTableLockHintStr(dbType) 
							+ " where queuestreamtable.queueid=" + queueId + " and "
							+ " queuestreamtable.streamid=streamdeftable.streamid and "
							+ " processdeftable.processdefid=queuestreamtable.processdefid "
							+ " and queuestreamtable.activityid=activitytable.activityid "
							+ " and activitytable.processdefid=processdeftable.processdefid "
							+ " and streamdeftable.processdefid=processdeftable.processdefid "
							+ " and streamdeftable.activityid=activitytable.activityid ";
						rs = stmt.executeQuery(str);
						while(rs.next()){
							tempXml.append("\n<StreamInfo>\n");
							tempXml.append(gen.writeValueOf("Id", String.valueOf(rs.getInt(1))));
							tempXml.append(gen.writeValueOf("Name", rs.getString(2)));
							tempXml.append(gen.writeValueOf("ProcessDefId", String.valueOf(rs.getInt(3))));
							tempXml.append(gen.writeValueOf("ActivityId", String.valueOf(rs.getInt(4))));
							tempXml.append(gen.writeValueOf("ActivityName", rs.getString(5)));
							tempXml.append(gen.writeValueOf("ProcessName", rs.getString(6)));
							tempXml.append(gen.writeValueOf("Definition", rs.getString(7)));
							tempXml.append(gen.writeValueOf("VersionNo", rs.getString(8)));
							tempXml.append("\n</StreamInfo>\n");
						}
						if(rs != null)
							rs.close();
						if(stmt != null){
							stmt.close();
							stmt = null;
						}
						tempXml.append("\n</StreamList>\n");
						tempXml.append("\n</Data>\n");*/
						
						if(lastValueIndex.equalsIgnoreCase("0")) {
                            tempXml.append("\n<StreamList>\n");
                            String str = " Select distinct streamdeftable.streamid,streamname, "
                                + " queuestreamtable.processdefid,queuestreamtable.activityid, "
                                + " activitytable.activityname,processdeftable.processname, "
                                + " streamdeftable.streamcondition, processdeftable.versionno "
                                + " from streamdeftable " + getTableLockHintStr(dbType) + ", queuestreamtable " + getTableLockHintStr(dbType) + ", processdeftable " + getTableLockHintStr(dbType) + ", activitytable " + getTableLockHintStr(dbType)
                                + " where queuestreamtable.queueid=" + queueId + " and "
                                + " queuestreamtable.streamid=streamdeftable.streamid and "
                                + " processdeftable.processdefid=queuestreamtable.processdefid "
                                + " and queuestreamtable.activityid=activitytable.activityid "
                                + " and activitytable.processdefid=processdeftable.processdefid "
                                + " and streamdeftable.processdefid=processdeftable.processdefid "
                                + " and streamdeftable.activityid=activitytable.activityid ";
								rs = stmt.executeQuery(str);
								while(lastValueIndex.equalsIgnoreCase("0") && rs.next()){
									tempXml.append("\n<StreamInfo>\n");
									tempXml.append(gen.writeValueOf("Id", String.valueOf(rs.getInt(1))));
									tempXml.append(gen.writeValueOf("Name", rs.getString(2)));
									tempXml.append(gen.writeValueOf("ProcessDefId", String.valueOf(rs.getInt(3))));
									tempXml.append(gen.writeValueOf("ActivityId", String.valueOf(rs.getInt(4))));
									tempXml.append(gen.writeValueOf("ActivityName", rs.getString(5)));
									tempXml.append(gen.writeValueOf("ProcessName", rs.getString(6)));
									tempXml.append(gen.writeValueOf("Definition", rs.getString(7)));
									tempXml.append(gen.writeValueOf("VersionNo", rs.getString(8)));
									tempXml.append("\n</StreamInfo>\n");
								}
                            }
                            if(rs != null)
                                rs.close();
                            if(stmt != null){
                                stmt.close();
                                stmt = null;
                            }
                            tempXml.append("\n</StreamList>\n");
                            tempXml.append("\n</Data>\n");
						
					}else{
						if(countDataFlag || dataFlag == 'Y' || dataFlag == 'y'){
                            tempXml.append("\n<Data>\n");
                            stmt = con.createStatement();
							stmt1 = con.createStatement();
                            tempXml.append("\n<UserList>\n");
                            String queryForUser="SELECT  "+WFSUtil.getFetchPrefixStr(dbType, noOfRecordsToFetch+1)+ " A.Userindex, A.Username, B.QueryFilter,B.QueryPreview, B.EditableonQuery FROM wfuserview A, QueueUserTable B where A.Userindex = B.UserId And AssociationType = 0 AND Queueid=" + queueId+" "+filterStringForUser+ " "+UGPrefixForUser+ " ORDER BY B.UserId ASC";
                            
                            rs = stmt.executeQuery(queryForUser); //SRNo-1//WFS_8.0_054
                            if(lastValueType.equalsIgnoreCase("DEFAULT") || lastValueType.equalsIgnoreCase("U")) {                            
                                while(i<noOfRecordsToFetch && rs.next()){
									tempXml1.append("\n<UserInfo>\n");
									tempXml1.append(gen.writeValueOf("Id", String.valueOf(rs.getInt(1))));
									tempXml1.append(gen.writeValueOf("Name", rs.getString(2)));
									tempXml1.append(gen.writeValueOf("QueryFilter", rs.getString("QueryFilter"))); //SRNo-1
									tempXml1.append(gen.writeValueOf("QueryPreview", rs.getString("QueryPreview"))); //WFS_8.0_054
									tempXml1.append(gen.writeValueOf("EditWorkItem", rs.getString("EditableonQuery")));
									tempXml1.append("\n</UserInfo>\n");
									i++;
									strTemp=tempXml1.append(strTemp);
									tempXml1=new StringBuffer();
								}
                            }
                            tempXml.append(strTemp);
                            tempXml.append("\n</UserList>\n");
                            tempXml.append("\n<GroupList>\n");
                            
                            String queryForGroup="SELECT  "+WFSUtil.getFetchPrefixStr(dbType, noOfRecordsToFetch+1)+ " A.Groupindex,A.Groupname, B.QueryFilter,B.QueryPreview, B.EditableonQuery FROM Wfgroupview A, QueueUserTable B Where A.Groupindex = B.Userid And AssociationType = 1 And Queueid = " + queueId+" "+filterStringForGroup+ " "+UGPrefixForGroup + " ORDER BY B.UserId ASC";                           
                            rs = stmt.executeQuery(queryForGroup); //SRNo-1//WFS_8.0_054                          
                            tempXml1=new StringBuffer();
                            strTemp=new StringBuffer();
                            while(i<noOfRecordsToFetch && rs.next()){
                                tempXml1.append("\n<GroupInfo>\n");
                                tempXml1.append(gen.writeValueOf("Id", String.valueOf(rs.getInt(1))));
                                tempXml1.append(gen.writeValueOf("Name", rs.getString(2)));
                                tempXml1.append(gen.writeValueOf("QueryFilter", rs.getString("QueryFilter"))); //SRNo-1
                                tempXml1.append(gen.writeValueOf("QueryPreview", rs.getString("QueryPreview"))); //WFS_8.0_054
                                tempXml1.append(gen.writeValueOf("EditWorkItem", rs.getString("EditableonQuery")));
                                tempXml1.append("\n</GroupInfo>\n");
                                i++;
								rs=rs1;
                                strTemp=tempXml1.append(strTemp);
                                tempXml1=new StringBuffer();
                            }
                            tempXml.append(strTemp);
                            tempXml.append("\n</GroupList>\n");
                             
                            
                            nextRecords = (i == noOfRecordsToFetch) && rs.next() ? i + 1 : i;
                            if(rs != null)
                                rs.close();
							 if(rs1 != null)
                                rs1.close();
								
                            if(lastValueIndex.equalsIgnoreCase("0")) {
                            tempXml.append("\n<StreamList>\n");
                            String str = " Select distinct streamdeftable.streamid,streamname, "
                                + " queuestreamtable.processdefid,queuestreamtable.activityid, "
                                + " activitytable.activityname,processdeftable.processname, "
                                + " streamdeftable.streamcondition, processdeftable.versionno "
                                + " from streamdeftable " + getTableLockHintStr(dbType) + ", queuestreamtable " + getTableLockHintStr(dbType) + ", processdeftable " + getTableLockHintStr(dbType) + ", activitytable " + getTableLockHintStr(dbType)
                                + " where queuestreamtable.queueid=" + queueId + " and "
                                + " queuestreamtable.streamid=streamdeftable.streamid and "
                                + " processdeftable.processdefid=queuestreamtable.processdefid "
                                + " and queuestreamtable.activityid=activitytable.activityid "
                                + " and activitytable.processdefid=processdeftable.processdefid "
                                + " and streamdeftable.processdefid=processdeftable.processdefid "
                                + " and streamdeftable.activityid=activitytable.activityid ";
								rs = stmt.executeQuery(str);
								while(rs.next()){
									tempXml.append("\n<StreamInfo>\n");
									tempXml.append(gen.writeValueOf("Id", String.valueOf(rs.getInt(1))));
									tempXml.append(gen.writeValueOf("Name", rs.getString(2)));
									tempXml.append(gen.writeValueOf("ProcessDefId", String.valueOf(rs.getInt(3))));
									tempXml.append(gen.writeValueOf("ActivityId", String.valueOf(rs.getInt(4))));
									tempXml.append(gen.writeValueOf("ActivityName", rs.getString(5)));
									tempXml.append(gen.writeValueOf("ProcessName", rs.getString(6)));
									tempXml.append(gen.writeValueOf("Definition", rs.getString(7)));
									tempXml.append(gen.writeValueOf("VersionNo", rs.getString(8)));
									tempXml.append("\n</StreamInfo>\n");
								}
                            }
                            if(rs != null)
                                rs.close();
                            if(stmt != null){
                                stmt.close();
                                stmt = null;
                            }
                            tempXml.append("\n</StreamList>\n");
                            tempXml.append("\n</Data>\n");
						}
					}
			
					tempXml.append(gen.writeValueOf("TotalCount", String.valueOf(nextRecords)));
					tempXml.append(gen.writeValueOf("RetrievedCount", String.valueOf(i)));				
					tempXml.append("\n</QueueInfo>\n");        

				}
				else{
					if(rs != null)
						rs.close();
					pstmt.close();
					int mainCode = WFSError.WM_NO_MORE_DATA;
					int subCode = 0;
					String subject = WFSErrorMsg.getMessage(mainCode);
					String descr = WFSErrorMsg.getMessage(subCode);
					String errType = WFSError.WF_TMP;
					throw new WFSException(mainCode, subCode, errType, subject, descr);

				}
			}else{
				if(workListConfigFlag.equalsIgnoreCase("Y")){
					tempXml.append("\n<QueueInfo>\n");
					tempXml.append(varStr);
					tempXml.append("\n</QueueInfo>\n");
				}
		    }
			
		}catch (Exception e){
			// Do Nothing
		}
		finally{
			try{
				if(rs != null){
					rs.close();
					rs = null;
				}                
			} catch(Exception e){
				printErr(engine,"",e);
			}
			try{
				if(rs1 != null){
					rs1.close();
					rs1 = null;
				}                
			} catch(Exception e){
				printErr(engine,"",e);
			}
			try{
				if(rsWListConfig != null){
					rsWListConfig.close();
					rsWListConfig = null;
				}                
			} catch(Exception e){
				printErr(engine,"",e);
			}
			try{
				// WFS_6_004, statement closed in finally.
				if(stmt != null){
					stmt.close();
					stmt = null;
				}

			} catch(Exception e){
				printErr(engine,"",e);
			}
			try{
				if(stmt1 != null){
					stmt1.close();
					stmt1 = null;
				}                
			} catch(Exception e){
				printErr(engine,"",e);
			}
			try{
				if(stmtWListConfig != null){
					stmtWListConfig.close();
					stmtWListConfig = null;
				}                
			} catch(Exception e){
				printErr(engine,"",e);
			}
			try{
				if(pstmt != null){
					pstmt.close();
					pstmt = null;
				}                
			} catch(Exception e){
				printErr(engine,"",e);
			}
			

		}
		return tempXml.toString();
	}
        /**
     * *************************************************************
     * Function Name    :   sortMapByComparator(Map)
     * Author		:   Shweta Singhal
     * Date Written     :   11/06/2013
     * Input Parameters :   Map unsortMap
     * Output Parameters:   Map
     * Return Value     :   Map
     * Description      :   return the map in the sorted order by Value
     * *************************************************************
     */
    public static Map sortMapByValue(Map unsortMap) {
        List list = new LinkedList(unsortMap.entrySet());
        Collections.sort(list, new Comparator() {
            public int compare(Object o1, Object o2) {
                return ((Comparable) ((Map.Entry) (o1)).getValue()).compareTo(((Map.Entry) (o2)).getValue());
            }
        });
        Map sortedMap = new LinkedHashMap();
            for (Iterator it = list.iterator(); it.hasNext();) {
                    Map.Entry entry = (Map.Entry) it.next();
                    sortedMap.put(entry.getKey(), entry.getValue());
            }
        return sortedMap;
    }		
	
	 //----------------------------------------------------------------------------------
    //	Function Name               :	imageToNtext
    //	Date Written (DD/MM/YYYY)   :	27/09/2012
    //	Author                      :	Anwar Ali Danish
    //	Input Parameters            :	Connection , XMLParser 
    //	Output Parameters           :   none
    //	Return Values               :	String
    //	Description                 :   Method to convert IMAGE to NTEXT column in existing data base table
    //                                  
    //                                      
    //----------------------------------------------------------------------------------
	
	
	public static void imageToNtext(Connection con, XMLParser parser) throws JTSException, WFSException {
        int mainCode = 0;
        int subCode = 0;
        String subject = null;
        String descr = null;
        String errType = WFSError.WF_TMP;
        StringBuffer tempXml = new StringBuffer(100);
        String engine = parser.getValueOf("EngineName");
        InputStream is=null;
        try {
		printOut(engine,"Inside ImageToNText");
           // int sessionID = parser.getIntOf("SessionId", 0, false);
            //WFParticipant user = WFSUtil.WFCheckSession(con, sessionID);
            //if (user != null) {
				
				int dbType = ServerProperty.getReference().getDBType(engine);
				String colName = null;
				WFConfigLocator configurationLocator = WFConfigLocator.getInstance();
				String filePath = configurationLocator.getPath(Location.IBPS_CONFIG) + File.separator + WFSConstant.CONST_DIRECTORY_CONFIG;
				filePath = filePath + File.separatorChar + WFSConstant.CONST_IMAGEUPGRADE;
				printOut(engine,"filepath:" + filePath);
				 is = new FileInputStream(filePath);
				StringBuffer buffer = new StringBuffer();
				byte[] b = new byte[40000];
				for (int n; (n = is.read(b)) != -1;) {
					buffer.append(new String(b, 0, n));
				}            
				String str = buffer.toString();
				XMLParser tmsParser = new XMLParser(str);
			printOut(engine,"tmsParser::"+tmsParser);
				
				int startTable = tmsParser.getStartIndex("Tables", 0, 0);
				int deadendTable = tmsParser.getEndIndex("Tables", startTable, 0);
				int noOfAttTable = tmsParser.getNoOfFields("TableInfo", startTable, deadendTable);
				int endTable = 0;				
				tmsParser.getNoOfFields("TableInfo");            
				int start = 0;
				for(int count = 0; count < noOfAttTable; count++){
					startTable = tmsParser.getStartIndex("TableInfo", endTable, 0);
					endTable = tmsParser.getEndIndex("TableInfo", startTable, 0);
					String tName = tmsParser.getValueOf("TableName",startTable,endTable);
					int startex = tmsParser.getStartIndex("TableInfo", start, Integer.MAX_VALUE);
					int deadendex = tmsParser.getEndIndex("TableInfo", startex, 0);
					start = deadendex;
					int noOfAttEx = tmsParser.getNoOfFields("ColumnInfo", startex, deadendex);
					int endEx = startex;
					for(int i = 0; i < noOfAttEx ; i++){
						startex = tmsParser.getStartIndex("ColumnInfo", endEx, 0);
						endEx = tmsParser.getEndIndex("ColumnInfo", startex, 0);
						String cName = tmsParser.getValueOf("Name",startex,endEx);					
						extractionFromColumn(con,dbType,cName,tName,engine);
					}
				}
			/*} else {
					mainCode = WFSError.WM_INVALID_SESSION_HANDLE;
					subCode = 0;
					subject = WFSErrorMsg.getMessage(mainCode);
					descr = WFSErrorMsg.getMessage(subCode);
					errType = WFSError.WF_TMP;
			}*/
		/*	if (mainCode == 0) {
				outputXML = new StringBuffer(500);
			//	outputXML.append(gen.createOutputFile("WFImageToNTEXT"));
				outputXML.append("<Exception>\n<MainCode>0</MainCode>\n</Exception>\n");
			//	outputXML.append(gen.closeOutputFile("WFImageToNTEXT"));
			}*/
		} catch (NumberFormatException e) {
				WFSUtil.printErr(engine,"", e);
				mainCode = WFSError.WF_OPERATION_FAILED;
				subCode = WFSError.WFS_ILP;
				subject = WFSErrorMsg.getMessage(mainCode);
				errType = WFSError.WF_TMP;
				descr = e.toString();
		} catch (NullPointerException e) {
			WFSUtil.printErr(engine,"", e);
			mainCode = WFSError.WF_OPERATION_FAILED;
			subCode = WFSError.WFS_SYS;
			subject = WFSErrorMsg.getMessage(mainCode);
			errType = WFSError.WF_TMP;
			descr = e.toString();
		} catch (Exception e) {
			WFSUtil.printErr(engine,"", e);
			mainCode = WFSError.WF_OPERATION_FAILED;
			subCode = WFSError.WFS_EXP;
			subject = WFSErrorMsg.getMessage(mainCode);
			errType = WFSError.WF_TMP;
			descr = e.toString();
		} catch (Error e) {
			WFSUtil.printErr(engine,"", e);
			mainCode = WFSError.WF_OPERATION_FAILED;
			subCode = WFSError.WFS_EXP;
			subject = WFSErrorMsg.getMessage(mainCode);
			errType = WFSError.WF_TMP;
			descr = e.toString();
		} finally {
			try{
				if(is!=null){
					is.close();
					is=null;
				}
			}catch(Exception e){
				WFSUtil.printErr(engine,"", e);
			}
			
		}
        if (mainCode != 0) {
			throw new WFSException(mainCode, subCode, errType, subject, descr);
		}
		//return outputXML.toString();
	 
	}
/**
     * *************************************************************
     * Function Name    :   extractionFromColumn
     * Author			:   Anwar Ali Danish
     * Date Written     :   27/09/2012
     * Input Parameters :   Connection con, int dbType,String colName,String tableName
     * Output Parameters:   
     * Return Value     :   
     * Description      :    
     * *************************************************************
     */
	public static void extractionFromColumn(Connection con, int dbType, String colName, String tableName, String engine) throws SQLException, Exception{
        PreparedStatement pstmt = null;
        Statement stmt = null;
        ResultSet rs = null;
        //ResultSet rs1 = null;
        String actIcon = null;
		Object[] result = null;        
        //byte[] icon = new byte[510];
        int procDefid = 0;
        int actid = 0;
        ResultSetMetaData rsmtd = null;
        DatabaseMetaData dbmd = null;
        StringBuffer updateKeyString = null;
        StringBuffer selectKeyString = null;
        boolean isFirstColumn = true;
        String keyFieldName = null;
        int colCount = 0;
        int isImageColumnNullable = 1;
        
        try{
            int i= 0;
            String tempColName = null;
            stmt = con.createStatement();
            
            dbmd = con.getMetaData();
            if(dbType == JTSConstant.JTS_ORACLE){
            	rs = dbmd.getPrimaryKeys(con.getCatalog(), engine.toUpperCase(), tableName);
            }else {
            	rs = dbmd.getPrimaryKeys(con.getCatalog(), null, tableName);
            }
            updateKeyString = new StringBuffer(100);
            selectKeyString = new StringBuffer(100);
                        
            while(rs.next()){
                keyFieldName = rs.getString("COLUMN_NAME");
                keyFieldName = WFSUtil.TO_SANITIZE_STRING(keyFieldName,true);
                if(isFirstColumn){
                    selectKeyString.append(keyFieldName);                    
                    updateKeyString.append(keyFieldName);
                    updateKeyString.append(" = ?");
                    isFirstColumn = false;
                }else{
                    selectKeyString.append(",");
                    selectKeyString.append(keyFieldName);
                    updateKeyString.append(" and ");
                    updateKeyString.append(keyFieldName);
                    updateKeyString.append(" = ?");
                }                
            }
            
            if(rs != null){
                rs.close();
                rs = null;
            }           
                
            rs = stmt.executeQuery("select "+WFSUtil.TO_SANITIZE_STRING(colName,true)+","+selectKeyString.toString()+" from "+WFSUtil.TO_SANITIZE_STRING(tableName,false)+" ");
            rsmtd = rs.getMetaData(); 
            colCount = rsmtd.getColumnCount();
            isImageColumnNullable = rsmtd.isNullable(1);
            tempColName = "temp" + WFSUtil.TO_SANITIZE_STRING(colName,true);
            addTempColumn(con, dbType, tableName, tempColName, isImageColumnNullable);
           
                        
            while(rs.next()){
                
                result = getBIGData(con, rs, colName, 1, "8859_1");
                actIcon = (String)result[0];
                
                //icon = rs.getBytes(colName);
                
                //writeInFile(actIcon);
                /*tempColName = "temp" + colName;
                if(i==0){
                    addTempColumn(con, dbType, tableName, tempColName, isImageColumnNullable);
                    i = 1;
                }*/
                //String newactIcon = EncodeImage.encodeImageData(icon).toString();//Removed as encoded data is already present in the database

                pstmt = con.prepareStatement("update "+WFSUtil.TO_SANITIZE_STRING(tableName,false)+"  set "+WFSUtil.TO_SANITIZE_STRING(tempColName,true)+" = ? where "+WFSUtil.TO_SANITIZE_STRING(updateKeyString.toString(),true));
                pstmt.setString(1,actIcon);
                int k;
                for(k = 2; k <= colCount; k++){
                    if(rsmtd.getColumnType(k) == java.sql.Types.INTEGER)
                        pstmt.setInt(k, rs.getInt(k));
                    else
                        pstmt.setString(k, rs.getString(k));
                }
             
                pstmt.execute();
            }
            stmt = con.createStatement();
            if(dbType == JTSConstant.JTS_MSSQL){
                stmt.execute("alter table "+WFSUtil.TO_SANITIZE_STRING(tableName,false)+" drop column "+WFSUtil.TO_SANITIZE_STRING(colName,true)+" ");
                stmt.execute("exec sp_rename  @objname = '"+WFSUtil.TO_SANITIZE_STRING(tableName,false)+"."+WFSUtil.TO_SANITIZE_STRING(tempColName,true)+"', @newname ="+WFSUtil.TO_SANITIZE_STRING(colName,true)+", @objtype = 'COLUMN'");            
            }else{
                stmt.execute("alter table "+WFSUtil.TO_SANITIZE_STRING(tableName,false)+" drop column "+WFSUtil.TO_SANITIZE_STRING(colName,true)+" ");
                stmt.execute("alter table "+WFSUtil.TO_SANITIZE_STRING(tableName,false)+" rename column "+WFSUtil.TO_SANITIZE_STRING(tempColName,true)+" to "+WFSUtil.TO_SANITIZE_STRING(colName,true)+"");            
            }            
        }catch(SQLException se){
            // se.printStackTrace();
        	 printErr(engine,"", se);
        }catch(Exception e){
            //  e.printStackTrace();
        	 printErr(engine,"", e);
        }finally{
            try{
                 if(rs != null){
                    rs.close();
                    rs = null;
                }
            }catch(SQLException se){
            	 WFSUtil.printErr(engine,"", se);
            }
            try{
                if(stmt != null){
                    stmt.close();
                    stmt = null;
                }
            }catch(SQLException se){
            	WFSUtil.printErr(engine,"", se);
            }
            try{
                if(pstmt != null){
                    pstmt.close();
                    pstmt = null;
                }
            }catch(SQLException se){
            	WFSUtil.printErr(engine,"", se);
            }
        }
	}
	/*
 Omniflow Mobile Support --Data to be inserted into WFWorkListConfigTable.
 * Sajid Khan--30 Jan 2014.
 */
public static void insertIntoWFWorkListConfig(Connection con, int qId,String engine) throws WFSException{
        PreparedStatement pstmtWListConfig = null;
        ResultSet rsVarTable = null;
        Statement stmt = null;
        int mainCode = 0;
        int subCode = 0;
        String subject = null;
        String descr = null;
        String errType = WFSError.WF_TMP;
		int dbType = ServerProperty.getReference().getDBType(engine);
        try {
            
            int varId = 0;
            String strQry = "";
			String displayName = "";
            stmt = con.createStatement();
            pstmtWListConfig = con.prepareStatement("Select Distinct VariableId, SystemDefinedName from VarMappingTable " + WFSUtil.getTableLockHintStr(dbType) + " where  VariableId IN (29,31,32,37,38,46,48,49,52)");
            //pstmtWListConfig.setInt(1, processDefId);
            pstmtWListConfig.execute();
            rsVarTable = pstmtWListConfig.getResultSet();
            while (rsVarTable.next()) {				
                strQry =  "Insert Into WFWorkListConfigTable (QueueId,VariableId,AliasId,VariableType,ViewCategory,DisplayName,MobileDisplay) Values ("+qId+ ", "+varId+", 0,'S','M','" + displayName +"','Y')";
                printOut(engine,"insertIntoWFWorkListConfig>>>InsertQuerry>>"+strQry);
                varId = rsVarTable.getInt(1);
                if(varId == 31){//Bug 67849 - Registration No should be the default value for ProcessInstanceId variable to maintain consistency.
                    displayName = "Registration No";
                }else if(varId == 49){//Bug 67849 - Workstep Name  should be the default value for ActivityName variable to maintain consistency.
                    displayName = "Workstep Name";
                }else{
				displayName = rsVarTable.getString(2);
                }
                stmt.executeUpdate("Insert Into WFWorkListConfigTable (QueueId,VariableId,AliasId,VariableType,ViewCategory,DisplayName,MobileDisplay) Values ("+qId+ ", "+varId+", 0,'S','M','" + WFSUtil.TO_SANITIZE_STRING(displayName, true) +"','Y')" );
            }
         

        } catch (SQLException e){
                printErr(engine,"", e);
                mainCode = WFSError.WM_INVALID_FILTER;
                subCode = WFSError.WFS_SQL;
                subject = WFSErrorMsg.getMessage(mainCode);
                errType = WFSError.WF_FAT;
                if(e.getErrorCode() == 0){
                    if(e.getSQLState().equalsIgnoreCase("08S01")){
                        descr = (new JTSSQLError(e.getSQLState())).getMessage() + "(SQL State : " + e.getSQLState() + ")";
                    }
                } else{
                    descr = e.getMessage();
                }
            }catch(NumberFormatException e){
                WFSUtil.printErr(engine,"", e);
                mainCode = WFSError.WF_OPERATION_FAILED;
                subCode = WFSError.WFS_ILP;
                subject = WFSErrorMsg.getMessage(mainCode);
                errType = WFSError.WF_TMP;
                descr = e.toString();
            }catch(Exception e){
                printErr(engine,"", e);
                mainCode = WFSError.WF_OPERATION_FAILED;
                subCode = WFSError.WFS_EXP;
                subject = WFSErrorMsg.getMessage(mainCode);
                errType = WFSError.WF_TMP;
                descr = e.toString();
            }catch(Error e){
                WFSUtil.printErr(engine,"", e);
                mainCode = WFSError.WF_OPERATION_FAILED;
                subCode = WFSError.WFS_EXP;
                subject = WFSErrorMsg.getMessage(mainCode);
                errType = WFSError.WF_TMP;
                descr = e.toString();
            } finally {
                // WFS_6_004, Statement closed in finally.
            	try {  
    				if(rsVarTable!=null){
    					rsVarTable.close();
    					rsVarTable = null;
    				}
    			}catch(Exception e){
    				WFSUtil.printErr(engine,"", e);
    			}
                try {
                    if (stmt != null) {
                        stmt.close();
                        stmt = null;
                    }
                } catch (Exception ignored) {
                	 WFSUtil.printErr(engine,"", ignored);
                }
                try {
                    if (pstmtWListConfig != null) {
                        pstmtWListConfig.close();
                        pstmtWListConfig = null;
                    }
                } catch (Exception ignored) {
                	 WFSUtil.printErr(engine,"", ignored);
                }
             
            }
        if(mainCode != 0){
            throw new WFSException(mainCode, subCode, errType, subject, descr);
    }
}

/*
 Omniflow Mobile Support --Data to be inserted or deleted into/from WFWorkListConfigTable.
 * Sajid Khan--30 Jan 2014.
 */
public static void changeWorkListConfig(Connection con, int qId,XMLParser parser,String operation,String engine) throws JTSException,WFSException{
        PreparedStatement pstmt = null;
        PreparedStatement pstmt1 = null;
        ResultSet rs = null;
        Statement stmt = null;
        int mainCode = 0;
        int subCode = 0;
        String subject = null;
        String descr = null;
		String displayName = "";
		String mobileDisplay = "";
        String errType = WFSError.WF_TMP;
		int dbType = ServerProperty.getReference().getDBType(engine);
        try {
            int varId = 0;
            int aliasId = 0;
            String varType = "";
            String strQry = "";
            stmt = con.createStatement();
          
            ArrayList mobFieldList = new ArrayList();

            if (operation.equalsIgnoreCase("I")){
                String viewCategoryStr = parser.getValueOf("ViewCategory", "M", true);
                int noOfFields = parser.getNoOfFields("Variable");
                if(noOfFields > 0) {
                            pstmt1 = con.prepareStatement("Select * from WFWorkListConfigTable " + WFSUtil.getTableLockHintStr(dbType) + "  where QueueId = ?");
                            pstmt1.setInt(1, qId);
                            rs = pstmt1.executeQuery();
                            if(rs.next()){
                                pstmt = con.prepareStatement("Delete from WFWorklistConfigTable where QueueID = ? ");
                                pstmt.setInt(1, qId);
                                pstmt.execute();
                            }
                         mobFieldList.add(parser.getFirstValueOf("Variable"));
                         for(int i = 1; i < noOfFields; i++) {
                            mobFieldList.add(parser.getNextValueOf("Variable"));
                         }
                         mobFieldList.add(parser.getFirstValueOf("Variable"));

                         for(int i = 0; i < noOfFields; i++){
                             parser.setInputXML((String) mobFieldList.get(i));
                             varId = parser.getIntOf("VariableId", 0, true);
                             varType = parser.getValueOf("VariableType", "S", true);
							 displayName = parser.getValueOf("DisplayName", "", true);
							 mobileDisplay = parser.getValueOf("MobileDisplay", "", true);
                             if(varType.equalsIgnoreCase("A")){
                                 aliasId = varId;
                                 varId = 0;
                             }
                             strQry =  "Insert Into WFWorkListConfigTable (QueueId,VariableId,AliasId,VariableType,ViewCategory,DisplayName,MobileDisplay) Values ("+qId+ ", "+varId+","+aliasId+",'"+varType+"','"+viewCategoryStr+"','" + displayName + "','" + mobileDisplay + "')";
                             printOut(engine,"insertIntoWFWorkListConfig>>>InsertQuerry>>"+strQry);
                             stmt.executeUpdate(strQry);
                          }
                    }
            }else if(operation.equalsIgnoreCase("D")){
                    pstmt = con.prepareStatement("Delete from WFWorklistConfigTable where QueueID = ? ");
                    pstmt.setInt(1, qId);
                    pstmt.execute();
            }
      

        }catch (SQLException e){
                printErr("", e);
                mainCode = WFSError.WM_INVALID_FILTER;
                subCode = WFSError.WFS_SQL;
                subject = WFSErrorMsg.getMessage(mainCode);
                errType = WFSError.WF_FAT;
                if(e.getErrorCode() == 0){
                    if(e.getSQLState().equalsIgnoreCase("08S01")){
                        descr = (new JTSSQLError(e.getSQLState())).getMessage() + "(SQL State : " + e.getSQLState() + ")";
                    }
                } else{
                    descr = e.getMessage();
                }
            }catch(NumberFormatException e){
                WFSUtil.printErr(engine,"", e);
                mainCode = WFSError.WF_OPERATION_FAILED;
                subCode = WFSError.WFS_ILP;
                subject = WFSErrorMsg.getMessage(mainCode);
                errType = WFSError.WF_TMP;
                descr = e.toString();
            }catch(Exception e){
                printErr(engine,"", e);
                mainCode = WFSError.WF_OPERATION_FAILED;
                subCode = WFSError.WFS_EXP;
                subject = WFSErrorMsg.getMessage(mainCode);
                errType = WFSError.WF_TMP;
                descr = e.toString();
            }catch(Error e){
                WFSUtil.printErr(engine,"", e);
                mainCode = WFSError.WF_OPERATION_FAILED;
                subCode = WFSError.WFS_EXP;
                subject = WFSErrorMsg.getMessage(mainCode);
                errType = WFSError.WF_TMP;
                descr = e.toString();
            } finally {
                // WFS_6_004, Statement closed in finally.
               
            	try {  
    				if(rs!=null){
    					rs.close();
    					rs = null;
    				}
    			}catch(Exception e){
    				WFSUtil.printErr(engine,"", e);
    			}
            	
                try {
                    if (stmt != null) {
                        stmt.close();
                        stmt = null;
                    }
                } catch (Exception ignored) {
                	WFSUtil.printErr(engine,"", ignored);
                }
                try {
                    if (pstmt != null) {
                        pstmt.close();
                        pstmt = null;
                    }
                } catch (Exception ignored) {
                	WFSUtil.printErr(engine,"", ignored);
                }
                try {
                    if (pstmt1 != null) {
                        pstmt1.close();
                        pstmt1 = null;
                    }
                } catch (Exception ignored) {
                	WFSUtil.printErr(engine,"", ignored);
                }
              
              
            }
            if(mainCode != 0){
                throw new WFSException(mainCode, subCode, errType, subject, descr);
        }
     }

	
	/**
     * *************************************************************
     * Function Name    :   addTempColumn
     * Author			:   Anwar Ali Danish
     * Date Written     :   27/09/2012
     * Input Parameters :   Connection con, int dbType, String tableName,String tempColName,int nullableStatus
     * Output Parameters:   
     * Return Value     :   
     * Description      : 	Method to add temporary column in Existing Table  
     * *************************************************************
     */	
	 
	 
	public static void addTempColumn(Connection con, int dbType, String tableName,String tempColName,int nullableStatus) throws SQLException{    
        PreparedStatement pstmt = null;
       // ResultSet rs = null;
        int count = 0;
        String setDefaultValue = null;
        String notNullString = null;
        try{
            String st = null;
            switch(dbType){
                case JTSConstant.JTS_MSSQL: {                  
                    
                    st = "alter table "+WFSUtil.TO_SANITIZE_STRING(tableName,false)+" add "+WFSUtil.TO_SANITIZE_STRING(tempColName,true)+" ntext ";
                    if(nullableStatus == 0){
                        setDefaultValue = "Update "+WFSUtil.TO_SANITIZE_STRING(tableName,false)+" set "+WFSUtil.TO_SANITIZE_STRING(tempColName,true)+" = 'Newgen'";
                        notNullString = "Alter table "+WFSUtil.TO_SANITIZE_STRING(tableName,false)+" Alter column "+WFSUtil.TO_SANITIZE_STRING(tempColName,true)+" ntext not null";
                    }
                        
                    break;
                }
                case JTSConstant.JTS_ORACLE: {
                
                    st = "alter table "+WFSUtil.TO_SANITIZE_STRING(tableName,false)+" add "+WFSUtil.TO_SANITIZE_STRING(tempColName,true)+" nclob ";
                    if(nullableStatus == 0){
                       setDefaultValue = "Update "+WFSUtil.TO_SANITIZE_STRING(tableName,false)+" set "+WFSUtil.TO_SANITIZE_STRING(tempColName,true)+" = 'Newgen'";
                       notNullString = "Alter table "+WFSUtil.TO_SANITIZE_STRING(tableName,false)+" modify "+WFSUtil.TO_SANITIZE_STRING(tempColName,true)+" not null";
                    }
                    
                    break;
                    
                }
                case JTSConstant.JTS_POSTGRES: {
                    st = "alter table "+WFSUtil.TO_SANITIZE_STRING(tableName,false)+" add "+WFSUtil.TO_SANITIZE_STRING(tempColName,true)+" ntext ";
                    if(nullableStatus == 0){
                       setDefaultValue = "Update "+WFSUtil.TO_SANITIZE_STRING(tableName,false)+" set "+WFSUtil.TO_SANITIZE_STRING(tempColName,true)+" = 'Newgen'";
                       notNullString = "ALTER TABLE "+WFSUtil.TO_SANITIZE_STRING(tableName,false)+" ALTER COLUMN "+WFSUtil.TO_SANITIZE_STRING(tempColName,true)+" SET NOT NULL";
                    }
                    break;
                }
            }             
            
            pstmt = con.prepareStatement(WFSUtil.TO_SANITIZE_STRING(st,true));
//            pstmt.setString(1,tableName);
//            pstmt.setString(2,tempColName);
            count = pstmt.executeUpdate();
            if(pstmt != null){
                pstmt.close();
                pstmt = null;
            }
            if(nullableStatus == 0){
                pstmt = con.prepareStatement(WFSUtil.TO_SANITIZE_STRING(setDefaultValue,true));
                count = pstmt.executeUpdate();
                if(pstmt != null){
                    pstmt.close();
                    pstmt = null;
                }
                pstmt = con.prepareStatement(WFSUtil.TO_SANITIZE_STRING(notNullString,true));
                count = pstmt.executeUpdate();
                if(pstmt != null){
                    pstmt.close();
                    pstmt = null;
                }
                
            }
            
            
        }catch(SQLException se){
            //se.printStackTrace();
        }finally{
             try{
            if(pstmt != null){
                    pstmt.close();
                    pstmt = null;
                }
//                 if(rs != null){
//                    rs.close();
//                    rs = null;
//                }
            }catch(SQLException se){
            }
       }
    }		
    public static boolean jdbcCallableExecute(CallableStatement cstmt, String engine, String queryString) throws Exception{
        boolean res = false;
        StringBuilder message = new StringBuilder();
        long startTime = 0l;    
        long endTime = 0l;    
        long timeDiff = 0l;
        try{
        	int queryTimeout = getQueryTimeOut();
            startTime = System.currentTimeMillis();
            if(queryTimeout <= 0)
      			cstmt.setQueryTimeout(60);
        	else
      			cstmt.setQueryTimeout(queryTimeout);
            res = cstmt.execute();    
            endTime = System.currentTimeMillis();    
            timeDiff = endTime-startTime;
        }finally{
            message.append(" StartTime: ");
			message.append(startTime);
			message.append(" EndTime: ");
			message.append(endTime);
			message.append(" Difference: ");	
			message.append(timeDiff);
            message.append(" QueryString: ");	
			message.append(queryString);
            if(engine != null)
                NGUtil.writeQueryLog(engine, WFSConstant.CONST_MODULE_NAME, message);
                //WFLogger.printQuery(message,engine);
        }
    return res;
    }  
	
	// Merging of Bug 37658  - Mail trigger Mails to be in transaction with create workitem
		/**
     * *************************************************************
     * Function Name    :   addToMailQueue
     * Programmer' Name :   Ashish Mangla
     * Date Written     :   04/01/2012
     * Input Parameters :   String userName, Connection con, XMLParser parser, XMLGenerator gen
     * Description      :   Makes entry in WF Mail Queue Table
     * *************************************************************
     */
  public static StringBuffer addToMailQueue(String userName, Connection con, XMLParser parser, XMLGenerator gen) throws
        JTSException, WFSException{
		
		/**
		* No need to check session here Session should be already checked in WFMailAgent / OraCreateWorkitem.
		* No need to open transaction here, OraCreateWorkitem will open transcation and close itself.
		* No tranasaction required in WFMailAgent
		* Where to parse the data ?  - In WFMailAgent / WMCreate or here ??
		*/
        StringBuffer outputXML = null;
        PreparedStatement pstmt = null;
        int mainCode = 0;
        int subCode = 0;
        String subject = null;
        String descr = null;
        String errType = WFSError.WF_TMP;
        ResultSet rs=null;
        try{
            String engine = parser.getValueOf("EngineName");
            int dbType = ServerProperty.getReference().getDBType(engine);

			String strFrom = parser.getValueOf("MailFrom");
			String strTo = parser.getValueOf("MailTo");
			String strCC = parser.getValueOf("MailCC");
			String strBCC = parser.getValueOf("MailBCC");
			String strSubject = parser.getValueOf("MailSubject"); 
			String strMessage = parser.getValueOf("MailMessage"); 
			String strContentType = parser.getValueOf("ContentType");
			String strAttachments = parser.getValueOf("AttachmentISIndex");
			String strAttachmentNames = parser.getValueOf("AttachmentNames");
			String strAttachmentExts = parser.getValueOf("AttachmentExts");
			int iPriority = parser.getIntOf("Priority", 1, true);
			String strComments = parser.getValueOf("Comments");
			String strMailActionType = parser.getValueOf("MailActionType");
			String strAgentName = parser.getValueOf("AgentName");
			int iProcessDefId = parser.getIntOf("ProcessDefId", 0, true);
			String strProcessInstanceId = parser.getValueOf("ProcessInstanceId");
			int iWorkitemId = parser.getIntOf("WorkitemId", 0, true);
			int iActivityId = parser.getIntOf("ActivityId", 0, true);
			if(strAgentName == null || strAgentName.trim().equalsIgnoreCase(""))
				strAgentName = userName;
			//WFS_8.0_094
			if(iPriority > 3){
				iPriority = 3;
			}else if(iPriority < 1){
				iPriority =1;
			}
			if(strContentType.toUpperCase().contains("HTML"))
			{   if(!strMessage.toUpperCase().contains("</HTML>"))
					 strMessage = "<html><body>"+strMessage.replaceAll("\n","<br>")+"</body></html>";
			}
			String strSQL = "INSERT INTO WFMailQueueTable (mailFrom, mailTo, mailCC, mailSubject, mailMessage, " 
				+ "mailContentType, attachmentISINDEX, attachmentNames, mailPriority, mailStatus, statusComments, " 
				+ "insertedTime, insertedBy, mailActionType, processDefId, processInstanceId, workitemId, activityId, " 
				+ "attachmentExts, noOfTrials, mailBCC ) values(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?," + WFSUtil.getDate(dbType) 
				+ ", ?, ?, ?, ?, ?, ?, ?, ?, ?) ";
			pstmt = con.prepareStatement(strSQL);
			WFSUtil.DB_SetString(1, strFrom, pstmt, dbType);
			WFSUtil.DB_SetString(2, strTo, pstmt, dbType);
			WFSUtil.DB_SetString(3, strCC, pstmt, dbType);
			if(dbType!=JTSConstant.JTS_POSTGRES){
				pstmt.setNString(4, strSubject);
				pstmt.setNCharacterStream(5, new java.io.StringReader(strMessage), strMessage.length());
			}
			else
			{
				WFSUtil.DB_SetString(4, strSubject, pstmt, dbType);
				pstmt.setCharacterStream(5, new java.io.StringReader(strMessage), strMessage.length());
			}
			WFSUtil.DB_SetString(6, strContentType, pstmt, dbType);
			WFSUtil.DB_SetString(7, strAttachments, pstmt, dbType);
			WFSUtil.DB_SetString(8, strAttachmentNames, pstmt, dbType);
			pstmt.setInt(9, iPriority);
			WFSUtil.DB_SetString(10, "N", pstmt, dbType);
			WFSUtil.DB_SetString(11, strComments, pstmt, dbType);
			WFSUtil.DB_SetString(12, strAgentName, pstmt, dbType);
			WFSUtil.DB_SetString(13, strMailActionType, pstmt, dbType);
			pstmt.setInt(14, iProcessDefId);
			WFSUtil.DB_SetString(15, strProcessInstanceId, pstmt, dbType);
			pstmt.setInt(16, iWorkitemId);
			pstmt.setInt(17, iActivityId);
			WFSUtil.DB_SetString(18, strAttachmentExts, pstmt, dbType);
			pstmt.setInt(19, 0);
			WFSUtil.DB_SetString(20, strBCC, pstmt, dbType);
			pstmt.execute();
			pstmt.close();
			pstmt = null;

			outputXML = new StringBuffer(500);
			outputXML.append(gen.createOutputFile("WFAddToMailQueue"));
			outputXML.append("<Exception>\n<MainCode>0</MainCode>\n</Exception>\n");
			outputXML.append(gen.closeOutputFile("WFAddToMailQueue"));
                        // Generating audit log for action Add_To_MailQueue
            pstmt = con.prepareStatement(" Select ActivityName from ActivityTable  where ProcessDefId = ? and ActivityId = ? ");
            pstmt.setInt(1, iProcessDefId);
            pstmt.setInt(2, iActivityId);
            pstmt.execute();
            rs = pstmt.getResultSet();
            String actName = "";
            if (rs.next()) {
                actName = rs.getString(1);
            }
             if(rs != null){
                rs.close();
                rs = null;
             }
            StringBuilder fieldName = new StringBuilder();
            fieldName.append("<MailFrom>").append(strFrom).append("</MailFrom>");
            fieldName.append("<MailTo>").append(strTo).append("</MailTo>");
            fieldName.append("<MailCC>").append(strCC).append("</MailCC>");
            fieldName.append("<MailSubject>").append(strSubject).append("</MailSubject>");
            WFSUtil.generateLog(engine, con, WFSConstant.ACTION_ADD_TO_MAILQUEUE, strProcessInstanceId, iWorkitemId, iProcessDefId,
            iActivityId, actName, 0, 0, userName, 0, fieldName.toString(), null, null, null, null, 1);
        } catch(SQLException e){
            WFSUtil.printErr("", e);
            mainCode = WFSError.WM_INVALID_FILTER;
            subCode = WFSError.WFS_SQL;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_FAT;
            if(e.getErrorCode() == 0){
                if(e.getSQLState().equalsIgnoreCase("08S01"))
                    descr = (new JTSSQLError(e.getSQLState())).getMessage() + "(SQL State : " +
                        e.getSQLState() + ")";
            } else
                descr = e.getMessage();
        } catch(JTSException e){
            WFSUtil.printErr("", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = e.getErrorCode();
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.getMessage();
        } catch(Exception e){
            WFSUtil.printErr("", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch(Error e){
            WFSUtil.printErr("", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } finally{
        	try {  
				if(rs!=null){
					rs.close();
					rs = null;
				}
			}catch(Exception e){
				 WFSUtil.printErr("", e);
			}
            try{
                if(pstmt != null){
                    pstmt.close();
                    pstmt = null;
                }
            } catch(Exception e){
            	 WFSUtil.printErr("", e);
            }
           
        }
        if(mainCode != 0)
            throw new WFSException(mainCode, subCode, errType, subject, descr);
        return outputXML;
    }	
  
  /*******************************************************************************************************************************
   * Function Name    :   fetchTaskData
   * Programmer' Name :   Mohnish Chopra/Sajid Khan
   * Date Written     :   29/04/2015
   * Input Parameters :   Connection con, int iProcDefId, int iActId, int taskId ,int subTaskId,String procInstID,
   *                      int workItemID,int sessionId,int userId,int dbType,boolean debugFlag, String cabinet,
   *                      XMLGenerator gen,boolean isMappedFlag
   * Output Parameters:   None.
   * Return Value     :   String
   * Description      :   Method to fetch task Data
   * 
   * *****************************************************************************************************************************
   */
  public static LinkedHashMap fetchTaskData(Connection con, int iProcDefId, int iActId, int taskId ,int subTaskId,
          String procInstID, int workItemID,int sessionId,int userId,int dbType,boolean debugFlag, String cabinet,
          XMLGenerator gen,boolean isMappedFlag) throws SQLException{
	  	PreparedStatement pstmt = null;
                Statement stmt = null;
	  	StringBuffer queryString =new StringBuffer(100);
	  	ArrayList parameters = new ArrayList();
	  	ResultSet rs = null;
                ResultSet rs1 = null;
	  	int taskType  =0;
	  	int templateId =0;
                int variableId = 0;
                StringBuffer selectQueryString = new StringBuffer();
	  	LinkedList<String> variableList = new LinkedList<String>();
	  	StringBuffer tempXML = new StringBuffer();
                //boolean isMappedFlag = true;//If isMapped is true then return a hashmap containgin key as templatevariableid and values as Mapped variable value
                LinkedHashMap fieldValueMap = new LinkedHashMap();
                LinkedHashMap varValueMap = new LinkedHashMap();
                LinkedHashMap tempVarIdValueMap = new LinkedHashMap();
                String qVariables = "";
                String extVariables= "";
                TreeMap<Integer,String> qVarMap = new TreeMap<Integer,String>();
                TreeMap<Integer,String> extVarMap = new TreeMap<Integer,String>();
                HashMap complexMap = new HashMap();
                String extTableName = null;
                String complexTableName = null;
                String complexFieldName = null;
                String value = null;
                int relationId = 0;
                int typeId = 0;
                int varType = 0;
                int previousTypeId = 0;
                String parentObj = null;//Variable to store PArent Table to which The RefKey is Mapped
                String foreignKey = null;//Field of the Parent Table to which the RefKey is Mapped
                String refKey = null;//Reference Key in Child Table[Complex Table]
                boolean isEmptyTemplate = true;
	  	try{
	            if(isMappedFlag){
                            if(rs!=null){
                                rs.close();
                                rs = null;
                            }
                            if(pstmt!=null){
                                pstmt.close();
                                pstmt = null;
                            }
                            int exObjId = 0;
                            int typeFieldId = 0;
                            int tempVarId = 0;
                            int qCount = 0;
                            String sysDefName = "";
                            String  strQry = "select a.TemplatevariableId, a.TypefieldId,b.SystemDefinedName, b.ExtObjId, a.VariableId from"
                            + " WFTaskVariableMappingTable a Inner join VARMAPPINGTABLE b on a.ProcessDefId = b.Processdefid"
                             + " and a.VariableId = b.Variableid where a.ProcessDefId = ? and a.ActivityId = ? and a.TaskId = ? order by a.TemplatevariableId ";
                            pstmt = con.prepareStatement(strQry);
                            pstmt.setInt(1,iProcDefId);
                            pstmt.setInt(2,iActId);
                            pstmt.setInt(3,taskId);
                            rs = pstmt.executeQuery();
                            while(rs.next()){
                                tempVarId = rs.getInt(1);
                                typeFieldId = rs.getInt(2);
                                sysDefName = rs.getString(3);
                                exObjId = rs.getInt(4);
                                variableId = rs.getInt(5);
                                if(exObjId==0){                                                          //For Queue Variables
                                   // varValueMap.put(tempVarId,sysDefName);
                                    if(sysDefName.equalsIgnoreCase("ProcessInstanceName")){
                                        sysDefName = "ProcessInstanceId"; 
                                    }
                                    qVariables += ","+sysDefName;
                                    qVarMap.put(tempVarId,sysDefName);
                                  
                                }else if(exObjId==1){                                                   //For External Variables
                                    if(extTableName==null){
                                            if(stmt!=null){
                                               stmt.close();
                                               stmt = null;
                                            }
                                            if(rs1!=null){
                                               rs1.close();
                                               rs1 = null;
                                            }
                                            stmt = con.createStatement();
                                            rs1 = stmt.executeQuery("Select TableName from EXTDBCONFTABLE Where ProcessDefId  = "+iProcDefId+" And ExtObjId = 1");
                                            if(rs1.next()){
                                                extTableName = rs1.getString(1);
                                            }
                                    }
                                    //varValueMap.put(tempVarId,sysDefName);
                                    extVariables += ","+sysDefName;
                                    extVarMap.put(tempVarId,sysDefName);
                                }else{                                                          //Complex TYpe Variables
                                    if(stmt!=null){
                                        stmt.close();
                                        stmt = null;
                                    }
                                    if(rs1!=null){
                                       rs1.close();
                                       rs1 = null;
                                    }
                                   
                                  
                                    stmt = con.createStatement();
                                    rs1 = stmt.executeQuery("select  a.MappedObjectName, a.RelationId, b.ParentObject ,b.ForeignKey,b.refKey,a.TypeId FROM "
                                            + "WFUDTVarMappingTable a Inner Join WFVarRelationTable b on a.ProcessDefId = b.ProcessDefId and "
                                            + "a.RelationId = b.RelationId Where a.ProcessDefId = "+iProcDefId+" and a.VariableId = "+variableId);
                                    if(rs1.next()){
                                       complexTableName = rs1.getString(1);
                                       relationId = rs1.getInt(2);
                                       parentObj = rs1.getString(3);
                                       foreignKey = rs1.getString(4);
                                       refKey = rs1.getString(5);
                                       typeId = rs1.getInt(6);
                                    }
                                    
                                    if(stmt!=null){
                                        stmt.close();
                                        stmt = null;
                                    }
                                    if(rs1!=null){
                                       rs1.close();
                                       rs1 = null;
                                    }
                                    stmt = con.createStatement();
                //Get the VariableTYpe for the ComplexField
                                    rs1 = stmt.executeQuery("Select  WFType from WFTypeDefTable Where ProcessDefId  = "+iProcDefId+""
                                            + " And TypeFieldId = "+typeFieldId+" And  ParentTypeId = "+typeId);
                                    if(rs1.next()){
                                       varType = rs1.getInt(1);
                                    }
                                    if(stmt!=null){
                                        stmt.close();
                                        stmt = null;
                                    }
                                    if(rs1!=null){
                                       rs1.close();
                                       rs1 = null;
                                    }
                                    stmt = con.createStatement();
                                    rs1 = stmt.executeQuery("Select  MappedObjectName From WFUDTVarMappingTable Where ProcessDefId  = "+iProcDefId+""
                                            + " And TypeFieldId = "+typeFieldId+" And  VariableId = "+variableId);
                                    if(rs1.next()){
                                       complexFieldName = rs1.getString(1);
                                    }
                                    complexMap.put(tempVarId, new ComplexDataClass(complexTableName,complexFieldName,parentObj,foreignKey,refKey,varType));
                                }
                            }
                    if(!qVariables.equals("")){                 //Updating the varValue map with the value of Queue variable if it is mapped with it.
                                qVariables  = qVariables.substring(1);
                                String qFieldValueQry = " Select "+WFSUtil.TO_SANITIZE_STRING(qVariables, true)+" From WFInstrumentTable "+getLockPrefixStr(dbType)+""
                                        + " Where ProcessInstanceId = ? And ActivityId = ? and WorkItemId = ? and ProcessDefId = ? ";
                                if(rs!=null){
                                    rs.close();
                                    rs = null;
                                }
                                if(pstmt!=null){
                                    pstmt.close();
                                    pstmt = null;
                                }
                                pstmt = con.prepareStatement(qFieldValueQry);
                                WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
                                pstmt.setInt(2, iActId);
                                pstmt.setInt(3,workItemID);
                                pstmt.setInt(4, iProcDefId);
                                rs = pstmt.executeQuery();
                                if(rs.next()){
                                    Set<Integer> keys = qVarMap.keySet();
                                    int i = 1;
                                    for(Integer key:keys){
                                      value = rs.getString(i);
                                      if(!(value==null || ("").equals(value)))
                                             varValueMap.put(key,value);//Updating the Map with QVariable Value.
                                      i++;
                                    }
                                }
                            }
                        if(!extVariables.equals("")){               //Updating the varValue map with the value of external variable if it is mapped with it.
                                if(stmt!=null){
                                   stmt.close();
                                   stmt = null;
                                }
                                if(rs1!=null){
                                   rs1.close();
                                   rs1 = null;
                                }
                                if(rs!=null){
                                   rs.close();
                                   rs = null;
                                }
                                if(pstmt!=null){
                                   pstmt.close();
                                   pstmt = null;
                                }
                                String itemIndex = "";
                                String itemType = "";
                                stmt = con.createStatement();
                                rs1 = stmt.executeQuery("Select VAR_REC_1, VAR_REC_2 from WFInstrumentTable "+WFSUtil.getTableLockHintStr(dbType)+" Where "
                                        + "ProcessInstanceId = "+WFSUtil.TO_STRING(procInstID, true, dbType)+" And WorkItemId = 1");
                                if(rs1.next()){
                                    itemIndex = rs1.getString(1);
                                    itemType = rs1.getString(2);
                                }
                                extVariables  = extVariables.substring(1);
                                String extFieldQry = " Select "+WFSUtil.TO_SANITIZE_STRING(extVariables, true)+" From "+WFSUtil.TO_SANITIZE_STRING(extTableName, false)+" "+getLockPrefixStr(dbType)+""
                                        + " Where ItemIndex = ? And ItemType = ? ";
                               
                                pstmt = con.prepareStatement(extFieldQry);
                                pstmt.setString(1, itemIndex);
                                pstmt.setString(2, itemType);
                                rs = pstmt.executeQuery();
                                if(rs.next()){
                                    Set<Integer> keys = extVarMap.keySet();
                                    int i = 1;
                                    for(Integer key:keys){
                                       value = rs.getString(i);
                                       if(!(value==null || ("").equals(value)))
                                             varValueMap.put(key,value);
                                       i++;
                                    }
                                }
                        }
                            
                        if(!complexMap.isEmpty()){
                                String strQry1 = null;
                                String mappedValue = null;//Value of the ForeignKey which needs to be compared to the child table RefKeyField.
                                String complexVarValueQry = null;
                                Set<Integer> keys = complexMap.keySet();
                                for(Integer key:keys){
                                        if(pstmt!=null){
                                           pstmt.close();
                                           pstmt = null;
                                        }
                                        if(rs1!=null){
                                            rs1.close();
                                            rs1 = null;
                                        }
                                        if(stmt!=null){
                                           stmt.close();
                                           stmt = null;
                                        }
                                        ComplexDataClass complexData = null;
                                        complexData = (ComplexDataClass)complexMap.get(key);
                                        refKey = complexData.refKey;
                                        parentObj = complexData.parentObj;
                                        foreignKey = complexData.foreignKey;
                                        complexFieldName = complexData.complexFieldName;
                                        complexTableName = complexData.complexTableName;
                                        varType = complexData.varType;
                        //Get the value of foreignKey  from ParentTable which is mapped with the refKey.
                                        strQry1 = "Select "+WFSUtil.TO_SANITIZE_STRING(foreignKey, false)+" From "+WFSUtil.TO_SANITIZE_STRING(parentObj, true)+" Where ProcessInstanceId = ?  And WorkItemId = ?  "
                                                + "And ProcessDefId = ?";
                                        pstmt = con.prepareStatement(strQry1);
                                        WFSUtil.DB_SetString(1, procInstID, pstmt, dbType);
                                        pstmt.setInt(2,workItemID);
                                        pstmt.setInt(3, iProcDefId);
                                        rs1= pstmt.executeQuery();
                                        if(rs1.next()){
                                              mappedValue = rs1.getString(1);        
                                        }
                                        if(rs1!=null){
                                            rs1.close();
                                            rs1 = null;
                                        }
                                      //  if(varType==WFSConstant.WF_INT || varType==WFSConstant.WF_LONG ||varType==WFSConstant.WF_FLT)
                                        //    mappedValue = mappedValue;
                                         if(varType==WFSConstant.WF_STR)
                                            mappedValue = TO_STRING(mappedValue, true, dbType);
                                        else
                                            mappedValue = "'"+mappedValue+"'";
                                        
                                        strQry1 = "Select "+WFSUtil.TO_SANITIZE_STRING(complexFieldName, true)+" From "+WFSUtil.TO_SANITIZE_STRING(complexTableName, false)+" Where "+WFSUtil.TO_SANITIZE_STRING(refKey, true)+" = "+WFSUtil.TO_SANITIZE_STRING(mappedValue, true);
                                        pstmt = con.prepareStatement(strQry1);
                                        rs1 = pstmt.executeQuery();
                                        if(rs1.next()){
                                            value = rs1.getString(1);
                                        }
                                        if(!(value==null || ("").equals(value)))
                                              varValueMap.put(key,value);
                             }
                        }
                 }
                if(!isMappedFlag){
//	  		queryString.append("Select TaskType,TemplateId from WFTaskDefTable where TaskId = ? And ProcessDefId = ? ");
//	  		pstmt = con.prepareStatement(queryString.toString());
//	  		pstmt.setInt(1, taskId);
//                        pstmt.setInt(2,iProcDefId);
//
//	  		parameters.addAll(Arrays.asList(taskId));
//	  		//pstmt.execute();
//	  		jdbcExecute(procInstID,sessionId,userId,queryString.toString(),pstmt,parameters,debugFlag,cabinet);
//	  		rs = pstmt.getResultSet();
//	  		if (rs.next()) {
//	  			taskType = rs.getInt("TaskType");
//	  			templateId =rs.getInt("TemplateId");
//	  		}
//	  		if(rs!=null){
//	  			rs.close();
//	  			rs = null;
//	  		}
//	  		if(pstmt!=null){
//	  			pstmt.close();
//	  			pstmt = null;
//	  		}
                        
	  		queryString=new StringBuffer();
	  		String scope = "P";
	  		boolean useSeparateTable = false;
            if(taskId>0){
            	String taskQry = "Select Scope,UseSeparateTable from WFTaskDefTable " +WFSUtil.getTableLockHintStr(dbType)+ " where  ProcessDefId =? And TaskId = ?";
            	pstmt = con.prepareStatement(taskQry);
            	pstmt.setInt(1, iProcDefId);
            	pstmt.setInt(2, taskId);

            	rs = pstmt.executeQuery();
            	if(rs.next()){
            		scope= rs.getString("Scope");
            		useSeparateTable = rs.getString("UseSeparateTable").equalsIgnoreCase("Y");
            	}
            }
            if(rs!=null){
            	rs.close();
            	rs=null;
            }
            if(pstmt!=null){
            	pstmt.close();
            	pstmt=null;
            }
	  		String tableName =getTableNameForTask(iProcDefId,taskId,scope);

            if(useSeparateTable&&scope.equalsIgnoreCase("U") ){
            	tableName =getTableNameForTask(iProcDefId,taskId,"P");
            }


	  		queryString.append("Select TemplateVariableId, TaskVariableName,DisplayName,VariableType from WFTaskTemplateFieldDefTable where ProcessDefId = ? and TaskId = ? ");
	  		pstmt = con.prepareStatement(queryString.toString());
	  		//pstmt.setInt(1, templateId==1?0:iProcDefId);
	  		pstmt.setInt(1,iProcDefId);
                        pstmt.setInt(2,taskId);
	  		parameters.clear();
	  		parameters.addAll(Arrays.asList(iProcDefId,taskId));
	  		jdbcExecute(procInstID,sessionId,userId,queryString.toString(),pstmt,parameters,debugFlag,cabinet);
	  		rs = pstmt.getResultSet();
	  		selectQueryString.append("Select ");
	  		StringBuffer queryFilterString= new StringBuffer(200);
	  		while(rs.next()){
	  			isEmptyTemplate =false;
	  			int templateVarId = rs.getInt("TemplateVariableId");
	  			String variableName= rs.getString("TaskVariableName");
	  			queryFilterString.append(variableName);
	  			queryFilterString.append(",");
	  			int variableType= rs.getInt("VariableType");
  				variableList.add(variableName);
				fieldValueMap.put(templateVarId,variableName);
  				selectQueryString.append(WFSUtil.TO_SANITIZE_STRING(variableName, true));
  				selectQueryString.append(",");
	  		}
	  		if(rs!=null){
	  			rs.close();
	  			rs = null;
	  		}
	  		if(pstmt!=null){
	  			pstmt.close();
	  			pstmt = null;
	  		}
	  		//tempXML.append("</Attributes>");
	  		if(!isEmptyTemplate){
	  			if(scope.equalsIgnoreCase("U")&&(!useSeparateTable)){
	                LinkedHashMap taskVariableValueMap = new LinkedHashMap();

	  				queryFilterString.deleteCharAt(queryFilterString.length()-1);
	  				StringBuffer selectQueryForAdhocTable = new StringBuffer(100);
	  				selectQueryForAdhocTable .append("Select TaskVariableName, Value from ");
	  				selectQueryForAdhocTable .append(WFSUtil.TO_SANITIZE_STRING(tableName, false));
	  				selectQueryForAdhocTable .append(getTableLockHintStr(dbType));
	  				selectQueryForAdhocTable .append(" where processinstanceid =? and workitemid=? and activityId=? and taskId = ? ");
	  				
	  				pstmt=con.prepareStatement(selectQueryForAdhocTable.toString());
	  				pstmt.setString(1, procInstID);
	  				pstmt.setInt(2, workItemID);
	  				pstmt.setInt(3, iActId);
	  				pstmt.setInt(4, taskId);
	  				parameters.clear();
	  				parameters.addAll(Arrays.asList(procInstID,workItemID,iProcDefId,iActId,taskId));
	  				jdbcExecute(procInstID,sessionId,userId,selectQueryForAdhocTable.toString(),pstmt,parameters,debugFlag,cabinet);
	  				rs = pstmt.getResultSet();
	  				while(rs.next()){
	  					taskVariableValueMap .put(rs.getString("TaskVariableName"), rs.getString("Value")==null?"":rs.getString("Value"));
	  				}
                           Iterator iter= fieldValueMap.entrySet().iterator();
                           while (iter.hasNext()) {
                               Map.Entry pair = (Map.Entry)iter.next();
                               String varName = (String) pair.getValue();
                               int varId = (Integer) pair.getKey();
                               String varValue = (String)taskVariableValueMap.get(varName);
                               varValue=WFSUtil.handleSpecialCharInXml(varValue, false);
                               if(varValue == null){
                            	   varValueMap.put(varId, "");
                               }else{
                            	   varValueMap.put(varId,varValue);
                               }
                           }
//			String variableName = variableList.get(counter);
//			String variableValue = rs.getString(variableName);
//			if(!rs.wasNull()){
//			tempXML.append("<Attribute>");
//			tempXML.append(gen.writeValueOf("Name", variableName));
//			tempXML.append(gen.writeValueOf("Value", String.valueOf(variableValue)));
//			tempXML.append("</Attribute>");
//		}
		
		
	  			}
	  			else{
	  				selectQueryString.deleteCharAt(selectQueryString.length()-1);
	  				selectQueryString.append(" from ");
	  				selectQueryString.append(WFSUtil.TO_SANITIZE_STRING(tableName, false));
	  				selectQueryString.append(" where processinstanceid =? and workitemid=? and processdefid =? and activityId=? and taskId = ? and subtaskid=? ");
	  				pstmt=con.prepareStatement(selectQueryString.toString());
	  				pstmt.setString(1, procInstID);
	  				pstmt.setInt(2, workItemID);
	  				pstmt.setInt(3, iProcDefId);
	  				pstmt.setInt(4, iActId);
	  				pstmt.setInt(5, taskId);
	  				pstmt.setInt(6, subTaskId);
	  				parameters.clear();
	  				parameters.addAll(Arrays.asList(procInstID,workItemID,iProcDefId,iActId,taskId,subTaskId));
	  				jdbcExecute(procInstID,sessionId,userId,selectQueryString.toString(),pstmt,parameters,debugFlag,cabinet);
	  				rs = pstmt.getResultSet();
	  				//int counter =0;
	  				//tempXML.append("<TaskData>");
	  				if(rs.next()){
	  					Set<Integer> keys = fieldValueMap.keySet();
	  					int i = 1;
	  					for(Integer key:keys){
	  						value = rs.getString(i);
	  						value=WFSUtil.handleSpecialCharInXml(value, false);
	  						if(!(value==null || ("").equals(value)))
	  							varValueMap.put(key,value);//Updating the Map with TaskVariable Value.
	  						i++;
	  					}
	  					//	  			String variableName = variableList.get(counter);
	  					//	  			String variableValue = rs.getString(variableName);
	  					//	  			if(!rs.wasNull()){
	  					//					tempXML.append("<Attribute>");
	  					//					tempXML.append(gen.writeValueOf("Name", variableName));
	  					//					tempXML.append(gen.writeValueOf("Value", String.valueOf(variableValue)));
	  					//					tempXML.append("</Attribute>");
	  					//				}

	  				}
	  			}
//	  		tempXML.append("</TaskData>");
                }//End of isMapped = false
	  		if(pstmt!=null){
	  			pstmt.close();
	  			pstmt=null;
	  		}
	  		if(rs!=null){
	  			rs.close();
	  			rs=null;
	  		}
	  	}
	  	}
	  finally{
		  try {  
				if(rs!=null){
					rs.close();
					rs = null;
				}
			}catch(Exception e){
				WFSUtil.printErr(cabinet,"", e);
			}
		  try {  
				if(rs1!=null){
					rs1.close();
					rs1 = null;
				}
			}catch(Exception e){
				WFSUtil.printErr(cabinet,"", e);
			}
			
		  try{
				if(stmt!=null){
					stmt.close();
					stmt = null;
				} 
			}catch(Exception e){
				WFSUtil.printErr(cabinet,"", e);
			}
			
		  try{
				if(pstmt!=null){
					pstmt.close();
					pstmt = null;
				} 
			}catch(Exception e){
				WFSUtil.printErr(cabinet,"", e);
			}
		  
	  }
         // if(isMappedFlag){
              return varValueMap;
         // }else{
            //  return tempXML.toString();
          //}
	  
          
       
  }
  /**
	  * *************************************************************
	  * Function Name    :   getTableNameForTask
	  * Programmer' Name :   Mohnish Chopra
	  * Date Written     :   18/05/2015
	  * Input Parameters :   int iProcDefId, int taskType,int templateId
	  * Description      :   Method to get Table Name For Task
	  * *************************************************************
	  */
	public static String getTableNameForTask(int iProcDefId, int taskId,String scope) {
		String tableName=null;
//		switch(taskType){
//			case 1 : 
//					tableName = "WFGenericData_"+iProcDefId+"_"+ templateId;
//					break;
//					
//			case 3 : 	
//					tableName = "WFMeetingTaskDataTable";	
//					break;
//					
//			case 4 : 	
//					tableName = "WFApprovalTaskDataTable";	
//					break;
//			default :
//					tableName = "";
//		}	
                
//                switch(templateId){
//			case 1 : 
//					tableName = "WFApprovalTaskDataTable";
//					break;
//			
//			default :
//					tableName = "WFGenericData_"+iProcDefId+"_"+ templateId;
//
//		}	
		if(scope.equalsIgnoreCase("P")){
			tableName = "WFGenericData_"+iProcDefId+"_"+taskId;
		}
		else{
			tableName = "WFAdhocTaskData_"+iProcDefId;
		}
	return WFSUtil.TO_SANITIZE_STRING(tableName,false);
}
	 /**
	  * *************************************************************
	  * Function Name    :   isCaseWorkStepActivity
	  * Programmer' Name :   Mohnish Chopra
	  * Date Written     :   18/05/2015
	  * Input Parameters :   Connection con, int dbType, int processdefid,int activityId
	  * Description      :   Method to check if activity type is Case Workstep
	  * *************************************************************
	  */
	public static boolean isCaseWorkStepActivity(Connection con, int dbType, int processdefid,int activityId) throws SQLException {
		PreparedStatement pstmt = null;
		ResultSet rs=null;
		int activityType =0;
		try{
		pstmt = con.prepareStatement("Select ActivityType FROM ActivityTable " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessDefId = ? AND ActivityId  = ? ");
        pstmt.setInt(1, processdefid);
        pstmt.setInt(2, activityId);

        pstmt.execute();
		rs = pstmt.getResultSet();
        if (rs != null && rs.next()) {
			activityType = rs.getInt("ActivityType");
        }

        if (rs != null) {
            rs.close();
            rs = null;
        }
        if (pstmt != null) {
            pstmt.close();
            pstmt = null;
        }
    }
		finally{
			try {  
				if(rs!=null){
					rs.close();
					rs = null;
				}
			}catch(Exception e){
				WFSUtil.printErr("","", e);
			}
			try{
				if(pstmt!=null){
					pstmt.close();
					pstmt = null;
				} 
			}catch(Exception e){
				WFSUtil.printErr("","", e);
			}
		}
		return (activityType==WFSConstant.ACT_CASE);
	}
	
	 /**
	  * *************************************************************
	  * Function Name    :   isCompletedAllTasks
	  * Programmer' Name :   Mohnish Chopra
	  * Date Written     :   18/05/2015
	  * Input Parameters :   Connection con, int dbType, String processInstanceId,int workItemId, int processDefId, int activityId
	  * Description      :   Method to check if all initiated/mandatory tasks are completed
	  * *************************************************************
	  */
	public static boolean isCompletedAllTasks(Connection con, int dbType, String processInstanceId,int workItemId, int processDefId, int activityId) throws SQLException {

		boolean isCompleted=true;
		PreparedStatement pstmt = null; 
		ResultSet rs=null;
		ArrayList<Integer> madatoryTaskList= new ArrayList<Integer>(); 
		ArrayList<Integer> completedTaskList= new ArrayList<Integer>();
		ArrayList<Integer> optionalTaskList= new ArrayList<Integer>();
		try{
			pstmt = con.prepareStatement("Select TaskStatus FROM WFTaskStatusTable " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkItemId = ? and ProcessDefId = ? AND ActivityId  = ? and (taskStatus= ? or TaskStatus=?)");
			pstmt.setString(1, processInstanceId);
			pstmt.setInt(2, workItemId);
			pstmt.setInt(3,processDefId);
			pstmt.setInt(4,activityId);
			pstmt.setInt(5,WFSConstant.WF_TaskInitiated);
			pstmt.setInt(6,WFSConstant.WF_TaskPendingForApproval);
			pstmt.execute();
			rs = pstmt.getResultSet();
			if (rs.next()) {
				isCompleted =false;
				return isCompleted;
			}
        
			if (rs != null) {
				rs.close();
				rs = null;
			}
			if (pstmt != null) {
				pstmt.close();
				pstmt = null;
			}
			pstmt=con.prepareStatement("SELECT TaskId,Mandatory FROM WFTaskPreConditionResultTable where ProcessInstanceId = ? and WorkitemId=? and ActivityId=?");
			pstmt.setString(1,processInstanceId);
			pstmt.setInt(2,workItemId);
			pstmt.setInt(3,activityId);
			pstmt.execute();
			rs = pstmt.getResultSet();
			while(rs.next()){
				if(rs.getString("Mandatory").equals("Y")){
				madatoryTaskList.add(rs.getInt("TaskId"));
				}
				else if(rs.getString("Mandatory").equals("N")){
				optionalTaskList.add(rs.getInt("TaskId"));	
				}
			}
			
			pstmt = con.prepareStatement("Select InterfaceElementId from ACTIVITYINTERFACEASSOCTABLE where ProcessDefId= ? and ActivityId = ? and InterfaceType = ? and Attribute like ? ");
			pstmt.setInt(1,processDefId);
			pstmt.setInt(2,activityId);
			pstmt.setString(3,"J");
			pstmt.setString(4,"%M%");
			pstmt.execute();
			rs = pstmt.getResultSet();
			while (rs.next() && !optionalTaskList.contains(rs.getInt("InterfaceElementId"))) {
				madatoryTaskList.add(rs.getInt("InterfaceElementId"));
			}
			
			if (rs != null) {
				rs.close();
				rs = null;
			}
			if (pstmt != null) {
				pstmt.close();
				pstmt = null;
			}
			pstmt = con.prepareStatement("Select TaskId FROM WFTaskStatusTable " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessInstanceId = ? and WorkItemId = ? and ProcessDefId = ? AND ActivityId  = ? and taskStatus= ? ");
			pstmt.setString(1, processInstanceId);
			pstmt.setInt(2, workItemId);
			pstmt.setInt(3,processDefId);
			pstmt.setInt(4,activityId);
			pstmt.setInt(5,3);
			pstmt.execute();
			rs = pstmt.getResultSet();
			while (rs.next()) {
				completedTaskList.add(rs.getInt("TaskId"));
			}
			if (rs != null) {
				rs.close();
				rs = null;
			}
			if (pstmt != null) {
				pstmt.close();
				pstmt = null;
			}
		}
		finally{
			try {  
				if(rs!=null){
					rs.close();
					rs = null;
				}
			}catch(Exception e){
				WFSUtil.printErr("","", e);
			}
			try{
				if(pstmt!=null){
					pstmt.close();
					pstmt = null;
				} 
			}catch(Exception e){
				WFSUtil.printErr("","", e);
			}
		}
		return ((completedTaskList.containsAll(madatoryTaskList) )&&(isCompleted)) ;
	}
	/**
   * *************************************************************
   * Function Name    :   isWorkItemExpired
   * Programmer' Name :   Mohnish Chopra
   * Date Written     :   04/04/2014
   * Input Parameters :   Connection con, int dbType, String processinstanceid, int workItemId, int sessionId, int userId, boolean debugFlag, String engineName
   * Description      :   Checks whether workitem has expired
   * *************************************************************
   */
	public static boolean isWorkItemExpired(Connection con, int dbType, String processinstanceid, int workItemId, int sessionId, int userId, boolean debugFlag, String engineName) {
    boolean isWorkItemExpired = false;
    ArrayList parameters = new ArrayList();
    ResultSet rs = null;
	PreparedStatement pstmt = null;
    try {
      String query = new StringBuilder().append("Select 1 from WFInstrumentTable ").append(getTableLockHintStr(dbType)).append(" where processinstanceid =? and WorkItemId =? and validTill<").append(getDate(dbType)).toString();
      pstmt = con.prepareStatement(query);
      pstmt.setString(1, processinstanceid);
      pstmt.setInt(2, workItemId);
      parameters.add(processinstanceid);
      parameters.add(Integer.valueOf(workItemId));
       rs = jdbcExecuteQuery(processinstanceid, sessionId, userId, query, pstmt, parameters, Boolean.valueOf(debugFlag), engineName);
      if(rs.next()){
    	  isWorkItemExpired =true;
      }
      
      else{
    	  isWorkItemExpired =false;
      }
    }
    catch (Exception ignored){
    }
    finally{
    	if(rs!=null){
    		try {
				rs.close();
			} catch (SQLException ignored) {
				// TODO Auto-generated catch block
			}
    		rs=null;
    	}
		if(pstmt != null){
    		try {
				pstmt.close();
			} catch (SQLException ignored) {
				// TODO Auto-generated catch block
			}
    		pstmt = null;
    	}
    	
    }

    return isWorkItemExpired;
  }
	
	
	public static int getActivityType(Connection con, int processDefId, int activityId, String processInstanceId, int workItemId,int dbType) {
		boolean isWorkItemExpired = false;
		ArrayList parameters = new ArrayList();
		ResultSet rs=null;
		int activityType = 0;
		PreparedStatement pstmt =null;
		int iprocessDefId = 0;
		try {
			if(processDefId==0){
				String query = "Select ProcessDefId from WFInstrumentTable " +getTableLockHintStr(dbType)+" where ProcessInstanceId =? and WorkItemId = ? ";
				pstmt = con.prepareStatement(query);
				WFSUtil.DB_SetString(1, processInstanceId, pstmt, dbType);
				pstmt.setInt(2, workItemId);
				rs = pstmt.executeQuery();
				if(rs.next()){
					iprocessDefId =rs.getInt("ProcessDefId");
				}
				if(rs!=null){
					rs.close();
					rs = null;
				}
				if(pstmt!=null){
					pstmt.close();
					pstmt = null;
				}
				
			}
			else{
				iprocessDefId= processDefId;
			}
			String query = "Select ActivityType from ActivityTable "+getTableLockHintStr(dbType)+" where ProcessDefId =? and  ActivityId = ? " ;
			pstmt = con.prepareStatement(query);
			pstmt.setInt(1, iprocessDefId);
			pstmt.setInt(2, activityId);
			rs = pstmt.executeQuery();
			if(rs.next()){
				activityType =rs.getInt("ActivityType");
			}
			if(rs!=null){
				rs.close();
				rs = null;
			}
			if(pstmt!=null){
				pstmt.close();
				pstmt = null;
			}
		}
		catch (Exception ignored){
		}
		finally{

			try {  
				if(rs!=null){
					rs.close();
					rs = null;
				}
			}catch(Exception e){
				WFSUtil.printErr("","", e);
			}
			try{
				if(pstmt!=null){
					pstmt.close();
					pstmt = null;
				} 
			}catch(Exception e){
				WFSUtil.printErr("","", e);
			}
		}
		return activityType;  	
	}

	  
	  
        /*Method to convert JsonMsg into XML
         Sajid Khan - 27 may 2014
         */
 public static String convertJsonToXml(String jsonMsg){
        String xmlMsg = null;
        try {
            JSONObject json = new JSONObject(jsonMsg);
            xmlMsg = XML.toString(json);
        } catch (JSONException ex) {
           //ex.printStackTrace();
        }
        return xmlMsg;
 }
 
 /** 
  * *************************************************************
  * Function Name    :   getRegisterationStartingNo
  * Programmer' Name :   Mohnish Chopra
  * Date Written     :   22/08/2014
  * Input Parameters :   Connection con, int processDefID,int dbType
  * Description      :   Returns starting sequence number for a process --Added for Bug 47515 
  * *************************************************************
  */
 public static int getRegisterationStartingNo(Connection con, int processDefID,int dbType) {
	 ArrayList parameters = new ArrayList();
	 int regNo=1;
	 ResultSet rs=null;
	 PreparedStatement pstmt=null;
	 try {
		 StringBuilder query = new StringBuilder().append("Select RegStartingNo from ProcessDefTable ").append(getTableLockHintStr(dbType)).append(" where processdefid =? ");
		 pstmt = con.prepareStatement(query.toString());
		 pstmt.setInt(1, processDefID);
		 rs= pstmt.executeQuery();
		 if(rs.next()){
			 regNo =rs.getInt("RegStartingNo");
		 }
		 rs.close();
		 rs=null;
	 }
	 catch (Exception ignored){
	 }
	 finally{
		 if(rs!=null){
			 try {
				 rs.close();
			 } catch (SQLException ignored) {
				 // TODO Auto-generated catch block
			 }
			 rs=null;
		 }
		 try{
			 if(pstmt!=null){
				 pstmt.close();
				 pstmt=null;
			 }
		 }catch (Exception ignored){
		 }

	 }

	 return regNo;
 }
 
 public static Connection createConnectionToTargetCabinet(String tarCabName,String strOption,String engine) throws Exception{
     Connection tarConn=null;
     XMLGenerator outputXml = new XMLGenerator();
     String strReturn=null;
     try {
     	tarConn= (Connection) NGDBConnection.getDBConnection(tarCabName,strOption);
         if(tarConn == null){
         	strReturn = WFSUtil.generalError(strOption, tarCabName, outputXml,JTSError.JTSE_CAB_NOT_FOUND,"Cabinet : " + tarCabName + " Not Found");
         }
     }
     catch(Exception e) {
			WFSUtil.printOut(engine,strReturn);
         WFSUtil.printErr(engine,e);
           throw e;
      }
      return tarConn;
 }
 
 
 /*
  * Sajid Khan - ibps case management : 27 April 2015
  * Method to set TaskData which is called from Initiate API 
  * Method will check whehter the task variable is mapped with process variable or not 
  * If mapped then update wfinstrumenttable also by setattributeExt method.
  * 
  */
 public static int setTaskData(Connection con,WFParticipant user,String engine ,int dbType, int processDefId, String processInstanceId,int workItemId,
                                int activityId, int taskId,int subTaskId,int taskType,HashMap taskDataMap,boolean isConcurrentChangeDone,Boolean processVariablesModified[],String scope,boolean useSeparateTable,boolean internalServiceFlag) throws SQLException{
     int tempVarId = 0;
     String value = "";
     int varId = 0;
     String userDefinedName = "";
     int typeFieldId = 0;
     String complexFieldName = null;
     HashMap<Integer,String> varValueMap = new HashMap<Integer,String>();
     String tableName = "";
     Statement stmt = null;
     PreparedStatement pstmt = null;
     PreparedStatement pstmt1 = null;
     ResultSet rs = null; 
     ResultSet rs1 = null;
     String strQry = "";
     String strQry1 = "";
     int variableType = 0;
     boolean isReadOnly = false;
     StringBuffer attribXml = new StringBuffer(500);
     StringBuffer complexDataXml = new StringBuffer(500);
     //Default fields in TaskData tables
     Calendar cal = Calendar.getInstance();
	
     String updateQryStr = "";
     String colName = "";
     StringBuffer selectProcessVariablesFilter= new StringBuffer();
     //Get the TaskData's separate table to insert the values.
     /*For TaskType = 1- GenericType Task Table
      *         For TaskType =1 , table which should be created for Generic tasks would follow following names:
      *         WFGenericData_+$ProcessDefId$+"_"+$TemplateId$
       For TaskType = 2 - SubProcess Type Task Table
       
       For TaskType = 3 - WFMeetingTaskDataTable 
       For TaskType = 4 - WFApprovalTaskDataTable 
      
      */
     try {
    	// String stDate = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US).format(cal.getTime()).toString();
    	 String stDate=WFSUtil.dbDateTime(con, dbType);
         String colString = "ProcessDefId,ProcessInstanceId,WorkItemId,ActivityId, TaskId,SubTaskId,EntryDateTime";
         String colValueStr = processDefId+","+WFSUtil.TO_STRING(processInstanceId, true, dbType)+","+
                              workItemId+","+activityId+","+taskId+","+subTaskId+ ","+WFSUtil.TO_DATE(stDate, true, dbType);
//        if(taskType==1){
//            tableName = "WFGenericData_"+processDefId+"_"+templateId;//WFGenericDataTable1_1
//        }else if(taskType==2){
//            tableName = "WFSubProcessDataTable"; //Yet to be Decided
//        }else if(taskType==3){
//            tableName = "WFMeetingTaskDataTable"; 
//        }else if(taskType==4){
//            tableName = "WFApprovalTaskDataTable"; 
//        }

         if(useSeparateTable){
             tableName = getTableNameForTask(processDefId,taskId,"P");
        	
        }
         else{
        tableName = getTableNameForTask(processDefId,taskId,scope);

         }
        WFSUtil.printOut(engine, "TableName : " + tableName);
        //Get the column and value data for TaskData tables.
        String strValue = "";
        String strDate = ""; 
        String colValue = "";
        String isNull="N";
        StringBuffer auditLogStr = null;
         if(taskDataMap!=null&&(scope.equalsIgnoreCase("P")||(useSeparateTable))){
              auditLogStr = new StringBuffer(500);
              Set<Integer> keys = taskDataMap.keySet();
              auditLogStr.append("<FieldName>");
              auditLogStr.append("<Attributes>");
              for(Integer key:keys){
                  WFTaskInfoClass taskData = (WFTaskInfoClass)taskDataMap.get(key);
                  variableType = taskData.variableType;
                  colString += ","+taskData.taskVarName;
                  colName = taskData.taskVarName;
                  selectProcessVariablesFilter.append("'"+WFSUtil.TO_SANITIZE_STRING(colName,true)+"'");//Changes for Bug 57916 Null value showing in text variable in case data
                  selectProcessVariablesFilter.append(",");
                  colValue = taskData.value;
                  if(variableType==3 || variableType == 4 || variableType ==6 ){
                      colValueStr += ","+((taskData.value).equalsIgnoreCase("")?"NULL":taskData.value);   
                      updateQryStr += ","+WFSUtil.TO_SANITIZE_STRING(colName,true)+" = "+((taskData.value).equalsIgnoreCase("")?"NULL":taskData.value);
                  }else if(variableType==8 || variableType == 10){
                      if(variableType==10){
                          strValue = taskData.value;
                          colValueStr += ","+WFSUtil.TO_STRING(strValue, true, dbType);
                          updateQryStr += ","+WFSUtil.TO_SANITIZE_STRING(colName,true)+" = "+WFSUtil.TO_STRING(strValue, true, dbType);
                      }else{
                          strDate = taskData.value;
                          colValueStr += ","+WFSUtil.TO_DATE(strDate, true, dbType);
                          updateQryStr += ","+WFSUtil.TO_SANITIZE_STRING(colName,true)+" = "+WFSUtil.TO_DATE(strDate, true, dbType);
                      }
                      //colValueStr += ",'"+taskData.value+"'";
                  }
                  
                  isNull=(colValue == null || colValue.trim().equalsIgnoreCase("") || colValue.trim().equalsIgnoreCase("null"))?"Y":"N";
                  varValueMap.put(key,taskData.value);
                  auditLogStr.append("<Attribute>");
                  auditLogStr.append("<Name>"+WFSUtil.TO_SANITIZE_STRING(colName,true)+"</Name><Value>"+StringEscapeUtils.escapeXml(colValue)+"</Value><Type>" + variableType+"</Type><isNull>" +isNull+ "</isNull>");
                  auditLogStr.append("</Attribute>");
              }
              auditLogStr.append("</Attributes>");
              auditLogStr.append("</FieldName>");
              WFSUtil.printOut(engine, "Within if block, auditLogStr : " + auditLogStr.toString());
        }
         else if((taskDataMap!=null)&&(scope.equalsIgnoreCase("U"))){

             auditLogStr = new StringBuffer(500);
             Set<Integer> keys = taskDataMap.keySet();
             
             auditLogStr.append("<FieldName>");
             auditLogStr.append("<Attributes>");
             ArrayList<String> existingVariableList = new ArrayList<String>();
             
             String existingVariablesQuery = "Select TaskVariableName from "+WFSUtil.TO_SANITIZE_STRING(tableName,false)+getTableLockHintStr(dbType) + " where processinstanceid = ? and workitemid = ? and activityid = ? and taskid = ? ";
             pstmt= con.prepareStatement(existingVariablesQuery);
             WFSUtil.DB_SetString(1, processInstanceId, pstmt, dbType);
             pstmt.setInt(2, workItemId);
             pstmt.setInt(3, activityId);
             pstmt.setInt(4, taskId);
             rs = pstmt.executeQuery();
            
             while(rs.next()){
            	 existingVariableList .add(rs.getString("TaskVariableName"));
             }
             if(rs!=null){
            	 rs.close();
            	 rs=null;
             }
             if(pstmt!=null){
            	 pstmt.close();
            	 pstmt=null;
             }
             PreparedStatement updateQueryStmt = con.prepareStatement("Update " + WFSUtil.TO_SANITIZE_STRING(tableName,false) +" set Value = ? where processinstanceid = ? and workitemid = ? and activityid = ? and taskid =? and TaskVariableName= ?");
             PreparedStatement insertQueryStmt = con.prepareStatement("Insert into " + WFSUtil.TO_SANITIZE_STRING(tableName,false) +"(ProcessInstanceId, WorkItemId, ActivityId,TaskId, TaskVariableName,VariableType,Value) values (?,?,?,?,?,?,?)");

             for(Integer key:keys){
            	 
                 WFTaskInfoClass taskData = (WFTaskInfoClass)taskDataMap.get(key);

            	 boolean insertFlag= false;
            	 boolean updateFlag= false;
            	 String taskVariableValue = null;
            	 if(existingVariableList .contains ( taskData.taskVarName)){
            		 updateFlag =true;
            	 }
            	 else{
            		 insertFlag= true;
            	 }
            	 variableType = taskData.variableType;
            	 colValue = taskData.value;   
            	 colName = taskData.taskVarName;
                 /*if(variableType==3 || variableType == 4 || variableType ==6 ){
                	 taskVariableValue= colValue;
                 }else if(variableType==8 || variableType == 10){
                     if(variableType==10){
                    	 taskVariableValue =taskData.value; 
                     }else{
                         strDate = taskData.value;
                         taskVariableValue = WFSUtil.TO_DATE(strDate, true, dbType);
                     }
                     //colValueStr += ",'"+taskData.value+"'";
                 }*/
            	 taskVariableValue=colValue;
                 isNull=(colValue == null || colValue.trim().equalsIgnoreCase("") || colValue.trim().equalsIgnoreCase("null"))?"Y":"N";
                 
                 if(updateFlag){
                	 updateQueryStmt.setString(1,taskVariableValue);
                	 updateQueryStmt.setString(2,processInstanceId);
                	 updateQueryStmt.setInt(3,workItemId);
                	 updateQueryStmt.setInt(4,activityId);
                	 updateQueryStmt.setInt(5,taskId);
                	 updateQueryStmt.setString(6, taskData.taskVarName);

                	 updateQueryStmt.addBatch();
                 }
                 else if(insertFlag){

                	 insertQueryStmt.setString(1,processInstanceId);
                	 insertQueryStmt.setInt(2,workItemId);
                	 insertQueryStmt.setInt(3,activityId);
                	 insertQueryStmt.setInt(4,taskId);
                	 insertQueryStmt.setString(5, taskData.taskVarName);
                	 insertQueryStmt.setInt(6, variableType);
                	 insertQueryStmt.setString(7,taskVariableValue);
                	 insertQueryStmt.addBatch();
                 }
                 
                 auditLogStr.append("<Attribute>");
                 auditLogStr.append("<Name>"+colName+"</Name><Value>"+StringEscapeUtils.escapeXml(colValue)+"</Value><Type>" + variableType+"</Type><isNull>" +isNull+ "</isNull>");
                 auditLogStr.append("</Attribute>");
             }
             auditLogStr.append("</Attributes>");
             auditLogStr.append("</FieldName>");
             updateQueryStmt.executeBatch();
             insertQueryStmt.executeBatch();
             if(updateQueryStmt!=null){
            	 updateQueryStmt.close();
            	 updateQueryStmt=null;
             }
             if(insertQueryStmt!=null){
            	 insertQueryStmt.close();
            	 insertQueryStmt=null;
             }
             WFSUtil.printOut(engine, "Within else block, auditLogStr : " + auditLogStr.toString());
         }
         if(taskDataMap!=null&&scope.equalsIgnoreCase("P")){
         selectProcessVariablesFilter.deleteCharAt(selectProcessVariablesFilter.length()-1);//Changes for Bug 57916  Null value showing in text variable in case data
       //Check whether entry exists in the table or not.If exist then update the same else insert a new record.  
         strQry = " Select  1 from  "+WFSUtil.TO_SANITIZE_STRING(tableName,false)+" Where ProcessDefId = ? And  ProcessInstanceId = ?  And WorkItemId = ? "
                 + "And ActivityId = ? And TaskId = ? And SubTaskId = ?";
         pstmt = con.prepareStatement(strQry);
         pstmt.setInt(1,processDefId);
         WFSUtil.DB_SetString(2, processInstanceId, pstmt, dbType);
         pstmt.setInt(3,workItemId);
         pstmt.setInt(4,activityId);
         pstmt.setInt(5,taskId);
         pstmt.setInt(6,subTaskId);
         rs = pstmt.executeQuery();
         if(rs.next()){//Update the existing one.
             if(!("".equals(updateQryStr))){
                 updateQryStr = updateQryStr.substring(1);
                 updateQryStr = " Update "+WFSUtil.TO_SANITIZE_STRING(tableName,false)+" Set "+updateQryStr+" Where ProcessDefId = ? And  ProcessInstanceId = ?  And WorkItemId = ? "
                 + "And ActivityId = ? And TaskId = ? And SubTaskId = ?";
                 pstmt = con.prepareStatement(updateQryStr);
                 pstmt.setInt(1,processDefId);
                 WFSUtil.DB_SetString(2, processInstanceId, pstmt, dbType);
                 pstmt.setInt(3,workItemId);
                 pstmt.setInt(4,activityId);
                 pstmt.setInt(5,taskId);
                 pstmt.setInt(6,subTaskId);
                 pstmt.executeUpdate();
             }
         }else{
            //Insert data into TaskSpecifc Tables- tableName
            strQry = " Insert into "+WFSUtil.TO_SANITIZE_STRING(tableName,false)+"("+colString+")Values("+colValueStr+")";
            stmt = con.createStatement();
            stmt.execute(strQry);
         }
         if(pstmt!=null){
             pstmt.close();
             pstmt = null;
         }   
         if(rs!=null){
            rs.close();
            rs = null;
         }   
         //Get the Task Variables mapped with process Variables[Queue, External and Complex variables]
         strQry = "select a.TemplatevariableId,a.TypefieldId, b.VariableId , b.UserDefinedName,a.ReadOnly,b.SystemDefinedName from"
                 + " WFTaskVariableMappingTable a left outer join VARMAPPINGTABLE b on a.ProcessDefId = b.Processdefid"
                 + " and a.VariableId = b.Variableid where a.ProcessDefId = ? and a.ActivityId = ? and a.TaskId = ? and a.taskvariableName in("+selectProcessVariablesFilter +")";
         pstmt = con.prepareStatement(strQry);
         pstmt.setInt(1,processDefId);
         pstmt.setInt(2,activityId);
         pstmt.setInt(3,taskId);
         rs = pstmt.executeQuery();
         attribXml.append("<Attributes>");
         WFSUtil.printOut(engine, "Task Variables Query : " + strQry);
         while(rs.next()){
             tempVarId = rs.getInt(1);
             typeFieldId = rs.getInt(2);
             varId = rs.getInt(3);
             userDefinedName = rs.getString(4);
             isReadOnly = rs.getString(5).equalsIgnoreCase("Y");
             String systemDefinedName=rs.getString(6);
             value = varValueMap.get(tempVarId);
            
             if(!isReadOnly){//It means values for  only those mapped variables which can be modified(isReadOnly = N) sould be updated in WFINstrumenttable
                  //<Id>12</Id> 
                  if(typeFieldId==0)//Queue Variables and External variables Case
                        attribXml.append("<").append(userDefinedName).append(">").append(value).append("</").append(userDefinedName).append(">");
                  //Get the complex field name if the task variable is mapped with Complex fields.
                  if(typeFieldId!=0){
                	  int parentTypeId=0;
                        if (pstmt1 != null) {
                            pstmt1.close();
                            pstmt1 = null;
                        }
                        
                        strQry1="Select typeId From wftypedesctable "+WFSUtil.getTableLockHintStr(dbType)+" where processdefid=? and typename = ?";
                        pstmt1=con.prepareStatement(strQry1);
                        pstmt1.setInt(1, processDefId);
                        if(dbType==JTSConstant.JTS_POSTGRES){
                        	pstmt1.setString(2, systemDefinedName);
                        }else{
                        	pstmt1.setNString(2, systemDefinedName);
                        }
                        rs1=pstmt1.executeQuery();
                        if(rs1!=null && rs1.next()){
                        	parentTypeId=rs1.getInt(1);
                        }else{
                        	WFSUtil.printOut(engine, "Complex Type does not exists for processdefid ="+processDefId+" VariableId ="+varId);
                        }
                        if(rs1!=null){
                        	rs1.close();
                        	rs1=null;
                        }
                        if(pstmt1!=null){
                        	pstmt1.close();
                        	pstmt1=null;
                        }
                        
                        strQry1 = " select FieldName from WFTypeDefTable "+WFSUtil.getTableLockHintStr(dbType)+" where ParentTypeId =? and ProcessDefId = ?  and TypeFieldId = ? ";
                        pstmt1 = con.prepareStatement(strQry1);
                        pstmt1.setInt(1,parentTypeId);
                       // pstmt1.setInt(1,varId);
                       // pstmt1.setInt(2,typeFieldId);
                        pstmt1.setInt(2,processDefId);
                        //pstmt1.setInt(4,processDefId);
                        pstmt1.setInt(3,typeFieldId);
                        rs1 = pstmt1.executeQuery();
                        if(rs1.next()){
                            complexFieldName = rs1.getString(1);
                        }
                        //<ComplexVar><c1>123</c1></ComplexVar>
                        complexDataXml.append("<").append(userDefinedName).append(">");
                        complexDataXml.append("<").append(complexFieldName).append(">");
                        complexDataXml.append(value);
                        complexDataXml.append("</").append(complexFieldName).append(">");
                        complexDataXml.append("</").append(userDefinedName).append(">");
                }
           }//End of check isReadOnly
         }
         if(complexDataXml.toString().trim().length()>0){
             attribXml.append(complexDataXml);
         }
         attribXml.append("</Attributes>");
         XMLParser attribXMLParser = new XMLParser(attribXml.toString());
         if(attribXMLParser.getValueOf("Attributes").toString().length()>0){
        	 
        	 if(isConcurrentChangeDone){
        		 int mainCode = WFSError.WF_OPERATION_FAILED;
                 int subCode = WFSError.WF_WORKITEM_DATA_MODIFIED;
                 String subject = WFSErrorMsg.getMessage(mainCode);
                 String descr = WFSErrorMsg.getMessage(subCode);
                 String errType = WFSError.WF_TMP; 

 				throw new WFSException(mainCode, subCode, errType, subject, descr);
 			
        	 }
        	 processVariablesModified[0] = true;
             XMLGenerator gen = new XMLGenerator();
             boolean afterUpdateFlag = false;
             if(rs!=null){
                 rs.close();
                 rs= null;
             }
             if(stmt!=null){
                 stmt.close();
                 stmt = null;
             }
             //Workitem should be locked before updation
             String query=" Select RoutingStatus , LockStatus  from WFInstrumentTable "+WFSUtil.getTableLockHintStr(dbType)+" Where " +
                               "ProcessInstanceId = ? and WorkitemId = ? and LockStatus = ? ";
             pstmt = con.prepareStatement(query);
             WFSUtil.DB_SetString(1, processInstanceId, pstmt, dbType);
             pstmt.setInt(2, workItemId);
             pstmt.setString(3, "Y");
             rs = pstmt.executeQuery();
             if(!rs.next()){
                 afterUpdateFlag = true;
                 stmt = con.createStatement();
                 stmt.executeUpdate(" Update WFInstrumentTable Set LockStatus = 'Y' , LockedByName = "+WFSUtil.TO_STRING(user.getname(), true, dbType)+" Where ProcessInstanceId = "+WFSUtil.TO_STRING(processInstanceId, true, dbType)+""
                         + " And WorkItemId = "+workItemId);
             }

             WFSUtil.setAttributesExt(con, user,(attribXMLParser.getValueOf("Attributes")), engine, 
                     processInstanceId, workItemId, gen, null, internalServiceFlag, false, false);
             WFSUtil.printOut(engine, "After setting the attributes");
             //If LockStatus was modified then after settting the attributes , revert the lockstatus.
             if(afterUpdateFlag){
                  if(stmt!=null){
                     stmt.close();
                     stmt = null;
                  }
                 stmt = con.createStatement();
                 stmt.executeUpdate(" Update WFInstrumentTable Set LockStatus = 'N', LockedByName = NULL Where ProcessInstanceId = "+WFSUtil.TO_STRING(processInstanceId, true, dbType)+""
                         + " And WorkItemId = "+workItemId);
             }
         }
         }
         if(pstmt!=null){
             pstmt.close();
             pstmt = null;
         }
         if(pstmt1!=null){
             pstmt1.close();
             pstmt1 = null;
         }
         if(rs!=null){
             rs.close();
             rs = null;
         }
         if(rs1!=null){
             rs1.close();
             rs1 = null;
         }
		 if(stmt!=null){
            stmt.close();
            stmt = null;
         }
      
        //Auditing of Task Data being set .
        if(auditLogStr!=null){
            generateTaskLog(engine,con,dbType, processInstanceId,WFSConstant.WFL_TaskDataSet, workItemId, processDefId,
            activityId,null,0,user.getid(),user.getname(),auditLogStr.toString(),taskId, subTaskId,stDate); 
        }  
        return 0;
         
     }catch(SQLException sqe){
    	  WFSUtil.printErr(engine, "SQLException", sqe);
          return -1;
     }catch(Exception e){
    	 WFSUtil.printErr(engine, "Exception", e); 
    	 return -1;
     }
     finally{
    	 try{
             if (rs != null) {
                 rs.close();
                rs = null;
             }}catch(Exception ignore){
            	 WFSUtil.printErr(engine, "", ignore); 
             }
    	 try{
             if (rs1 != null) {
                 rs1.close();
                rs1 = null;
             }}catch(Exception ignore){
            	 WFSUtil.printErr(engine, "", ignore); 
             }
    	 try{
             if (pstmt != null) {
                 pstmt.close();
                pstmt = null;
             }}catch(Exception ignore){
            	 WFSUtil.printErr(engine, "", ignore); 
             }
    	 try{
             if (pstmt1 != null) {
                 pstmt1.close();
                pstmt1 = null;
             }}catch(Exception ignore){
            	 WFSUtil.printErr(engine, "", ignore); 
             }
    	 try{
         if (stmt != null) {
             stmt.close();
            stmt = null;
         }}catch(Exception ignore){
        	 WFSUtil.printErr(engine, "", ignore); 
         }
     }
 }
 
 /**
  * *************************************************************
  * Function Name    :   completeTask
  * Programmer' Name :   Mohnish Chopra
  * Date Written     :   18/05/2015
  * Input Parameters :   Connection con, int dbType, String processinstanceid, int workItemId, int sessionId, int userId, boolean debugFlag, String engineName
  * Description      :   Completes a task - Changes taskstatus from initiated(2) to completed(3).
  * *
 * @throws WFSException ************************************************************
  */
 public static HashMap<String,Integer> completeTask(Connection con,int dbType, int processDefId, String processInstanceId,int workItemId,
		 int activityId, int taskId,int subTaskId,String modifiedTime,String username) throws SQLException, WFSException{
	 PreparedStatement pstmt = null;
	 boolean approvalRequired =false;
	 boolean approvalPending =false;
	 HashMap<String,Integer> completeTaskMap=new HashMap<String,Integer>();
	// ResultSet rs =null;
	 pstmt = con.prepareStatement(" update WFTaskStatusTable set TaskStatus=?,ActionDateTime=" + WFSUtil.TO_DATE(modifiedTime, true, dbType) + " where ProcessInstanceId=? and WorkItemId=? and ProcessDefId=? and ActivityId=? and TaskId=? and SubTaskId =? and (TaskStatus=? or TaskStatus= ? ) and UPPER(Assignedto)=? ");
	 pstmt.setInt(1, 3); 
	 WFSUtil.DB_SetString(2, processInstanceId, pstmt, dbType);
	 pstmt.setInt(3, workItemId); 
	 pstmt.setInt(4, processDefId);
	 pstmt.setInt(5, activityId);
	 pstmt.setInt(6, taskId); 
	 pstmt.setInt(7, subTaskId); 
	 pstmt.setInt(8, 2);
	 pstmt.setInt(9, 6);
	 WFSUtil.DB_SetString(10, username.toUpperCase(), pstmt, dbType);
	 completeTaskMap.put("CallTaskListThread",0);
	 int rs1=pstmt.executeUpdate();
	 /*Updating it to 'Y' so that pre-condition gets checked*/
 	if(WFSUtil.checkTaskAndVariableinPreCondition(con,processDefId,activityId,taskId,null,"T",1)){//checing for Task
 		WFSUtil.updateWFTaskPreCheckTable( con,  processInstanceId,  workItemId,activityId,"Y"); 
 		 completeTaskMap.put("CallTaskListThread",1);
 	}
 	
//	 if (rs != null) {
//		 rs.close();
//		 rs = null;
//	 }
	 if (pstmt != null) {
		 pstmt.close();
		 pstmt = null;
	 }
	 pstmt = con.prepareStatement(" update WFCaseDocStatusTable set CompleteStatus=? where ProcessInstanceId=? and WorkItemId=? and ProcessDefId=? and ActivityId=? and TaskId=? and SubTaskId =?");
	 WFSUtil.DB_SetString(1, "Y", pstmt, dbType);
	 WFSUtil.DB_SetString(2, processInstanceId, pstmt, dbType);
	 pstmt.setInt(3, workItemId); 
	 pstmt.setInt(4, processDefId);
	 pstmt.setInt(5, activityId);
	 pstmt.setInt(6, taskId); 
	 pstmt.setInt(7, subTaskId); 
	 pstmt.executeUpdate();
//	 if (rs != null) {
//		 rs.close();
//		 rs = null;
//	 }
	 if (pstmt != null) {
		 pstmt.close();
		 pstmt = null;
	 }
	 completeTaskMap.put("UpdateCount",rs1);
	
	 return completeTaskMap;
 }
 
 
 /**
  * *************************************************************
  * Function Name    :   isuserCaseWorker
  * Programmer' Name :   Mohnish Chopra
  * Date Written     :   1/12/2015
  * Input Parameters :   Connection con, int dbType, String processinstanceid, int workItemId, int sessionId, int userId, boolean debugFlag, String engineName
  * Description      :   isUserCaseWorker returns true if he is either a case worker or case manager.
  * *
 * @throws WFSException ************************************************************
  */
 public static boolean isUserCaseWorker(Connection con,int dbType, int processDefId, String processInstanceId,int workItemId,
		 int activityId,int userId,String userName) throws SQLException, WFSException{
	 ResultSet rs = null;
	 PreparedStatement pstmt = null;
	 boolean isInitiateAllowed =false;

	 try{
		 String query = new StringBuilder().append("Select 1 from WFInstrumentTable ").append(getTableLockHintStr(dbType)).append(" where " +
				 "processinstanceid =? and WorkItemId =? and Q_UserID = ? and ActivityType =? " +
		 "union Select 1 from  WFTaskStatusTable ").append(getTableLockHintStr(dbType)).append("where processinstanceid = ? " +
		 "and workitemid = ? and processdefid = ? and activityid = ? and assignedto = ? and taskstatus in (?,?)  and caninitiate = ? ").toString();
		 pstmt = con.prepareStatement(query);
		 DB_SetString(1, processInstanceId, pstmt, dbType);
		 pstmt.setInt(2, workItemId);
		 pstmt.setInt(3, userId);
		 pstmt.setInt(4, 32);
		 DB_SetString(5, processInstanceId, pstmt, dbType);
		 pstmt.setInt(6, workItemId);
		 pstmt.setInt(7, processDefId);
		 pstmt.setInt(8, activityId);
		 DB_SetString(9, userName, pstmt, dbType);
		 pstmt.setInt(10,2);
		 pstmt.setInt(11,3);
		 DB_SetString(12, "Y", pstmt, dbType);
		 rs = pstmt.executeQuery();
		 if(rs.next()){
			 isInitiateAllowed = true; 
		 }

	 }
	 finally {
		 if(rs!=null){
			 rs.close();
			 rs= null;
		 }
		 if(pstmt!=null){
			 pstmt.close();
			 pstmt = null;
		 }
	 }
	return isInitiateAllowed;
}
 /**
  * *************************************************************
  * Function Name    :   isUserManager
  * Programmer' Name :   Kirti Wadhwa
  * Date Written     :   02/08/2016
  * Input Parameters :   Connection con, int dbType, String processinstanceid, int workItemId, int sessionId, int userId, boolean debugFlag, String engineName
  * Description      :   isUserCaseManager returns true if he is case manager.
  * *
 * @throws WFSException ************************************************************
  */

 public static boolean isUserCaseManager(Connection con,int dbType, int processDefId, String processInstanceId,int workItemId,
		 int activityId,int userId,String userName) throws SQLException, WFSException{
	 ResultSet rs = null;
	 PreparedStatement pstmt = null;
	 boolean isInitiateAllowed =false;
	 try{
		 String query = new StringBuilder().append("Select 1 from WFInstrumentTable ").append(getTableLockHintStr(dbType)).append(" where " +
	    " processinstanceid =? and WorkItemId =? and Q_UserID = ? and ActivityType =? ").toString();
		 pstmt = con.prepareStatement(query);
		 DB_SetString(1, processInstanceId, pstmt, dbType);
		 pstmt.setInt(2, workItemId);
		 pstmt.setInt(3, userId);
		 pstmt.setInt(4, 32);
		 rs = pstmt.executeQuery();
		 if(rs.next()){
			 isInitiateAllowed = true; 
		 }
     }
	 finally {
		 if(rs!=null){
			 rs.close();
			 rs= null;
		 }
		 if(pstmt!=null){
			 pstmt.close();
			 pstmt = null;
		 }
	 }
	return isInitiateAllowed;  
 }
 /**
  * *************************************************************
  * Function Name    :   getCaseManager
  * Programmer' Name :   Kumar Kimil
  * Date Written     :   28/09/2017
  * Input Parameters :   Connection con,int dbType,String processInstanceId,int workItemId
  * Description      :   getCaseManager returns case manager, if present for the Case.
  * *
 * @throws WFSException ************************************************************
  */

 public static HashMap<String,String> getCaseManager(Connection con,int dbType,String processInstanceId,int workItemId) throws SQLException, WFSException{
	 ResultSet rs = null;
	 PreparedStatement pstmt = null;
	 String caseManager ="";
	 String processName="";
	 String activityName="";
	 HashMap<String,String> map=new HashMap<String,String>();
	 try{
		 String query = new StringBuilder().append("Select AssignedUser,ProcessName,ActivityName FROM WFInstrumentTable ").append(getTableLockHintStr(dbType)).append(" where " +
	    " processinstanceid =? and WorkItemId =? AND AssignmentType='F' ").toString();
		 pstmt = con.prepareStatement(query);
		 DB_SetString(1, processInstanceId, pstmt, dbType);
		 pstmt.setInt(2, workItemId);
		
		 rs = pstmt.executeQuery();
		 if(rs.next()){
			 caseManager=rs.getString("AssignedUser");
			 processName=rs.getString("ProcessName");
			 activityName=rs.getString("ActivityName");
		 }
		 
		 map.put("CaseManager", caseManager);
		 map.put("ProcessName", processName);
		 map.put("ActivityName", activityName);
     }
	 finally {
		 if(rs!=null){
			 rs.close();
			 rs= null;
		 }
		 if(pstmt!=null){
			 pstmt.close();
			 pstmt = null;
		 }
	 }
	return map;  
 }
	/**
   * *************************************************************
   * Function Name    :   handleSpecialCharInXml
   * Programmer' Name :   Kahkeshan
   * Date Written     :   17/04/2014
   * Input Parameters :   String strXml
   * Description      :   To handle special characters in xml 
   * *************************************************************
   */
   public static String handleSpecialCharInXml(String strXml,boolean flag){
        
        String  excludeChars = CachedObjectCollection.getReference().getExcludeCatalog();
        //String excludeChars="";
        if(excludeChars != null){
            for (int counter1 = 0; counter1 < excludeChars.length(); counter1++) {
                strXml = strXml.replace(excludeChars.charAt(counter1), ' ');
            }
        }
		if(strXml != null){
			strXml = strXml.replace("&amp;", "&");
			strXml = strXml.replace( "&lt;", "<");
			strXml = strXml.replace( "&gt;", ">");
			strXml = strXml.replace( "&quot;", "\"");
			strXml = strXml.replace("&apos;", "'");
		}
        return strXml;
    }

	private static int getOccurence(String data, char c){
        int counter = 0;
        for( int i=0; i<data.length(); i++ ) {
            if( data.charAt(i) == c ) {
                counter++;
            } 
        }
        return counter;
    }
	public static void deleteEscalation(String engine, Connection con, String pinstId, int wrkItmId, int processDefId, int activityId) throws JTSException
    {
        PreparedStatement pstmt = null;
        int error = 0;
        String errorMsg = "";
        try
        {
            int dbType = ServerProperty.getReference().getDBType(engine);
            pstmt = con.prepareStatement("Delete From WFEscalationTable Where  processInstanceId = ? AND workitemId = ?");
            //pstmt.setInt(1, processDefId);
           // pstmt.setInt(2, activityId);
            WFSUtil.DB_SetString(1, pinstId.trim(), pstmt, dbType);
            pstmt.setInt(2,wrkItmId);
            pstmt.executeUpdate();
            pstmt.close();
            pstmt = null;
        }
        catch (SQLException e)
        {
            //printErr(engine, e);
            error = WFSError.WFS_SQL;
            errorMsg = e.toString();
        }
        catch (Exception e)
        {
            //printErr(engine, e);
            error = WFSError.WFS_SQL;
            errorMsg = e.toString();
        } 
        finally
        {
            if (pstmt != null)
            {
                try
                {
                    pstmt.close();
                }
                catch (Exception e) {}
            }
           
        }
        if (error != 0)
            throw new JTSException(error, errorMsg);
    }	
	public static String avoidNullValues(String value){
		return (value == null ? "" : value);
	
	}	
	/**
     * *************************************************************
     * Function Name    :   getQueryTimeOut()
     * Author			:   Kahkeshan
     * Date Written     :   09/02/2016
     * Input Parameters :   NONE
     * Output Parameters:   NONE
     * Return Value     :   int : query time out value 
     * Description      :   Returns query timeout from wfappcontext
     * *************************************************************
     */
	public static int getQueryTimeOut() {
        Integer OFQueryTimeOut = (Integer) WFFindClass.wfGetServerPropertyMap().get(WFSConstant.CONST_OFQUERYTIMEOUT);
        if (OFQueryTimeOut == null) {
            OFQueryTimeOut = 60;
        }
        return OFQueryTimeOut;
    }
public static void generateTaskLog(String engine, Connection con,int dbType, String processInstanceId,int actionId, int workitemId, int processDefId,
          int activityId,String activityName, int queueId,int userId,String userName, String fieldName,int taskId, int subTaskId,String strDate ) throws SQLException,WFSException{
        String strQry = "";
        int summaryFlag = 0;
        int mainCode = 0;
        int subCode = 0;
        String subject = null;
        String descr = null;
        String errType = WFSError.WF_TMP;
        String taskName = "";
        int fieldId = 0;
        //If SummaryFlag = 1, then data goes only to WFCurrentRouteLogTable else Data will go to WFMessageTable and WFCurrentRouteLogTable both.
        switch (actionId) {
            case WFSConstant.WFL_TaskInitiated:
            case WFSConstant.WFL_TaskAdded:
            case WFSConstant.WFL_TaskCompleted:
            case WFSConstant.WFL_TaskRevoked:
            case WFSConstant.WFL_TaskDataSet:
            case WFSConstant.WFL_TaskDiverted: 	
      		case WFSConstant.WFL_TaskDeclined:
      		case WFSConstant.WFL_TaskReassigned:
      		case WFSConstant.WFL_TaskExpired:
      		case WFSConstant.WFL_TaskUnlocked:
      		case WFSConstant.WFL_TaskApproved:
      		case WFSConstant.WFL_TaskRejected:
      		case WFSConstant.WFL_AssignBackDivertedTask:
                summaryFlag = 1;
                break;
            default:
                summaryFlag = 3;
                break;
        }
        Statement stmt = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        //boolean commit = false;
        HashMap actionMap = new HashMap();
        String urn = "";
        try{
            if(activityName ==null){
                strQry = "Select ActivityName from ActivityTable where ProcessDefId = "+processDefId+" And ActivityId = "+activityId;
                stmt = con.createStatement();
                rs = stmt.executeQuery(strQry);
                if(rs.next()){
                    activityName = rs.getString(1);
                }
            }
            if(stmt!=null){
                stmt.close();
                stmt = null;
            }
            if(rs!=null){
                rs.close();
                rs = null;
            }
            strQry = "Select TaskName from WFTaskDefTable  where ProcessDefId = "+processDefId+" And TaskId = "+taskId;
            stmt = con.createStatement();
            rs = stmt.executeQuery(strQry);
            if(rs.next()){
                taskName = rs.getString(1);
            }
            if(rs!=null){
                rs.close();
                rs = null;
            }
            if(stmt!=null){
                stmt.close();
                stmt = null;
            }
            /*Changes to add the URN in Workitem history*/
            if(processInstanceId != null && !processInstanceId.isEmpty()){
                pstmt = con.prepareStatement("Select URN from WFinstrumentTable " + getTableLockHintStr(dbType) + " where ProcessInstanceId=? and WorkitemId = ? ");
                pstmt.setString(1,processInstanceId);
                pstmt.setInt(2, workitemId);
                rs = pstmt.executeQuery();
                if(rs.next()){
                	urn = rs.getString(1);
                }
                if(rs != null){
                	rs.close();
                	rs = null;
                }
                if(pstmt != null){
                	pstmt.close();
                	pstmt = null;
                }
            }
            /*Changes to add the URN in Workitem history till here*/            
            strQry = "Select ActionId From WFActionStatusTable Where ActionId IN(701,702,703,704,705,707,708, 709, 710, 712,713,714, 715) And Status = 'Y'";
            stmt = con.createStatement();
            rs = stmt.executeQuery(strQry);
            while(rs.next()){
                actionMap.put(rs.getInt(1), null);
            }
            if (actionMap.containsKey(actionId)){
                if(actionId==WFSConstant.WFL_TaskDataSet){
                    StringBuffer tempXml = new StringBuffer(100);
                    tempXml.append("<Message>");
                    tempXml.append("<ActionId>"+actionId+"</ActionId>");
                    tempXml.append("<ProcessDefId>"+processDefId+"</ProcessDefId>");
                    tempXml.append("<ActivityId>"+activityId+"</ActivityId>");
                    tempXml.append("<ActivityName>"+activityName+"</ActivityName>");
                    tempXml.append("<UserName>"+userName+"</UserName>");
                    tempXml.append("<ProcessInstance>"+processInstanceId+"</ProcessInstance>");
                    tempXml.append("<WorkitemId>"+workitemId+"</WorkitemId>");
                    tempXml.append("<TaskId>"+taskId+"</TaskId>");
                    tempXml.append("<SubTaskId>"+subTaskId+"</SubTaskId>");
                    tempXml.append("<TaskName>"+taskName+"</TaskName>");
                    tempXml.append("<LoggingFlag>"+summaryFlag+"</LoggingFlag>");
                    if(urn != null && !urn.isEmpty()){
                    	tempXml.append("<URN>"+urn+"</URN>");
                    }
                    tempXml.append(replace(fieldName, "'", "''"));
                    tempXml.append("</Message>");
                    String finalXml = escapeXML(tempXml.toString());
                    JSONObject JSON = org.json.XML.toJSONObject(finalXml);
                    String jMessage =JSON.toString();
                    printOut(engine,"WFSUTIL>>>SET_TASKDATA>>>>JSON MESSAGE FOR ACTION ID = 705 "+jMessage);
                    if ((dbType == JTSConstant.JTS_MSSQL) || (dbType == JTSConstant.JTS_DB2) || (dbType == JTSConstant.JTS_POSTGRES)) {
                            pstmt = con.prepareStatement("Insert into WFAttriButeMessageTable (ProcessDefId,ProcessInstanceId ,WorkitemId , ProcessVariantId, message, status, ActionDateTime) Values (?,?, ?, ?, ?," + WFSUtil.TO_STRING("N", true, dbType) + ", " + WFSUtil.TO_DATE(strDate, true, dbType) + ")");
                            pstmt.setInt(1,processDefId);
                            WFSUtil.DB_SetString(2, processInstanceId, pstmt, dbType);
                            pstmt.setInt(3,workitemId);
                            pstmt.setInt(4,0);
                            pstmt.setCharacterStream(5, new java.io.StringReader(jMessage), jMessage.length());
                            pstmt.execute();
                            stmt = con.createStatement();
//                            stmt.execute("Select @@IDENTITY");
//                            rs = stmt.getResultSet();
//                            if(rs != null && rs.next()) {
//                                fieldId = rs.getInt(1);
//                                rs.close();
//                            }
                            if(dbType == JTSConstant.JTS_MSSQL){
                                stmt.execute("Select @@IDENTITY");
                                rs = stmt.getResultSet();
                                if(rs != null && rs.next()) {
                                    fieldId = rs.getInt(1);
                                    rs.close();
                                }
                            }else if(dbType == JTSConstant.JTS_POSTGRES){
                                stmt.execute("Select currval('wfattributemessagetable_messageid_seq')");
                                rs = stmt.getResultSet();
                                if(rs != null && rs.next()) {
                                    fieldId = rs.getInt(1);
                                    rs.close();
                                }
                            }
                            rs = null;
                            printOut(engine,"messageId to be inserted into AssocaitedField id = "+fieldId);

                    } else if(dbType == JTSConstant.JTS_ORACLE){
                                String messageId = "0";
                                stmt = con.createStatement();
//                                if (con.getAutoCommit()) {
//                                    con.setAutoCommit(false);
//                                    commit = true;
//                                }
                                messageId = nextVal(con, "seq_attribmessageId", dbType);
                                fieldId = Integer.parseInt(messageId);
                                printOut(engine,"messageId to be inserted into AssocaitedField id = "+fieldId);
                                pstmt = con.prepareStatement("Insert into WFAttriButeMessageTable (ProcessDefId,ProcessInstanceId ,WorkitemId , ProcessVariantId, messageId, message, status, ActionDateTime) Values ( ?,?,?,? , " + WFSUtil.TO_SANITIZE_STRING(messageId, false) + ",EMPTY_CLOB(), " + WFSUtil.TO_STRING("N", true, dbType) + ", " + WFSUtil.TO_DATE(strDate, true, dbType) + ")");
                                pstmt.setInt(1,processDefId);
                                WFSUtil.DB_SetString(2, processInstanceId, pstmt, dbType);
                                pstmt.setInt(3,workitemId);
                                pstmt.setInt(4,0);	
                                pstmt.execute();
                                writeOracleCLOB(con, stmt, "WFAttriButeMessageTable", "message", "messageId = " + messageId, jMessage);
                    }
                    actionId = WFSConstant.WFL_TaskDataHasBeenSet;//To be inserted into WFCurrentRouteLogTable 
                    fieldName = null;
                 }
                if ((dbType == JTSConstant.JTS_MSSQL) || dbType == JTSConstant.JTS_POSTGRES) {
                       pstmt = con.prepareStatement("Insert into WFCurrentRouteLogTable (ProcessDefId, ActivityId, ProcessInstanceId,"
                               + " WorkItemId, UserId, ActionId, ActionDateTime,"
                               + " AssociatedFieldName, ActivityName, UserName,NewValue, QueueId,TaskId,SubTaskId,AssociatedFieldId,URN)"
                               + " values (?, ?, ?, ?, ?, ?, "+ WFSUtil.TO_DATE(strDate, true, dbType) +",?,?,?,?,?,?,?,?,?)");
               } else if (dbType == JTSConstant.JTS_ORACLE) {
                   String logId = "0";
//                   if (con.getAutoCommit()) {
//                       con.setAutoCommit(false);
//                       //commit = true;
//                   }
                   logId = nextVal(con, "seq_rootlogid", dbType);
                   pstmt = con.prepareStatement("Insert into WFCurrentRouteLogTable (LogId,ProcessDefId, ActivityId, ProcessInstanceId,"
                           + " WorkItemId, UserId, ActionId, ActionDateTime, AssociatedFieldName,"
                           + " ActivityName, UserName,NewValue, QueueId,TaskId,SubTaskId,AssociatedFieldId,URN) values ( " + WFSUtil.TO_SANITIZE_STRING(logId, false) + " ,?, ?, ?, ?, ?, ?, "+ WFSUtil.TO_DATE(strDate, true, dbType)
                           +",?,?,?,?,?,?,?,?,?)");
              }
                pstmt.setInt(1, processDefId);
                pstmt.setInt(2, activityId);
                WFSUtil.DB_SetString(3, processInstanceId, pstmt, dbType);
                pstmt.setInt(4, workitemId);
                pstmt.setInt(5,userId );
                pstmt.setInt(6, actionId);
                WFSUtil.DB_SetString(7, fieldName, pstmt, dbType);//AssociateFieldName will contain AssignedTo User Data
                WFSUtil.DB_SetString(8, activityName, pstmt, dbType);
                WFSUtil.DB_SetString(9, userName, pstmt, dbType);//UserName field will have AssignedBy User Data.
                WFSUtil.DB_SetString(10, taskName, pstmt, dbType);
                pstmt.setInt(11, queueId);
                pstmt.setInt(12,taskId);
                pstmt.setInt(13, subTaskId);
                pstmt.setInt(14, fieldId);
                WFSUtil.DB_SetString(15, urn, pstmt, dbType);
                pstmt.execute();
//                if (!con.getAutoCommit()) {
//                    con.commit();
//                    con.setAutoCommit(true);
//                   // commit = false;
//                }
                pstmt.close();
                pstmt = null;
            }
           
      }catch (SQLException e){
                printErr(engine,"", e);
                mainCode = WFSError.WM_INVALID_FILTER;
                subCode = WFSError.WFS_SQL;
                subject = WFSErrorMsg.getMessage(mainCode);
                errType = WFSError.WF_FAT;
                if(e.getErrorCode() == 0){
                    if(e.getSQLState().equalsIgnoreCase("08S01")){
                        descr = (new JTSSQLError(e.getSQLState())).getMessage() + "(SQL State : " + e.getSQLState() + ")";
                    }
                } else{
                    descr = e.getMessage();
                }
        }catch(NumberFormatException e){
            WFSUtil.printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_ILP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        }catch(Exception e){
            WFSUtil.printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        }catch(Error e){
           WFSUtil.printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } finally {
            try {
//                if (!con.getAutoCommit()) {
//                    con.rollback();
//                    con.setAutoCommit(true);
//                }
            } catch (Exception ignored) {
            }
            try {
                if (rs != null) {
                    rs.close();
                    rs = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (stmt != null) {
                    stmt.close();
                    stmt = null;
                }
            } catch (Exception ignored) {
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                    pstmt = null;
                }
            } catch (Exception ignored) {
            }
          
    }  
        if(mainCode != 0){
            throw new WFSException(mainCode, subCode, errType, subject, descr);
        }
  }
/**
*
* @author kamaljot_singh
* Changes for  upgradeScript to update updateExtDBFeildDefinition table 
* @throws SQLException 
*/
public static void updateExtDBFeildDefinition(Connection con,int dbType) throws Exception {
	// TODO Auto-generated method stub
	   Statement stmt=null;
	   PreparedStatement pstmt=null;
	   PreparedStatement pstmtColInfo=null;
	   ResultSet rset=null;
	   String sQuery="";
	   ArrayList arrTableInfo=new ArrayList();
	   HashMap<String,String> defaultValueMap = null;
           HashMap<String,Integer> columnLengthMap = null;
	   int iProcessdefid=-1;
	   int iExtObjId=-1;
	   boolean bSuccess = false;
	    try{
	    sQuery = "Select processdefid,tablename,extobjid from extdbconftable";
	    stmt = con.createStatement();
	    rset = stmt.executeQuery(sQuery);
	    String sTableName="";
	    while(rset != null && rset.next()){
	       int iProcId = rset.getInt("processdefid");
	       int iExtObj = rset.getInt("extobjid");
	       sTableName = rset.getString("Tablename");
	       arrTableInfo.add(iProcId+":"+sTableName+":"+iExtObj);
	    }
	    String sTableInfo="";
	    String strtablename="";
	    
	    for (int counter = 0; counter < arrTableInfo.size(); counter++) {
	           defaultValueMap = new HashMap<String, String>(); 
                   columnLengthMap = new HashMap<String, Integer>();
	           String colName= "";
	           String defValue="";
	           sTableInfo = (String) arrTableInfo.get(counter);
	           String [] arrTabInfo =  sTableInfo.split(":");
	           strtablename = arrTabInfo[1];
	           iProcessdefid =Integer.parseInt(arrTabInfo[0]);
	           iExtObjId = Integer.parseInt(arrTabInfo[2]);
	           sQuery = "Select * from extdbfielddefinitiontable where processdefid=" + iProcessdefid + " and extobjid="+iExtObjId;
	           pstmt = con.prepareStatement(sQuery);
	           rset = pstmt.executeQuery();
	           if(rset!=null && rset.next())
	           {
	        	   try{
	        	   if(rset!=null){
		               rset.close();
		               rset = null;
		           }
		           if(pstmt!=null){
		               pstmt.close();
		               pstmt=null;
		           }
	           } catch (Exception ignored) {
		        }
	               continue;
	           }
	           
	           if(rset!=null){
	               rset.close();
	               rset = null;
	           }
	           if(pstmt!=null){
	               pstmt.close();
	               pstmt=null;
	           }
	           if(dbType == JTSConstant.JTS_MSSQL){
	           sQuery="SELECT  name ColumnName,TYPE_NAME(user_type_id) TypeName,OBJECT_DEFINITION(default_object_id) DefaultValue,max_length MaxLength,PRECISION percisions,scale scales FROM sys.columns WHERE OBJECT_NAME(object_id) ='"+WFSUtil.TO_SANITIZE_STRING(strtablename, false)+"'";
	           pstmt = con.prepareStatement(sQuery);
	           rset = pstmt.executeQuery();
	           while(rset!=null && rset.next())
	           {
	               String sColDetail="";
	               int iLength=-1;
	               colName=rset.getString("ColumnName");
	               String value  = rset.getString("DefaultValue");
	               String sMaxLength = rset.getString("MaxLength");
	               String sScale = rset.getString("scales");
	               String sPercisions = rset.getString("percisions");
	               String sType = rset.getString("TypeName");
	               if(value!=null)
	                   defValue=value.toString();
	               else 
	                   defValue = "";
	              iLength = Integer.parseInt(sMaxLength);
	              int iPrecison = Integer.parseInt(sPercisions);
	              if(sType.equalsIgnoreCase("nvarchar") || sType.equalsIgnoreCase("varchar")||sType.equalsIgnoreCase("nchar")){
	                  if(defValue.equals("")) 
	                  sColDetail = "STRING:"+(iLength/2)+":0";
	                  else
	                  sColDetail = "STRING:"+(iLength/2)+":0:"+defValue;    
	               }else if(sType.equalsIgnoreCase("char") ){
	                   if(defValue.equals("")) 
	                       sColDetail = "STRING:"+(iLength)+":0";
	                       else
	                       sColDetail = "STRING:"+(iLength)+":0:"+defValue;    
	                    }
	               else if(sType.equalsIgnoreCase("smallint")){
	                  if(defValue.equals("")) 
	                  sColDetail = "INTEGER:"+iLength+":0";
	                  else
	                  sColDetail = "INTEGER:"+iLength+":0:"+defValue;
	               }else if(sType.equalsIgnoreCase("numeric") || sType.equalsIgnoreCase("float")){
	                  if(defValue.equals("")) 
	                  sColDetail = "FLOAT:"+sPercisions+":"+sScale;
	                  else
	                  sColDetail = "FLOAT:"+sPercisions+":"+sScale+":"+defValue;
	               }else if(sType.equalsIgnoreCase("int")||sType.equalsIgnoreCase("bigint")){
	                  if(defValue.equals("")) 
	                  sColDetail = "LONG:"+iLength+":0";
	                  else
	                  sColDetail = "LONG:"+iLength+":0:"+defValue;
	               }else if(sType.equalsIgnoreCase("datetime")){
	                  if(defValue.equals("")) 
	                  sColDetail = "DATE:"+iLength+":0";
	                  else
	                  sColDetail = "DATE:"+iLength+":0:"+defValue;
	               }else if(sType.equalsIgnoreCase("smalldatetime")){
	                  if(defValue.equals("")) 
	                  sColDetail = "SHORTDATE:"+(iPrecison/2)+":0";
	                  else
	                  sColDetail = "SHORTDATE:"+(iPrecison/2)+":0:"+defValue;
	               }else if(sType.equalsIgnoreCase("time")){
	                  if(defValue.equals("")) 
	                  sColDetail = "TIME:"+(iPrecison/2)+":0";
	                  else
	                  sColDetail = "TIME:"+(iPrecison/2)+":0:"+defValue;
	               }
	               else if(sType.equalsIgnoreCase("ntext")){
	                  if(defValue.equals("")) 
	                  sColDetail = "NTEXT:0:0";
	                  else
	                  sColDetail = "NTEXT:0:0:"+defValue;
	               }else if(sType.equalsIgnoreCase("binary")){
	                  if(defValue.equals("")) 
	                  sColDetail = "BINARY:8000:0";
	                  else
	                  sColDetail = "BINARY:8000:0:"+defValue;
	               }else if(sType.equalsIgnoreCase("varbinary")){
	                  if(defValue.equals("")) 
	                  sColDetail = "VARBINARY:8000:0";
	                  else
	                  sColDetail = "VARBINARY:8000:0:"+defValue;
	               }
	               defaultValueMap.put(colName, sColDetail);
	           }
	           
	           if(rset!=null){
	               rset.close();
	               rset = null;
	           }
	           if(pstmt!=null){
	               pstmt.close();
	               pstmt=null;
	           }
	           ArrayList<String> uniqueKey = new ArrayList<String>();
	           ArrayList<String> primaryKey = new ArrayList<String>();
	           HashMap<String,String> defaultValMap = new HashMap<String,String>();
				sQuery = "select CCU.CONSTRAINT_NAME, CCU.COLUMN_NAME from INFORMATION_SCHEMA.TABLE_CONSTRAINTS as TC "
	                       + "inner join INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE as CCU "
	                       + "on TC.CONSTRAINT_CATALOG = CCU.CONSTRAINT_CATALOG "
	                       + "and TC.CONSTRAINT_SCHEMA = CCU.CONSTRAINT_SCHEMA "
	                       + "and TC.CONSTRAINT_NAME = CCU.CONSTRAINT_NAME where TC.TABLE_NAME = '" + WFSUtil.TO_SANITIZE_STRING(strtablename, false)+ "' and TC.CONSTRAINT_TYPE = 'PRIMARY KEY'";
	               pstmt = con.prepareStatement(sQuery);
	               rset = pstmt.executeQuery();
	               while (rset != null && rset.next()) {
	                   colName = rset.getString("COLUMN_NAME");
	                   primaryKey.add(colName);
	               }

	               if (rset != null) {
	                   rset.close();
	                   rset = null;
	               }
	               if (pstmt != null) {
	                   pstmt.close();
	                   pstmt = null;
	               }

	               sQuery = "select CCU.CONSTRAINT_NAME, CCU.COLUMN_NAME from INFORMATION_SCHEMA.TABLE_CONSTRAINTS as TC "
	                       + "inner join INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE as CCU "
	                       + "on TC.CONSTRAINT_CATALOG = CCU.CONSTRAINT_CATALOG "
	                       + "and TC.CONSTRAINT_SCHEMA = CCU.CONSTRAINT_SCHEMA "
	                       + "and TC.CONSTRAINT_NAME = CCU.CONSTRAINT_NAME where TC.TABLE_NAME = '" + WFSUtil.TO_SANITIZE_STRING(strtablename, false) + "' and TC.CONSTRAINT_TYPE = 'UNIQUE'";
	               pstmt = con.prepareStatement(sQuery);
	               rset = pstmt.executeQuery();
	               while (rset != null && rset.next()) {
	                   colName = rset.getString("COLUMN_NAME");
	                   uniqueKey.add(colName);
	               }

	               if (rset != null) {
	                   rset.close();
	                   rset = null;
	               }
	               if (pstmt != null) {
	                   pstmt.close();
	                   pstmt = null;
	               }
					
	           Iterator itr = defaultValueMap.entrySet().iterator();
	           String sColName="";
	           String sColdetails="";
	           sQuery = "Insert into extdbfielddefinitiontable values(?,?,?,?,?,?,?,?)";
	           pstmtColInfo=con.prepareStatement(sQuery);
	           while(itr.hasNext()){
	               Map.Entry sColEntry =(Map.Entry) itr.next();
	               sColdetails = (String) sColEntry.getValue();
	               sColName = (String) sColEntry.getKey();
	               String[] arrColInfo = sColdetails.split(":");
	               pstmtColInfo.setInt(1, iProcessdefid);
	               pstmtColInfo.setString(2,sColName);
	               pstmtColInfo.setString(3,arrColInfo[0]);
	               pstmtColInfo.setInt(4,Integer.parseInt(arrColInfo[1]));
	               if(arrColInfo.length==4)
	               pstmtColInfo.setString(5,arrColInfo[3]);
	               else
	               pstmtColInfo.setNull(5, java.sql.Types.NVARCHAR);    
	               if(primaryKey.contains(sColName)){
	            	   pstmtColInfo.setString(6,"Primary");
	               } else if(uniqueKey.contains(sColName)){
	            	   pstmtColInfo.setString(6,"Unique");
	               } else {
	            	   pstmtColInfo.setNull(6, java.sql.Types.NVARCHAR);
	               }
	               pstmtColInfo.setInt(7,Integer.parseInt(arrColInfo[2]));
	               pstmtColInfo.setInt(8,iExtObjId);
	               pstmtColInfo.addBatch();
	           }
		      int ret[] = pstmtColInfo.executeBatch();
	                   for (int j = 0; j < ret.length; j++) {
	                       if (ret[j] >= 0) {
	                           bSuccess = true;
	                       } else {
	                           bSuccess = false;
	                           break;
	                       }
	              }
	              if (pstmtColInfo != null) {
	                  pstmtColInfo.close();
	                  pstmtColInfo = null;
	              }
	              if (!bSuccess) {
	                   if (!con.getAutoCommit()) {
	                           con.rollback();
	                           con.setAutoCommit(true);
	                    }
	                  
	              }

	           }
	           else if(dbType == JTSConstant.JTS_ORACLE){
	        	   sQuery="select column_name as ColumnName , data_type as TypeName , data_length as MaxLength, data_default as DefaultValue , data_precision, data_scale from all_tab_columns where table_name=upper('"+WFSUtil.TO_SANITIZE_STRING(strtablename, false)+"')";
	               colName= "";
	               defValue="";
	               pstmt = con.prepareStatement(sQuery);
	               rset = pstmt.executeQuery();
                       int fieldLength = 0;
                   HashMap hColNameTypeMap=new HashMap();
                   Boolean boolInsert=false;
	               while(rset!=null && rset.next())
	               {
	                       colName=rset.getString("ColumnName");
                               fieldLength = rset.getInt("MaxLength");
	                       String value  = rset.getString("DefaultValue");
	                       String sType=rset.getString("TypeName");
	                       String sColDetail="";
	                       boolInsert=false;
	                       if(value!=null)
	                               defValue=value.toString();
	                       else 
	                               defValue = "";
	                       defaultValueMap.put(colName, defValue);
                               columnLengthMap.put(colName.toUpperCase(), fieldLength);
                               
                               if("nvarchar2".equalsIgnoreCase(sType) ||"nchar".equalsIgnoreCase(sType)){
              	                  sColDetail = "STRING:"+(fieldLength/2)+":0";  
              	                 boolInsert=true;
              	               }else if("char".equalsIgnoreCase(sType)|| "varchar2".equalsIgnoreCase(sType) ){
              	            	  sColDetail = "STRING:"+(fieldLength)+":0"; 
              	            	 boolInsert=true;
              	               }
              	               else if("Number".equalsIgnoreCase(sType)){
              	                 String dataPrecision=rset.getString("data_precision");
              	                 int dataScale=rset.getInt("data_scale");
              	                 if(dataPrecision==null||dataPrecision==""){
              	                	dataPrecision="38";
              	                 }
              	                 if(dataScale==0){
              	                	sColDetail = "LONG:"+dataPrecision+":0";
              	                 }
              	                 else{
              	                	sColDetail = "FLOAT:"+dataPrecision+":"+dataScale;
              	                 }
              	                boolInsert=true;
              	               }
              	               else if("date".equalsIgnoreCase(sType)){
              	            	  sColDetail = "DATE:"+fieldLength+":0";
              	            	 boolInsert=true;
              	               }
              	              else if(("timestamp("+rset.getInt("data_scale")+")").equalsIgnoreCase(sType)){
              	            	  sColDetail = "TIME:"+fieldLength+":0";
              	            	 boolInsert=true;
                	            	}
              	             else if("nclob".equalsIgnoreCase(sType)||"clob".equalsIgnoreCase(sType)||"blob".equalsIgnoreCase(sType)||"bfile".equalsIgnoreCase(sType)){
             	            	  sColDetail = "NTEXT:"+fieldLength+":0";
             	            	  boolInsert=true;
             	               }
              	               else if("LONG".equalsIgnoreCase(sType)){
              	            	   	int dataPrecision=rset.getInt("data_precision");	
                  	                sColDetail = "LONG:"+dataPrecision+":0";
                  	               boolInsert=true;
                  	            }
              	               else if("FLOAT".equalsIgnoreCase(sType)){
              	            	   	int dataPrecision=rset.getInt("data_precision");
              	            	   int dataScale=rset.getInt("data_scale");
                  	                sColDetail = "FLOAT:"+dataPrecision+":"+dataScale;
                  	               boolInsert=true;
                  	            }
                                if(boolInsert){
                                hColNameTypeMap.put(colName, sColDetail);}
	               }

	               if(rset!=null){
	                       rset.close();
	                       rset = null;
	               }
	               if(pstmt!=null){
	                       pstmt.close();
	                       pstmt=null;
	               }
	               ArrayList<String> uniqueKey = new ArrayList<String>();
	               ArrayList<String> primaryKey = new ArrayList<String>();
	               ArrayList<String> identityColumn = new ArrayList<String>();
	               sQuery = "SELECT cols.table_name, cols.column_name, cols.position, cons.status, cons.owner"
	                               + " FROM all_constraints cons, all_cons_columns cols"
	                               + " WHERE cols.table_name = upper('" + WFSUtil.TO_SANITIZE_STRING(strtablename, false) + "')"
	                               + " AND cons.constraint_type = 'P'"
	                               + " AND cons.constraint_name = cols.constraint_name"
	                               + " AND cons.owner = cols.owner"
	                               + " ORDER BY cols.table_name, cols.position";
	               pstmt = con.prepareStatement(sQuery);
	               rset = pstmt.executeQuery();
	               while (rset != null && rset.next()) {
	                       colName = rset.getString("column_name");
	                       primaryKey.add(colName);
	               }

	               if (rset != null) {
	                       rset.close();
	                       rset = null;
	               }
	               if (pstmt != null) {
	                       pstmt.close();
	                       pstmt = null;
	               }

	               sQuery = "SELECT cols.table_name, cols.column_name, cols.position, cons.status, cons.owner"
	                               + " FROM all_constraints cons, all_cons_columns cols"
	                               + " WHERE cols.table_name = upper('" + WFSUtil.TO_SANITIZE_STRING(strtablename, false) + "')"
	                               + " AND cons.constraint_type = 'U'"
	                               + " AND cons.constraint_name = cols.constraint_name"
	                               + " AND cons.owner = cols.owner"
	                               + " ORDER BY cols.table_name, cols.position";
	               pstmt = con.prepareStatement(sQuery);
	               rset = pstmt.executeQuery();
	               while (rset != null && rset.next()) {
	                       colName = rset.getString("column_name");
	                       uniqueKey.add(colName);
	               }

	               if (rset != null) {
	                       rset.close();
	                       rset = null;
	               }
	               if (pstmt != null) {
	                       pstmt.close();
	                       pstmt = null;
	               }
	                                           
	              // HashMap hColNameTypeMap=new HashMap();
	               String sTypeInfo="";
	               String sColName="";
	             //  String[] strColumns3 = {"ProcessDefId","typefieldid","parentvarfieldid"};
	              // String[] strColumns4 = {"ProcessDefId","typefieldid","parenttypeid"};
	              /* sQuery = "select a.fieldlength,a.varprecision, a.mappedobjectname, b.wftype from ";
	               sQuery += join(dbType, 3, "WFUDTVarMappingTable", "a", "WFTypeDefTable", "b", strColumns3, strColumns4);
	               sQuery += " and a.extobjid = "+iExtObjId+" And a.ProcessDefId="+iProcessdefid+" order by a.typefieldid";
	               pstmt = con.prepareStatement(sQuery);
	               rset = pstmt.executeQuery(); 
	               int iColType=-1;
	               while(rset.next()){
	                       sColName=rset.getString(3);
	                       iColType =  rset.getInt(4);
	                       sTypeInfo= getColumnType(dbType,iColType,0,0,false);
	                       sTypeInfo=sTypeInfo+":"+rset.getString("fieldlength");
	                       sTypeInfo=sTypeInfo+":"+rset.getString("varprecision");
	                       hColNameTypeMap.put(sColName.toLowerCase(), sTypeInfo);
	               }
	               if(hColNameTypeMap.size()==0){
	               sQuery = "select userdefinedname, variabletype, variablelength, varprecision from varmappingtable where processdefid="+iProcessdefid+" and  variablescope='I' and variabletype!=11 and extobjid="+iExtObjId;
	               pstmt = con.prepareStatement(sQuery);
	               rset = pstmt.executeQuery(); 
	               while(rset.next()){
	                       sColName=rset.getString(1);
	                       iColType =  rset.getInt(2);
	                       sTypeInfo= getColumnType(dbType,iColType,0,0,false);
	                       sTypeInfo=sTypeInfo+":"+rset.getString("variablelength");
	                       sTypeInfo=sTypeInfo+":"+rset.getString("varprecision");
	                       hColNameTypeMap.put(sColName.toLowerCase(), sTypeInfo);
	               }
	               }*/
	               String sq1=sQuery;
	               Iterator itr = hColNameTypeMap.entrySet().iterator();
	               sColName="";
	               String sColdetails="";
	               sQuery = "Insert into extdbfielddefinitiontable values(?,?,?,?,?,?,?,?)";
	               pstmtColInfo=con.prepareStatement(sQuery);
	               while(itr.hasNext()){
	                   Map.Entry sColEntry =(Map.Entry) itr.next();
	                   sColdetails = (String) sColEntry.getValue();
	                   sColName = (String) sColEntry.getKey();
	                   String[] arrColInfo = sColdetails.split(":");
	                   pstmtColInfo.setInt(1, iProcessdefid);
	                   pstmtColInfo.setString(2,sColName);
	                   pstmtColInfo.setString(3,arrColInfo[0]);
	                   try{
	                   if(arrColInfo[0].equalsIgnoreCase("DATE")){
	                	   pstmtColInfo.setInt(4,8);
	                   } else if(arrColInfo[0].equalsIgnoreCase("NTEXT")){
	                	   pstmtColInfo.setNull(4, java.sql.Types.INTEGER);
	                   } else if(arrColInfo[0].equalsIgnoreCase("LONG")){
	                	   pstmtColInfo.setInt(4,4);
	                   } else{
	                	   //pstmtColInfo.setInt(4,columnLengthMap.get(colName.toUpperCase()));
	                	   pstmtColInfo.setInt(4, Integer.parseInt(arrColInfo[1]));
	                   }
	                   }catch(Exception e){
	                       //System.out.println("exception  "+e.getMessage());
	                   }
	                   if(defaultValueMap.get(sColName)!=null)
	                   pstmtColInfo.setString(5,defaultValueMap.get(sColName));
	                   else
	                   pstmtColInfo.setNull(5, java.sql.Types.NVARCHAR);
	                   if(primaryKey.contains(sColName)){
	                	   pstmtColInfo.setString(6,"Primary");
	                   } else if(uniqueKey.contains(sColName)){
	                	   pstmtColInfo.setString(6,"Unique");
	                   } else {
	                	   pstmtColInfo.setNull(6, java.sql.Types.NVARCHAR);
	                   }
	                   pstmtColInfo.setInt(7,Integer.parseInt(arrColInfo[2]));
	                   pstmtColInfo.setInt(8,iExtObjId);
	                   pstmtColInfo.addBatch();
	               }
	                 int ret[] = pstmtColInfo.executeBatch();
	                       for (int j = 0; j < ret.length; j++) {
	                           if (ret[j] >= 0) {
	                               bSuccess = true;
	                           } else {
	                               bSuccess = false;
	                               break;
	                           }
	                  }
	                  if (pstmtColInfo != null) {
	                      pstmtColInfo.close();
	                      pstmtColInfo = null;
	                  }
	                  if (!bSuccess) {
	                       if (!con.getAutoCommit()) {
	                               con.rollback();
	                               con.setAutoCommit(true);
	                        }
	                  }
	           
	           }
		}
	    }finally{
	   	 try {
	            if (rset != null) {
	           	 rset.close();
	           	 rset = null;
	            }
	        } catch (Exception ignored) {
	        }
	        try {
	            if (stmt != null) {
	                stmt.close();
	                stmt = null;
	            }
	        } catch (Exception ignored) {
	        }
	        try {
	            if (pstmt != null) {
	                pstmt.close();
	                pstmt = null;
	            }
	        } catch (Exception ignored) {
	        }
	    }
	   
}
/**
*
* @author kamaljot_singh
* Changes for  upgradeScript to update updateExtDBFeildDefinition table 
* @throws SQLException 
*/
public static String getColumnType(int iDBType, int iType, int iLength, int iPrecision, boolean bExport) {
    String sReturn = "";
    switch (iType) {
        case 3://integer
            sReturn = "INTEGER";
            break;
        case 4://long
            sReturn = "LONG";
            break;
        case 6://float
            sReturn = "FLOAT";
            break;
        case 8://Date
            sReturn = "DATE";
            break;
        case 15://ShortDate
            sReturn = "SHORTDATE";
            break;
        case 16://Time
            sReturn = "TIME";
            break;
        case 10: //String
            sReturn = "STRING";
            if (bExport) {
                sReturn = "TEXT";
            }
            break;
        case 17: //Duration
            sReturn = "DURATION";
            break;
        case 12: //boolean
            sReturn = "BOOLEAN";
            break;
        case 18: //NTEXT
            sReturn = "NTEXT";
            break;
    }
    return sReturn;
}public static String getDateTimeFormat() {
    String dateTimeFormat = "";
    try {
        dateTimeFormat = (String) WFFindClass.wfGetServerPropertyMap().get(WFSConstant.CONST_DATETIMEFORMAT);
    } catch (Exception ignored) {
        printOut("[WFSUtil] isSyncRoutingMode() ignoring exception >> " + ignored);
    }
    return dateTimeFormat;
}
public static String getMailFromEmailId() {
    String mailFromEmailId = "";
    try {
        mailFromEmailId = (String) WFFindClass.wfGetServerPropertyMap().get(WFSConstant.CONST_MAILFROMEMAILID);
    } catch (Exception ignored) {
        printOut("[WFSUtil] isSyncRoutingMode() ignoring exception >> " + ignored);
    }
    return mailFromEmailId;
}
public static void printOut(Object message) {
    printOut("",message);
}
public static String searchAndReplaceTags(String str, String tokenToAdd, String dateFormat, XMLParser parser) {
    int begIndex = 0, endIndex = 0;
    String strInputXml = parser.toString();
    String attribute = null;
    String attributeValue = null;
    WMAttribute attrib = null;
    StringBuffer string = new StringBuffer(str);
    begIndex = str.indexOf("&<", begIndex);
    while (begIndex >= 0) {
        if (begIndex + 2 >= string.length()) {
            break;
        }
        endIndex = string.toString().indexOf(">&", begIndex + 2);
        if (endIndex > 0) {
            try {
                attribute = string.substring(begIndex + 2, endIndex);
                /*if (opattr != null) {
                    attrib = (WMAttribute) opattr.get(attribute.toUpperCase());
                }*/
                if (attrib != null) {
                    attributeValue = attrib.value;
                    if (attributeValue == null) {
                        attributeValue = "";
                    }
                } else if (strInputXml.contains(attribute)) {
                    attributeValue = parser.getValueOf(attribute);
                } else if (attribute.equals("Logs")) {
                    attributeValue = WFSUtil.handleSpecialCharInXml(strInputXml);
                } else {
                    attributeValue = "";
                }
            if (attrib != null) {
                String type = String.valueOf(attrib.type);
                if (type.substring(type.length() - 1).equals("8")) {
                    SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
                    java.util.Date tempdate = formatter.parse(attributeValue);
                    SimpleDateFormat formatted = new SimpleDateFormat(dateFormat);
                    attributeValue = formatted.format(tempdate);
                }
            }
             } catch (Exception ex) {
                attributeValue = "";
            }
            if(attributeValue==null)
            {
            	attributeValue="";
            }
            string.replace(begIndex, endIndex + 2, attributeValue + tokenToAdd);
            endIndex = begIndex + attributeValue.length() + tokenToAdd.length(); //for next begIndex

        } else {
            break;
        }
        begIndex = string.toString().indexOf("&<", endIndex);
    }
    return string.toString();
}    
 public static String getAddToMailQueueXML(String engineName, String mailFrom, String mailTo, String mailCC, String mailSubject, String mailMessage,
        String contentType, String processDefId, String processInstanceId, String workitemId,
        String activityId) throws Exception {

    StringBuffer inputXml = new StringBuffer(500);
    inputXml.append("<MailItem>");
    inputXml.append("<EngineName>" + engineName + "</EngineName>");
    inputXml.append("<MailFrom>" + mailFrom + "</MailFrom>");
    inputXml.append("<MailTo>" + mailTo + "</MailTo>");
    inputXml.append("<MailCC>" + mailCC + "</MailCC>");
    inputXml.append("<MailSubject>" + mailSubject + "</MailSubject>");
    inputXml.append("<ContentType>" + contentType + "</ContentType>");
    inputXml.append("<ProcessDefId>" + processDefId + "</ProcessDefId>");
    inputXml.append("<ProcessInstanceId>" + processInstanceId + "</ProcessInstanceId>");
    inputXml.append("<WorkitemId>" + workitemId + "</WorkitemId>");
    inputXml.append("<ActivityId>" + activityId + "</ActivityId>");
    inputXml.append("<ProcessInstanceId>" + processInstanceId + "</ProcessInstanceId>");
    inputXml.append("<MailMessage>" + mailMessage + "</MailMessage>");
    inputXml.append("</MailItem>");
    return inputXml.toString();
}
 public static void sendDiversionNotification(String engine, Connection con, WFParticipant participant, XMLParser parser) {
     try {
         String diversionUserEmail = parser.getValueOf("DivertedUserEmail");
         String assignedToUserEmail = parser.getValueOf("AssignedToUserEmail");
         String mailTo = diversionUserEmail + ";" + assignedToUserEmail;
         boolean isToSendEmail = EmailTemplateUtil.isToSendEmail("UserDiversion", engine,  0);
         if(isToSendEmail){
         String mailMessage = EmailTemplateUtil.retrieveEmailTemplate("UserDiversion"+"_"+Locale.getDefault().toString(), engine, 0);  
         Properties emailProperties = EmailTemplateUtil.retrieveEmailProperties("UserDiversion"+"_"+Locale.getDefault().toString(), engine, 0);
         String mailSubject = (String) emailProperties.get("EmailSubject");
         String mailFrom = (String) emailProperties.get("EmailFrom");
         mailFrom = TO_SANITIZE_STRING(mailFrom, true);
 		 if(mailFrom == null){
 			mailFrom = "OmniFlowSystem_do_not_reply@newgen.co.in";
 		 }
 		 if(mailSubject == null){
 			mailSubject = "Diversion Notification";	
 		 }
         String dateTimeFormat = WFSUtil.getDateTimeFormat();     
         /*if ((mailMessage.contains("<Subject>")) && (mailMessage.contains("</Subject>"))) {
             mailSubject = mailMessage.substring(mailMessage.indexOf("<Subject>") + 9, mailMessage.indexOf("</Subject>"));
             mailSubject = searchAndReplaceTags(mailSubject, "", dateTimeFormat, parser);
         } else {
             mailSubject = "Diversion Notification - User Diversion &<Operation>&";
         }*/
         mailMessage = searchAndReplaceTags(mailMessage, "", dateTimeFormat, parser);
         mailSubject = searchAndReplaceTags(mailSubject, "", dateTimeFormat, parser);
         String mailCC = "";
         String strInputXml = getAddToMailQueueXML(engine, mailFrom, mailTo, mailCC,
                 mailSubject, mailMessage, "text/html;charset=UTF-8",
                 "", "", "", "");
         XMLParser mailParser = new XMLParser();
         mailParser.setInputXML(strInputXml);
         XMLGenerator gen = new XMLGenerator();
         WFSUtil.addToMailQueue(participant.getname(), con, mailParser, gen);
         }
     } catch (Exception ex) {
          WFSUtil.printErr(engine,"", ex);
     }
 }
/**
 * This method returns the Username of the given userID, Added for the Calendar Sharing Task
 * @param con
 * @param parser
 * @param customUserId
 * @return username
 */
	public static String getCustomUserName(Connection con, XMLParser parser, int customUserId) {
		String customUserName = "";
		PreparedStatement prepStmt = null;
		ResultSet rs = null;
		String engine = "";
		try {
			engine = parser.getValueOf("EngineName");
			prepStmt = con.prepareStatement("select username from WFUSERVIEW where userindex = ?");
 			prepStmt.setInt(1, customUserId);
			prepStmt.execute();
			rs = prepStmt.getResultSet();
			if (rs.next()) {
				customUserName = rs.getString(1);
			} else {
				WFSUtil.printErr(engine, "No user exists for User ID " + customUserId);
			}
		} catch (SQLException ex) {
			WFSUtil.printErr(engine, "", ex);
		} catch (Exception ex) {
			WFSUtil.printErr(engine, "", ex);
		} finally {
			try {
				if (rs != null) {
					rs.close();
					rs = null;
				}
				if (prepStmt != null) {
					prepStmt.close();
					prepStmt = null;
				}
			} catch (Exception e) {
				WFSUtil.printErr(engine, "", e);
			}
		}
		return customUserName;
	}
//Added for the Calendar Sharing Task till here
	
	/**
	 * This executes rule condition for the taskid
	 * @param con
	 * @param parser
	 * @param customUserId
	 * @return username
	 * @throws Exception 
	 */
	public static int executeRuleCondition(Connection con, int processDefId, String pId,
			int wId, int activityId,int taskId, int dbType, String engine, int sessionID,
			int userId,int OperationType,int subTaskId,int taskType,LinkedHashMap taskDataMap,int ruleId) throws Exception {
		String lockFlag="";
		WFParticipant participant=null ; 
		participant = WFSUtil.WFCheckSession(con, sessionID);
		String extTableName="";String result="";
		String key="";
		PreparedStatement pstmt=null;
		PreparedStatement pstmt1=null;
		   ResultSet rs=null;
		ResultSet rs1=null;
		int userID = participant.getid();
		int processVariantId=0;
		String itemIndex = "";
        String itemType = "";
        int mainCode=-1;
        String attribXML="";
        ResultSetMetaData rsMetaData=null;
		long startTime = System.currentTimeMillis();
		   WFVariabledef attribs = (WFVariabledef) CachedObjectCollection.getReference().getCacheObject(con, engine, processDefId, WFSConstant.CACHE_CONST_Variable, 
                   "" + (participant.gettype() == 'P' ? -1 : activityId) + string21 + processVariantId ).getData();
        long   endTime = System.currentTimeMillis();
          
           HashMap attribMap = attribs.getAttribMap();
           
           TaskSetValueParam setValParam=getTaskSetValueParam(con,processDefId,activityId,taskId,OperationType,ruleId);
           if(setValParam.extObjId1.contains("1")||setValParam.extObjId2.contains("1")||setValParam.extObjId3.contains("1")){
        	   extTableName=WFSExtDB.getTableName(engine,processDefId,1);
           }
           StringBuffer wfinstrumentStr=new StringBuffer();
           StringBuffer extTableStr=new StringBuffer();
           pstmt1 = con.prepareStatement("Select * from WFInstrumentTable " + WFSUtil.getTableLockHintStr(dbType) + " Where "
                   + "ProcessInstanceId = "+WFSUtil.TO_STRING(pId, true, dbType)+" And WorkItemId = "+wId);
           rs1 = pstmt1.executeQuery();
           ResultSetMetaData rsMetaData1=rs1.getMetaData();
           HashMap<String,String> wfinstrumentDataMap=new HashMap<String,String>();
           HashMap<String,Integer> typeDataMap=new HashMap<String,Integer>();
           if(rs1.next()){
               itemIndex = rs1.getString("VAR_REC_1");
               itemType = rs1.getString("VAR_REC_2");
               
            	   
            	   int j;
            	   for(j=1;j<=rsMetaData1.getColumnCount();j++){
	               wfinstrumentDataMap.put((rsMetaData1.getColumnName(j)).toUpperCase(),rs1.getString(j));
	               typeDataMap.put((rsMetaData1.getColumnName(j)).toUpperCase(),JDBCTYPE_TO_WFSTYPE(rsMetaData1.getColumnType(j)));
	               
            	   }
            	   
               
               
            	   //purposely done to catch exception when all columns has been fetched
            	   //Adding mapped column which are not presemt in cachedObject
            	   wfinstrumentDataMap.put("CURRENTDATETIME",WFSUtil.dbDateTime(con, dbType));
            	   wfinstrumentDataMap.put("WORKITEMNAME",(String)wfinstrumentDataMap.get("PROCESSINSTANCENAME"));
            	   wfinstrumentDataMap.put("EVENTNAME",(String)wfinstrumentDataMap.get("VAR_REC_4"));
            	   wfinstrumentDataMap.put("ROUTINGCOUNT",(String)wfinstrumentDataMap.get("VAR_REC_5"));
            	   wfinstrumentDataMap.put("TURNAROUNDDATETIME",(String)wfinstrumentDataMap.get("EXPECTEDWORKITEMDELAY"));
            	   wfinstrumentDataMap.put("VALIDTILLDATETIME",(String)wfinstrumentDataMap.get("VALIDTILL")==null?(String)wfinstrumentDataMap.get("ENTRYDATETIME"):(String)wfinstrumentDataMap.get("VALIDTILL"));
            	   
               
           }
           for(int i=0;i<setValParam.totalNumberOfSetRules;i++){
        	   if(setValParam.extObjId1.get(i).equals("1")){
        		   pstmt=con.prepareStatement("SELECT "+((WFFieldInfo) attribMap.get(setValParam.param1.get(i).toUpperCase())).getMappedColumn()+" from "+WFSUtil.TO_SANITIZE_STRING(extTableName, false)+" " + WFSUtil.getTableLockHintStr(dbType) + " where itemindex=? and itemtype=?");
     			  pstmt.setString(1, itemIndex);
     			  pstmt.setString(2, itemType);
     			  rs=pstmt.executeQuery();
     			 if(rs.next()){
     				  rsMetaData=rs.getMetaData();
	        			  setValParam.param1Value.put((String)setValParam.param1.get(i),rs.getString(1));  
	        			  typeDataMap.put(((String)setValParam.param1.get(i)).toUpperCase(),JDBCTYPE_TO_WFSTYPE(rsMetaData.getColumnType(1)));
     			  } 
     			 rs.close();
     			 pstmt.close();
        	   }
        	  if(setValParam.param2Type.get(i).equals("C")){
        		  setValParam.param2Value.put((String)setValParam.param2.get(i),(String)setValParam.param2.get(i));
        		  typeDataMap.put(((String)setValParam.param2.get(i)).toUpperCase(),typeDataMap.get(((WFFieldInfo) attribMap.get(setValParam.param1.get(i).toUpperCase())).getMappedColumn().toUpperCase()));
        	  }
        	  else{
        		  if(setValParam.extObjId2.get(i).equals("1")){
        			  
                      
        			  pstmt=con.prepareStatement("SELECT "+((WFFieldInfo) attribMap.get(setValParam.param2.get(i).toUpperCase())).getMappedColumn()+" from "+WFSUtil.TO_SANITIZE_STRING(extTableName, false)+" " + WFSUtil.getTableLockHintStr(dbType) + " where itemindex=? and itemtype=?");
        			  pstmt.setString(1, itemIndex);
        			  pstmt.setString(2, itemType);
        			  rs=pstmt.executeQuery();
        			 if(rs.next()){
        				  rsMetaData=rs.getMetaData();
	        			  setValParam.param2Value.put((String)setValParam.param2.get(i),rs.getString(1));  
	        			  typeDataMap.put(((String)setValParam.param2.get(i)).toUpperCase(),JDBCTYPE_TO_WFSTYPE(rsMetaData.getColumnType(1)));
        			  }
        			 else{
        				 throw new Exception("No Data in external Table");
        			 }
        			 rs.close();
        			 pstmt.close();
        		  }
        		  else{
        			  setValParam.param2Value.put((String)setValParam.param2.get(i),wfinstrumentDataMap.get(((WFFieldInfo) attribMap.get(setValParam.param2.get(i).toUpperCase())).getMappedColumn().toUpperCase()));
        			  typeDataMap.put(((String)setValParam.param2.get(i)).toUpperCase(),JDBCTYPE_TO_WFSTYPE(rsMetaData1.getColumnType(1)));
        		  }
        	  }
        	  if( !(setValParam.operator.get(i)==0)){//if = is the operator then no need to evaluate
        	  
        		  if(setValParam.param3Type.get(i).equals("C")){
        		  setValParam.param3Value.put((String)setValParam.param3.get(i),(String)setValParam.param3.get(i));  
        		  typeDataMap.put(((String)setValParam.param3.get(i)).toUpperCase(),WFConstants.WF_STR);
	        	  }
	        	  else{
	        		  if(setValParam.extObjId3.get(i).equals("1")){
	        			  
	                      
	        			  pstmt=con.prepareStatement("SELECT "+((WFFieldInfo) attribMap.get(setValParam.param3.get(i).toUpperCase())).getMappedColumn()+" from "+WFSUtil.TO_SANITIZE_STRING(extTableName, false)+" " + WFSUtil.getTableLockHintStr(dbType) + "where itemindex=? and itemtype=?");
	        			  pstmt.setString(1, itemIndex);
	        			  pstmt.setString(2, itemType);
	        			  rs=pstmt.executeQuery();
	        			  if(rs.next()){
		    				  rsMetaData=rs.getMetaData();
			    			  setValParam.param3Value.put((String)setValParam.param3.get(i),rs.getString(1));  
			    			  typeDataMap.put(((String)setValParam.param3.get(i)).toUpperCase(),JDBCTYPE_TO_WFSTYPE(rsMetaData.getColumnType(1)));
	        			  }
	        			  else{
	        				  throw new Exception("No Data in external Table");
	        			  }
	        			  rs.close();
	         			 pstmt.close();
	        		  }
	        		  else{
	        			  setValParam.param3Value.put((String)setValParam.param3.get(i),wfinstrumentDataMap.get(((WFFieldInfo) attribMap.get(setValParam.param3.get(i).toUpperCase())).getMappedColumn().toUpperCase()));
	        			  typeDataMap.put(((String)setValParam.param3.get(i)).toUpperCase(),JDBCTYPE_TO_WFSTYPE(rsMetaData1.getColumnType(1)));
	        		  }
	        	  }
	        	  
	        	   result=Utility.evaluateExpression(
	        			  typeDataMap.get(((WFFieldInfo) attribMap.get(setValParam.param1.get(i).toUpperCase())).getMappedColumn().toUpperCase()),
	        			  setValParam.operator.get(i),
	        			  setValParam.param2Value.get((String)setValParam.param2.get(i)),
	        			  typeDataMap.get(((String)setValParam.param2.get(i)).toUpperCase()),
	        			  setValParam.param3Value.get((String)setValParam.param3.get(i)),
	        			  typeDataMap.get(((String)setValParam.param3.get(i)).toUpperCase()));
        	  		}
        	  else{
        		  result=setValParam.param2Value.get((String)setValParam.param2.get(i));
        	  }
	        	  if(!attribXML.contains("<"+setValParam.param1.get(i)+">")){//Handling repeatition of XML Node Tags
	        		  result=result==null?"":result;//Incase value to be set comes as NULL
	        		  attribXML=attribXML+"<"+setValParam.param1.get(i)+">"+result+"</"+setValParam.param1.get(i)+">";
	        	  }
	        	  key=((WFFieldInfo) attribMap.get(setValParam.param1.get(i).toUpperCase())).getMappedColumn().toUpperCase();
	        	  wfinstrumentDataMap.put(key, result);
	           }
           
           rs1.close();
           pstmt1.close();
           	XMLGenerator gen = new XMLGenerator();
           	lockFlag=wfinstrumentDataMap.get("LOCKSTATUS");
           	if("N".equals(lockFlag)){
				participant = new WFParticipant(0, "System", 'P', "SERVER", Locale.getDefault().toString());
				}
     	  	WFSUtil.setAttributesExt(con, participant,attribXML, engine,pId, wId, gen, null, false, false, false,sessionID,null,true);
     	  	mainCode=0;
		
           return mainCode;
		
	}

	/**
	 * This method returns TaskSetValueParam of the given processdefid , activityId, TaskId, OperationType
	 * @param con
	 * @param processDefId
	 * @param activityId
	 * @param taskId
	 * @param OperationType
	 * @return TaskSetValueParam
	 * @throws SQLException 
	 */
	private static  TaskSetValueParam getTaskSetValueParam(Connection con,int processDefId,int activityId,int taskId,int OperationType,int ruleId) throws SQLException {
	// TODO Auto-generated method stub
		PreparedStatement pstmt=null;
		   ResultSet rs=null;
	    pstmt=con.prepareStatement("SELECT PARAM1,PARAM2,PARAM3,OPERATOR,EXTOBJID1,EXTOBJID2,EXTOBJID3,TYPE1,TYPE2,TYPE3 from WFTaskRuleOperationTable where processdefid=? and activityId=? and TaskId=? and OperationType=? and ruleId=?  order by operationorderid");
	    pstmt.setInt(1,processDefId);
	    pstmt.setInt(2,activityId);
	    pstmt.setInt(3,taskId);
	    pstmt.setInt(4,OperationType);
	    pstmt.setInt(5,ruleId);
	    rs=pstmt.executeQuery();
	    
	   
	    TaskSetValueParam setValParam=new TaskSetValueParam();
	    while(rs.next()){
	 	   
	 	   setValParam.param1.add(rs.getString("PARAM1"));
	 	   setValParam.param2.add(rs.getString("PARAM2"));
	 	   setValParam.param3.add(rs.getString("PARAM3"));
	 	   setValParam.operator.add(rs.getInt("OPERATOR"));
	 	   setValParam.param1Type.add(rs.getString("TYPE1"));
	 	   setValParam.param2Type.add(rs.getString("TYPE2"));
	 	   setValParam.param3Type.add(rs.getString("TYPE3"));
	 	   setValParam.extObjId1.add(rs.getString("EXTOBJID1"));
	 	   setValParam.extObjId2.add(rs.getString("EXTOBJID2"));
	 	   setValParam.extObjId3.add(rs.getString("EXTOBJID3"));
	 	   setValParam.totalNumberOfSetRules=setValParam.totalNumberOfSetRules+1;
	    }
    return setValParam;
}
 
/***
 * This method checks if the user has the rights to update the task details(while reassigning the task) : Ambuj
 * Used in WFReassignTask API
 * @param con
 * @param parser
 * @param customUserId
 * @return boolean true/false
 * @author ambuj.tripathi
 */
	 public static boolean hasTaskUpdatePrivileges(Connection con,int dbType, int processDefId, String processInstanceId,int workItemId,
			 int activityId, int taskId, int SubTaskId, int userId, String userName) throws SQLException, WFSException{
		 boolean hasPrivilege =false;
		 hasPrivilege = isUserCaseManager(con, dbType, processDefId, processInstanceId, workItemId, activityId, userId, userName);
		 if(hasPrivilege)
			 return true;
		 else{
			 ResultSet rs = null;
			 PreparedStatement pstmt = null;
			 try{
				 String query = "select 1 from WFTaskStatusTable where processinstanceid = ? and workitemid = ? and processdefid = ? " 
						 		+ " and activityid = ? and TaskId = ? and SubTaskId = ? and InitiatedBy = ? ";
				 pstmt = con.prepareStatement(query);
				 DB_SetString(1, processInstanceId, pstmt, dbType);
				 pstmt.setInt(2, workItemId);
				 pstmt.setInt(3, processDefId);
				 pstmt.setInt(4, activityId);
				 pstmt.setInt(5, taskId);
				 pstmt.setInt(6, SubTaskId);
				 DB_SetString(7, userName, pstmt, dbType);
				 rs = pstmt.executeQuery();
				 if(rs.next()){
					 hasPrivilege = true; 
				 }
			 }
			 finally {
				 if(rs!=null){
					 rs.close();
					 rs= null;
				 }
				 if(pstmt!=null){
					 pstmt.close();
					 pstmt = null;
				 }
			 }
			return hasPrivilege;
		}
	}
	 
public static void addToCaseSummaryQueue(Connection con,int dbType,int processdefid, String processInstanceId, int workitemId, int activityId,
		String activityName) throws SQLException {
	PreparedStatement pstmt = null;
	try{
		StringBuffer query = new StringBuffer("Insert into WFCaseSummaryDetailsTable (ProcessInstanceid,WorkitemId,processdefid,ActivityId,ActivityName,"
				+ "Status,NoOfRetries,EntryDateTime )values(?,?,?,?,?,?,?, "+getDate(dbType)+")");
		pstmt = con.prepareStatement(query.toString());
		DB_SetString(1, processInstanceId, pstmt, dbType);
		pstmt.setInt(2, workitemId);
		pstmt.setInt(3, processdefid);
		pstmt.setInt(4, activityId);
		DB_SetString(5, activityName, pstmt, dbType);
		pstmt.setInt(6,0);
		pstmt.setInt(7,0);
		pstmt.execute();
	}
	finally {
		if(pstmt!=null){
			pstmt.close();
			pstmt = null;
		}
	}	
}

public static boolean isGenerationCaseDocRequired(Connection con, int dbType, int procDefID, int activityId) throws SQLException {
	PreparedStatement pstmt = null;
	ResultSet rs=null;
	String generateCaseDoc = null;

	try{
		pstmt = con.prepareStatement("Select GenerateCaseDoc FROM ActivityTable " + WFSUtil.getTableLockHintStr(dbType) + " where ProcessDefId = ? AND ActivityId  = ? ");
		pstmt.setInt(1, procDefID);
		pstmt.setInt(2, activityId);

		pstmt.execute();
		rs = pstmt.getResultSet();
		if (rs != null && rs.next()) {
			generateCaseDoc = rs.getString("GenerateCaseDoc");
		}

		if (rs != null) {
			rs.close();
			rs = null;
		}
		if (pstmt != null) {
			pstmt.close();
			pstmt = null;
		}
}
	finally{
		try{
			if (rs != null) {
				rs.close();
				rs = null;
			}
		}catch(Exception e){
			
		}
		try{
			if (pstmt != null) {
				pstmt.close();
				pstmt = null;
			}
		}catch(Exception e){
			
		}
		
	}
	return ("Y".equalsIgnoreCase(generateCaseDoc));
}



/**
 * This method retrives the variable value based on the type of the variable
 * @param name
 * @param type
 * @param extObjId
 * @param varId
 * @param varFieldId
 * @param con
 * @param processDefId
 * @param processInstanceId
 * @param workItemId
 * @param activityId
 * @param taskId
 * @param dbType
 * @param cabinetName
 * @return variable value as String
 * @throws SQLException
 * @throws JTSException
 * @author ambuj.tripathi
 */
      public static String getVarValueAllTypes(String name, String type, int extObjId, int varId, int varFieldId, Connection con,
      int processDefId, String processInstanceId, int workItemId, int activityId, int taskId, int dbType, String cabinetName, String taskInitiator) throws SQLException, JTSException{
	      ResultSet rs = null;
	      PreparedStatement pstmt = null;
	      String varValue = "";
	      /*Check for the Adhoc task parameters*/
	      if("TaskInitiator".equalsIgnoreCase(name) && "T".equalsIgnoreCase(type)){
	    	  varValue = taskInitiator;
	    	  return varValue;
	      }else if ("CaseManager".equalsIgnoreCase(name) && "N".equalsIgnoreCase(type)){
	    	  varValue = getCaseManager(con, processInstanceId, processDefId, workItemId, dbType, cabinetName);
	    	  return varValue;
	      }
	      /*Check for adhoc ends heretasks */
	      if(extObjId == 0){
	          if(type.equalsIgnoreCase("C")){//Constant
	              varValue = name;
	          }else if(type.equalsIgnoreCase("U") || type.equalsIgnoreCase("Q")){//Queue Variables
	              String sysDefName = "";
	              pstmt = con.prepareStatement("select SystemDefinedName from varmappingtable where processdefid = ? and variableid = ?");
	              pstmt.setInt(1, processDefId);
	              pstmt.setInt(2, varId);
	              rs = pstmt.executeQuery();
	              if(rs.next()){
	                  sysDefName = rs.getString("SystemDefinedName");
	              }
	              if(rs!=null){
	                   rs.close();
	                   rs= null;
	              }
	              if(pstmt!=null){
	                   pstmt.close();
	                   pstmt = null;
	              }
	              pstmt = con.prepareStatement("select " + WFSUtil.TO_SANITIZE_STRING(sysDefName, false) + " from WFInstrumentTable where ProcessInstanceID = ? " + " and workItemId = ? and ProcessDefID =?  and activityId = ?");
	              WFSUtil.DB_SetString(1, processInstanceId, pstmt, dbType);
	              pstmt.setInt(2, workItemId);
	              pstmt.setInt(3, processDefId);
	              pstmt.setInt(4, activityId);
	              rs = pstmt.executeQuery();
	              if(rs.next()){
	                  varValue = rs.getString(sysDefName);
	              }
	              if(rs!=null){
	                   rs.close();
	                   rs= null;
	              }
	              if(pstmt!=null){
	                   pstmt.close();
	                   pstmt = null;
	              }
	          }else if("S".equalsIgnoreCase(type) || "M".equalsIgnoreCase(type)){//System Variables
	              pstmt = con.prepareStatement("select " + WFSUtil.TO_SANITIZE_STRING(name, false) + " from  WFInstrumentTable where ProcessInstanceID = ? " + " and workItemId = ? and ProcessDefID =? and  activityId = ?");
	              WFSUtil.DB_SetString(1, processInstanceId, pstmt, dbType);
	              pstmt.setInt(2, workItemId);
	              pstmt.setInt(3, processDefId);
	              pstmt.setInt(4, activityId);
	              rs = pstmt.executeQuery();
	              if(rs.next()){
	                  varValue = rs.getString(name);
	              }
	              if(rs!=null){
	                   rs.close();
	                   rs= null;
	              }
	              if(pstmt!=null){
	                   pstmt.close();
	                   pstmt = null;
	              }
	          }
	      } else if(extObjId == 1){
	          if(type.equalsIgnoreCase("I")){
	              varValue = getVariableValue(con, varId, name, processDefId, processInstanceId, workItemId, activityId, taskId, dbType, cabinetName, extObjId);
	          }
	      }
	      return varValue;
	  }
      
  /***
   * This method getTaskAssignedTo returns the name to which task is assigned in case of Auto_initiate : Kimil
   * @param con
   * @param parser
   * @param customUserId
   * @return int maincode
   * @author Kumar Kimil
 * @throws Exception 
   */		      
  
	public static String getTaskAssignedTo(Connection con,int processDefId, String pId, int wId, int activityId,int taskId, 
			    		  int dbType, String engine, int sessionID,int userId, int operationType, int subTaskId,
			    		  int taskType, LinkedHashMap taskDataMap,int ruleId,int caseManagerId) throws Exception {
		WFParticipant participant = WFSUtil.WFCheckSession(con, sessionID);
		String extTableName="";String result="";
		
		PreparedStatement pstmt=null;
		   ResultSet rs=null;
		int userID = participant.getid();
		int processVariantId=0;
		String itemIndex = "";
        String itemType = "";
        int mainCode=-1;
        String attribXML="";
		long startTime = System.currentTimeMillis();
		   WFVariabledef attribs = (WFVariabledef) CachedObjectCollection.getReference().getCacheObject(con, engine, processDefId, WFSConstant.CACHE_CONST_Variable, 
                   "" + (participant.gettype() == 'P' ? -1 : activityId) + string21 + processVariantId ).getData();
        long   endTime = System.currentTimeMillis();
          
           HashMap attribMap = attribs.getAttribMap();
           
           TaskSetValueParam setValParam=getTaskSetValueParam(con,processDefId,activityId,taskId,operationType,ruleId);
           if(setValParam.extObjId1.contains("1")){
               extTableName=WFSExtDB.getTableName(engine,processDefId,1);
           }
               StringBuffer wfinstrumentStr=new StringBuffer();
               StringBuffer extTableStr=new StringBuffer();
               pstmt = con.prepareStatement("Select * from (Select * from WFInstrumentTable where ProcessInstanceId = "+WFSUtil.TO_STRING(pId, true, dbType)+" And WorkItemId = "+wId+" and processdefId="+processDefId+" and activityId="+activityId+" )W LEFT OUTER JOIN (select processdefid,activityId,taskId,username USERID from wfuserview w,WFDefaultTaskUser u where w.userindex=u.userid  and taskId="+taskId+" and useralive='Y' and CaseManagerId="+caseManagerId+" ) D on W.ProcessDefId=D.ProcessDefId and W.ActivityId=D.ActivityId and D.TaskId="+taskId+" and  "
                       + " W.ProcessInstanceId = "+WFSUtil.TO_STRING(pId, true, dbType)+" And W.WorkItemId = "+wId+" and W.processdefId="+processDefId+" and W.activityId="+activityId+"");
               rs = pstmt.executeQuery(); 
               ResultSetMetaData rsMetaData=rs.getMetaData();
               HashMap<String,String> wfinstrumentDataMap=new HashMap<String,String>();
             //  HashMap<String,Integer> typeDataMap=new HashMap<String,Integer>();
               if(rs.next()){
                   itemIndex = rs.getString("VAR_REC_1");
                   itemType = rs.getString("VAR_REC_2");
                   
                	   
                	   int j;
                	   for(j=1;j<=rsMetaData.getColumnCount();j++){
    	               wfinstrumentDataMap.put((rsMetaData.getColumnName(j)).toUpperCase(),rs.getString(j));
    	               
    	        //       typeDataMap.put((rsMetaData.getColumnName(j)).toUpperCase(),JDBCTYPE_TO_WFSTYPE(rsMetaData.getColumnType(j)));
    	               
                	   }
                	   //purposely done to catch exception when all columns has been fetched
                	 //purposely done to catch exception when all columns has been fetched
                	   //Adding mapped column which are not presemt in cachedObject
                	   wfinstrumentDataMap.put("CURRENTDATETIME",WFSUtil.dbDateTime(con, dbType));
                	   wfinstrumentDataMap.put("WORKITEMNAME",(String)wfinstrumentDataMap.get("PROCESSINSTANCENAME"));
                	   wfinstrumentDataMap.put("EVENTNAME",(String)wfinstrumentDataMap.get("VAR_REC_4"));
                	   wfinstrumentDataMap.put("ROUTINGCOUNT",(String)wfinstrumentDataMap.get("VAR_REC_5"));
                	   wfinstrumentDataMap.put("TURNAROUNDDATETIME",(String)wfinstrumentDataMap.get("EXPECTEDWORKITEMDELAY"));
                	   wfinstrumentDataMap.put("VALIDTILLDATETIME",(String)wfinstrumentDataMap.get("VALIDTILL"));
                   
               }
               int i=0;
             	  if(setValParam.param1Type.get(i).equals("C")){
             		  setValParam.param1Value.put((String)setValParam.param1.get(i),(String)setValParam.param1.get(i));
             //		  typeDataMap.put(((String)setValParam.param2.get(i)).toUpperCase(),typeDataMap.get(((WFFieldInfo) attribMap.get(setValParam.param1.get(i).toUpperCase())).getMappedColumn()));
             	  }
             	  else{
             		  if(setValParam.extObjId1.get(i).equals("1")){
             			  
                           
             			  pstmt=con.prepareStatement("SELECT "+((WFFieldInfo) attribMap.get(setValParam.param1.get(i).toUpperCase())).getMappedColumn()+" from "+WFSUtil.TO_SANITIZE_STRING(extTableName, false)+" where itemindex=? and itemtype=?");
             			  pstmt.setString(1, itemIndex);
             			  pstmt.setString(2, itemType);
             			  rs=pstmt.executeQuery();
             			 if(rs.next()){
             				  rsMetaData=rs.getMetaData();
     	        			  setValParam.param1Value.put((String)setValParam.param1.get(i),rs.getString(1));  
     	        //			  typeDataMap.put(((String)setValParam.param2.get(i)).toUpperCase(),JDBCTYPE_TO_WFSTYPE(rsMetaData.getColumnType(1)));
             			  }
             			 else{
             				 throw new Exception("No Data in external Table");
             			 }
             		  }
             		  else{
             			  if(setValParam.param1.get(i).equalsIgnoreCase("CaseManager") && setValParam.param1Type.get(i).equals("M")){
             				  	setValParam.param1Value.put((String)setValParam.param1.get(i),wfinstrumentDataMap.get("ASSIGNEDUSER"));
             		//		 	typeDataMap.put(((String)setValParam.param2.get(i)).toUpperCase(),JDBCTYPE_TO_WFSTYPE(rsMetaData.getColumnType(1)));
               		    	  }
             			  else if(setValParam.param1.get(i).equalsIgnoreCase("PreferredUser") && setValParam.param1Type.get(i).equals("P")){
           				  	setValParam.param1Value.put((String)setValParam.param1.get(i),wfinstrumentDataMap.get("USERID"));
                     		//		 	typeDataMap.put(((String)setValParam.param2.get(i)).toUpperCase(),JDBCTYPE_TO_WFSTYPE(rsMetaData.getColumnType(1)));
                       	   	  }
             			  else{
             				  	setValParam.param1Value.put((String)setValParam.param1.get(i),wfinstrumentDataMap.get(((WFFieldInfo) attribMap.get(setValParam.param1.get(i).toUpperCase())).getMappedColumn().toUpperCase()));
             		//		  	typeDataMap.put(((String)setValParam.param2.get(i)).toUpperCase(),JDBCTYPE_TO_WFSTYPE(rsMetaData.getColumnType(1)));
                		    
             			  	  }
             			  }
             	  	}
             	 
             		  result=setValParam.param1Value.get((String)setValParam.param1.get(i));
               return result;
	}
	/***
	   * This method isUserValid is used in Validating User: Kimil
	   * @param Connection con
	   * @param String assignedTo
	   * @return int maincode
	   * @author Kumar Kimil
	 * @throws SQLException 
	   */		      
	  
		public static int isUserValid(Connection con, String assignedTo,String taskMode) throws SQLException {
			PreparedStatement pstmt=null;
			   ResultSet rs=null;
			   int status=0;    
			   if(taskMode!=null && ((taskMode.equals(WFSConstant.TASK_SUB_ASYNCHRONOUS))||(taskMode.equals(WFSConstant.TASK_SUB_SYNCHRONOUS)) && assignedTo.equalsIgnoreCase("System"))){
				   status=0;
			   }
			   else{
			   String query="Select 1 from WFUserView where UPPER(userName)=UPPER(?) and UserAlive=?";
			   pstmt=con.prepareStatement(query);
			   pstmt.setString(1, assignedTo);
			   pstmt.setString(2, "Y");
			   rs=pstmt.executeQuery();
			   if(rs.next()){
				   status= 0;
			   }
			   else{
				   status= 1;
			   }
			   
				   rs.close();
			       pstmt.close();
			   }
			   return status;
			
		}
		
/**
 * This method retrives the duration details from the durationtable based on teh durationid
 * @param con
 * @param processdefid
 * @param durationId
 * @param taskId
 * @param processInstanceId
 * @param workItemId
 * @param activityId
 * @param dbType
 * @param engine
 * @return Map of String, Integer Containing duration values 
 * @throws SQLException
 * @throws JTSException
 * @throws ParseException
 */
		public static Map getDateTimeMapFromDuration(Connection con, int processdefid, int durationId, int taskId, String processInstanceId, 
				int workItemId, int activityId, int dbType, String engine) throws SQLException, JTSException, ParseException{
	         HashMap<String, Integer> duration = new HashMap<String,Integer>();
	         PreparedStatement pstmt;
	         ResultSet rs;
	         String years = "";
	         int varYears = 0;
	         int varFieldYear = 0;
	         String months = "";
	         int varMonths = 0;
	         int varFieldMonths = 0;
	         String days = "";
	         int varDays = 0;
	         int varFieldDays = 0;
	         String hours = "";
	         int varHours = 0;
	         int varFieldHours = 0;
	         String minutes = "";
	         int varMinutes = 0;
	         int varFieldMinutes = 0;
	         String seconds = "";
	         int varSeconds = 0;
	         int varFieldSeconds = 0;
	         //TBD//If durationID is already given
	         pstmt = con.prepareStatement("select D.WFYears,D.VariableId_Years, " + " D.VarFieldId_Years, D.WFMonths,D.VariableId_Months, D.VarFieldId_Months, D.WFDays, D.VariableId_Days, " + " D.VarFieldId_Days, D.WFHours, D.VariableId_Hours,	D.VarFieldId_Hours, D.WFMinutes, D.VariableId_Minutes," + " D.VarFieldId_Minutes, D.WFSeconds,D.VariableId_Seconds, D.VarFieldId_Seconds from WFDurationTable D" + " where D.processdefid=? and D.durationId = ?");
	         pstmt.setInt(1, processdefid);
	         pstmt.setInt(2, durationId);
	         rs = pstmt.executeQuery();
	         if(rs.next()){
	             years = rs.getString("WFYears");
	             varYears = rs.getInt("VariableId_Years");
	             varFieldYear = rs.getInt("VarFieldId_Years");
	             months = rs.getString("WFMonths");
	             varMonths = rs.getInt("VariableId_Months");
	             varFieldMonths = rs.getInt("VarFieldId_Months");
	             days = rs.getString("WFDays");
	             varDays = rs.getInt("VariableId_Days");
	             varFieldDays = rs.getInt("VarFieldId_Days");
	             hours = rs.getString("WFHours");
	             varHours = rs.getInt("VariableId_Hours");
	             varFieldHours = rs.getInt("VarFieldId_Hours");
	             minutes = rs.getString("WFMinutes");
	             varMinutes = rs.getInt("VariableId_Minutes");
	             varFieldMinutes = rs.getInt("VarFieldId_Minutes");
	             seconds = rs.getString("WFSeconds");
	             varSeconds = rs.getInt("VariableId_Seconds");
	             varFieldSeconds = rs.getInt("VarFieldId_Seconds");
	         }
	         int yearVal = getDurationVarValue(con, years, varYears, processdefid, processInstanceId, workItemId, activityId, taskId, dbType, engine);
	         int monthVal = getDurationVarValue(con, months, varMonths, processdefid, processInstanceId, workItemId, activityId, taskId, dbType, engine);
	         int dayVal = getDurationVarValue(con, days, varDays, processdefid, processInstanceId, workItemId, activityId, taskId, dbType, engine);
	         int hourVal = getDurationVarValue(con, hours, varHours, processdefid, processInstanceId, workItemId, activityId, taskId, dbType,engine);
	         int minuteVal = getDurationVarValue(con, minutes, varMinutes, processdefid, processInstanceId, workItemId, activityId, taskId, dbType, engine);
	         int secondVal = getDurationVarValue(con, seconds, varSeconds, processdefid, processInstanceId, workItemId, activityId, taskId, dbType,	engine);
	         duration.put("Year", Integer.valueOf(yearVal));
	         duration.put("Month", Integer.valueOf(monthVal));
	         duration.put("Day", Integer.valueOf(dayVal));
	         duration.put("Hour", Integer.valueOf(hourVal));
	         duration.put("Minute", Integer.valueOf(minuteVal));
	         duration.put("Second", Integer.valueOf(secondVal));
	         if(rs!= null){
	             rs.close();
	             rs = null;
	         }
	         if(pstmt!= null){
	             pstmt.close();
	             pstmt = null;
	         }
	         return duration;
	     }

/**
 * This is utility method to support the getDateTimeMapFromDuration() method
 * @param con
 * @param varName
 * @param variableId
 * @param processdefid
 * @param processInstanceId
 * @param workItemId
 * @param activityId
 * @param taskId
 * @param dbType
 * @param engine
 * @return calcualted integer values of each duration field 
 * @throws SQLException
 * @throws JTSException
 * @author ambuj.tripathi
 */
public static int getDurationVarValue(Connection con, String varName, int variableId, int processdefid, String processInstanceId, int workItemId, int activityId, int taskId, int dbType, String engine) throws SQLException, JTSException{
	String var = "";
	if(variableId==0){
		return ((varName==null)||(varName.isEmpty())?0:Integer.parseInt(varName));
	}else{
		PreparedStatement pstmt=con.prepareStatement("Select ExtObjId,SystemDefinedName from VarmappingTable where processdefId=? and VariableId=?");
		pstmt.setInt(1,processdefid);
		pstmt.setInt(2,variableId);
		ResultSet rs=pstmt.executeQuery();
		int ExtObjId=0;
		if(rs.next()){
			ExtObjId=rs.getInt("ExtObjId");
			varName=rs.getString("SystemDefinedName");
		}
		if(rs!=null){
			rs.close();
		}
		if(pstmt!=null){
			pstmt.close();
		}
		
			var = getVariableValue(con, variableId, varName, processdefid, processInstanceId, workItemId, activityId, taskId, dbType, engine, ExtObjId);
			return ((var==null)||(var.isEmpty())?0:Integer.parseInt(var));//Only for Integers(WfDurationTable)
		
	}
}
		
/**
 * This method will extract the variable value irrespective of variable type from the DB and return it in the string format
 * @param variableId
 * @param processDefId
 * @param processInstanceId
 * @param workItemId
 * @param activityId
 * @param taskId
 * @return string
 * @throws SQLException 
 * @throws JTSException 
 */
public static String getVariableValue(Connection con, int variableId, String varName, int processDefId, String processInstanceId, int workItemId, 
		int activityId, int taskId, int dbType, String cabinetName, int extObjId) throws SQLException, JTSException {
	String varValue = "";
	 ResultSet rs = null;
	 PreparedStatement pstmt = null;
	 //int extObjId = 0;
	 try{
		// When ExtObjId is not known , then it will calculate extObjId
		 extObjId = -1;
		 if(extObjId == -1){
			 String query = "select ExtObjId, SystemDefinedName  from varmappingtable where "
					 		+ " processdefid =? and variableid =?";
			 pstmt = con.prepareStatement(query);
			 pstmt.setInt(1, processDefId);
			 pstmt.setInt(2, variableId);
			 rs = pstmt.executeQuery();
			 if(rs.next()){
				 extObjId = rs.getInt("ExtObjId");
				 varName = rs.getString("SystemDefinedName");
			 }
			 if(rs!=null){
				 rs.close();
				 rs= null;
			 }
			 if(pstmt!=null){
				 pstmt.close();
				 pstmt = null;
			 }
		 }
		 //Variable is queue variable type
		 if(extObjId == 0){
			 pstmt = con.prepareStatement("select " + WFSUtil.TO_SANITIZE_STRING(varName, false) + " from WFInstrumentTable where ProcessInstanceID = ? ");
			 WFSUtil.DB_SetString(1, processInstanceId, pstmt, dbType);
			 rs = pstmt.executeQuery();
			 if(rs.next()){
				 varValue = rs.getString(varName);
				 varValue = StringEscapeUtils.escapeHtml(varValue);
				 varValue = StringEscapeUtils.unescapeHtml(varValue);
			 }
			 if(rs!=null){
				 rs.close();
				 rs= null;
			 }
			 if(pstmt!=null){
				 pstmt.close();
				 pstmt = null;
			 }
		 }else if(extObjId == 1){
			int itemIndex = 0;
			String itemType = "";
			String extTabName = "";
			pstmt = con.prepareStatement("select VAR_REC_1,	VAR_REC_2 from WFInstrumentTable where ProcessInstanceID = ? " 
	 					+ " and workItemId = ? and ProcessDefID =? and activityId = ?");
			WFSUtil.DB_SetString(1, processInstanceId, pstmt, dbType);
			pstmt.setInt(2, workItemId);
			pstmt.setInt(3, processDefId);
			pstmt.setInt(4, activityId);
			rs = pstmt.executeQuery();
			if(rs.next()){
				itemIndex = rs.getInt("VAR_REC_1");
				itemType = rs.getString("VAR_REC_2");
			}
			if(rs!=null){
				 rs.close();
				 rs= null;
			}
			if(pstmt!=null){
				 pstmt.close();
				 pstmt = null;
			}
			extTabName = WFSExtDB.getTableName(cabinetName, processDefId, 1);
			pstmt = con.prepareStatement(" select " + WFSUtil.TO_SANITIZE_STRING(varName, false) + " from " + WFSUtil.TO_SANITIZE_STRING(extTabName, false) + " where ItemIndex = ? and ItemType = ?");
			pstmt.setInt(1, itemIndex);
			WFSUtil.DB_SetString(2, itemType, pstmt, dbType);
			rs = pstmt.executeQuery();
			if(rs.next()){
				varValue = rs.getString(varName);
				varValue = StringEscapeUtils.escapeHtml(varValue);
				varValue = StringEscapeUtils.unescapeHtml(varValue);
			}
			if(rs!=null){
				 rs.close();
				 rs= null;
			}
			if(pstmt!=null){
				 pstmt.close();
				 pstmt = null;
			}
		 }
	 }
	 finally {
		 if(rs!=null){
			 rs.close();
			 rs= null;
		 }
		 if(pstmt!=null){
			 pstmt.close();
			 pstmt = null;
		 }
	 }
	return varValue;
}

/**
 * This method returns the case manager for any workitem
 * @param con
 * @param parser
 * @param processInstanceId
 * @param processDefId
 * @param workitemId
 * @param dbType
 * @return string case manager username
 * @author ambuj.tripathi
 */
	public static String getCaseManager(Connection con, String processInstanceId, int processDefId, int workitemId, int dbType, String engine) {
		String caseManager = "";
		PreparedStatement prepStmt = null;
		ResultSet rs = null;
		try {
			StringBuilder query = new StringBuilder().append(" Select u.username from Wfuserview u " + WFSUtil.getTableLockHintStr(dbType));
			query.append(", WFInstrumentTable i " + WFSUtil.getTableLockHintStr(dbType) + " where u.UserIndex = i.Q_UserId and ");
			query.append(" i.ProcessDefID = ? and i.WorkItemId = ? and i.processinstanceid = ?");
			prepStmt = con.prepareStatement(query.toString());
				prepStmt.setInt(1, processDefId); 			
				prepStmt.setInt(2, workitemId);
				DB_SetString(3, processInstanceId, prepStmt, dbType);
			rs = prepStmt.executeQuery();
			if (rs.next()) {
				caseManager = rs.getString(1);
				caseManager = StringEscapeUtils.escapeHtml(caseManager);
				caseManager = StringEscapeUtils.unescapeHtml(caseManager);
			}
		} catch (SQLException ex) {
			WFSUtil.printErr(engine, "", ex);
		} catch (Exception ex) {
			WFSUtil.printErr(engine, "", ex);
		} finally {
			try {
				if (prepStmt != null) {
					prepStmt.close();
					prepStmt = null;
				}
				if (rs != null) {
					rs.close();
					rs = null;
				}
			} catch (Exception e) {
				WFSUtil.printErr(engine, "", e);
			}
		}
		return caseManager;
	}

/**
 * This method returns the Task Initiator for any workitem
 * @param con
 * @param parser
 * @param processInstanceId
 * @param processDefId
 * @param workitemId
 * @param dbType
 * @return string case manager username
 * @author ambuj.tripathi
 */
	public static String getTaskInitiator(Connection con, String processInstanceId, int processDefId, int workitemId, int dbType, String engine) {
		String taskInitiator = "";
		PreparedStatement prepStmt = null;
		ResultSet rs = null;
		try {
			StringBuilder query = new StringBuilder().append("  select InitiatedBy from wftaskstatustable " + WFSUtil.getTableLockHintStr(dbType));
			query.append(" where processdefid = ? and workitem = ? and processinstanceid = ? ");
			prepStmt = con.prepareStatement(query.toString());
				prepStmt.setInt(1, processDefId); 			
				prepStmt.setInt(2, workitemId);
				DB_SetString(3, processInstanceId, prepStmt, dbType);
			rs = prepStmt.executeQuery();
			if (rs.next()) {
				taskInitiator = rs.getString(1);
			}
		} catch (SQLException ex) {
			WFSUtil.printErr(engine, "", ex);
		} catch (Exception ex) {
			WFSUtil.printErr(engine, "", ex);
		} finally {
			try {
				if (prepStmt != null) {
					prepStmt.close();
					prepStmt = null;
				}
				if (rs != null) {
					rs.close();
					rs = null;
				}
			} catch (Exception e) {
				WFSUtil.printErr(engine, "", e);
			}
		}
		return taskInitiator;
	}
	
/**
 * This method replaces the tags in mailMessage and mailSubject by corrsp. values
 * @param con
 * @param processDefId
 * @param pId
 * @param wId
 * @param activityId
 * @param taskId
 * @param subTaskId
 * @param dbType
 * @param engine
 * @param sessionID
 * @return replaced mail message/subject
 * @throws SQLException
 * @author ambuj.tripathi
 */	
   public static String replaceMailTags(String sourceStr, Connection con, int processDefId, String processInstanceId, int workItemId, 
    		int activityId, int taskId, int dbType, Map attribMap, String engine) throws Exception{
    	PreparedStatement pstmt = null;
    	ResultSet rs = null;
    	int itemIndex = 0;
    	String itemType = "";
    	StringBuilder extTabQuery = new StringBuilder("select ItemIndex ");
    	HashMap wfinstrumentDataMap = new HashMap<String,String>();
		/*WFVariabledef attribs = (WFVariabledef) CachedObjectCollection.getReference().getCacheObject(con, engine, processDefId, 
				WFSConstant.CACHE_CONST_Variable, "" + (participant.gettype() == 'P' ? -1 : activityId) + string21 + 0 ).getData();
		HashMap attribMap = attribs.getAttribMap();
		*/
    	if(attribMap.isEmpty()){
    		throw new Exception("Attribute Map cannot be empty");
    	}
        pstmt = con.prepareStatement("Select * from WFInstrumentTable " + WFSUtil.getTableLockHintStr(dbType) + " Where ProcessInstanceId = " 
        							+ WFSUtil.TO_STRING(processInstanceId, true, dbType)+" And WorkItemId = " + workItemId);
        rs = pstmt.executeQuery();
        ResultSetMetaData rsMetaData=rs.getMetaData();
        if(rs.next()){
            try{
         	   int j = 1;
         	   for(;;){
	               wfinstrumentDataMap.put((rsMetaData.getColumnName(j)).toUpperCase(),rs.getString(j));
	               j++;
	               if (j  == Integer.MAX_VALUE) {
	            	    break;
	            }
         	   }
            }
            catch(Exception e){
            }
        	itemIndex = rs.getInt("VAR_REC_1");
        	itemType = rs.getString("VAR_REC_2");
        }
		if (rs != null) {
			rs.close();
			rs = null;
		}
		if (pstmt != null) {
			pstmt.close();
			pstmt = null;
		}
		
		//Replace currentDateTime before processing any other tag
    	if(sourceStr != null && !sourceStr.isEmpty()){
        	sourceStr = sourceStr.replaceAll("&<CurrentDateTime>&", dbDateTime(con, dbType));        		
    	}
    	String procId = (String)wfinstrumentDataMap.get("PROCESSINSTANCEID");
    	wfinstrumentDataMap.put("PROCESSINSTANCENAME", procId);
        Set<String> wfInstrumentCols = wfinstrumentDataMap.keySet();
    	Set<String> extVarSet = new HashSet<String>();
    	Set<String> qVarSet = new HashSet<String>();
        int begin = 0;
        int end = 0;
        begin = sourceStr.indexOf("&<", begin);
        while(begin >= 0){
            if(begin + 2 >= sourceStr.length()){
                break;
            }
            end = sourceStr.indexOf(">&", begin+2);
            if(end > 0){
                try{
                    String tagName = sourceStr.substring(begin+2, end);
                    if(tagName != null && !tagName.isEmpty()){
                    	if(wfInstrumentCols.contains(tagName.toUpperCase())){
                    		qVarSet.add(tagName);
                    	}else{
                    		//String instrColName = ((WFFieldInfo)attribMap.get(tagName.toUpperCase())).getMappedColumn();
                    		String instrColName = (String) attribMap.get(tagName.toUpperCase());
                    		if(instrColName != null && wfInstrumentCols.contains(instrColName.toUpperCase())){
                    			qVarSet.add(tagName);
                    		}else{
                    			extVarSet.add(tagName);
                    		}
                    	}
                    }
                }catch(Exception ex){
                }
                end = end + 2;
            }else{
                break;
            }
            begin = sourceStr.indexOf("&<", end);
        }
        //Getting the data from instrument table
        for(String varTag: qVarSet){
        	String qVarValue = (String)wfinstrumentDataMap.get((String)attribMap.get(varTag.toUpperCase()));
			qVarValue = qVarValue.replaceAll("\\\\", "\\\\\\\\");
			qVarValue = qVarValue.replaceAll("\\$","\\\\\\$");
        	String replaceTagStr = "&<" + varTag + ">&";
        	if(qVarValue != null && !qVarValue.isEmpty()){
            	sourceStr = sourceStr.replaceAll(replaceTagStr, qVarValue);        		
        	}else{
        		sourceStr = sourceStr.replaceAll(replaceTagStr, "");
        	}        	
        }
        if(extVarSet.size() > 0){
        //Getting the data from external table
        	String extTabName = WFSExtDB.getTableName(engine, processDefId, 1);

	        for(String varTag: extVarSet){
	        	extTabQuery.append(", " + WFSUtil.TO_SANITIZE_STRING(varTag, true));
	        }
	    	extTabQuery.append(" from " + WFSUtil.TO_SANITIZE_STRING(extTabName, false) + WFSUtil.getTableLockHintStr(dbType) + " where ItemIndex = ? and ItemType = ?");
	    	pstmt = con.prepareStatement(extTabQuery.toString());
	    	pstmt.setInt(1, itemIndex);
	    	DB_SetString(2, itemType, pstmt, dbType);
	    	rs = pstmt.executeQuery();
	    	if(rs.next()){
		        for(String varTag : extVarSet){
		        	String qVarValue = rs.getString(varTag);
					qVarValue = qVarValue.replaceAll("\\\\", "\\\\\\\\");
					qVarValue = qVarValue.replaceAll("\\$","\\\\\\$");
	        		String replaceTagStr = "&<" + varTag + ">&";
	        	    if(qVarValue != null && !qVarValue.isEmpty()){
		        		sourceStr = sourceStr.replaceAll(replaceTagStr, qVarValue);
		        	}else{
		        		sourceStr = sourceStr.replaceAll(replaceTagStr, "");
		        	}
		        }
	    	}
        }
		if (rs != null) {
			rs.close();
			rs = null;
		}
		if (pstmt != null) {
			pstmt.close();
			pstmt = null;
		}
    	return sourceStr;
    }

/**
 * This method returns the mail values from teh DB
 * @param con
 * @param processDefId
 * @param triggerId
 * @param processInstanceId
 * @param workItemId
 * @param activityId
 * @param taskId
 * @param dbType
 * @param engineName
 * @return Map containing mailvalues
 * @throws SQLException
 * @throws JTSException
 * @author ambuj.tripathi
 */
   public static Map getMailMapFromTable(Connection con, int processDefId, int triggerId, String processInstanceId, int workItemId, 
   		int activityId, int taskId, int dbType, String engineName, String taskInitiator) throws SQLException, JTSException{
   	HashMap<String, String> mailMap = new HashMap<String, String>();
   	PreparedStatement pstmt = null;
   	ResultSet rs1 = null;
		//FromUser
		String fromUser = "";
		String fromUserType = "";
		int fromExtObjId = 0;
		int fromVarId = 0;
		int fromVarFieldId = 0;
		//ToUser
		String toUser = "";
		String toUserType = "";
		int toExtObjId = 0;
		int toVarId = 0;
		int toVarFieldId = 0;
		//CCUser
		String ccUser = "";
		String ccUserType = "";
		int ccExtObjId = 0;
		int ccVarId = 0;
		int ccVarFieldId = 0;
		//BccUser
		String bccUser = "";
		String bccUserType = "";
		int bccExtObjId = 0;
		int bccVarId = 0;
		int bccVarFieldId = 0;
		//Mail Priority
		String mailPriority = "";
		String mailPriorityType = "";
		int mpExtObjId = 0;
		int mpVarId = 0;
		int mpVarFieldId = 0;
		//Others
		String mailSubject = "";
		String mailMessage = "";
		//Final Values
		String fromUserValue = "";
		String toUserValue = "";
		String ccUserValue = "";
		String bccUserValue = "";
		String mailPriorityValue = "";
		pstmt = con.prepareStatement("select Subject, FromUser, FromUserType, ExtObjIDFromUser, VariableIdFrom, VarFieldIdFrom, "
								+ " ToUser, ToType, ExtObjIDTo, VariableIdTo, VarFieldIdTo, CCUser, CCType, ExtObjIDCC, "
								+ " VariableIdCc, VarFieldIdCc, Message, BCCUser, BCCType, ExtObjIDBCC, VariableIdBCc, "
								+ " VarFieldIdBCc, MailPriority, MailPriorityType, ExtObjIdMailPriority, VariableIdMailPriority, "
								+ " VarFieldIdMailPriority from MailTriggerTable " +WFSUtil.getTableLockHintStr(dbType)+" where processdefid = ? and triggerId = ?");
		pstmt.setInt(1, processDefId);
		pstmt.setInt(2, triggerId);
		rs1 = pstmt.executeQuery();
		if(rs1.next()){
			fromUser = rs1.getString("FromUser");
			fromUserType = rs1.getString("FromUserType");
			fromExtObjId = rs1.getInt("ExtObjIDFromUser");
			fromVarId = rs1.getInt("VariableIdFrom");
			fromVarFieldId = rs1.getInt("VarFieldIdFrom");
			 
			toUser = rs1.getString("ToUser");
			toUserType = rs1.getString("ToType");
			toExtObjId = rs1.getInt("ExtObjIDTo");
			toVarId = rs1.getInt("VariableIdTo");
			toVarFieldId = rs1.getInt("VarFieldIdTo");
			 
			ccUser = rs1.getString("CCUser");
			ccUserType = rs1.getString("CCType");
			ccExtObjId = rs1.getInt("ExtObjIDCC");
			ccVarId = rs1.getInt("VariableIdCc");
			ccVarFieldId = rs1.getInt("VarFieldIdCc");
			 
			bccUser = rs1.getString("BCCUser");
			bccUserType = rs1.getString("BCCType");
			bccExtObjId = rs1.getInt("ExtObjIDBCC");
			bccVarId = rs1.getInt("VariableIdBCc");
			bccVarFieldId = rs1.getInt("VarFieldIdBCc");
			 
			mailPriority = rs1.getString("MailPriority");
			mailPriorityType = rs1.getString("MailPriorityType");
			mpExtObjId = rs1.getInt("ExtObjIdMailPriority");
			mpVarId = rs1.getInt("VariableIdMailPriority");
			mpVarFieldId = rs1.getInt("VarFieldIdMailPriority");
			 
			mailSubject = rs1.getString("Subject");
			mailMessage = rs1.getString("Message");
		}
		if (rs1 != null) {
			rs1.close();
			rs1 = null;
		}
		if (pstmt != null) {
			pstmt.close();
			pstmt = null;
		}
		
		//Get the actual values from the above fields
		//Adding null check for Bug#72146
		if( (fromUser != null && !fromUser.isEmpty()) && (fromUserType != null && !fromUserType.isEmpty())){
			fromUserValue = WFSUtil.getVarValueAllTypes(fromUser, fromUserType, fromExtObjId, fromVarId, fromVarFieldId, con, processDefId, processInstanceId, workItemId, activityId, taskId, dbType, engineName, taskInitiator);
		}else{
			fromUserValue = null;
		}
		if( (toUser != null && !toUser.isEmpty()) && (toUserType != null && !toUserType.isEmpty())){
			toUserValue = WFSUtil.getVarValueAllTypes(toUser, toUserType, toExtObjId, toVarId, toVarFieldId, con, processDefId, processInstanceId, workItemId, activityId, taskId, dbType, engineName, taskInitiator);
		}else{
			toUserValue = null;
		}
		if( (ccUser != null && !ccUser.isEmpty()) && (ccUserType != null && !ccUserType.isEmpty())){
			ccUserValue = WFSUtil.getVarValueAllTypes(ccUser, ccUserType, ccExtObjId, ccVarId, ccVarFieldId, con, processDefId, processInstanceId, workItemId, activityId, taskId, dbType, engineName, taskInitiator);
		}else{
			ccUserValue = null;
		}
		if( (bccUser != null && !bccUser.isEmpty()) && (bccUserType != null && !bccUserType.isEmpty())){
			bccUserValue = WFSUtil.getVarValueAllTypes(bccUser, bccUserType, bccExtObjId, bccVarId, bccVarFieldId, con, processDefId, processInstanceId, workItemId, activityId, taskId, dbType, engineName, taskInitiator);
		}else{
			bccUserValue = null;
		}
		if( (mailPriority != null && !mailPriority.isEmpty()) && (mailPriorityType != null && !mailPriorityType.isEmpty())){
			mailPriorityValue = WFSUtil.getVarValueAllTypes(mailPriority, mailPriorityType, mpExtObjId, mpVarId, mpVarFieldId, con, processDefId, processInstanceId, workItemId, activityId, taskId, dbType, engineName, taskInitiator);
		}else{
			mailPriorityValue = "0";
		}
		
		//Put the values into a hashmap
		mailMap.put("FROM", fromUserValue);
		mailMap.put("TO", toUserValue);
		mailMap.put("CC", ccUserValue);
		mailMap.put("BCC", bccUserValue);
		mailMap.put("PRIORITY", mailPriorityValue);
		mailMap.put("SUBJECT", mailSubject);
		mailMap.put("MESSAGE", mailMessage);
		
   	return mailMap;
   }
   
 public static Object getTaskData(Connection con, int processDefId,String pId, int wId, int activityId, int taskId,int subTaskId, int dbType,
				String engine, int sessionID) throws SQLException {
			// TODO Auto-generated method stub
			StringBuffer tempXml = new StringBuffer(500);
			LinkedHashMap varValueMap = new LinkedHashMap();
			PreparedStatement pstmt=null;
			String templateName="";
			ResultSet rs=null;
			 pstmt = con.prepareStatement("Select TemplateName from WFTaskTemplateDefTable " +WFSUtil.getTableLockHintStr(dbType)+" Where ProcessDefId=? and TaskId = ?");
             pstmt.setInt(1,processDefId);
             pstmt.setInt(2,taskId);
             rs = pstmt.executeQuery();
             if(rs.next()){
                 templateName = rs.getString(1);
             }
             if(pstmt!=null){
                 pstmt.close();
                 pstmt = null;
             }
             if(rs!=null){
                 rs.close();
                 rs = null;
             }
             XMLGenerator gen =new XMLGenerator();
             varValueMap = WFSUtil.fetchTaskData(con, processDefId, activityId, taskId,subTaskId, pId,
                     wId, 0, 0, dbType, false, engine,gen ,true);
             
             String strQry = "Select  a.TemplateVariableId,a.TaskVariableName,a.VariableType from WFTaskTemplateFieldDefTable a LEFT JOIN "
                 + "(Select * from WFTaskVariableMappingTable where ProcessDefId=? and ActivityId = ? and TaskId=? ) b on "
                 + "a.TemplateVariableId=b.TemplateVariableId where  a.ProcessDefId = ? and a.TaskId=? ";
    //For Generic Tasks only template fields will be  process specific and for rest of the types processdefid in template tables will be 0.
		     pstmt = con.prepareStatement(strQry);
		     pstmt.setInt(1,processDefId);
		     pstmt.setInt(2,activityId);
		     pstmt.setInt(3,taskId);
		     pstmt.setInt(4,processDefId);
		     pstmt.setInt(5,taskId);
		     rs = pstmt.executeQuery();
		     tempXml.append("<TaskData>\n");
		     while(rs.next()){
		         
		         tempXml.append("<Data>\n");
		         tempXml.append(gen.writeValue("TemplateVariableId", String.valueOf(rs.getInt(1))));
		         tempXml.append(gen.writeValue("TaskVariableName", rs.getString(2)));
		         tempXml.append(gen.writeValue("VariableType", String.valueOf(rs.getInt(3))));
		         if(varValueMap.containsKey(rs.getInt(1))){
		             tempXml.append(gen.writeValue("Value", WFSUtil.handleSpecialCharInXml(String.valueOf(varValueMap.get(rs.getInt(1))))));
		         }
		         else{
		        	 tempXml.append("<Value/>");
		         }
		         
		         tempXml.append("\n</Data>\n");
		        
			     }
			     if (rs != null) { 
			         rs.close();
			         rs = null;
			    }
			    
			    if (pstmt != null) {
			        pstmt.close();
			        pstmt = null;
			    }
			     tempXml.append("</TaskData>\n");
					return tempXml.toString();
				}

public static boolean checkTaskAndVariableinPreCondition(Connection con,int processdefid,int activityId, Integer taskId,
		String param1, String type, int extObjId) throws SQLException {

	String qry;
	boolean flag=false;
	PreparedStatement pstmt=null;
	ResultSet rs=null;
	if("T".equals(type)){
	   qry="Select 1 from WFTaskRulePreConditionTable where processdefid=? and activityId=? and variableId_1=? and ruleType=?";
	   pstmt=con.prepareStatement(qry);
	   pstmt.setInt(1, processdefid);
	   pstmt.setInt(2, activityId);
	   pstmt.setInt(3, taskId);
	   pstmt.setString(4, type);
	   rs= pstmt.executeQuery();
	   if(rs.next()){
		  flag=true;
	   }
	   rs.close();
	   pstmt.close();
	}
	else if("V".equals(type)){ 
		   qry="Select 1 from WFTaskRulePreConditionTable where processdefid=? and activityId=? and UPPER(Param1) in (?) and ruleType=?";
		   pstmt=con.prepareStatement(qry);
		   pstmt=con.prepareStatement(qry);
		   pstmt.setInt(1, processdefid);
		   pstmt.setInt(2, activityId);
		   if(param1!=null){
		   pstmt.setString(3, (param1.substring(0, param1.length()-3)).toUpperCase());
		   }else{
			   throw new SQLException("WFSUtil.checkTaskAndVariableinPreCondition param1 is null");
		   }
		   pstmt.setString(4, type);
		   rs= pstmt.executeQuery();
		   if(rs.next()){
			  flag=true;
		   }
		   rs.close();
		   pstmt.close();
		}

	   if(rs!=null){
		  rs.close();
     	  }
	   if(pstmt!=null){
		   pstmt.close();
	   }

	return flag;
}

public static HashMap<String, String> getTaskDetail(
		Connection con, int processDefId, String processInstanceId,
		String taskParentProcInstance) throws SQLException, JTSException {
	
	HashMap<String, String> infoMap=new HashMap<String,String>();
	PreparedStatement pstmt=con.prepareStatement("select T.taskId,W.TaskType,T.SubTaskId,W.TaskMode from WftaskStatusTable T,WfLinkstable L,WFTaskDefTable W where T.TaskId=L.TaskId and T.processinstanceid=L.ChildProcessInstanceId and W.ProcessdefId=T.ProcessDefId and T.TaskId=W.TaskId and L.ParentprocessInstanceId=? and L.ChildProcessInstanceId=? and W.ProcessDefId=? ");
	pstmt.setString(1,processInstanceId);//subprocess instance
	pstmt.setString(2,taskParentProcInstance);//Parent instance -- This is childInstance in WFLinksTable
	pstmt.setInt(3, processDefId);
	ResultSet rSet=pstmt.executeQuery();
	if(rSet.next()){
		infoMap.put("TaskId",rSet.getString(1));
		infoMap.put("TaskType",rSet.getString(2));
		infoMap.put("SubTaskId", rSet.getString(3));
		infoMap.put("TaskMode",rSet.getString(4)); 
	}
	else{
		infoMap.put("TaskId","0");
		infoMap.put("TaskType","0");
		infoMap.put("SubTaskId", "0");
		infoMap.put("TaskMode", "");
	}
	
		rSet.close();
	
	
		pstmt.close();
	
	return infoMap;
}

public static void changeTaskProperty(Connection con, WFParticipant user,
		XMLParser parser, XMLGenerator gen) throws JTSException, SQLException {
	PreparedStatement pstmt = null;
	StringBuilder outputXML = null;
	int mainCode ;
	int subCode ;
	String subject ;
	String descr ;
	String errType = WFSError.WF_TMP;
	
	String taskList;
	int noOfTasks = 0;
	XMLParser tmpParser = new XMLParser();
	String isMandatory;
	int rowsAffected;
	int activityId;
	int wId;
	String pId;
	int taskId;
	
	int counter=0;
	taskList = parser.getValueOf("TaskList", "", false);		
	
	if(!"".equals(taskList)){
		noOfTasks = parser.getNoOfFields("TaskInfo");
	}
	if (con.getAutoCommit()) {
		con.setAutoCommit(false);
	}
	
	String query="Update WFTaskPreConditionResultTable Set Mandatory = ? where ProcessInstanceID = ? and WorkItemId=? and ActivityId=? and TaskId=? ";
	
	while(noOfTasks>0){
		pstmt = con.prepareStatement(query);
		if(counter==0)
		{
			tmpParser.setInputXML(parser.getFirstValueOf("TaskInfo"));
			counter++;
		}
		else{
			tmpParser.setInputXML("");
			tmpParser.setInputXML(parser.getNextValueOf("TaskInfo"));
		}
		activityId = tmpParser.getIntOf("ActivityId",0,false);
		wId = tmpParser.getIntOf("WorkItemId", 0, false);
		pId = tmpParser.getValueOf("ProcessInstanceId","",false);
		taskId=tmpParser.getIntOf("taskId", 0, false);
		isMandatory=tmpParser.getValueOf("IsMandatory","N",false);
		pstmt.setString(1,isMandatory);
		pstmt.setString(2,pId);
		pstmt.setInt(3,wId);
		pstmt.setInt(4,activityId);
		pstmt.setInt(5,taskId);
		rowsAffected=pstmt.executeUpdate();
		pstmt.close();
		if(rowsAffected>0){
			}
		else {
			String qry="Insert into WFTaskPreConditionResultTable (ProcessInstanceId,WorkitemId,ActivityId,TaskId,Ready,Mandatory) values (?,?,?,?,?,?)";
			pstmt = con.prepareStatement(qry);
			pstmt.setString(1,pId);
			pstmt.setInt(2,wId);
			pstmt.setInt(3,activityId);
			pstmt.setInt(4,taskId);
			pstmt.setInt(5,1);
			pstmt.setString(6,isMandatory);
			rowsAffected=pstmt.executeUpdate();
			pstmt.close();
			if(rowsAffected==0){
				mainCode = WFSError.WF_NO_AUTHORIZATION;
				subCode = 0;
				subject = WFSErrorMsg.getMessage(mainCode);
				descr = WFSErrorMsg.getMessage(subCode);
				errType = WFSError.WF_TMP;
				throw new WFSException(mainCode, subCode, errType, subject, descr);
			}
			
		}
		noOfTasks--;
	}
	
}

        
         //----------------------------------------------------------------------------------------------------
//	Function Name 				:	WMConnect
//	Date Written (DD/MM/YYYY)	:	29/04/2002
//	Author						:	Prashant
//	Input Parameters			:	Connection , XMLParser , XMLGenerator
//	Output Parameters			:   none
//	Return Values				:	String
//	Description					:   The WMConnect command informs the WFM Engine that other
//									commands will be originating from this source. Connect to the
//									WFM Engine for this series of interactions
//----------------------------------------------------------------------------------------------------
    public static String WMConnect(Connection con, XMLParser parser, XMLGenerator gen) throws JTSException, WFSException{
        StringBuffer outputXML = new StringBuffer("");
        PreparedStatement pstmt = null;
        int mainCode = 0;
        int subCode = 0;
		int wmConnectValue = 0;//WFS_8.0_050
        String subject = null;
        String descr = null;
        String errType = WFSError.WF_TMP;
        String sValidationRequestList= "";
        ResultSet rs1 = null;
		String queryString ;
		ArrayList parameters = new ArrayList();
		Boolean printQueryFlag = true;
		String engine ="";
		String module = null;
		String isAdmin ="N";
		String strLocale = null;
		try{
             String lastLoginTime = "";
            String str = parser.getValueOf("Name", "", false);
            String p_wd = parser.getValueOf("Password", "", true);
            String scope = parser.getValueOf("Scope", "USER", true);
            char particpantType = parser.getCharOf("ParticipantType", 'U', true);
            strLocale	= parser.getValueOf("Locale", "", true);
            String strRemoteInfoFlag	= parser.getValueOf("RemoteInfoFlag", "N", true);//WFS_8.0_125
            SecureRandom secureRandom = new SecureRandom(); 
            secureRandom.setSeed(System.currentTimeMillis());
            int randomnumber = secureRandom.nextInt();
            randomnumber = Math.abs(randomnumber);
			String privileges = ""; // bug 2746
            StringBuffer tempXml = new StringBuffer(100);
			StringBuffer failXml = new StringBuffer(100);
			StringBuffer timeZoneXml = new StringBuffer(100);//SrNo-2
            engine = parser.getValueOf("EngineName");
            String forceful = parser.getValueOf("UserExist", "Y", true);
            /** 30/12/2008, Single-Sign-On support in WMConnect - Ruhi Hira */
            String securityCredentials = parser.getValueOf("SecurityCredentials", "", true);
			String hook = parser.getValueOf("Hook", "", true);
            int dbType = ServerProperty.getReference().getDBType(engine);
            int userID = 0;
            String clientId = parser.getValueOf("ApplicationInfo", "", true);
            String parentData=parser.getValueOf("ParentData", "", true);
			char userType = parser.getCharOf("UserType", 'U', true);
            int strpass_wordExpiryDaysLeft = -999;
            //  Change for colored display starts here       Abhishek Gupta
            String strRuleListFlag = parser.getValueOf("RuleListFlag", "", true);
            StringBuffer strRuleListXML = new StringBuffer();
            if(strRuleListFlag.equalsIgnoreCase("Y")){
                strRuleListXML.append("<RuleList>");
				queryString = new String("Select FieldName, CompareValue, Operator, Color from WFQueueColorTable " + WFSUtil.getTableLockHintStr(dbType) + " where QueueId = 0");
                pstmt = con.prepareStatement(queryString);
                rs1 = WFSUtil.jdbcExecuteQuery(null,0,0,queryString,pstmt,null,printQueryFlag,engine);
                while(rs1 != null && rs1.next()){
                    strRuleListXML.append("<Rule>");
                    strRuleListXML.append(gen.writeValueOf("FieldName", rs1.getString("FieldName")));
                    strRuleListXML.append(gen.writeValueOf("CompareValue", rs1.getString("CompareValue")));
                    strRuleListXML.append(gen.writeValueOf("Operator", rs1.getString("Operator")));
                    strRuleListXML.append(gen.writeValueOf("Color", rs1.getString("Color")));
                    strRuleListXML.append("</Rule>");
                }
                strRuleListXML.append("</RuleList>");
                if(rs1 != null)
                    rs1.close();
                rs1 = null;
                pstmt.close();
            }
            //  Change for colored display ends here

            if(particpantType == 'U'){
				if(scope.equalsIgnoreCase("USER"))
					module = "Webdesktop";
                else if(scope.equalsIgnoreCase("ADMIN"))
					module = "Processmanager";			
                /* WFS_5_161, MultiLingual Support (Inherited from 5.0), 05/06/2007 - Ruhi Hira */
                String txnstr =
                    "<?xml version=\"1.0\"?><NGOConnectCabinet_Input><Option>NGOConnectCabinet</Option>"
                    + "<CabinetName>" + engine + "</CabinetName><UserName>" + str
                    + "</UserName><UserPassword>" + p_wd + "</UserPassword>" + "<UserExist>" + forceful
					+ "</UserExist><ListSysFolder>N</ListSysFolder><UserType>"+userType+"</UserType><ApplicationInfo>" + clientId + "</ApplicationInfo>"
                    + "<Locale>" + strLocale + "</Locale>"
                    + ((securityCredentials != null && !securityCredentials.equals(""))
                       ? "<SecurityCredentials>" + securityCredentials + "</SecurityCredentials>"
                       : "")
					+ ((hook != null && ! hook.equals("")) ? "<Hook>" + hook + "</Hook>" : "")
					+parentData
                    + "</NGOConnectCabinet_Input>";
                //code for invocation of hook commented by Mandeep-WFS_6.1_050

                try{
                    //condition for checking sub code removed -By Mandeep(WFS_6.1_050)
                    parser.setInputXML(txnstr);
                    txnstr = WFFindClass.getReference().execute("NGOConnectCabinet", engine, con, parser,
                                                                gen);
                    parser.setInputXML(txnstr);
                    subCode = parser.getIntOf("Status", WFSError.WM_CONNECT_FAILED, true);
                    descr = parser.getValueOf("Error"); //error description not correct in case of any exception returned from LDAP hook in WMConnect-By Mandeep Kaur
					wmConnectValue = subCode;//WFS_8.0_050

                } catch(Exception e){
                    WFSUtil.printErr(engine,"", e);
                    mainCode = 1;
                    subject = WFSErrorMsg.getMessage(mainCode, strLocale);
                    subCode = WFSError.WFS_SQL;
                    descr = e.toString();
//                } catch(Throwable t){
//                    WFSUtil.printErr(engine,"", t);/*A catch statement should never catch throwable since it includes errors-- Shweta Singhal*/
                }
                switch(subCode){
                    case 0:
                        mainCode = 0;
                        randomnumber = parser.getIntOf("UserDBId", 0, true);
                        userID = parser.getIntOf("LoginUserIndex", 0, true);
						privileges = parser.getValueOf("Privileges","",true); //bug 2746
						isAdmin =parser.getValueOf("IsAdmin","N",true);
                        /* Added  Bug 1699 */
                        lastLoginTime = parser.getValueOf("LastLoginTime", "", true);
                        String lastLoginFailTime = parser.getValueOf("LastLoginFailureTime", "", true);
                        int failAttemptCount = parser.getIntOf("FailureAttemptCount", 0, true);
                        strpass_wordExpiryDaysLeft = parser.getIntOf("PasswordExpiryDaysLeft", -999, true);
                        failXml.append(gen.writeValueOf("LastLoginTime", lastLoginTime));
						failXml.append(gen.writeValueOf("LastLoginFailureTime", lastLoginFailTime));
						failXml.append(gen.writeValueOf("FailureAttemptCount", String.valueOf(failAttemptCount)));
						queryString = new String(
                            "Update WFSessionView Set Scope =	? where SessionID = ? and UserID = ? and ParticipantType = ? ");
						pstmt = con.prepareStatement(queryString);
                        WFSUtil.DB_SetString(1, scope.trim().toUpperCase(), pstmt, dbType);
                        pstmt.setInt(2, randomnumber);
                        pstmt.setInt(3, userID);
						WFSUtil.DB_SetString(4, "U", pstmt, dbType);						
						parameters.add(scope.trim().toUpperCase());
						parameters.add(randomnumber);
						parameters.add(userID);
						parameters.add("U");
                        WFSUtil.jdbcExecute(null,0,0,queryString,pstmt,parameters,printQueryFlag,engine);
                        pstmt.close();
                        populateQueues(con, userID, dbType,parser,engine);
						timeZoneXml.append("<TimeZoneInfo>");//SrNo-2
						timeZoneXml.append("<DBServer>");
						timeZoneXml.append(gen.writeValueOf("OffSet", WFSUtil.getTimeZoneInfo(con,dbType,parser)));
						timeZoneXml.append("</DBServer>");
						timeZoneXml.append("</TimeZoneInfo>");

						HashMap actionMap = (HashMap) CachedActionObject.getReference().getCacheObject(con, engine);
						HashMap actionIDMap = (HashMap) actionMap.get(new Integer(0));

						if(actionIDMap.containsKey(new Integer(23))){

							WFSUtil.generateLog(engine, con, WFSConstant.WFL_UserLogIn,
                                null, 0, 0, 0, null, 0, userID, str, 0, module, null, null, null, null);
						}				
						
                        break;
                    case -50125:
                        mainCode = WFSError.WM_CONNECT_FAILED;
                        subject = WFSErrorMsg.getMessage(mainCode, strLocale);
                        descr = parser.getValueOf("Error");
                        break;
                    case -50141:
                        mainCode = WFSError.WM_CONNECT_FAILED;
                        subject = WFSErrorMsg.getMessage(mainCode, strLocale);
                        descr = parser.getValueOf("Error");
                        break;
                    case -50127:
                        mainCode = WFSError.WM_CONNECT_FAILED;
                        subCode = WFSError.WFS_INV_PWD;
                        subject = WFSErrorMsg.getMessage(mainCode, strLocale);
                        descr = parser.getValueOf("Error");
                        break;
                    case -50110:
                        mainCode = WFSError.WM_CONNECT_FAILED;
                        subject = WFSErrorMsg.getMessage(mainCode, strLocale);
                        descr = parser.getValueOf("Error");
                        break;
                    case -50198:
                        mainCode = WFSError.WM_CONNECT_FAILED;
                        subject = WFSErrorMsg.getMessage(mainCode, strLocale);
                        descr = parser.getValueOf("Error");
                        break;
                    case -50167:
                        mainCode = WFSError.WM_CONNECT_FAILED;
                        subject = WFSErrorMsg.getMessage(mainCode, strLocale);
                        descr = parser.getValueOf("Error");
                        break;
                    case -50006:
                        mainCode = WFSError.WM_CONNECT_FAILED;
                        subCode = WFSError.WFS_INV_USR;
                        subject = WFSErrorMsg.getMessage(mainCode, strLocale);
                        descr = parser.getValueOf("Error");
                        break;
                    case -50010:
                        mainCode = WFSError.WM_CONNECT_FAILED;
                        subCode = wmConnectValue;//WFS_8.0_050
                        subject = WFSErrorMsg.getMessage(mainCode, strLocale);
                        descr = parser.getValueOf("Error");
                        break;
                    case -50003:
                        mainCode = WFSError.WM_CONNECT_FAILED;
                        subCode = WFSError.WFS_INV_USR;
                        subject = WFSErrorMsg.getMessage(mainCode, strLocale);
                        descr = parser.getValueOf("Error");
                        break;
                    case 310:
                        mainCode = WFSError.WM_CONNECT_FAILED;
                        subCode = WFSError.WFS_INV_USR;
                        subject = WFSErrorMsg.getMessage(mainCode, strLocale);
                        descr = parser.getValueOf("Error");
                        break;
                    case 307:
                        mainCode = WFSError.WM_CONNECT_FAILED;
                        subCode = WFSError.WFS_INV_USR;
                        subject = WFSErrorMsg.getMessage(mainCode, strLocale);
                        descr = parser.getValueOf("Error");
                        break;
                    case 302:
                        mainCode = WFSError.WM_CONNECT_FAILED;
                        subCode = -50010;
                        subject = WFSErrorMsg.getMessage(mainCode, strLocale);
                        descr = parser.getValueOf("Error");
                        break;
				case -50285:
				case -50286:
				case -50287:
				case -50288:
					mainCode = WFSError.WM_CONNECT_FAILED;
					subject = WFSErrorMsg.getMessage(mainCode, strLocale);
					sValidationRequestList = parser.getValueOf("ValidationRequestList");
					if (!sValidationRequestList.isEmpty()) {
						sValidationRequestList = "<ValidationRequestList>" + sValidationRequestList + "</ValidationRequestList>";
					}
					break;

                    default:
                        mainCode = WFSError.WM_CONNECT_FAILED;
                        subject = WFSErrorMsg.getMessage(mainCode, strLocale);
                        //descr = parser.getValueOf("Error");
                        break;
                }
            } else if(particpantType == 'C'){			
				int psId = 0;
                ResultSet rs = null;
				queryString = new String("Select PSCon.SessionId from PSREGISTERATIONTABLE PSRegTab " + WFSUtil.getTableLockHintStr(dbType) + " , WFPSConnection PSCon " + WFSUtil.getTableLockHintStr(dbType) + " where PSRegTab.Type = ? AND UPPER(PSRegTab.PSName) = ? and PSRegTab.PSId = PSCon.PSId ");
                pstmt = con.prepareStatement(queryString);
                WFSUtil.DB_SetString(1, "C", pstmt, dbType);
				WFSUtil.DB_SetString(2, str.toUpperCase(), pstmt, dbType);				
				parameters = new ArrayList();
				parameters.add("C");
				parameters.add(str);
                WFSUtil.jdbcExecute(null,0,0,queryString,pstmt,parameters,printQueryFlag,engine);
                rs = pstmt.getResultSet();
                if(rs.next()){
                    randomnumber = rs.getInt(1);
                } else{
                    randomnumber = 0;
                }
                if(rs != null)
                    rs.close();
                if(pstmt != null){
					pstmt.close();
					pstmt = null;
				}	
				
				queryString = new String("Select PSId from PSREGISTERATIONTABLE " + WFSUtil.getTableLockHintStr(dbType) + " where Type = ? AND UPPER(PSName) = ? ");
                pstmt = con.prepareStatement(queryString);
                WFSUtil.DB_SetString(1, "C", pstmt, dbType);
				WFSUtil.DB_SetString(2, str.toUpperCase(), pstmt, dbType);				
				parameters = new ArrayList();
				parameters.add("C");
				parameters.add(str);
                WFSUtil.jdbcExecute(null,0,0,queryString,pstmt,parameters,printQueryFlag,engine);
                rs = pstmt.getResultSet();
                if(rs.next()){
                    psId = rs.getInt(1);
                } 
                if(rs != null)
                    rs.close();
                pstmt.close();				

                int res = 1; //number of rows found for CS entry

                if(randomnumber == 0){
                    if(con.getAutoCommit())
                        con.setAutoCommit(false);
					queryString = new String("Select * from (Select SessionID from WFPSConnection " + WFSUtil.getTableLockHintStr(dbType) + " UNION Select SessionID from WFSessionView " + WFSUtil.getTableLockHintStr(dbType) + " ) b where SessionID = ? ");
                    pstmt = con.prepareStatement(queryString);
                    rs = null;
                    secureRandom = new SecureRandom(); 
                    secureRandom.setSeed(System.currentTimeMillis());
                    while(true){
                        randomnumber = secureRandom.nextInt();
                        pstmt.setInt(1, randomnumber);
						parameters = new ArrayList();
						parameters.add(randomnumber);
                        WFSUtil.jdbcExecute(null,0,0,queryString,pstmt,parameters,printQueryFlag,engine);
                        rs = pstmt.getResultSet();
                        if(rs.next()){
                            rs.close();
                        } else{
                            break;
                        }
                    }
                    if(rs != null)
                        rs.close();
                    pstmt.close();
					queryString = "Insert into WFPSConnection (PSId, SessionId, Locale, PSLoginTime) values (?, ?, null, " + WFSUtil.getDate(dbType) + " )";
                    pstmt = con.prepareStatement(queryString);
                    pstmt.setInt(1, psId);
					pstmt.setInt(2, randomnumber);
					parameters = new ArrayList();
					parameters.add(randomnumber);
					parameters.add(psId);
					parameters.add(randomnumber);
                    res = WFSUtil.jdbcExecuteUpdate(null,0,0,queryString,pstmt,parameters,printQueryFlag,engine);
                    if(!con.getAutoCommit()){
                        con.commit();
                        con.setAutoCommit(true);
                    }
                }
                if(res == 0){
                    mainCode = WFSError.WM_CONNECT_FAILED;
                    subCode = WFSError.WFS_INV_USR;
                    subject = WFSErrorMsg.getMessage(mainCode, strLocale);
                    descr = WFSErrorMsg.getMessage(subCode, strLocale);
                    errType = WFSError.WF_TMP;
                } else{
                    pstmt.close();
					//queryString = new String("Select PSName from PSRegisterationTable where SessionID is null ");
					queryString = "Select PSName from PSREGISTERATIONTABLE " + WFSUtil.getTableLockHintStr(dbType) + " where PSId not in (select PSId from WFPSConnection " + WFSUtil.getTableLockHintStr(dbType) + " )"; 
                    pstmt = con.prepareStatement(queryString);
                    WFSUtil.jdbcExecute(null,0,0,queryString,pstmt,null,printQueryFlag,engine);
                    rs = pstmt.getResultSet();
                    tempXml.append("<StoppedProcessServers>");
                    while(rs.next()){
                        tempXml.append(gen.writeValueOf("PSName", rs.getString(1)));
                    }
                    tempXml.append("</StoppedProcessServers>");
                }
            } else if(particpantType == 'P'){
                //---------------------------------------------------------------------------------
                // Changed By  : Harmeet kaur
                // Changed On  : 11th May 2005
                // Description : WFS_6_014 - Process Server is routing Workitems with User's id and hence showing these as adhoc routed
                //---------------------------------------------------------------------------------

                /** 05/02/2008, Bugzilla Bug 3750, session generation algorithm revised,
                 * transaction removed. - Ruhi Hira */

//                if(con.getAutoCommit())
//                    con.setAutoCommit(false);

//                pstmt = con.prepareStatement(
//                    "Select PSID,Processdefid from PSRegisterationTable " + WFSUtil.getLockPrefixStr(dbType) + " where Type = 'P' and " + WFSUtil.TO_STRING("PSName", false, dbType) + " = " + WFSUtil.TO_STRING(WFSUtil.TO_STRING(str, true, dbType), false, dbType) + WFSUtil.getLockSuffixStr(dbType));	//Bugzilla Id 47

                queryString = new String(
                    "Select PSID,Processdefid, Data from PSRegisterationTable " + WFSUtil.getTableLockHintStr(dbType) + " where Type = 'P' and UPPER(" + WFSUtil.TO_STRING("PSName", false, dbType) + ") = " + WFSUtil.TO_STRING(WFSUtil.TO_STRING(str.toUpperCase(), true, dbType), false, dbType));	//Bugzilla Id 47
				pstmt = con.prepareStatement(queryString);
                //WFSUtil.DB_SetString(1, str.toUpperCase(), pstmt, dbType);	//Bugzilla Id 47
                WFSUtil.jdbcExecute(null,0,0,queryString,pstmt,null,printQueryFlag,engine);
                ResultSet rs = pstmt.getResultSet();
                if(rs.next()){
                    userID = rs.getInt(1);
                    int procdefid = rs.getInt(2);
                    String appType = rs.getString(3);
                    rs.close();
                    pstmt.close();
                    if (appType != null && appType.toUpperCase().trim().contains("MESSAGE AGENT")) {
                        pstmt = con.prepareStatement("DELETE FROM WFPSConnection WHERE PSId  IN (SELECT PSID FROM PSRegisterationTable " + getTableLockHintStr(dbType) + " WHERE Data = ?)");
                        pstmt.setString(1, appType);
                        pstmt.execute();
                        pstmt.close();
                    }
//				pstmt = con.prepareStatement("Update PSRegisterationTable Set SessionID = ? where not exists ( Select * from (Select SessionID from PSRegisterationTable UNION Select SessionID from WFSessionView) b where SessionID = ? ) and Type = 'P' and PSName = ? ");
                //queryString = new String("Update PSRegisterationTable Set SessionID = ? where Type = ? and PSName = ? ");
				queryString = "Insert into WFPSConnection (PSId, SessionId, Locale, PSLoginTime) values (?, ?, null, " + WFSUtil.getDate(dbType) + " )";
				WFSUtil.printOut(engine, "1111111111 :: " + queryString);
				pstmt = con.prepareStatement(queryString);
//				java.util.Random random = new java.util.Random(System.currentTimeMillis());
				 int iCnt = 0;
                    while(true){

                        if(iCnt++ > 5){
                            mainCode = WFSError.WM_CONNECT_FAILED;
                            subCode = WFSError.WFS_INV_USR;
                            subject = WFSErrorMsg.getMessage(mainCode, strLocale);
                            descr = WFSErrorMsg.getMessage(subCode, strLocale);
                            errType = WFSError.WF_TMP;
                            break;
                        }
                        /** 05/02/2008, Bugzilla Bug 3750, session generation algorithm revised,
                         * transaction removed. - Ruhi Hira */
                        secureRandom = new SecureRandom(); 
    		            secureRandom.setSeed(System.currentTimeMillis());
                        randomnumber = secureRandom.nextInt(8999 + (con.hashCode() % 1000));
                        parameters = new ArrayList();
						pstmt.setInt(1, userID);
						WFSUtil.printOut(engine, "222222222 :: " + userID);
                        pstmt.setInt(2, randomnumber);
						WFSUtil.printOut(engine, "33333333333 :: " + randomnumber);
						parameters.add(userID);
//					    pstmt.setInt(2, randomnumber);						
						parameters.add(randomnumber);                       
						
                        int res = 0;
						
						PreparedStatement pstmt2 = null;
						ResultSet rs2 = null;
						pstmt2 = con.prepareStatement("Select SessionId from WFPSConnection " + WFSUtil.getTableLockHintStr(dbType) + " where PSId = ? ");
						pstmt2.setInt(1, userID);
						try{
							rs2 = pstmt2.executeQuery();
							if(rs2 != null && rs2.next()){
								randomnumber = rs2.getInt(1);
								res = 1;
							}else {                        
								res = WFSUtil.jdbcExecuteUpdate(null,0,0,queryString,pstmt,parameters,printQueryFlag,engine);
							}
                        } catch(Exception th){/*A catch statement should never catch throwable since it includes errors-- Shweta Singhal*/
                            WFSUtil.printErr(engine,"", th);
                        }
						
						if(rs2 != null){
							rs2.close();
							rs2 = null;
						}
						if(pstmt2 != null){
							pstmt2.close();
							pstmt2 = null;						
						}
						

//					while(true) {
//					randomnumber = random.nextInt();
//					pstmt.setInt(1, randomnumber);
//					pstmt.setInt(2, randomnumber);
//					WFSUtil.DB_SetString(3, str.toUpperCase(),pstmt,dbType);

//					int res = pstmt.executeUpdate();
                        if(res > 0){
                            break;
                        }
                    }
                    pstmt.close();
                    /* if(procdefid > 0) {
                      WFProcessServers.getInstance(engine, procdefid).connect(userID, con);
                               }
                     */
                } else{
                    if(rs != null)
                        rs.close();
                    pstmt.close();
                    mainCode = WFSError.WM_CONNECT_FAILED;
                    subCode = WFSError.WFS_INV_USR;
                    subject = WFSErrorMsg.getMessage(mainCode, strLocale);
                    descr = WFSErrorMsg.getMessage(subCode, strLocale);
                    errType = WFSError.WF_TMP;
                }
                if(!con.getAutoCommit()){
                    con.commit();
                    con.setAutoCommit(true);
                }
                pstmt.close();
                pstmt = null;
            } else{
                mainCode = WFSError.WM_CONNECT_FAILED;
                subCode = WFSError.WFS_INV_UTP;
                subject = WFSErrorMsg.getMessage(mainCode, strLocale);
                descr = WFSErrorMsg.getMessage(subCode, strLocale);
                errType = WFSError.WF_TMP;
            }
            if(mainCode == 0){
                outputXML = new StringBuffer(500);
                outputXML.append(gen.createOutputFile("WMConnect"));
                outputXML.append("<Exception>\n<MainCode>0</MainCode>\n</Exception>\n");
                outputXML.append("<Participant>\n");
                outputXML.append(gen.writeValueOf("SessionId", String.valueOf(randomnumber)));
                outputXML.append(gen.writeValueOf("ID", String.valueOf(userID)));
                outputXML.append(gen.writeValueOf("LastLoginTime", lastLoginTime));
                //Sending IsAdmin flag in output of WMConnect to identify whether user is of type admin(authorized to perform Upgrade operation)
                outputXML.append(gen.writeValueOf("IsAdmin", isAdmin));
                if (strpass_wordExpiryDaysLeft != -999)
					outputXML.append(gen.writeValueOf("PasswordExpiryDaysLeft", String.valueOf(strpass_wordExpiryDaysLeft)));

				outputXML.append(gen.writeValueOf("Privileges",privileges)); //bug 2746
				outputXML.append("\n</Participant>\n");
				outputXML.append(failXml); // Bugzilla Bug 1699
                outputXML.append(tempXml);
				outputXML.append(timeZoneXml);//SrNo-2
                if(strRemoteInfoFlag.equalsIgnoreCase("Y"))
                {
                   String strWebServerFlagVal=getWebServerInfo(con, userID, dbType, parser,engine);
                   outputXML.append(gen.writeValueOf("WebServerInfo", strWebServerFlagVal));
                }
                outputXML.append(strRuleListXML);
                outputXML.append(gen.closeOutputFile("WMConnect"));
            }
        } catch(SQLException e){
            WFSUtil.printErr(engine,"", e);
            mainCode = WFSError.WM_CONNECT_FAILED;
            subCode = WFSError.WFS_SQL;
            subject = WFSErrorMsg.getMessage(mainCode, strLocale);
            errType = WFSError.WF_FAT;
            if(e.getErrorCode() == 0){
                if(e.getSQLState().equalsIgnoreCase("08S01")){
                    descr = (new JTSSQLError(e.getSQLState())).getMessage() + "(SQL State : " + e.getSQLState()
                        + ")";
                }
            } else{
                descr = e.toString();
            }
        } catch(NumberFormatException e){
            WFSUtil.printErr(engine,"", e);
            mainCode = WFSError.WM_CONNECT_FAILED;
            subCode = WFSError.WFS_ILP;
            subject = WFSErrorMsg.getMessage(mainCode, strLocale);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch(NullPointerException e){
            WFSUtil.printErr(engine,"", e);
            mainCode = WFSError.WM_CONNECT_FAILED;
            subCode = WFSError.WFS_SYS;
            subject = WFSErrorMsg.getMessage(mainCode, strLocale);
            errType = WFSError.WF_FAT;
            descr = e.toString();
        } catch(JTSException e){
            WFSUtil.printErr(engine,"", e);
            mainCode = WFSError.WM_CONNECT_FAILED;
            subCode = e.getErrorCode();
            subject = WFSErrorMsg.getMessage(mainCode, strLocale);
            errType = WFSError.WF_FAT;
            descr = e.getMessage();
        } catch(Exception e){
            WFSUtil.printErr(engine,"", e);
            mainCode = WFSError.WM_CONNECT_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode, strLocale);
            errType = WFSError.WF_FAT;
            descr = e.toString();
        } catch(Error e){
            WFSUtil.printErr(engine,"", e);
            mainCode = WFSError.WM_CONNECT_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode, strLocale);
            errType = WFSError.WF_FAT;
            descr = e.toString();
        } finally{
            try{
                if(!con.getAutoCommit()){
                    con.rollback();
                    con.setAutoCommit(true);
                }
            } catch(Exception e){}
            try{
                if(pstmt != null){
                    pstmt.close();
                    pstmt = null;
                }
            } catch(Exception e){}
            try{
                if(rs1 != null){
                    rs1.close();
                    rs1 = null;
                }
            } catch(Exception e){}
            
        }
        if(mainCode != 0){
        	throw new WFSException(mainCode, subCode, errType, subject, descr,sValidationRequestList);
        	//throw new WFSException(mainCode, subCode, errType, subject, descr);
            
        }
        return outputXML.toString();
    } //  end of WMConnect.
    public static void populateQueues(Connection con, int userid, int dbType, XMLParser parser,String engine){
        CallableStatement cstmt = null;
        try {

            cstmt = con.prepareCall("{call WFPopulateUserQueue(?, ?)}");
            cstmt.setInt(1, userid);
            cstmt.setNull(2, java.sql.Types.INTEGER);
            cstmt.execute();
            cstmt.close();
            cstmt = null;
        } catch (SQLException ex) {
            WFSUtil.printErr(engine, "", ex);
        } finally {
            try {
                if (cstmt != null) {
                    cstmt.close();
                    cstmt = null;
                }
            } catch (SQLException ex) {
            }
        }
    }
     public static String getWebServerInfo(Connection con, int userid, int dbType, XMLParser parser,String engine){
        PreparedStatement stmt = null;
        String strWebServerInfo="";
        ResultSet rs=null;
        try{
            stmt = con.prepareStatement("Select WebServerInfo from WFUserWebServerInfoTable " + WFSUtil.getTableLockHintStr(dbType) + " where UserId = ?");
			stmt.setInt(1, userid);
            rs=stmt.executeQuery();
            if(rs != null && rs.next())
            {
                strWebServerInfo=rs.getString(1);
            }
			rs.close();
			rs=null;
            stmt.close();
         	stmt = null;
        } catch(SQLException ex){
            WFSUtil.printErr(engine,"", ex);
        } finally{
            try{
				if(rs != null) {
	                rs.close();
					rs=null;
				}
				if(stmt != null) {
		            stmt.close();
        		 	stmt = null;
				}
            } catch(SQLException ex){
            }
        }
        return strWebServerInfo;
    }
    public static String WMDisConnect(Connection con, XMLParser parser,
                               XMLGenerator gen) throws JTSException, WFSException{
        StringBuffer outputXML = null;
		/*	Added by Amul Jain on 26/08/2008 for WFS_6.2_033	*/
		PreparedStatement pstmt = null;
        int mainCode = 0;
        int subCode = 0;
        String subject = null;
        String descr = null;
        String errType = WFSError.WF_TMP;
		ArrayList parameters = new ArrayList();
		Boolean printQueryFlag = true;
        String queryString = new String();
        String engine= null;
        String option = parser.getValueOf("Option", "", false);
		String module = null;
		String userLocale = null;
		PreparedStatement unlockSharedpstmt = null;
        PreparedStatement unlockFixedAssignedpstmt = null; 
        PreparedStatement unlockHoldpstmt = null; 
        String unlockSharedQuery = null;
        String unlockFixedAssignedQuery = null;
        String unlockHoldQuery = null;
        try{
            int SessionId = parser.getIntOf("SessionId", 0, false);
            String psName = parser.getValueOf("Name", "", true);
            char relLocksOnly = parser.getCharOf("ReleaseLocksOnly", 'N', true);
            int userID = 0;
            String str = null;
            String participantType = null;
            engine = parser.getValueOf("EngineName");
            userLocale = parser.getValueOf("Locale", "", true);
            int dbType = ServerProperty.getReference().getDBType(engine);
            printQueryFlag = parser.getValueOf("DebugFlag", "N", true).equalsIgnoreCase("Y");
            boolean unlockWorkitem = parser.getValueOf("UnlockWorkitem", "Y", true).equalsIgnoreCase("Y");
            WFParticipant cs = WFSUtil.WFCheckSession(con, SessionId);
            if(cs != null && psName.equals("") && cs.gettype() == 'U'){
            	int count=0;
            	int f = 0;
            	queryString = "Select ParticipantType  from  WFSessionView  where SessionID = ?";				
    			pstmt = con.prepareStatement(queryString);						
                pstmt.setInt(1, SessionId);            
                pstmt.execute();
                ResultSet rs = pstmt.getResultSet();						
    			if (rs.next()) {
    				 participantType = rs.getString("ParticipantType");
    			}
    			rs.close();
				if(pstmt!=null){
                	pstmt.close();
                	pstmt=null;
                }
				if("S".equalsIgnoreCase(participantType)){
					unlockWorkitem =false;
				}
                userID = cs.getid();
                str = cs.getname();

				/*	Changed by Amul Jain on 26/08/2008 for WFS_6.2_033	*/
                if(con.getAutoCommit())
                    con.setAutoCommit(false);
                //OF Optimization
                if(unlockWorkitem){
                	

                    unlockSharedQuery = "update WFInstrumentTable set LockStatus = ?, LockedByName = null, LockedTime = null , AssignedUser = null , Q_UserId = 0 where processinstanceid = ? and workitemid =?";
                	unlockSharedpstmt = con.prepareStatement(unlockSharedQuery);
                	
                	
                	unlockFixedAssignedQuery = "update WFInstrumentTable set LockStatus=?, LockedByName = null, LockedTime = null where  processinstanceid = ? and workitemid =?";
                	unlockFixedAssignedpstmt = con.prepareStatement(unlockFixedAssignedQuery);
                	
                	unlockHoldQuery = "update WFInstrumentTable set LockStatus = ?, LockedByName = null, LockedTime = null , AssignedUser = null , Q_UserId = 0 where processinstanceid = ? and workitemid =?";
                  	unlockHoldpstmt = con.prepareStatement(unlockHoldQuery);
                  	
                    queryString = "select ProcessInstanceid, workitemid, AssignmentType, processdefid, Q_QUEUEID, ACTIVITYID, ACTIVITYNAME, LOCKEDTIME, "+ WFSUtil.getDate(dbType) +", QUEUETYPE  from WFInstrumentTable" + WFSUtil.getTableLockHintStr(dbType)+" where Q_Userid= ? and Routingstatus=? and LockStatus = ?";
    				pstmt = con.prepareStatement(queryString);
                    pstmt.setInt(1, userID);
                    WFSUtil.DB_SetString(2, "N", pstmt, dbType);
                    WFSUtil.DB_SetString(3, "Y", pstmt, dbType);

                    
                	rs = pstmt.executeQuery();
                    
                    while(rs != null && rs.next()){
                        f=1;
                    	String assignmmentType = rs.getString("AssignmentType");
                    	String procInstId = rs.getString("ProcessInstanceid");
                    	int  workItemId = rs.getInt("workitemid");
                    	int  procDefId = rs.getInt("processdefid");
                    	int  qId = rs.getInt("Q_QUEUEID");
                    	int  actId = rs.getInt("ACTIVITYID");
                    	String actName = rs.getString("ACTIVITYNAME");
                    	String lockedTime = rs.getString("LOCKEDTIME");
                    	String currentDate =  rs.getString(9);
                    	String queueType = rs.getString("QUEUETYPE");
    				
                    	if(assignmmentType.equalsIgnoreCase("S") && !queueType.equalsIgnoreCase("F") ){
                    		
                             WFSUtil.DB_SetString(1, "N", unlockSharedpstmt, dbType);
                             WFSUtil.DB_SetString(2, procInstId, unlockSharedpstmt, dbType);
                             unlockSharedpstmt.setInt(3, workItemId); 
                             unlockSharedpstmt.addBatch();
                             
                             WFSUtil.generateLog(engine, con, WFSConstant.WFL_WorkItemUnlock, procInstId, workItemId, procDefId,
                            		 actId, actName, qId, userID, str, 0, null, currentDate, null, lockedTime, null);
                             
                             count++;
                             
                    	
                    }
                    	else if(assignmmentType.equalsIgnoreCase("F")){

                            WFSUtil.DB_SetString(1, "N", unlockFixedAssignedpstmt, dbType);
                            WFSUtil.DB_SetString(2, procInstId, unlockFixedAssignedpstmt, dbType);
                            unlockFixedAssignedpstmt.setInt(3, workItemId); 
                            unlockFixedAssignedpstmt.addBatch();
                            WFSUtil.generateLog(engine, con, WFSConstant.WFL_WorkItemUnlock, procInstId, workItemId, procDefId,
                           		 actId, actName, qId, userID, str, 0, null, currentDate, null, lockedTime, null);
							count++;
                    	}else if (assignmmentType.equalsIgnoreCase("H")){
                    		
                    		WFSUtil.DB_SetString(1, "N", unlockHoldpstmt, dbType);
                            WFSUtil.DB_SetString(2, procInstId, unlockHoldpstmt, dbType);
                            unlockHoldpstmt.setInt(3, workItemId); 
                            unlockHoldpstmt.addBatch();
                    		
                            WFSUtil.generateLog(engine, con, WFSConstant.WFL_WorkItemUnlock, procInstId, workItemId, procDefId,
                              		 actId, actName, qId, userID, str, 0, null, currentDate, null, lockedTime, null);
							count++;
                    	}
                    
                    	
                    }
                    
                    unlockSharedpstmt.executeBatch();
                    unlockFixedAssignedpstmt.executeBatch();
                    unlockHoldpstmt.executeBatch();
                    
                    if(unlockSharedpstmt!=null){
                   	    unlockSharedpstmt.close();
                   	    unlockSharedpstmt=null;
                    }
                    
                	if(unlockFixedAssignedpstmt!=null){
                		unlockFixedAssignedpstmt.close();
                		unlockFixedAssignedpstmt=null;
                    }
                	if(unlockHoldpstmt!=null){
                		unlockHoldpstmt.close();
                		unlockHoldpstmt=null;
                    }
                    
              
                    if(rs!=null){
                    	rs.close();
                    	rs=null;
                    }
                    
                    if(pstmt != null) {
    					pstmt.close();
    					pstmt = null;
    				}

                	
                /*	
                queryString = "update WFInstrumentTable set AssignmentType = ?, LockStatus = ?, LockedByName = null, LockedTime = null , AssignedUser = null , Q_UserId = 0 where Q_Userid=? and Routingstatus = ? and LockStatus = ? and AssignmentType = ? " ;
//				queryString = new String(" Insert into Worklisttable (ProcessInstanceId,WorkItemId,ProcessName,ProcessVersion,ProcessDefID, " +
//					"LastProcessedBy,ProcessedBy,ActivityName,ActivityId,EntryDateTime,ParentWorkItemId,CollectFlag, " +
//					"PriorityLevel,ValidTill,Q_StreamId,Q_QueueId,AssignmentType,FilterValue, " +
//					"CreatedDateTime,WorkItemState,Statename,ExpectedWorkitemDelay,PreviousStage,LockStatus,Queuename,Queuetype, PROCESSVARIANTID) " +
//					"Select ProcessInstanceId,WorkItemId,ProcessName,ProcessVersion,ProcessDefID,LastProcessedBy,ProcessedBy, " +
//					"ActivityName,ActivityId,EntryDateTime,ParentWorkItemId,CollectFlag,PriorityLevel,ValidTill, " +
//					"Q_StreamId,Q_QueueId," + WFSUtil.TO_STRING("S", true, dbType) + ",FilterValue,CreatedDateTime,WorkItemState,Statename, " +
//					"ExpectedWorkitemDelay,PreviousStage," + WFSUtil.TO_STRING("N", true, dbType) + ",Queuename,Queuetype " +
//					", PROCESSVARIANTID from WorkinProcessTable where (QueueType = " + WFSUtil.TO_STRING("F", true, dbType) + ") and Q_Userid=?");
				pstmt = con.prepareStatement(queryString);
                WFSUtil.DB_SetString(1, "S", pstmt, dbType);
                WFSUtil.DB_SetString(2, "N", pstmt, dbType);
                //WFSUtil.DB_SetString(3, "F", pstmt, dbType);
                pstmt.setInt(3, userID);
                WFSUtil.DB_SetString(4, "N", pstmt, dbType);
                WFSUtil.DB_SetString(5, "Y", pstmt, dbType);
                WFSUtil.DB_SetString(6, "S", pstmt, dbType);
                parameters.add("S");
                parameters.add("N");
                //parameters.add("F");
                parameters.add(userID);
                parameters.add("N");
                parameters.add("Y");
				int f = WFSUtil.jdbcExecuteUpdate(null,SessionId,userID,queryString,pstmt,parameters,printQueryFlag,engine);
                parameters.clear();
                if(pstmt!=null){
                	pstmt.close();
                	pstmt=null;
                }
                
                queryString = "update WFInstrumentTable set  LockStatus = ?, LockedByName = null, LockedTime = null , AssignedUser = null , Q_UserId = 0 where Q_Userid=? and Routingstatus = ? and LockStatus = ? AND ActivityType=?" ;
				pstmt = con.prepareStatement(queryString);
                WFSUtil.DB_SetString(1, "N", pstmt, dbType);
                pstmt.setInt(2, userID);
                WFSUtil.DB_SetString(3, "R", pstmt, dbType);
                WFSUtil.DB_SetString(4, "Y", pstmt, dbType);
                pstmt.setInt(5, WFSConstant.ACT_EXT);
                parameters.add("N");
                parameters.add(userID);
                parameters.add("R");
                parameters.add("Y");
                parameters.add(WFSConstant.ACT_EXT);
				f = f+WFSUtil.jdbcExecuteUpdate(null,SessionId,userID,queryString,pstmt,parameters,printQueryFlag,engine);
                parameters.clear();
                
                if(pstmt!=null){
                	pstmt.close();
                	pstmt=null;
                }*/
                
               /* queryString = "update QueueHistoryTable set  LockStatus = ?, LockedByName = null, LockedTime = null , AssignedUser = null , Q_UserId = 0 where Q_Userid=? and Routingstatus = ? and LockStatus = ? AND ActivityType=?" ;
				pstmt = con.prepareStatement(queryString);
                WFSUtil.DB_SetString(1, "N", pstmt, dbType);
                pstmt.setInt(2, userID);
                WFSUtil.DB_SetString(3, "R", pstmt, dbType);
                WFSUtil.DB_SetString(4, "Y", pstmt, dbType);
                pstmt.setInt(5, WFSConstant.ACT_EXT);
                parameters.add("N");
                parameters.add(userID);
                parameters.add("R");
                parameters.add("Y");
                parameters.add(WFSConstant.ACT_EXT);
				f = f+WFSUtil.jdbcExecuteUpdate(null,SessionId,userID,queryString,pstmt,parameters,printQueryFlag,engine);
                parameters.clear(); */
                if(f > 0){
					/*	Changed by Amul Jain on 26/08/2008 for WFS_6.2_033	*/
//					queryString = new String("Delete from WorkinProcessTable where (QueueType = " +
//						WFSUtil.TO_STRING("F", true, dbType) + ") and Q_Userid=?");
//					
//                    pstmt = con.prepareStatement(queryString);
//                    pstmt.setInt(1, userID);
//                    parameters = new ArrayList();
//					parameters.add(userID);
//					int result = WFSUtil.jdbcExecuteUpdate(null,SessionId,userID,queryString,pstmt,parameters,printQueryFlag,engine);
					//if(result == f) {
						if(!con.getAutoCommit()) {
							con.commit();
							con.setAutoCommit(true);
						}
//					}
//					else {
//						if(!con.getAutoCommit()) {
//							con.rollback();
//							con.setAutoCommit(true);
//						}
//					}
                } else {
                  if(!con.getAutoCommit()) {
                    con.rollback();
                    con.setAutoCommit(true);
                  }
                }
                }else{
                	if(!con.getAutoCommit()) {
						con.commit();
						con.setAutoCommit(true);
					}
                }

                if(relLocksOnly != 'Y'){
					/*	Changed by Amul Jain on 26/08/2008 for WFS_6.2_033	*/
					queryString = new String(" Delete from WFSessionView where SessionID = ?");
					pstmt = con.prepareStatement(queryString);
                    pstmt.setInt(1, SessionId);
                    parameters = new ArrayList(); 
					parameters.add(SessionId);
					int res = WFSUtil.jdbcExecuteUpdate(null,SessionId,userID,queryString,pstmt,parameters,printQueryFlag,engine);
					if(res <= 0) {
						mainCode = WFSError.WM_INVALID_SESSION_HANDLE;
						subject = WFSErrorMsg.getMessage(mainCode, userLocale);
					}
                }

                HashMap actionMap = (HashMap) CachedActionObject.getReference().getCacheObject(con, engine);
                HashMap actionIDMap = (HashMap) actionMap.get(new Integer(0));

                if(actionIDMap.containsKey(new Integer(24))){
                    WFSUtil.generateLog(engine, con, WFSConstant.WFL_UserLogOut,
                                null, 0, 0, 0, null, 0, userID, str, 0, null, null, null, null, null);
                }				
				
				
            } else{
                if(cs != null && cs.gettype() == 'C'){

					/*	Changed by Amul Jain on 26/08/2008 for WFS_6.2_033	*/
					queryString = new String("Select PSId,ProcessDefId from PSRegisterationTable " + WFSUtil.getTableLockHintStr(dbType) + " where " +
						WFSUtil.TO_STRING("PSName", false, dbType) + " = " + WFSUtil.TO_STRING("?", false, dbType));
                    pstmt = con.prepareStatement(queryString);
					WFSUtil.DB_SetString(1, psName, pstmt, dbType);
					parameters = new ArrayList(); 
                    parameters.add(psName);
					WFSUtil.jdbcExecute(null,SessionId,userID,queryString,pstmt,parameters,printQueryFlag,engine);
					ResultSet rs = pstmt.getResultSet();
					if(rs != null && rs.next()) {
						userID = rs.getInt(1);
						int procdefid = rs.getInt(2);
						if(rs != null)
							rs.close();
						//queryString = new String("Update PSRegisterationTable Set SessionID = null where " + WFSUtil.TO_STRING("PSName", false, dbType) + " = " + WFSUtil.TO_STRING("?", false, dbType));
						queryString = "Delete from WFPSConnection where PSId = ? ";
                        pstmt = con.prepareStatement(queryString);
						pstmt.setInt(1, userID);						
						parameters = new ArrayList(); 
                        parameters.add(userID);
						int res = WFSUtil.jdbcExecuteUpdate(null,SessionId,userID,queryString,pstmt,parameters,printQueryFlag,engine);

                        if(res >= 0){
                            if(con.getAutoCommit())
                              con.setAutoCommit(false);

                            //OF Optimization
                            queryString = "update WFInstrumentTable set LockStatus = ?, LockedByName = null, LockedTime = null,Q_Userid=0 where Q_Userid=? and Routingstatus = ?";	
							/*	Changed by Amul Jain on 26/08/2008 for WFS_6.2_033	*/
//							queryString = new String("Insert into Workdonetable (ProcessInstanceId,WorkItemId,"
//								+ "ProcessName,ProcessVersion,ProcessDefID,LastProcessedBy,"
//								+ "ProcessedBy,ActivityName,ActivityId,EntryDateTime,"
//								+ "ParentWorkItemId,AssignmentType,CollectFlag,PriorityLevel,"
//								+ "ValidTill,CreatedDateTime,WorkItemState,Statename,"
//								+ "ExpectedWorkitemDelay,PreviousStage,LockStatus, PROCESSVARIANTID) "
//								+ "Select ProcessInstanceId,WorkItemId,ProcessName,ProcessVersion,"
//								+ "ProcessDefID,LastProcessedBy,ProcessedBy,ActivityName,ActivityId,"
//								+ "EntryDateTime,ParentWorkItemId,AssignmentType,CollectFlag,"
//								+ "PriorityLevel,ValidTill,CreatedDateTime,WorkItemState,"
//								+ "Statename,ExpectedWorkitemDelay,PreviousStage," + WFSUtil.TO_STRING("N", true, dbType)
//								+ ", PROCESSVARIANTID from WorkwithPSTable where Q_Userid=?");
                            pstmt = con.prepareStatement(queryString);
							WFSUtil.DB_SetString(1, "N", pstmt, dbType);
                            pstmt.setInt(2, userID);
							WFSUtil.DB_SetString(3, "Y", pstmt, dbType);
                            parameters.add("N");
                            parameters.add(userID);
                            parameters.add("Y");
							int res1 = WFSUtil.jdbcExecuteUpdate(null,SessionId,userID,queryString,pstmt,parameters,printQueryFlag,engine);
                            parameters.clear();
                            if(res1 > 0){

								/*	Changed by Amul Jain on 26/08/2008 for WFS_6.2_033	*/
//								queryString = new String("Delete from WorkwithPSTable where Q_Userid=?");
//								pstmt = con.prepareStatement(queryString);
//                                pstmt.setInt(1, userID);
//								parameters = new ArrayList(); 
//                                parameters.add(userID);
//								int f = WFSUtil.jdbcExecuteUpdate(null,SessionId,userID,queryString,pstmt,parameters,printQueryFlag,engine);
//								if(f == res1) {
									if(!con.getAutoCommit()) {
										con.commit();
										con.setAutoCommit(true);
									}
//								}	else {
//									if(!con.getAutoCommit()) {
//										con.rollback();
//										con.setAutoCommit(true);
//									}
//								}
                            } else {
                                /* Commit/ Rollback anything would go here - Ruhi */
                                if(!con.getAutoCommit()) {
                                  con.rollback();
                                  con.setAutoCommit(true);
                                }
                            }
                        } else{
                            mainCode = WFSError.WM_INVALID_SESSION_HANDLE;
                            subject = WFSErrorMsg.getMessage(mainCode, userLocale);
                        }
                    } else{
                        if(rs != null)
                            rs.close();
                        mainCode = WFSError.WM_INVALID_SESSION_HANDLE;
                        subject = WFSErrorMsg.getMessage(mainCode, userLocale);
                    }
                } else if(cs != null && cs.gettype() == 'P'){

					/*	Changed by Amul Jain on 26/08/2008 for WFS_6.2_033	*/
					queryString = new String("Select ProcessDefId from PSRegisterationTable where PSId = ?");
					pstmt = con.prepareStatement(queryString);
                    pstmt.setInt(1, cs.getid());
					parameters.add(cs.getid());
					ResultSet rs = WFSUtil.jdbcExecuteQuery(null,SessionId,userID,queryString,pstmt,parameters,printQueryFlag,engine);
					//ResultSet rs = pstmt.getResultSet();
                    parameters.clear();
					if(rs != null && rs.next()) {
						int procdefid = rs.getInt(1);
						if(rs != null)
							rs.close();

                        

						/*	Changed by Amul Jain on 26/08/2008 for WFS_6.2_033	*/
						//queryString = new String("Update PSRegisterationTable Set SessionID = null where PSId = ?");
						queryString = new String("Delete from WFPSConnection where PSId = ?");
						pstmt = con.prepareStatement(queryString);
                        pstmt.setInt(1, cs.getid());
                        parameters.add(cs.getid());
                        parameters.clear();
						int res = WFSUtil.jdbcExecuteUpdate(null,SessionId,userID,queryString,pstmt,parameters,printQueryFlag,engine);
                        parameters.clear();
                        if(res >= 0){
                        	
                        	if(con.getAutoCommit())
                                con.setAutoCommit(false);
                            //OF Optimization
                            queryString = "update WFInstrumentTable set LockStatus = ?, LockedByName = null, LockedTime = null,Q_Userid=0  where Q_Userid=? and Routingstatus = ?";	
							/*	Changed by Amul Jain on 26/08/2008 for WFS_6.2_033	*/
//							queryString = new String("Insert into Workdonetable (ProcessInstanceId,WorkItemId,"
//								+ "ProcessName,ProcessVersion,ProcessDefID,LastProcessedBy,"
//								+ "ProcessedBy,ActivityName,ActivityId,EntryDateTime,"
//								+ "ParentWorkItemId,AssignmentType,CollectFlag,PriorityLevel,"
//								+ "ValidTill,CreatedDateTime,WorkItemState,Statename,"
//								+ "ExpectedWorkitemDelay,PreviousStage,LockStatus, PROCESSVARIANTID) "
//								+ "Select ProcessInstanceId,WorkItemId,ProcessName,ProcessVersion,"
//								+ "ProcessDefID,LastProcessedBy,ProcessedBy,ActivityName,ActivityId,"
//								+ "EntryDateTime,ParentWorkItemId,AssignmentType,CollectFlag,"
//								+ "PriorityLevel,ValidTill,CreatedDateTime,WorkItemState,"
//								+ "Statename,ExpectedWorkitemDelay,PreviousStage," + WFSUtil.TO_STRING("N", true, dbType)
//								+ ", PROCESSVARIANTID from WorkwithPSTable where Q_Userid = ?");
                            pstmt = con.prepareStatement(queryString);
                            WFSUtil.DB_SetString(1, "N", pstmt, dbType);
                            pstmt.setInt(2, cs.getid());
							WFSUtil.DB_SetString(3, "Y", pstmt, dbType);
                            parameters.add("N");
                            parameters.add(cs.getid());
                            parameters.add("Y");
							int res1 = WFSUtil.jdbcExecuteUpdate(null,SessionId,userID,queryString,pstmt,parameters,printQueryFlag,engine);
							parameters.clear();
                            if(res1 > 0)	{
//                                queryString =new String("Delete from WorkwithPSTable where Q_Userid=?");
//								pstmt = con.prepareStatement(queryString);
//                                pstmt.setInt(1, cs.getid());
//								parameters = new ArrayList(); 
//                                parameters.add(cs.getid());
//								int res2 = WFSUtil.jdbcExecuteUpdate(null,SessionId,userID,queryString,pstmt,parameters,printQueryFlag,engine);
//								if(res1 == res2 ){
									if (!con.getAutoCommit()){
										con.commit();
										con.setAutoCommit(true);
									}
//								} else{
//									if (!con.getAutoCommit()) {
//										con.rollback();
//										con.setAutoCommit(true);
//									}
//								}
							}
							else{
								if (!con.getAutoCommit()) {
									con.rollback();
									con.setAutoCommit(true);
								}
							}

                            /*
                             Changed By : Ruhi Hira
                             Changed On : 08/09/2004
                             Description: Code commented as no longer required, causing deadlocks.
                             */

//              if(procdefid > 0) {
//                WFProcessServers.getInstance(engine, procdefid).disconnect(userID, con);
//              }
                        } else{
                            mainCode = WFSError.WM_INVALID_SESSION_HANDLE;
                            subject = WFSErrorMsg.getMessage(mainCode, userLocale);
                            if(!con.getAutoCommit()){
                                con.rollback();
                                con.setAutoCommit(true);
                            }
                        }
                    } else{
                        mainCode = WFSError.WM_INVALID_SESSION_HANDLE;
                        subject = WFSErrorMsg.getMessage(mainCode, userLocale);
                    }
                } else{
                    mainCode = WFSError.WF_NO_AUTHORIZATION;
                    subject = WFSErrorMsg.getMessage(mainCode, userLocale);
                }
            }
            if(mainCode == 0){
                outputXML = new StringBuffer(500);
                outputXML.append(gen.createOutputFile("WMDisConnect"));
                outputXML.append("<Exception>\n<MainCode>0</MainCode>\n</Exception>\n");
                if(unlockWorkitem){
                	outputXML.append("<WorkItemUnlocked>Y</WorkItemUnlocked>\n");
                } else{
                	outputXML.append("<WorkItemUnlocked>N</WorkItemUnlocked>\n");
                }
                outputXML.append(gen.closeOutputFile("WMDisConnect"));
            }
        } catch(SQLException e){
            WFSUtil.printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_SQL;
            subject = WFSErrorMsg.getMessage(mainCode, userLocale);
            errType = WFSError.WF_FAT;
            if(e.getErrorCode() == 0){
                if(e.getSQLState().equalsIgnoreCase("08S01")){
                    descr = (new JTSSQLError(e.getSQLState())).getMessage() + "(SQL State : " + e.getSQLState()
                        + ")";
                }
            } else{
                descr = e.getMessage();
            }
        } catch(NumberFormatException e){
            WFSUtil.printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_ILP;
            subject = WFSErrorMsg.getMessage(mainCode, userLocale);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch(NullPointerException e){
            WFSUtil.printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_SYS;
            subject = WFSErrorMsg.getMessage(mainCode, userLocale);
            errType = WFSError.WF_FAT;
            descr = e.toString();
        } catch(JTSException e){
            WFSUtil.printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = e.getErrorCode();
            subject = WFSErrorMsg.getMessage(mainCode, userLocale);
            errType = WFSError.WF_FAT;
            descr = e.getMessage();
        } catch(Exception e){
            WFSUtil.printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode, userLocale);
            errType = WFSError.WF_FAT;
            descr = e.toString();
        } catch(Error e){
            WFSUtil.printErr(engine,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode, userLocale);
            errType = WFSError.WF_FAT;
            descr = e.toString();
        } finally{
            try{
                if(!con.getAutoCommit()){
                    con.rollback();
                    con.setAutoCommit(true);
                }

				/*	Added by Amul Jain on 26/08/2008 for WFS_6.2_033	*/
				if(pstmt != null) {
					pstmt.close();
					pstmt = null;
				}
            } catch(Exception e){}
            try{
                if(!con.getAutoCommit()){
                    con.rollback();
                    con.setAutoCommit(true);
                }
            } catch(Exception e){}
            
        }
        if(mainCode != 0){
            String strReturn = WFSUtil.generalError(option, engine, gen,mainCode, subCode,errType, subject,descr);
			return strReturn;	
            //throw new WFSException(mainCode, subCode, errType, subject, descr);
        }
        return outputXML.toString();
    }
    //-----------------------------------------------------------------------------------
    //	Function Name               :	getServiceStatusInfo
    //	Date Written (DD/MM/YYYY)   :	21/07/2017
    //	Author                      :	Sajid Khan
    //	Input Parameters            :	Connection , XMLParser , XMLGenerator
    //	Output Parameters           :   none
    //	Return Values               :	String
    //	Description                 :   Fetch Service Statue Info
    //-----------------------------------------------------------------------------------
    public static String getServiceStatusInfo(Connection con, String strCabinetName,int iServiceId,int iSessionId, XMLGenerator gen) throws JTSException, WFSException{
        int sessionID = 0;
        int mainCode = 0;
        int subCode = 0;
        StringBuffer tempXml = new StringBuffer();
        String subject = null;
        String descr = null;
        String errType = WFSError.WF_TMP;
        try {
            StringBuffer strGetStatusInputXML = new StringBuffer();
            strGetStatusInputXML.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
            strGetStatusInputXML.append("WFGetServiceStatus_Input");
            strGetStatusInputXML.append(gen.writeValueOf("Option", "WFGetServiceStatus"));
            strGetStatusInputXML.append(gen.writeValueOf("EngineName", strCabinetName));
            strGetStatusInputXML.append(gen.writeValueOf("SessionId", String.valueOf(iSessionId)));
            strGetStatusInputXML.append(gen.writeValueOf("ServiceId", String.valueOf(iServiceId)));
            strGetStatusInputXML.append("/WFGetServiceStatus_Input");
            XMLParser parser1 = new XMLParser();
            XMLGenerator generator = new XMLGenerator();
            parser1.setInputXML(strGetStatusInputXML.toString());
            String clusterName = (String) WFServerProperty.getSharedInstance().getCallBrokerData().get("ClusterName");
			clusterName = WFSUtil.escapeDN(clusterName);
			String port=WFServerProperty.getSharedInstance().getCallBrokerData().getProperty(WFSConstant.CONST_BROKER_APP_SERVER_PORT);
			port= StringEscapeUtils.escapeHtml(port);
			port= StringEscapeUtils.unescapeHtml(port);
			String serverIP=WFServerProperty.getSharedInstance().getCallBrokerData().getProperty(WFSConstant.CONST_BROKER_APP_SERVER_IP);
			serverIP= StringEscapeUtils.escapeHtml(serverIP);
			serverIP= StringEscapeUtils.unescapeHtml(serverIP);
            String strOutputXML = NGEjbClient.getSharedInstance().makeCall(
           serverIP,port,
            WFServerProperty.getSharedInstance().getCallBrokerData().getProperty(WFSConstant.CONST_BROKER_APP_SERVER_TYPE), parser1.toString(),
            TO_SANITIZE_STRING(clusterName,true),"");
            //String strOutputXML = WFFindClass.getReference().execute("WFGetServiceStatus", strCabinetName, con, parser1, generator);
            //String strOutputXML = WFGetServiceStatus(con, parser1, gen);
            parser1.setInputXML(strOutputXML);
            String strStatusInfo = parser1.getValueOf("StatusInfo");
            tempXml.append(gen.writeValueOf("StatusInfo", strStatusInfo));
           
          
        }catch (Exception e) {
            WFSUtil.printErr(strCabinetName,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch (Error e) {
            WFSUtil.printErr(strCabinetName,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } finally {
           
        }
        if (mainCode != 0) {
            throw new WFSException(mainCode, subCode, errType, subject, descr);
        }
        return tempXml.toString();
        
    }
    //-----------------------------------------------------------------------------------
    //	Function Name               :	persistServiceStatus
    //	Date Written (DD/MM/YYYY)   :	21/07/2017
    //	Author                      :	Sajid Khan
    //	Input Parameters            :	Connection , XMLParser , XMLGenerator
    //	Output Parameters           :   none
    //	Return Values               :	String
    //	Description                 :   Persist and get the status of a service
    //-----------------------------------------------------------------------------------
    public static String persistServiceStatus(Connection con, XMLParser parser,int iServiceId,String productVersion) throws JTSException, WFSException{
        int mainCode = 0;
        int subCode = 0;
        String subject = null;
        String descr = null;
        
        String errType = WFSError.WF_TMP;
        StringBuffer strOutputXML = new StringBuffer();
        String strCabinetName = "";
        char char21 = 21;
        String string21 = "" + char21;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
                int iSessionId = parser.getIntOf("SessionId", 0, false);
                strCabinetName = parser.getValueOf("EngineName", "", false);
                int dbType = ServerProperty.getReference().getDBType(strCabinetName);
                
                XMLParser tempParser = null;
                XMLGenerator generator = null;
                String qStr = "";
                StringBuffer inputXML = new StringBuffer(200);
                boolean serviceStatus = WFServiceStatusCache.getReference().checkStatusInfo(strCabinetName + string21 + iServiceId);
                if(serviceStatus){
                    if(productVersion.equalsIgnoreCase("iBPS"))
                        qStr = "select sessionid from WFSystemServicesTable A " + WFSUtil.getTableLockHintStr(dbType) + ", WFPSConnection B " + WFSUtil.getTableLockHintStr(dbType) + " where A.PSID = B.PSId and A.ServiceId = ? ";
                    else
                        qStr = "select sessionid from WFSystemServicesTable A " + WFSUtil.getTableLockHintStr(dbType) + ", psregisterationtable B " + WFSUtil.getTableLockHintStr(dbType) + " where A.PSID = B.PSId and A.ServiceId = ? ";
                    pstmt = con.prepareStatement(qStr);
                    pstmt.setInt(1, iServiceId);
                    rs = pstmt.executeQuery();
                    if(rs != null && rs.next()){
                        String str = rs.getString(1);
                        if(rs.wasNull() || str.trim().equalsIgnoreCase("") || str.trim().equalsIgnoreCase("NULL")){
                            WFSUtil.printOut(strCabinetName, "Do Nothing");
                        }else {
                            inputXML.append("<WFStartSystemService_Input>");
                            inputXML.append("<Option>").append("WFStartSystemService").append("</Option>");
                            inputXML.append("<EngineName>").append(strCabinetName).append("</EngineName>");
                            inputXML.append("<SessionId>").append(iSessionId).append("</SessionId>");
                            inputXML.append("<RestartFlag>Y</RestartFlag>");
                            inputXML.append("<ServiceIds>");
                            inputXML.append("<ServiceId>").append(iServiceId).append("</ServiceId>");
                            inputXML.append("</ServiceIds>");
                            inputXML.append("<AppServerId>").append(parser.getValueOf("AppServerId", "", true)).append("</AppServerId>");
                            inputXML.append("</WFStartSystemService_Input>");                        
                            tempParser = new XMLParser();
                            tempParser.setInputXML(inputXML.toString());
                            generator = new XMLGenerator();
                            String clusterName = (String) WFServerProperty.getSharedInstance().getCallBrokerData().get("ClusterName");
    						clusterName = WFSUtil.escapeDN(clusterName);
    						String port=WFServerProperty.getSharedInstance().getCallBrokerData().getProperty(WFSConstant.CONST_BROKER_APP_SERVER_PORT);
    						port= StringEscapeUtils.escapeHtml(port);
    						port= StringEscapeUtils.unescapeHtml(port);
    						String serverIP=WFServerProperty.getSharedInstance().getCallBrokerData().getProperty(WFSConstant.CONST_BROKER_APP_SERVER_IP);
    						serverIP= StringEscapeUtils.escapeHtml(serverIP);
    						serverIP= StringEscapeUtils.unescapeHtml(serverIP);
                             String output = NGEjbClient.getSharedInstance().makeCall(
                            		 serverIP,port,
                WFServerProperty.getSharedInstance().getCallBrokerData().getProperty(WFSConstant.CONST_BROKER_APP_SERVER_TYPE), tempParser.toString(),
                TO_SANITIZE_STRING(clusterName,true),"");
                            //String output = WFFindClass.getReference().execute("WFStartSystemService", strCabinetName, con, tempParser, generator);
                           // String output = WFStartSystemService(con, tempParser, generator);                        
                        }
                    }
                }  
        }catch (Exception e) {
            WFSUtil.printErr(strCabinetName,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch (Error e) {
            WFSUtil.printErr(strCabinetName,"", e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } finally {
        	try{
            	if(rs!=null){
            		rs.close();
            		rs=null;
            	}
            }catch(Exception e){
            	
            }
            try{
            	if(pstmt!=null){
            		pstmt.close();
            		pstmt=null;
            	}
            }catch(Exception e){
            	
            }
        }
        if (mainCode != 0) {
            throw new WFSException(mainCode, subCode, errType, subject, descr);
        }
        return strOutputXML.toString();
        
    }
    //-----------------------------------------------------------------------------------
    //	Function Name               :	RegisterPS
    //	Date Written (DD/MM/YYYY)   :	16/05/2002
    //	Author                      :	Prashant
    //	Input Parameters            :	Connection , XMLParser , XMLGenerator
    //	Output Parameters           :   none
    //	Return Values               :	String
    //	Description                 :   Register the given Process Server
    //-----------------------------------------------------------------------------------
    public static String RegisterService(Connection con, XMLParser parser,
                                  XMLGenerator gen) throws JTSException, WFSException{
        int mainCode = 0;
        int subCode = 0;
        String subject = null;
        String descr = null;
        String errType = WFSError.WF_TMP;
        ResultSet rs = null;
        PreparedStatement pstmt = null;
        StringBuffer outputXML = new StringBuffer("");
        String engine = "";
        String userLocale = null;
        try{
            int sessionId = parser.getIntOf("SessionId", 0, true);
            String psName = parser.getValueOf("PSName", "", false);
            char psType = parser.getCharOf("PSType", 'P', true);
            String regInfo = parser.getValueOf("Data", "", true);
            int procDefId = parser.getIntOf("ProcessDefId", 0, true);
            String bulkPS = parser.getValueOf("BulkPS", "N", true);
            userLocale = parser.getValueOf("Locale", "", true);
            engine = parser.getValueOf("EngineName");
            //String licenseKey = parser.getValueOf("LicenseKey");
            int dbType = ServerProperty.getReference().getDBType(engine);
            int psId = 0;

            if(sessionId == 0 && psType != 'C'){
                throw new WFSException(WFSError.WF_NO_AUTHORIZATION, 0, errType,
                                       WFSErrorMsg.getMessage(WFSError.WF_NO_AUTHORIZATION, userLocale), "");
            } else if(sessionId == 0 && psType == 'C'){
                pstmt = con.prepareStatement("Select PSID from PSRegisterationTable " + WFSUtil.getTableLockHintStr(dbType) + " where PSName=? and Type=?");
                WFSUtil.DB_SetString(1, psName.toUpperCase(), pstmt, dbType);
                WFSUtil.DB_SetString(2, String.valueOf(psType), pstmt, dbType);
                pstmt.execute();
                rs = pstmt.getResultSet();
                if(rs.next()){
                    psId = rs.getInt(1);
                    rs.close();
                    pstmt.close();
                } else{
                    // Register configuration Server
                    if(rs != null)
                        rs.close();
                    pstmt.close();
                    pstmt = con.prepareStatement(
                    		 "INSERT INTO PSRegisterationTable(PSName,Type,ProcessDefID,Data)" + " VALUES(?,?,?,?)");
                    WFSUtil.DB_SetString(1, psName.toUpperCase(), pstmt, dbType);
                    WFSUtil.DB_SetString(2, String.valueOf(psType), pstmt, dbType);
                    pstmt.setInt(3, procDefId);
                    if(regInfo.equals("")){
                        pstmt.setNull(4, java.sql.Types.LONGVARCHAR);
                    } else{
                        WFSUtil.DB_SetString(4, regInfo.toUpperCase(), pstmt, dbType);
                    }
                    pstmt.executeUpdate();

                    pstmt = con.prepareStatement("SELECT PSID FROM PSRegisterationTable " + WFSUtil.getTableLockHintStr(dbType) + " WHERE PSName=? and Type=?");
                    WFSUtil.DB_SetString(1, psName.toUpperCase(), pstmt, dbType);
                    WFSUtil.DB_SetString(2, String.valueOf(psType), pstmt, dbType);
                    pstmt.execute();
                    rs = pstmt.getResultSet();
                    if(rs.next()){
                        psId = rs.getInt(1);
                    }
                    if(rs != null)
                        rs.close();
                    pstmt.close();
                }
            } else{
                WFParticipant ps = WFSUtil.WFCheckSession(con, sessionId);
                if(ps != null && ps.gettype() == 'C'){
                    pstmt = con.prepareStatement("SELECT PSID FROM PSRegisterationTable " + WFSUtil.getTableLockHintStr(dbType) + " WHERE PSName=? and Type=?");
                    WFSUtil.DB_SetString(1, psName.toUpperCase(), pstmt, dbType);
                    WFSUtil.DB_SetString(2, String.valueOf(psType), pstmt, dbType);
                    pstmt.execute();
                    rs = pstmt.getResultSet();
                    if(rs.next()){
                        psId = rs.getInt(1);
                        rs.close();
                        pstmt.close();
                    } else{
                        if(rs != null)
                            rs.close();
                        pstmt.close();
                        /* SrNo-6, utility registration is license based, at present for process server only, Omniflow 6.1 - Ruhi Hira */
                        /*if(regInfo.equalsIgnoreCase(WFSConstant.UTIL_PS)){
                            int noOfLicenses = new GetNoOfUsersLic().getNoOfUsers(licenseKey);
                            int userCount = 0;
                            pstmt = con.prepareStatement("SELECT COUNT(*) AS CNT FROM PSREGISTERATIONTABLE " + WFSUtil.getTableLockHintStr(dbType) + " WHERE data = ?");
                            WFSUtil.DB_SetString(1, regInfo.toUpperCase(), pstmt, dbType);
                            rs = pstmt.executeQuery();
                            if(rs != null && rs.next()){
                                userCount = rs.getInt("CNT");
                            }
                            if(rs != null){
                                rs.close();
                                rs = null;
                            }
                            if(pstmt != null){
                                pstmt.close();
                                pstmt = null;
                            }
                            if(userCount >= noOfLicenses){
                                mainCode = WFSError.WFS_ERR_NO_MORE_LICENSE;
                                subject = WFSErrorMsg.getMessage(mainCode, userLocale);
                            }
                        } */
                        if(mainCode == 0){
                        	pstmt = con.prepareStatement("INSERT INTO PSRegisterationTable(PSName,Type,ProcessDefID,Data,BULKPS)" + " VALUES(?, ?, ?, ?, ?) ");
                            WFSUtil.DB_SetString(1, psName.toUpperCase(), pstmt, dbType);
                            WFSUtil.DB_SetString(2, String.valueOf(psType), pstmt, dbType);
                            pstmt.setInt(3, procDefId);
                            if(regInfo.equals("")){
                                pstmt.setNull(4, java.sql.Types.LONGVARCHAR);
                            } else{
                                WFSUtil.DB_SetString(4, regInfo.toUpperCase(), pstmt, dbType);
                            }
                            pstmt.setString(5, bulkPS);
                            pstmt.execute();
                            pstmt.close();

                            pstmt = con.prepareStatement("SELECT PSID FROM PSRegisterationTable " + WFSUtil.getTableLockHintStr(dbType) + " WHERE PSName=? and Type=?");
                            WFSUtil.DB_SetString(1, psName.toUpperCase(), pstmt, dbType);
                            WFSUtil.DB_SetString(2, String.valueOf(psType), pstmt, dbType);
                            pstmt.execute();
                            rs = pstmt.getResultSet();
                            if(rs.next()){
                                psId = rs.getInt(1);
                            }
                            if(rs != null)
                                rs.close();
                            pstmt.close();
                        }
                    }
                }else{
                    mainCode = WFSError.WM_INVALID_SESSION_HANDLE;
                    subCode = 0;
                    subject = WFSErrorMsg.getMessage(mainCode, userLocale);
                    descr = WFSErrorMsg.getMessage(subCode, userLocale);
                    errType = WFSError.WF_TMP;
                }
            }
            outputXML = new StringBuffer(100);
            if(mainCode == 0){
                outputXML.append(gen.createOutputFile("RegisterService"));
                outputXML.append("<Exception><MainCode>0</MainCode></Exception>");
                outputXML.append("<PSName>" + psName + "</PSName>");
                outputXML.append("<PSID>" + psId + "</PSID>");
                outputXML.append("<PSType>" + psType + "</PSType>");
                outputXML.append("<BulkPS>" + bulkPS + "</BulkPS>");
                outputXML.append(gen.closeOutputFile("RegisterService"));
            }
        } catch(SQLException e){
            WFSUtil.printErr(engine, e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_SQL;
            subject = WFSErrorMsg.getMessage(mainCode, userLocale);
            errType = WFSError.WF_FAT;
            descr = e.toString();
        } catch(NumberFormatException e){
            WFSUtil.printErr(engine, e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_ILP;
            subject = WFSErrorMsg.getMessage(mainCode, userLocale);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch(NullPointerException e){
            WFSUtil.printErr(engine, e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_SYS;
            subject = WFSErrorMsg.getMessage(mainCode, userLocale);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch(Exception e){
            WFSUtil.printErr(engine, e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode, userLocale);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } catch(Error e){
            WFSUtil.printErr(engine, e);
            mainCode = WFSError.WF_OPERATION_FAILED;
            subCode = WFSError.WFS_EXP;
            subject = WFSErrorMsg.getMessage(mainCode, userLocale);
            errType = WFSError.WF_TMP;
            descr = e.toString();
        } finally{
        	try{
            	if(rs!=null){
            		rs.close();
            		rs=null;
            	}
            }catch(Exception e){
            	
            }
            try{
                if(pstmt != null){
                    pstmt.close();
                }
            } catch(Exception e){}
           
        }
        if(mainCode != 0){
            throw new WFSException(mainCode, subCode, errType, subject, descr);
        }
        return outputXML.toString();
    }
    
    public static void suspendWorkItem(String engine, Connection con, WFParticipant participant, XMLParser parser) throws JTSException {
        int error = 0;
        String errorMsg = "";
        ResultSet rs = null;
        PreparedStatement pstmt=null;
         int sessionID = parser.getIntOf("SessionId", 0, false);
        String suspensionCause = parser.getValueOf("SuspensionCause");
        int activityId = parser.getIntOf("ActivityId", 0, true);
		String activityName = parser.getValueOf("ActivityName", "", true);
        int procDefID = parser.getIntOf("ProcessDefId", 0, true);
		String assignmentType =  parser.getValueOf("AssignmentType","R", true);
		int wrkItmId = parser.getIntOf("WorkItemID", 0, false);
        String pinstId = parser.getValueOf("ProcessInstanceID", "", false);
		boolean debug = parser.getValueOf("DebugFlag", "N", true).equalsIgnoreCase("Y");
		String dateTimeFormat = WFSUtil.getDateTimeFormat();
                int userId = participant.getid();
        String query = null;
        ArrayList parameters = new ArrayList();
        try {
            int dbType = ServerProperty.getReference().getDBType(engine);

            query = "Update WFInstrumentTable set WorkItemState = ?,Statename =?, AssignmentType = ?, Var_Rec_3 = ? , RoutingStatus = ?, LockStatus = ?,"
                    + " Q_UserId = 0, LockedTime = null, LockedByName = null where ProcessInstanceID = ? and WorkItemID = ?";
            pstmt = con.prepareStatement(query);
			pstmt.setInt(1,3);
            WFSUtil.DB_SetString(2, WFSConstant.WF_SUSPENDED, pstmt, dbType);
            WFSUtil.DB_SetString(3, assignmentType, pstmt, dbType);
			WFSUtil.DB_SetString(4, suspensionCause, pstmt, dbType);
            WFSUtil.DB_SetString(5, "R", pstmt, dbType);
            WFSUtil.DB_SetString(6, "N", pstmt, dbType);
            WFSUtil.DB_SetString(7, pinstId.trim(), pstmt, dbType);
            pstmt.setInt(8,wrkItmId);
            
            parameters.add("3");
            parameters.add(WFSConstant.WF_SUSPENDED);
			parameters.add(assignmentType);
            parameters.add("R");
            parameters.add("R");
            parameters.add("N");
            parameters.add(pinstId.trim());
            parameters.add(wrkItmId);
            
            WFSUtil.jdbcExecute(pinstId, sessionID, userId, query, pstmt, parameters, debug, engine);
            parameters.clear();
			WFSUtil.generateLog(engine, con, WFSConstant.WFL_WorkItemSuspended, pinstId, wrkItmId, procDefID, activityId, activityName, 0, participant.getid(), (participant.gettype() == 'P' ? "System" : participant.getname()), 0,
                           suspensionCause, null, null, null, null);
			// Entry to be inserted into WFMailQueueTable for each suspended workitem
			String ownerEmailId = CachedObjectCollection.getReference().getOwnerEmailId(con, engine, procDefID);  
			WFSUtil.printOut(engine, " WFSUtil : suspendWorkItem() : OwnerEmailID : " + ownerEmailId);
			boolean isToSendEmail = EmailTemplateUtil.isToSendEmail("WorkItemSuspension", engine,  0);
			if (ownerEmailId != null && !ownerEmailId.equalsIgnoreCase("") && isToSendEmail) {
		         String mailMessage = EmailTemplateUtil.retrieveEmailTemplate("WorkItemSuspension"+"_"+Locale.getDefault().toString(), engine, 0);  
		         Properties emailProperties = EmailTemplateUtil.retrieveEmailProperties("WorkItemSuspension"+"_"+Locale.getDefault().toString(), engine, 0);
		         String mailSubject = (String) emailProperties.get("EmailSubject");
		         String mailFrom = (String) emailProperties.get("EmailFrom");
		         mailFrom = TO_SANITIZE_STRING(mailFrom, true);
		 		 if(mailFrom == null){
		 			mailFrom = "OmniFlowSystem_do_not_reply@newgen.co.in";
		 		 }
		 		 if(mailSubject == null){
		 			mailSubject = "WorkItem Suspended - &<WorkItemName>&";
		 		 }
				//mailMessage = WFMailTemplateUtil.getSharedInstance().getTemplate(procDefID);
				if(mailMessage == null || mailMessage.equals(""))
				{
				   mailMessage =  "&<WorkItemName>&  Workitem Suspended " ;
                                   if(assignmentType.equalsIgnoreCase("A")){
                                       mailMessage = mailMessage + " by Archive Utility  . \n\n ";
                                   }
                                   else if(assignmentType.equalsIgnoreCase("B")){
                                       mailMessage = mailMessage + " by Print Fax Email Utility . \n\n ";
                                   }
                                   else if(assignmentType.equalsIgnoreCase("P")){
                                       mailMessage = mailMessage + " by Process Server . \n\n ";
                                   }
				   mailMessage =  mailMessage + "\n\n PFB the logs : \n\n";
				   mailMessage =  mailMessage +" &<Logs>& ";
				}			
				String mailCC="";
				String strInputXml = WFSUtil.getAddToMailQueueXML(engine, mailFrom, ownerEmailId, mailCC,
				WFSUtil.searchAndReplaceTags(mailSubject, pinstId, dateTimeFormat, parser), WFSUtil.searchAndReplaceTags(mailMessage, "", dateTimeFormat,parser), "text/html;charset=UTF-8",
				String.valueOf( procDefID), pinstId , String.valueOf(wrkItmId), String.valueOf(activityId));
				XMLParser mailParser = new XMLParser();
				mailParser.setInputXML(strInputXml);
				XMLGenerator gen = new XMLGenerator();
				WFSUtil.addToMailQueue(participant.getname(), con, mailParser, gen);
			}
            //ends here
			
        } catch (SQLException e) {
            WFSUtil.printErr(engine,"", e);
            error = WFSError.WFS_SQL;
            errorMsg = e.toString();
        } catch (Exception e) {
            WFSUtil.printErr(engine,"", e);
            error = WFSError.WFS_SQL;
            errorMsg = e.toString();
        } finally {
            
            if(pstmt!=null){
                try {
                    pstmt.close();
                    pstmt=null;
                } catch (Exception e) {}
            }
           
        }
        if (error != 0) {
            throw new JTSException(error, errorMsg);
        }
    }
    
public static String getTrimedStr(int dbType)
    {
    String subStr = null;
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                subStr = "SUBSTRING(mailTo,1,512)";
                break;
            case JTSConstant.JTS_ORACLE:
                subStr = "SUBSTR(mailTo,1,512)";
                break;
            case JTSConstant.JTS_POSTGRES:
            default:
                subStr = "mailTo";
        }
        return subStr;
    }
public static void updateTaskPropertyMap(Connection con,int processDefId, int activityId,
		String taskPreChkList,String pId, int dbType,HashMap<Integer, Integer> deafaultStatusMap,
		HashMap<Integer, String> allowReassignmentMap,
		HashMap<Integer, String> allowDeclineMap,
		HashMap<Integer, String> approvalRequiredMap) throws JTSException, SQLException {
	
	PreparedStatement pstmt;  
	
	String query="SELECT "+WFSUtil.isnull("DefaultStatus", "1", dbType) +","+WFSUtil.isnull("AllowReassignment", "'Y'", dbType) +","+WFSUtil.isnull("AllowDecline", "'Y'", dbType) +","+WFSUtil.isnull("ApprovalRequired", "'N'", dbType) +",TaskId from WFTaskPropertyTable "+WFSUtil.getTableLockHintStr(dbType)+" where ProcessDefId=?  and ActivityId=? and TaskId in ("+taskPreChkList.substring(0,taskPreChkList.length()-1)+")";
	   pstmt=con.prepareStatement(query); 
	   pstmt.setInt(1, processDefId);
	   pstmt.setInt(2, activityId);
	   
	   ResultSet rsSet=pstmt.executeQuery();
	   while(rsSet.next()){
		   deafaultStatusMap.put(rsSet.getInt("TaskId"), rsSet.getInt(1));
		   allowReassignmentMap.put(rsSet.getInt("TaskId"), rsSet.getString(2));
		   allowDeclineMap.put(rsSet.getInt("TaskId"), rsSet.getString(3));
		   approvalRequiredMap.put(rsSet.getInt("TaskId"), rsSet.getString(4));
		 
	   }
	  
		   rsSet.close();
	   
	   
		   pstmt.close();
	   
	   query="SELECT 1,"+WFSUtil.isnull("AllowReassignment", "'Y'", dbType) +","+WFSUtil.isnull("AllowDecline", "'Y'", dbType) +","+WFSUtil.isnull("ApprovalRequired", "'N'", dbType) +",TaskId from WFTaskStatusTable "+WFSUtil.getTableLockHintStr(dbType)+" where ProcessInstanceId=? and ProcessDefId=? and ActivityId=? and TaskId in ("+taskPreChkList.substring(0,taskPreChkList.length()-1)+")";
	   pstmt=con.prepareStatement(query); 
	   pstmt.setString(1,pId);
	   pstmt.setInt(2, processDefId);
	   pstmt.setInt(3, activityId);
	   
	    rsSet=pstmt.executeQuery();
	   while(rsSet.next()){
		   deafaultStatusMap.put(rsSet.getInt("TaskId"), rsSet.getInt(1));
		   allowReassignmentMap.put(rsSet.getInt("TaskId"), rsSet.getString(2));
		   allowDeclineMap.put(rsSet.getInt("TaskId"), rsSet.getString(3));
		   approvalRequiredMap.put(rsSet.getInt("TaskId"), rsSet.getString(4));
		 
	   }
	 
		   rsSet.close();
	   
	   
		   pstmt.close();
	   
	}


public static HashMap<Integer, String> getColumnValueFromWFTaskStatusTable(String columnName, String processInstanceId,
		Connection con, int processDefId, int activityId, int dbType,String taskList) throws SQLException {
	// TODO Auto-generated method stub
	boolean flag=true;
	PreparedStatement pstmt=null;
	 HashMap<Integer,String> hMap=new HashMap<Integer,String>();
	 taskList=taskList.endsWith(",")?taskList.substring(0,taskList.length()-1):taskList;
	 /*Tokenizer added for Adhoc task*/
	 StringTokenizer str=new StringTokenizer(taskList,",");
	 while(str.hasMoreElements()){
		 hMap.put(Integer.parseInt(str.nextToken()), "Y");
	 }
	 /*Tokenizer added for Adhoc task*/
	String query="Select "+columnName+",TaskId from WFTaskStatusTable "+WFSUtil.getTableLockHintStr(dbType)+" where ProcessDefId=? and ActivityId=? and TaskId in ("+taskList+") and ProcessInstanceId=?";
	pstmt=con.prepareStatement(query);
	pstmt.setInt(1,processDefId);
	pstmt.setInt(2,activityId);
	DB_SetString(3, processInstanceId, pstmt, dbType);
	ResultSet rs=pstmt.executeQuery();
	while(rs.next()){
		hMap.put(rs.getInt(2),rs.getString(1));
	}
	if(rs!=null){
		rs.close();
	   }
	   if(pstmt!=null){
		   pstmt.close();
	   }
	return hMap;
}

/*This method creates an input xml for SetAttribute call and replaces the tag value in case it is being set for TaskVariable
 * @author- Kimil
 * */
 


public static String getSubProcessDetail(Connection con,int taskId,String processInstanceId,int processDefId) throws SQLException, JTSException {
	// TODO Auto-generated method stub
	StringBuffer xml=new StringBuffer();
	String childInstanceId="";String statusFlag="";
	PreparedStatement pstmt=con.prepareStatement("select Distinct ImportedProcessName from CaseIMPORTEDPROCESSDEFTABLE where TaskId=? and ProcessDefid=?");
	pstmt.setInt(1,taskId);
	pstmt.setInt(2,processDefId);
	ResultSet rSet=pstmt.executeQuery();
	xml.append("<SubProcess>");
	if(rSet.next()){
		statusFlag="I";
		xml.append("<ProcessName>").append(rSet.getString("ImportedProcessName")).append("</ProcessName>");
	}
	else{
		statusFlag="N";
	}
	if (rSet != null) {
		rSet.close();
	}
	if (pstmt != null) {
		pstmt.close();
	}
	if (statusFlag.equals("I")) {
		pstmt = con.prepareStatement("select ParentProcessInstanceId from WFLinksTable where Childprocessinstanceid=? and TaskId=?");
		pstmt.setString(1, processInstanceId);
		pstmt.setInt(2, taskId);
		rSet = pstmt.executeQuery();
		if (rSet.next()) {
			childInstanceId = rSet.getString("ParentProcessInstanceId");
			xml.append("<WorkitemId>").append(childInstanceId).append(
					"</WorkitemId>");
			statusFlag = "I";
		} else {
			statusFlag = "N";
		}
		if (rSet != null) {
			rSet.close();
		}
		if (pstmt != null) {
			pstmt.close();
		}
	}
	if(statusFlag.equals("I")){
		pstmt=con.prepareStatement("Select CreatedDateTime,ProcessInstanceState,WorkItemState,ProcessName,ActivityType,WorKitemId,ProcessInstanceId,processdefid,ActivityId from WfinstrumentTable where ProcessInstanceId=?");
		pstmt.setString(1,childInstanceId);
		rSet=pstmt.executeQuery();
		if(rSet.next()){
			xml.append("<InitiatedOn>").append(rSet.getString("CreatedDateTime")).append("</InitiatedOn>");
			if(rSet.getInt("WorkItemState")==6){
				statusFlag="C";//Completed
			}
			else if(rSet.getInt("WorkItemState")==2){
				statusFlag="I";//In process
			}
			else if(rSet.getInt("WorkItemState")==3){
				statusFlag="S";//Suspended
			}
			xml.append("<CurrentStatus>").append(statusFlag).append("</CurrentStatus>");
			xml.append("<ActivityType>").append(rSet.getInt("ActivityType")).append("</ActivityType>");
			xml.append("<SubprocessDefId>").append(rSet.getString("processdefid")).append("</SubprocessDefId>");
			xml.append("<WId>").append(rSet.getString("WorKitemId")).append("</WId>");
			xml.append("<ActivityId>").append(rSet.getString("ActivityId")).append("</ActivityId>");
			
		}
		else{
			statusFlag="N";
		}
	}
	
	if(rSet!=null){
		rSet.close();
	}
	if(pstmt!=null){
		pstmt.close();
	}
	xml.append("</SubProcess>");
	return xml.toString();
}
			
public static String getFullUserName(Connection con, int dbType, String engine,String userName) {
	String customUserName = "";
	PreparedStatement prepStmt = null;
	ResultSet rs = null;
	StringBuffer fullName = new StringBuffer();
	try {
		prepStmt = con.prepareStatement("select PersonalName,FamilyName from WFUSERVIEW where username = ?");
		prepStmt.setString(1, userName);
		prepStmt.execute();
		rs = prepStmt.getResultSet();
		if (rs.next()) {
			String personalName= rs.getString("PersonalName");
			fullName.append(personalName);
			String familyName= rs.getString("FamilyName");
			if(familyName!=null&&!("").equals(familyName)){
				fullName.append(" ");
				fullName.append(familyName);
	
			}
			fullName.append("(");
			fullName.append(userName);
			fullName.append(")");
		} else {
			WFSUtil.printOut(engine, "No user exists for UserName " + userName);
		}
	} catch (SQLException ex) {
		WFSUtil.printErr(engine, "", ex);
	} catch (Exception ex) {
		WFSUtil.printErr(engine, "", ex);
	} finally {
		try {
			if (rs != null) {
				rs.close();
				rs = null;
			}
			if (prepStmt != null) {
				prepStmt.close();
				prepStmt = null;
			}
		} catch (Exception e) {
			WFSUtil.printErr(engine, "", e);
		}
	}
	return fullName.toString();
}
//----------------------------------------------------------------------------------------------------
//Function Name 					:	genUserLog
//Date Written (DD/MM/YYYY)                       :	21/09/2017
//Author						:	Sakshi Gupta
//Description				        :   Generate log for set and change SetPreferences API .
//----------------------------------------------------------------------------------------------------
 public static void genUserLog(String engineName, Connection con, int actionId, int userId, String userName, String message) throws SQLException {
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    int dbType = ServerProperty.getReference().getDBType(engineName);
    try {
    	if(dbType == JTSConstant.JTS_ORACLE)
    	{
    	String userLogId = "";
    	userLogId = nextVal(con, "seq_userlogid", dbType);
        pstmt = con.prepareStatement("Insert into WFUserLogTable (UserLogId, ActionId, ActionDateTime, UserId, UserName, message) Values ( " + Integer.parseInt(userLogId) + " ,?, " + getDate(dbType) + ", ?, ?, ?)");
    	}
    	else
    	{
    		pstmt = con.prepareStatement("Insert into WFUserLogTable (ActionId, ActionDateTime, UserId, UserName, message) Values (?, " + getDate(dbType) + ", ?, ?, ?)");
    	}
        pstmt.setInt(1, actionId);
        pstmt.setInt(2, userId);
        WFSUtil.DB_SetString(3, userName, pstmt, dbType);
        WFSUtil.DB_SetString(4, message, pstmt, dbType);
        pstmt.execute();
        pstmt.close();
        pstmt = null;
    } catch (Exception e) {
        printErr(engineName, "", e);
    } finally {
        try {
            if (pstmt != null) {
                pstmt.close();
                pstmt = null;
            }
        } catch (Exception ignored) {
        }
    }
}

//----------------------------------------------------------------------------------------------------
//Function Name 					:	getURN
//Description				        :   Gets the URN for a given the processinstanceid
//----------------------------------------------------------------------------------------------------

public static String getURN(Connection con, String pid, int dbType){
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    String urn = null;
    try {
        pstmt = con.prepareStatement("select urn from wfinstrumenttable " + getTableLockHintStr(dbType) + " where processinstanceid = ? and urn is NOT NULL");
        DB_SetString(1, pid, pstmt, dbType);
        rs = pstmt.executeQuery();
        if(rs.next()){
        	urn = rs.getString(1);
        }
        rs.close();
        rs = null;
        pstmt.close();
        pstmt = null;
    } catch (Exception e) {
        printErr("", "Error while getting the URN in getURN method", e);
    } finally {
        try {
        	if(rs != null){
        		rs.close();
        		rs = null;
        	}
            if (pstmt != null) {
                pstmt.close();
                pstmt = null;
            }
        } catch (Exception ignored) {
        }
    }
    return urn;
}
public static String getPersonalName(Connection con, String username, int dbType){
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    String personalName = null;
    try {
        pstmt = con.prepareStatement("select personalName from WFUSERVIEW " + getTableLockHintStr(dbType) + " where username = ? ");
        pstmt.setString(1, username);
        rs = pstmt.executeQuery();
        if(rs.next()){
        	personalName = rs.getString(1);
        }
        rs.close();
        rs = null;
        pstmt.close();
        pstmt = null;
    } catch (Exception e) {
        printErr("", "Error while getting the PersonalName", e);
    } finally {
        try {
        	if(rs != null){
        		rs.close();
        		rs = null;
        	}
            if (pstmt != null) {
                pstmt.close();
                pstmt = null;
            }
        } catch (Exception ignored) {
        }
    }
    return personalName;
}
public static boolean isLikeSearchEnabled() {
    boolean likeSearchFlag = false;
    try {
    	likeSearchFlag = ((String) WFFindClass.wfGetServerPropertyMap().get(WFSConstant.CONST_LIKE_SEARCH_ENABLED)).equalsIgnoreCase("Y") ? true : false;
    } catch (Exception ignored) {
        //printOut(cabName,"[WFSUtil] isSyncRoutingMode() ignoring exception >> " + ignored);
    }
    return likeSearchFlag;
}

public static String getRevokedFromUser(Connection con, XMLParser parser, int dbType, String engine, int processDefId, String processInstanceId,
		int workItemId, int activityId, int revokedTaskId, int revokedSubTaskId) {
	String revokedFromUserName = "";
	PreparedStatement prepStmt = null;
	ResultSet rs = null;
	try {
		prepStmt = con.prepareStatement("select AssociatedFieldName from wfcurrentroutelogtable " + getTableLockHintStr(dbType) 
		+ " where processinstanceid = ? and WorkItemId = ? and ActivityId = ? and  actionid = ?  and taskid = ? and subtaskid = ? order by actiondatetime desc");
		DB_SetString(1, processInstanceId, prepStmt, dbType);
		prepStmt.setInt(2, workItemId);
		prepStmt.setInt(3, activityId);
		prepStmt.setInt(4, WFSConstant.WFL_TaskRevoked);
		prepStmt.setInt(5, revokedTaskId);
		prepStmt.setInt(6, revokedSubTaskId);
		prepStmt.execute();
		rs = prepStmt.getResultSet();
		if (rs.next()) {
			revokedFromUserName = rs.getString(1);
		}
	} catch (SQLException ex) {
		WFSUtil.printErr(engine, "", ex);
	} catch (Exception ex) {
		WFSUtil.printErr(engine, "", ex);
	} finally {
		try {
			if (rs != null) {
				rs.close();
				rs = null;
			}
			if (prepStmt != null) {
				prepStmt.close();
				prepStmt = null;
			}
		} catch (Exception e) {
			WFSUtil.printErr(engine, "", e);
		}
	}
	return revokedFromUserName;
}

public static String getTaskActionComments(Connection con, XMLParser parser, int dbType, String engine, String processInstanceId,
		int workItemId, int activityId, int taskId, int subTaskId, int commentsType) {
	String comments = "";
	PreparedStatement prepStmt = null;
	ResultSet rs = null;
	try {
		prepStmt = con.prepareStatement("select Comments from wfcommentstable " + getTableLockHintStr(dbType) 
		+ " where processinstanceid = ? and WorkItemId = ? and ActivityId = ? and taskid = ? and subtaskid = ? and commentsType = ? order by ActionDateTime desc");
		DB_SetString(1, processInstanceId, prepStmt, dbType);
		prepStmt.setInt(2, workItemId);
		prepStmt.setInt(3, activityId);
		prepStmt.setInt(4, taskId);
		prepStmt.setInt(5, subTaskId);
		prepStmt.setInt(6, commentsType);
		prepStmt.execute();
		rs = prepStmt.getResultSet();
		if (rs.next()) {
			comments = rs.getString(1);
		}
	} catch (SQLException ex) {
		WFSUtil.printErr(engine, "", ex);
	} catch (Exception ex) {
		WFSUtil.printErr(engine, "", ex);
	} finally {
		try {
			if (rs != null) {
				rs.close();
				rs = null;
			}
			if (prepStmt != null) {
				prepStmt.close();
				prepStmt = null;
			}
		} catch (Exception e) {
			WFSUtil.printErr(engine, "", e);
		}
	}
	return comments;
}

public static String getAttributesFilterCondition(WFFieldInfo fieldInfo,int dbType, String lop , String op, String filterAttribValue) throws WFSException{
    String filterCondition = "";
    int varType = fieldInfo.getWfType();
    int operator = Integer.parseInt(op);
    int logicalOperator = Integer.parseInt(lop);
    String operatorValue = "";
    String logicalOperatorValue = "";
    switch (operator) {
        case 1:{//less than <
            operatorValue = " < ";
            break;
        }    
        case 2: {//WF_LESSTHANEQUALTO 
           operatorValue = " <= ";
            break;
        }
        case 3: {//WF_EQUALTO
           operatorValue = " = ";
            break;
        }
        case 4: {//WF_NOTEQUALTO
           operatorValue = " != ";
            break;
        }
        case 5: {//WF_GREATERTHAN
           operatorValue = " > ";
           break;
        }
        case 6: {//WF_GREATERTHANEQUALTO
           operatorValue = " >= ";
           break;
        }
        default: {
            break;
        }
    }
    
    switch (logicalOperator) {
        case 1:{//WF_OPERATOR_AND
            logicalOperatorValue = " AND ";
            break;
        }    
        case 2: {//WF_OPERATOR_OR
           logicalOperatorValue = " OR ";
            break;
        }
        default: {
            break;
        }
    }
    String mappedColName = fieldInfo.getMappedColumn() +" ";
    if(operator==7){//WF_LIKE
    	XMLParser parser=new XMLParser("");
    	filterCondition +=WFSUtil.getLikeFilterStr(parser, mappedColName, filterAttribValue, dbType, true)+logicalOperatorValue;
    }
    else{
    	filterCondition +=mappedColName+operatorValue+TO_SQL(filterAttribValue, varType, dbType, true)+logicalOperatorValue;
    }
    return filterCondition;
}
 
public static boolean isCallAPIOnTaskExpiry() {
    boolean isCallAPIOnTaskExpiry = false;
    try {
    	isCallAPIOnTaskExpiry = ((String) WFFindClass.wfGetServerPropertyMap().get(WFSConstant.CONST_CALL_APIS_ON_TASK_EXPIRY)).equalsIgnoreCase("Y") ? true : false;
    } catch (Exception ignored) {
        //printOut(cabName,"[WFSUtil] isSyncRoutingMode() ignoring exception >> " + ignored);
    }
    return isCallAPIOnTaskExpiry ;
}
public static void getListOfParentWorkitems(Connection con, int dbType,String engine, String processInstanceId,
		int workItemId,ArrayList<Integer> parentWorkItems) {
	String caseManager = "";
	PreparedStatement prepStmt = null;
	ResultSet rs = null;
	int parentWorkitemid = 0;
	try {
		if(workItemId>1) {
			
			StringBuilder query = new StringBuilder().append(" Select parentworkitemid from WFInstrumentTable " 
			+ WFSUtil.getTableLockHintStr(dbType) 
			+ " where processinstanceid = ? and WorkItemId = ? ");
			prepStmt = con.prepareStatement(query.toString());
			DB_SetString(1, processInstanceId, prepStmt, dbType);
			prepStmt.setInt(2, workItemId);
			rs = prepStmt.executeQuery();
			if (rs.next()) {
				parentWorkitemid = rs.getInt(1);
				parentWorkItems.add(parentWorkitemid);
			}
			if(rs!=null) {
				rs.close();
				rs= null;
			}
			if(prepStmt!=null) {
				prepStmt.close();
				prepStmt=null;
			}
			getListOfParentWorkitems(con,dbType,engine,processInstanceId,parentWorkitemid,parentWorkItems);
		}
	} catch (SQLException ex) {
		WFSUtil.printErr(engine, "", ex);
	} catch (Exception ex) {
		WFSUtil.printErr(engine, "", ex);
	} finally {
		try {
			if (prepStmt != null) {
				prepStmt.close();
				prepStmt = null;
			}
			if (rs != null) {
				rs.close();
				rs = null;
			}
		} catch (Exception e) {
			WFSUtil.printErr(engine, "", e);
		}
	}
	
}

public static int getQueryActivityID(Connection con,int dbType,int processDefId,int userIndex,int activitytype){
	int queryActivityId=0;
	PreparedStatement pstmt=null;
	ResultSet rs=null;
	try {
		String query="Select  * From ( Select "+ WFSUtil.getFetchPrefixStr(dbType,  1)+"  ActivityTable.ActivityId from ActivityTable "+WFSUtil.getTableLockHintStr(dbType)+" ,QueueStreamTable "
				+ WFSUtil.getTableLockHintStr(dbType)+" ,QUSERGROUPVIEW "+WFSUtil.getTableLockHintStr(dbType) +" WHERE ActivityTable.ProcessDefId = QueueStreamTable.ProcessDefId "+
				" AND ActivityTable.ActivityId = QueueStreamTable.ActivityId AND QUSERGROUPVIEW.QueueId = QueueStreamTable.QueueId AND ActivityTable.ActivityType = ? "
				+ " AND ActivityTable.ProcessDefId = ? AND QUSERGROUPVIEW.UserId = ? AND QUSERGROUPVIEW.QueryPreview='Y'  ORDER BY QUSERGROUPVIEW.UserId DESC ) A "
				+ WFSUtil.getFetchSuffixStr(dbType, 1, WFSConstant.QUERY_STR_WHERE) ;
		pstmt = con.prepareStatement(query);
		pstmt.setInt(1, activitytype);
		pstmt.setInt(2,processDefId);
		pstmt.setInt(3, userIndex);
		rs=pstmt.executeQuery();
		if(rs!=null&&rs.next()){
			queryActivityId=rs.getInt(1);
		}
		
	} 
	catch (Exception ignored) {
	}
	finally{
		try{
		if(rs!=null)
		{
			rs.close();
			rs=null;
		}
		if(pstmt!=null){
			pstmt.close();
			pstmt=null;
		}}catch(Exception e){}
	}
	
	
	return  queryActivityId;
	
			
}

public static void convertFilterXMLToiBPSFormat(Connection con,int dbType,String engineName) throws Exception{
	PreparedStatement pstmt=null;
	PreparedStatement pstmt1=null;
	ResultSet rs=null;
	String query=null;
	try{
		query="SELECT Userid,ObjectId,DATA FROM USERPREFERENCESTABLE WHERE OBJECTTYPE=?";
		pstmt=con.prepareStatement(query);
		pstmt.setString(1, "A");
		rs=pstmt.executeQuery();
		if(rs!=null){
			int count=0;
			pstmt1=con.prepareStatement("UPDATE USERPREFERENCESTABLE SET DATA=? WHERE USERID=? AND OBJECTID=? AND OBJECTTYPE=?");
			String output = "";
			int i=1;
			while(rs.next()){
				int userID=rs.getInt(1);
				int objectID=rs.getInt(2);
				String userPreferencesXML=rs.getString(3);
				if(userPreferencesXML.indexOf("(CLOB)")< userPreferencesXML.indexOf("<Data>")){
					userPreferencesXML=userPreferencesXML.substring(userPreferencesXML.indexOf("<Data>"));
		          }
				if(userPreferencesXML.contains("<Data>")  && !userPreferencesXML.contains("</Data>") ){
					 userPreferencesXML = userPreferencesXML+"</Data>";
				}
				if(userPreferencesXML.contains("QueueID")  ){
					userPreferencesXML=userPreferencesXML.replaceAll("QueueID","QueueId");
		          }
				WFSUtil.printOut(engineName, "userPreferencesXML-->" + i++ + "---" + userPreferencesXML);
					if(userPreferencesXML.contains("FilterQuery") || userPreferencesXML.contains("FilterString")){
						output=userPreferencesXML.replaceAll("FilterQuery","FilterString");
			          }
					else if (!needToConvert(userPreferencesXML, engineName)) {
							output = convertUserPreferencesData(userPreferencesXML, engineName);
						}
					
					if(output!=null&&!output.isEmpty()){
					WFSUtil.printOut(engineName, "userPreferencesXML- output->"+ output);
						pstmt1.setString(1, output);
						pstmt1.setInt(2, userID);
						pstmt1.setInt(3, objectID);
						pstmt1.setString(4, "A");
						pstmt1.addBatch();
						count++;
					}
				
			}
			if(count>0){
				pstmt1.executeBatch();
			}
		}
		
	}catch(Exception e){
		printErr(engineName, e);
		 throw e;
	}finally{
		try{
			if(rs!=null){
				rs.close();
				rs=null;
			}
		}catch(Exception e){
			printErr(engineName, e);
		}
		try{
			if(pstmt1!=null){
				pstmt1.close();
				pstmt1=null;
			}
		}catch(Exception e){
			printErr(engineName, e);
		}
		try{
			if(pstmt!=null){
				pstmt.close();
				pstmt=null;
			}
		}catch(Exception e){
			printErr(engineName, e);
		}
	}
}
public static boolean needToConvert(String preferenceXml,String engineName) throws Exception{
	boolean convertFlag=false;
	try{
		Document doc = null;
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        dbf.setValidating(false);
        dbf.setNamespaceAware(true);
        dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        InputSource inputSource = new InputSource(new StringReader(preferenceXml));
        DocumentBuilder db = dbf.newDocumentBuilder();
        doc = db.parse(inputSource);
        Node node = doc.getElementsByTagName("Condition").item(0);
        if(node!=null){
        	Node aliasNode=node.getFirstChild();
        	if(aliasNode!=null){
        		String nodeName=aliasNode.getNodeName();
        		if("Alias".equalsIgnoreCase(nodeName)){
        			convertFlag=true;
        		}
        	}
        }
	}catch(Exception e){
		printErr(engineName, e);
		throw e;
	}
	
	return convertFlag;
}
public static String convertUserPreferencesData(String preferenceXml,String engineName) throws Exception{
	StringBuffer outPreferenceXml=new StringBuffer();	
	try{
		Document doc = null;
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        dbf.setValidating(false);
        dbf.setNamespaceAware(true);
        dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        InputSource inputSource = new InputSource(new StringReader(preferenceXml));
        DocumentBuilder db = dbf.newDocumentBuilder();
        doc = db.parse(inputSource);
        outPreferenceXml.append("<Filter>");
        outPreferenceXml.append("<Type>256</Type>");
        NodeList list = doc.getElementsByTagName("Filter").item(0).getChildNodes();
        if(list!=null){    	    
	        for(int i=0;i<list.getLength();i++){
	        	Node node=list.item(i);
	        	String value="";
	        	if(node!=null){
	        		String nodeName=node.getNodeName();
	        		if(node.getChildNodes()!=null && node.getChildNodes().item(0)!= null && node.getChildNodes().item(0).getNodeType()==Node.TEXT_NODE){
	        			value=node.getTextContent();      			
	        			outPreferenceXml.append("<").append(nodeName).append(">").append(value).append("</").append(nodeName).append(">");	        			
	        		}else if(node.getChildNodes()!=null && node.getChildNodes().item(0)!= null && node.getChildNodes().item(0).getNodeType()==Node.ELEMENT_NODE && "FilterXML".equalsIgnoreCase(nodeName)){
	        			outPreferenceXml.append("<FilterXML>");
	        			String childOutPreferenceXml=convertUserPreferencesData(node,engineName);        			
	        			outPreferenceXml.append(childOutPreferenceXml);        			
	        			outPreferenceXml.append("</FilterXML>");
	        		}
	        		else{
	        			value=node.getTextContent();	        			
         			outPreferenceXml.append("<").append(nodeName).append(">").append(value).append("</").append(nodeName).append(">");	        			
	        		}
	        	}
	        }
        }
        outPreferenceXml.append("</Filter>");
        
	}catch(Exception e){
		printErr(engineName, e);
		throw e;
	}
	
	return outPreferenceXml.toString();
}

	public static String convertUserPreferencesData(Node parentNode, String engineName) throws Exception {
		StringBuffer childOutPreferenceXml = new StringBuffer();
		try {
			if (parentNode != null) {
				NodeList list = parentNode.getChildNodes();
				if (list != null)
					for (int i = 0; i < list.getLength(); i++) {
						Node node = list.item(i);
						String value = "";
						if (node != null) {
							String nodeName = node.getNodeName();
							try {
								if (node.getChildNodes() != null && node.getChildNodes().item(0).getNodeType() == Node.TEXT_NODE) {
									value = node.getTextContent();
									childOutPreferenceXml.append("<").append(nodeName).append(">").append(value).append("</").append(nodeName).append(">");
								} else if (node.getChildNodes() != null && node.getChildNodes().item(0).getNodeType() == Node.ELEMENT_NODE && "Condition".equalsIgnoreCase(nodeName)) {
									String conditionXml = convertConditionIntoiBPS(node, engineName);
									childOutPreferenceXml.append(conditionXml);
								}
								else if (node.getNodeType() == Node.ELEMENT_NODE && "SearchAttributes".equalsIgnoreCase(nodeName)) {
									String searchOutPreferenceXml = convertUserPreferencesData(node, engineName);
									childOutPreferenceXml.append("<SearchAttributes>");
									childOutPreferenceXml.append(searchOutPreferenceXml);
									childOutPreferenceXml.append("</SearchAttributes>");
								}
							} catch (Exception e) {
								childOutPreferenceXml.append("<").append(nodeName).append(">").append(value).append("</").append(nodeName).append(">");
							}
						}
					}
			}

		} catch (Exception e) {
			printErr(engineName, e);
			throw e;
		}
		return childOutPreferenceXml.toString();
	}

private static String convertConditionIntoiBPS(Node node,String engineName)  throws Exception{
	// TODO Auto-generated method stub
	StringBuffer childOutPreferenceXml=new StringBuffer();
	try{
		if(node!=null){
			String nodeName=node.getNodeName();
			Node aliasNode=node.getFirstChild();
			if(aliasNode!=null){
				childOutPreferenceXml.append("<Condition").append(getAttributeValue(node)).append(">");
				String value=aliasNode.getTextContent();
				String name=aliasNode.getNodeName();
				String systemDefinedName=name;
				if("ProcessInstanceName".equalsIgnoreCase(name)){
					systemDefinedName="ProcessInstanceID";
				}else if("ProcessDefinitionID".equalsIgnoreCase(name)){
					systemDefinedName="ProcessDefID";
				}else if("Priority".equalsIgnoreCase(name)){
					systemDefinedName="PriorityLevel";
				}else if("ExceptionStatus".equalsIgnoreCase(name)){
					systemDefinedName="InstrumentStatus";
				}else if("AssignedToUser".equalsIgnoreCase(name)){
					systemDefinedName="AssignedUser";
				}else if("ReferByName".equalsIgnoreCase(name)){
					systemDefinedName="ReferredByName";
				}
				childOutPreferenceXml.append("<Alias Name=\"").append(systemDefinedName).append("\"").append(getAttributeValue(aliasNode)).append(">").append(value).append("</Alias>");
				childOutPreferenceXml.append("</Condition>");
			}
			
			
		}
	}catch(Exception e){
		printErr(engineName, e);
		throw e;
	}
	return childOutPreferenceXml.toString();
}

 private static String getAttributeValue(Node node) {
		// TODO Auto-generated method stub
	 String output="";
		if(node!=null) {
			NamedNodeMap attr=node.getAttributes();
			if(attr!=null) {
				for(int i=0;i<attr.getLength();i++){
					Node nodeattr=attr.item(i);
					if(nodeattr!=null) {
						String value=nodeattr.getTextContent();
						String name=nodeattr.getNodeName();
						output=output+" "+name+"=\""+value+"\"";
					}
				}
			}
			
		}
		return output;
	}

	public static String getReverseJoinType(String joinType) {
		String resultJoin = "";
		if(joinType == null || joinType.isEmpty()){
			resultJoin = " JOIN ";
		}
		else if(joinType.contains("LEFT")){
			resultJoin = " RIGHT OUTER JOIN ";
		}
		else if(joinType.contains("RIGHT")){
			resultJoin = " LEFT OUTER JOIN ";
		}
		return resultJoin;
	}
	
	public static String getFilterQueryFromXML(List<WFMappedColumn> filterMap, WFWorkitem workitem, String engine, int dbType) throws WFSException {
		int noOfColumns = filterMap.size();
		WFSUtil.printOut(engine, "WFSUtil.getFilterQueryFromXML :: total no of filter columns : " + noOfColumns );
		StringBuilder filter = new StringBuilder();
		for(int iCount = 0; iCount < noOfColumns; iCount++){
			WFMappedColumn mappedColumn = filterMap.get(iCount);
			String tableName = mappedColumn.getTableName();
			String columnName = mappedColumn.getColumnName();
			String mappedField = mappedColumn.getMappedField();
			String columnType = mappedColumn.getVariableType();
			String columnValue = "";
			int type = 0;
			int operator = mappedColumn.getOperator();
			int logicalOperaor = mappedColumn.getLogicalOp();

			filter.append(tableName + "." + columnName);
			
			switch(operator){
			case WFSConstant.WF_LESSTHAN:
				filter.append(" < ");
				break;
			case WFSConstant.WF_LESSTHANEQUALTO:
				filter.append(" <= ");
				break;
			case WFSConstant.WF_EQUALTO:
				filter.append(" = ");
				break;
			case WFSConstant.WF_NOTEQUALTO:
				filter.append(" != ");
				break;
			case WFSConstant.WF_GREATERTHAN:
				filter.append(" > ");
				break;
			case WFSConstant.WF_GREATERTHANEQUALTO:
				filter.append(" >= ");
				break;
			case WFSConstant.WF_LIKE:
				filter.append(" LIKE ");
				break;
			case WFSConstant.WF_NOTLIKE:
				filter.append(" IS NOT LIKE ");
				break;
			case WFSConstant.WF_NULL:
				filter.append(" IS NULL ");
				break;
			case WFSConstant.WF_NOTNULL:
				filter.append(" IS NOT NULL ");
				break;
			default:
				filter.append(" = ");
			}
			
			if(operator != WFSConstant.WF_NULL && operator != WFSConstant.WF_NOTNULL){
				if("U".equalsIgnoreCase(columnType) || "I".equalsIgnoreCase(columnType)){
					if(workitem.isRPACall()){
						columnValue = workitem.getMappedColumnsList().get(mappedColumn.getVariableName().toUpperCase()).getVariableValue();
						type = workitem.getMappedColumnsList().get(mappedColumn.getVariableName().toUpperCase()).getVarDataType();
					}
					else{
						columnValue = workitem.getVarIdAttributeMap().get(mappedColumn.getVariableId() + "#" + mappedColumn.getVarFieldId()).getValue();
						type = workitem.getVarIdAttributeMap().get(mappedColumn.getVariableId() + "#" + mappedColumn.getVarFieldId()).getType();
					}
				}
				else if("C".equalsIgnoreCase(columnType)){
					columnValue = mappedColumn.getVariableName();
				}
				filter.append(TO_SQL(columnValue, type, dbType, true) );
			}
			//logicalOperaor == 3 means End of the conditions list.
			if(logicalOperaor != 3){
				switch(logicalOperaor){
				case 1:
					filter.append(" AND ");
					break;
				case 2:
					filter.append(" OR ");
					break;
				default:
					filter.append(" AND ");
				}
			}
			WFSUtil.printOut(engine, "WFSUtil.getFilterQueryFromXML :: cumulative filter string till now : " + filter.toString() );
		}
		return filter.toString();
	}

	public static String evaluateAndExecuteDX(WFDataExchangeActivity dxActivityInfo, Connection con, WFWorkitem workitem, String engine, int sourceDBType,String processInstanceId,int workitemId,int processDefId, StringBuilder auditDataXML, int activityId) throws Exception {
		StringBuilder result = new StringBuilder();
		Connection targetConn = null;
		int mainCode = 0;
		boolean isIsolatedTxnFlag = "Y".equalsIgnoreCase(dxActivityInfo.getIsolateFlag());
		List<WFRule> rulesList = null;
		List<WFDBOperation> operationsList = null;
		Stack<WFRule> mainStack = new Stack<WFRule>();
		Stack<WFRule> conditionStack = new Stack<WFRule>();
		int ruleExecResult = 0;
    	final int ROOT_INDENT_LEVEL = 0;
		HashMap<Integer, Integer> exchangeIdRowCountMap = new HashMap<Integer, Integer>();
		HashMap<Integer, String> exchangeIdTableMap = new HashMap<Integer, String>();
		try{
			//Get target DB Connection. => Changes for data exchange in the same cabinet. (configID == -1 in that case).
			WFSUtil.printOut(engine, "WFSUtil.evaluateAndExecuteDX :: Getting the DB Connection from the cached data source map");
			if(dxActivityInfo.getConfigurationID() > 0){
				targetConn = getConnectionFromDataSource(dxActivityInfo, engine);
				WFSUtil.printOut(engine, "WFSUtil.evaluateAndExecuteDX :: using different target cabinet : " + engine);
			}else{
				dxActivityInfo.setDatabaseType(sourceDBType);
				targetConn = con;
				WFSUtil.printOut(engine, "WFSUtil.evaluateAndExecuteDX :: using same target cabinet : " + engine);
			}
			
			if(targetConn == null){
				WFSUtil.printErr(engine, "WFSUtil.evaluateAndExecuteDX :: Error occurred while creating the target connection ", null);
				throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_INVALID_DB_DETAILS, WFSError.WF_TMP, 
						WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WF_INVALID_DB_DETAILS));
			}
			WFSUtil.printOut(engine, "WFSUtil.evaluateAndExecuteDX :: Connection established with the target cabinet");

			//Open the transaction if created successfully and isolation is false.
			if( ! isIsolatedTxnFlag ){
				if(targetConn.getAutoCommit()){
					WFSUtil.printOut(engine, "WFSUtil.evaluateAndExecuteDX :: Isolation flag false, beginning the DB transaction here.");
					targetConn.setAutoCommit(false);
				}
			}
	    	
			//Execution of the condition rules starts from here.
	    	//rulesList = new ArrayList<WFRule>(dxActivityInfo.getRulesList());
	    	operationsList = new ArrayList<WFDBOperation>(dxActivityInfo.getOperationsList());

			/*mainStack.clear();
			conditionStack.clear();
			int prev_indent = ROOT_INDENT_LEVEL;*/
    		WFSUtil.printOut(engine, "WFSUtil.evaluateAndExecuteDX :: Point1 - Starting the operations execution.");
			while(true){
				if(operationsList.isEmpty()){
					break;
				}
				//WFRule tmpRule = rulesList.get(0);
				//rulesList.remove(0);
				WFDBOperation tmpOperations = operationsList.get(0);
				operationsList.remove(0);
	    		WFSUtil.printOut(engine, "WFSUtil.evaluateAndExecuteDX :: Point2 ExchangeId " + tmpOperations.getExchangeId() + ", ConfigTypeStr " + tmpOperations.getConfigTypeStr());
				
	    		evaluateDBRuleAndUpdateWorkitem(targetConn,con, tmpOperations, dxActivityInfo, workitem, engine,processInstanceId,workitemId,processDefId,exchangeIdRowCountMap,exchangeIdTableMap,sourceDBType,activityId);
				//Assuming if the indent level is increasing, the rule before was of type IF.
				/*if(tmpRule.getIndentLevel() == prev_indent + 1 && !mainStack.isEmpty()){
					WFSUtil.printOut(engine, "WFSUtil.evaluateAndExecuteDX :: Point3 Before calling evaluateIfRuleGroup.., RuleId " + tmpRule.getRuleId());
					evaluateIfRuleGroup(prev_indent, mainStack, conditionStack, workitem, engine);
					prev_indent = tmpRule.getIndentLevel();
				}*/
				
				//Actual evaluation of the rule.
				/*if(tmpRule.isDBRule()){
					if(tmpRule.getIndentLevel() > ROOT_INDENT_LEVEL && mainStack.isEmpty()){
						WFSUtil.printErr(engine, "WFSUtil.evaluateAndExecuteDX :: Point4 - IF Open Rule not found, RuleId " + tmpRule.getRuleId());
						throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_ERROR_EVALUATING_RULE, WFSError.WF_TMP, 
								WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WF_ERROR_EVALUATING_RULE));
					}
					if(tmpRule.getIndentLevel() == ROOT_INDENT_LEVEL || (!mainStack.isEmpty() && (tmpRule.getIndentLevel() == mainStack.peek().getIndentLevel() + 1 && mainStack.peek().getResult()))){
			    		WFSUtil.printOut(engine, "WFSUtil.evaluateAndExecuteDX :: Point5 Calling evaluateDBRuleAndUpdateWorkitem for RuleId : " + tmpRule.getRuleId());

						evaluateDBRuleAndUpdateWorkitem(targetConn, tmpRule, dxActivityInfo, workitem, engine);
						
					}else if(!mainStack.peek().getResult()){
			    		WFSUtil.printOut(engine, "WFSUtil.evaluateAndExecuteDX :: Point6 Removing all the Rules corresponding to unsatisfied conditions for RuleId : " + tmpRule.getRuleId());
						
			    		//Remove from the rules from rule list till we get the END IF of the same indent level.
						while(!rulesList.isEmpty() && rulesList.get(0).getIndentLevel() > mainStack.peek().getIndentLevel()){
							rulesList.remove(0);
						}
						if(!rulesList.isEmpty() && rulesList.get(0).getIndentLevel() == mainStack.peek().getIndentLevel() && mainStack.peek().getRuleTypeId() == WFSConstant.RESULT_RULE && rulesList.get(0).getRuleTypeId() == WFSConstant.END_IF_RULE){
							rulesList.remove(0);
							prev_indent = mainStack.peek().getIndentLevel();
							mainStack.pop();
						}else{
				    		WFSUtil.printErr(engine, "WFSUtil.evaluateAndExecuteDX :: Point7 - IF Close Rule not found, RuleId " + tmpRule.getRuleId());
							throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_ERROR_EVALUATING_RULE, WFSError.WF_TMP, 
									WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WF_ERROR_EVALUATING_RULE));
						}
					}
				}
				else if(tmpRule.getRuleTypeId() == WFSConstant.IF_RULE){
					if(tmpRule.getIndentLevel() > ROOT_INDENT_LEVEL && mainStack.isEmpty()){
						WFSUtil.printErr(engine, "WFSUtil.evaluateAndExecuteDX:: Point8 - IF Open Rule not found, RuleId " + tmpRule.getRuleId());
						throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_ERROR_EVALUATING_RULE, WFSError.WF_TMP, 
								WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WF_ERROR_EVALUATING_RULE));
					}
					if( (tmpRule.getIndentLevel() == ROOT_INDENT_LEVEL) || !mainStack.isEmpty() && ((tmpRule.getIndentLevel() == mainStack.peek().getIndentLevel()) 
									|| (tmpRule.getIndentLevel() == mainStack.peek().getIndentLevel() + 1 && mainStack.peek().getResult()))){
						WFSUtil.printOut(engine, "IL " + tmpRule.getIndentLevel() + " IF RuleID " + tmpRule.getRuleId());
						mainStack.push(tmpRule);
					}else if(!mainStack.peek().getResult()){
						
						//Remove from the rules from rule list till we get the END IF of the same indent level.
						//Removal strategy : If indent level is greater, then remove. If indent level is same 
						//and is closing end, then remove else throw error.
			    		WFSUtil.printOut(engine, "WFSUtil.evaluateAndExecuteDX :: Point9 Removing all the Rules corresponding to unsatisfied conditions for RuleId : " + tmpRule.getRuleId());
						while(!rulesList.isEmpty() && rulesList.get(0).getIndentLevel() > mainStack.peek().getIndentLevel()){
							rulesList.remove(0);
						}
						if(!rulesList.isEmpty() && rulesList.get(0).getIndentLevel() == mainStack.peek().getIndentLevel() && mainStack.peek().getRuleTypeId() == WFSConstant.RESULT_RULE && rulesList.get(0).getRuleTypeId() == WFSConstant.END_IF_RULE){
							rulesList.remove(0);
							prev_indent = mainStack.peek().getIndentLevel();
							mainStack.pop();
						}else{
							WFSUtil.printErr(engine, "WFSUtil.evaluate:: Point10 - IF Close Rule not found, RuleId " + tmpRule.getRuleId());
							throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_ERROR_EVALUATING_RULE, WFSError.WF_TMP, 
									WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WF_ERROR_EVALUATING_RULE));
						}
					}
				}
				else if(tmpRule.getRuleTypeId() == WFSConstant.END_IF_RULE){
					if(mainStack.isEmpty() || mainStack.peek().getRuleTypeId() != WFSConstant.RESULT_RULE || mainStack.peek().getIndentLevel() != tmpRule.getIndentLevel()){
						WFSUtil.printErr(engine, "WFSUtil.evaluate:: Point11 - IF Open rule not found for END IF, RuleId " + tmpRule.getRuleId());
						throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_ERROR_EVALUATING_RULE, WFSError.WF_TMP, 
								WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WF_ERROR_EVALUATING_RULE));
					}
					//Update the indentation level while ENDING IF
					WFSUtil.printOut(engine, "IL " + tmpRule.getIndentLevel() + " END IF RuleID " + tmpRule.getRuleId());
					prev_indent = mainStack.pop().getIndentLevel();
				}*/
			}
    	}
		catch(Exception ex){
			ruleExecResult = -1;
			WFSUtil.printErr(engine, "WFSUtil.evaluateAndExecuteDX :: Point12 - Within Catch Block",  ex);
			if(ex instanceof WFSException){
				throw ex;
			}
			else if(ex instanceof SQLException){
	            WFSUtil.printErr(engine,"", ex);
	            String descr = "";
	            if (((SQLException)ex).getErrorCode() == 0) {
	                if (((SQLException)ex).getSQLState().equalsIgnoreCase("08S01")) {
	                    descr = (new JTSSQLError(((SQLException)ex).getSQLState())).getMessage() + "(SQL State : " + ((SQLException)ex).getSQLState() + ")";
	                }
	            } else {
	                descr = ((SQLException)ex).getMessage();
	            }
				throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WFS_SQL, WFSError.WF_TMP, 
						WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), descr);
			}
			else{
				throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_ERROR_EVALUATING_RULE, WFSError.WF_TMP, 
						WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WF_ERROR_EVALUATING_RULE));
			}
		}
    	finally{
			if(ruleExecResult == 0){
				try{
					if( targetConn!=null&&!isIsolatedTxnFlag ){
						targetConn.commit();
						targetConn.setAutoCommit(true);
			    		WFSUtil.printOut(engine, "WFSUtil.evaluateAndExecuteDX :: Transaction committed successfully.");
					}
				}catch(Exception ex){
		    		WFSUtil.printErr(engine, "WFSUtil.evaluateAndExecuteDX :: Error occurred while commiting the transaction.", ex);
				}
				if(dxActivityInfo.getConfigurationID() > 0){
					//Target connection != con
					try{
						if(targetConn != null){
							targetConn.close();
							targetConn = null;
				    		WFSUtil.printOut(engine, "WFSUtil.evaluateAndExecuteDX :: Transaction closed successfully.");
						}
					}catch(Exception ex){
			    		WFSUtil.printErr(engine, "WFSUtil.evaluateAndExecuteDX :: Error occurred while closing the connection.", ex);
					}
				}else{
					//Target connection == con
		    		WFSUtil.printOut(engine, "WFSUtil.evaluateAndExecuteDX :: Local BD Connection, hence not closing the connection.");
				}
				//Get the xml attribute from the workitem and return
				auditDataXML.append(workitem.getAuditDataXML(exchangeIdRowCountMap,exchangeIdTableMap));
				result.append(workitem.getSetAttributeXML());
			}
			else{
				try{
					if( targetConn!=null&&!isIsolatedTxnFlag ){
						targetConn.rollback();
						targetConn.setAutoCommit(true);
			    		WFSUtil.printOut(engine, "WFSUtil.evaluateAndExecuteDX :: Transaction rolledback successfully.");
					}
				}catch(Exception ex){
		    		WFSUtil.printErr(engine, "WFSUtil.evaluateAndExecuteDX :: Error occurred while commiting the transaction in non isolation block.", ex);
				}
				if(dxActivityInfo.getConfigurationID() > 0){
					//Target connection != con
					try{
						if(targetConn != null){
							targetConn.close();
							targetConn = null;
				    		WFSUtil.printOut(engine, "WFSUtil.evaluateAndExecuteDX :: Transaction closed successfully.");
						}
					}catch(Exception ex){
			    		WFSUtil.printErr(engine, "WFSUtil.evaluateAndExecuteDX :: Error occurred while closing the connection in non isolation block.", ex);
					}
				}else{
					//Target connection == con
		    		WFSUtil.printOut(engine, "WFSUtil.evaluateAndExecuteDX :: Local BD Connection, hence not closing the connection.");
				}
			}
    	}
		
		return result.toString();
	}
	
	
	private static void evaluateDBRuleAndUpdateWorkitem(Connection targetConn,Connection sourceConn, WFDBOperation dbOperation, WFDataExchangeActivity dxActivityInfo, WFWorkitem workitem, String engine,String processInstanceId,int workitemId,int processDefId, HashMap<Integer, Integer> exchangeIdRowCountMap, HashMap<Integer, String> exchangeIdTableMap, int sourceDBType, int activityId) throws Exception {
		int result = 0;
		String relationExists = "N";
		boolean relationExistFlag = false;
		/*if(!dbRule.isDBRule()){
			WFSUtil.printErr(engine, "WFSUtil.evaluateDBRuleAndUpdateWorkitem:: invalid rule type");
    		throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_INVALID_RULEIDTYPE, WFSError.WF_TMP, 
					WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WF_INVALID_RULEIDTYPE));
		}
		WFDBOperation dbOperation = dxActivityInfo.getOperationsMap().get(dbRule.getRuleId());
		if(dbOperation == null){
			WFSUtil.printErr(engine, "WFSUtil.evaluateDBRuleAndUpdateWorkitem:: DB Operation not found");
    		throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_ERROR_GETTING_OPERATION_DETAILS, WFSError.WF_TMP, 
					WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WF_ERROR_GETTING_OPERATION_DETAILS));
		}*/
		
		//Starting the actual execution of the DB Operations
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		StringBuilder finalQuery = new StringBuilder();
		/*int ruleId = dbOperation.getRuleId();
		int ruleTypeId = dbOperation.getRuleTypeId();
		String tableName = dbOperation.getTableName();*/
		int exchangeId = dbOperation.getExchangeId();
		String configTypeStr = dbOperation.getConfigTypeStr();
	    String updateIfExist = dbOperation.getUpdateIfExist();
	    String dxVarType = dbOperation.getDxVarType(); 
		List<String> selectColsList = new LinkedList<String>();
		int dbType = dxActivityInfo.getDatabaseType();
		MultiValueMap tableColumnsMap = new MultiValueMap();
		MultiValueMap tableValuesMap = new MultiValueMap();
		MultiValueMap relationColumnsMap = new MultiValueMap();
		MultiValueMap relationValuesMap = new MultiValueMap();
		HashMap<String,String> relationExistsMap =  new HashMap<String,String>();
		HashMap<String,String> tableFilterMap =  new HashMap<String,String>();
		boolean updateFlag = false;
		StringBuilder relationInsertCol = new StringBuilder();
		StringBuilder relationInsertColValue = new StringBuilder();
		StringBuilder relationUpdateCol = new StringBuilder();
		String userFilterString ="";
		if("P".equalsIgnoreCase(dxVarType))
		{
		//Rule parsing, filtering and query formation starts here.
		if(WFSConstant.EXPORT_OPERATION.equalsIgnoreCase(configTypeStr) /*WFSConstant.INSERT_RULE*/){
			WFSUtil.printOut(engine, "WFSUtil.evaluateDBRuleAndUpdateWorkitem:: constructing query for Export DB Operation, exchangeId : " + exchangeId);
			StringBuilder insertColumnsList = new StringBuilder("");
			StringBuilder insertValuesList = new StringBuilder("");
			List<WFMappedColumn> insertMap = dbOperation.getInsertMap();
			int noOfColumns = insertMap.size();
			
			for(int iCount = 0; iCount < noOfColumns; iCount++){
				WFMappedColumn mappedColumn = insertMap.get(iCount);
				String tableName = mappedColumn.getTableName();
				String columnName = mappedColumn.getColumnName();
				String columnValue = getColumnValue(mappedColumn, workitem, engine, dbType);
				tableColumnsMap.put(tableName, columnName);
				tableValuesMap.put(tableName, columnValue);
				if(!exchangeIdTableMap.containsKey(exchangeId))
				exchangeIdTableMap.put(exchangeId,tableName);
				//insertColumnsList.append(columnName + ",");
				//insertValuesList.append( columnValue + ",");
			}
			//finalQuery.append("INSERT INTO " + tableName + "(" + insertColumnsList.toString().substring(0, insertColumnsList.length()-1) + ") values (" + insertValuesList.toString().substring(0, insertValuesList.length()-1) + ")");
		}
		//Query formation for the update rule
		/*else if(ruleTypeId == WFSConstant.UPDATE_RULE){
			//Set part of the update query.
			WFSUtil.printOut(engine, "WFSUtil.evaluateDBRuleAndUpdateWorkitem:: constructing query for update DB Operation, RuleId : " + ruleId);
			StringBuilder updateSetList = new StringBuilder("");
			String queryFilterList = "";
			List<WFMappedColumn> updateMap = dbOperation.getSetMap();
			int noOfColumns = updateMap.size();
			
			for(int iCount = 0; iCount < noOfColumns; iCount++){
				WFMappedColumn mappedColumn = updateMap.get(iCount);
				String columnName = mappedColumn.getColumnName();
				String columnValue = getColumnValue(mappedColumn, workitem, engine, dbType);
				updateSetList.append(columnName + " = " + columnValue + ",");
			}
			finalQuery.append("UPDATE " + tableName + " SET " + updateSetList.toString().substring(0, updateSetList.length()-1));
		}*/
		//Query formation for the select rule
		else if(WFSConstant.IMPORT_OPERATION.equalsIgnoreCase(configTypeStr)  /*WFSConstant.RETRIEVE_RULE*/){
			//Part1 -> Get the join details
			WFSUtil.printOut(engine, "WFSUtil.evaluateDBRuleAndUpdateWorkitem:: constructing query for Import DB Operation, exchangeId : " + exchangeId);
			StringBuilder selectColumns = new StringBuilder();
			String tableName ="";
			/*String tableName1 = "";
			String tableName2 = "";
			String joinType = " JOIN ";
			int joinTypeId = 0;
			List<WFJoinDetails> joinList = dbOperation.getJoinMap();

			int noOfJoins = joinList.size();
			String tableJoin = "";
			StringBuilder joinColumns = new StringBuilder(" ON 1 = 1 ");
			StringBuilder selectColumns = new StringBuilder();
			int noOfColumns = 0;
			
			for(int iCount = 0; iCount < noOfJoins; iCount++){
				WFJoinDetails joinDetails = joinList.get(iCount);
				tableName1 = joinDetails.getTableName1();
				tableName2 = joinDetails.getTableName2();
				joinTypeId = joinDetails.getJoinType();
				
				switch(joinTypeId){
				case 1:
					joinType = " INNER JOIN ";
					break;
				case 2:
					joinType = " RIGHT OUTER JOIN ";
					break;
				case 3:
					joinType = " LEFT OUTER JOIN ";
					break;
				case 4:
					joinType = " FULL JOIN ";
					break;
				case 5:
					joinType = " JOIN ";
					break;
				default:
					joinType = " JOIN ";
				}
				
				List<WFMappedColumn> joinColumnsList = joinDetails.getJoinMap();
				noOfColumns = joinColumnsList.size();
				
				for(int iCol = 0; iCol < noOfColumns; iCol++){
					WFMappedColumn mappedColumn = joinColumnsList.get(iCol);
					joinColumns.append(" AND " + mappedColumn.getJoinTableName1() + "." + mappedColumn.getJoinColumnName1() + " = ");
					joinColumns.append(mappedColumn.getJoinTableName2() + "." + mappedColumn.getJoinColumnName2());
				}
				
				if(tableJoin.isEmpty()){
					tableJoin = tableName1 + WFSUtil.getTableLockHintStr(dbType) + joinType + tableName2 + WFSUtil.getTableLockHintStr(dbType) + joinColumns.toString();
				}else{
					if(tableJoin.contains(tableName1)){
						tableJoin = tableJoin + joinType + tableName2 + WFSUtil.getTableLockHintStr(dbType) + joinColumns.toString();
					}
					else if(tableJoin.contains(tableName2)){
						joinType = WFSUtil.getReverseJoinType(joinType);
						tableJoin = tableJoin + joinType + tableName1 + WFSUtil.getTableLockHintStr(dbType) + joinColumns.toString();
					}
					else{
						//error case...it means two earlier joined tables are different from the two incoming tables. hence total tables >3 which is not allowed
						WFSUtil.printErr(engine, "WFSUtil.evaluateDBRuleAndUpdateWorkitem:: More than 3 table joins are not allowed.");
			    		throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_ERROR_EXECUTING_DB_QUERY, WFSError.WF_TMP, 
								WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WF_ERROR_EXECUTING_DB_QUERY));
					}
				}
				
				joinColumns.setLength(0);
				joinColumns.append(" ON 1 = 1 ");
			}
			if(tableJoin.isEmpty()){
				//tableJoin = tableName + WFSUtil.getTableLockHintStr(dbType);
			}
			*/
			//Part2 - Select Columns
			List<WFMappedColumn> selectList = dbOperation.getSelectMap();
			 int noOfColumns = selectList.size();

			for(int iCol = 0; iCol < noOfColumns; iCol++){
				WFMappedColumn mappedColumn = selectList.get(iCol);
				//String mappedColumnName = mappedColumn.getTableName() + "." + mappedColumn.getColumnName();
			 tableName = mappedColumn.getTableName();
				String columnName = mappedColumn.getColumnName();
				tableColumnsMap.put(tableName, columnName);
				userFilterString = mappedColumn.getFilterString();
				String mappedField = mappedColumn.getMappedField();
				selectColsList.add(mappedField);
				selectColumns.append(columnName + ",");
			}
			if(!exchangeIdTableMap.containsKey(exchangeId))
				exchangeIdTableMap.put(exchangeId,tableName);
			finalQuery.append("SELECT " + selectColumns.toString().substring(0, selectColumns.length()-1) + " FROM " + tableName + getTableLockHintStr(dbType));
		}
		//Part3: Filter Conditions (common to update and retrieve)
		/*if(ruleTypeId == WFSConstant.UPDATE_RULE || ruleTypeId == WFSConstant.RETRIEVE_RULE){
			String queryFilterList = "";
			List<WFMappedColumn> filterMap = dbOperation.getFilterMap();
			queryFilterList = getFilterQueryFromXML(filterMap, workitem, engine, dbType);
			if(queryFilterList != null && !queryFilterList.isEmpty()){
				finalQuery.append(" WHERE " + queryFilterList);
			}
		}*/
		WFSUtil.printOut(engine, "WFSUtil.evaluateDBRuleAndUpdateWorkitem:: selectColsList size for exchangeId : " + exchangeId + " is " + selectColsList.size());
		
		//This method is to map the return value with the process variable in process (Transient variable in RPA)
		populateSelectedColsList(selectColsList, dbOperation, workitem.isRPACall(), engine);
		WFSUtil.printOut(engine, "WFSUtil.evaluateDBRuleAndUpdateWorkitem:: selectColsList size after calling populateSelectedColsList : " + selectColsList.size());
		
		//Relation Part
		List<WFMappedColumn> RelationMap = dbOperation.getRelationMap();
		int noOfColumns = RelationMap.size();		
		for(int iCount = 0; iCount < noOfColumns; iCount++)
		{
			WFMappedColumn mappedColumn = RelationMap.get(iCount);
			String tableName = mappedColumn.getEntityName();
			String columnName = mappedColumn.getEntityColumnName();
			String columnValue = getRelationColumnValue(mappedColumn,engine,sourceConn,processInstanceId,workitemId,dxVarType,dbType,processDefId,sourceDBType);
			relationColumnsMap.put(tableName, columnName);
			relationValuesMap.put(tableName, columnValue);
		}
		
		if( !(relationColumnsMap.isEmpty() && relationValuesMap.isEmpty()))
		{
			relationExistFlag = true;
			String qStr="";
			Set<String> keys = relationColumnsMap.keySet();
            for (String key : keys) 
			{
			    List<String> columnlist = (List<String>) relationColumnsMap.get(key);
			    List<String> valuelist = (List<String>) relationValuesMap.get(key);
			    for(int i =0;i<columnlist.size();i++)
			    {
			    	relationInsertCol.append(columnlist.get(i)+",");
			    	relationInsertColValue.append(valuelist.get(i) + ",");
			    	relationUpdateCol.append(columnlist.get(i) + " = " + valuelist.get(i) + ",");
			    }
			    qStr="SELECT " + relationInsertCol.toString().substring(0, relationInsertCol.length()-1) + " FROM " + key + getTableLockHintStr(dbType)+" where "+
			    		relationUpdateCol.toString().substring(0, relationUpdateCol.length()-1);
			    pstmt = targetConn.prepareStatement(qStr);
			    rs = pstmt.executeQuery();
			    if(rs.next())
			    {
			    	relationExists = "Y";
			    }
			    relationExistsMap.put(key, relationExists);
			    if(rs != null){
					rs.close();
					rs = null;
                }
                if(pstmt != null){
                	pstmt.close();
                	pstmt = null;
                }
			 } 
			
			
		}
		else
		{
			finalQuery = null;
			WFSUtil.printOut(engine, "WFSUtil.evaluateDBRuleAndUpdateWorkitem:: Relation does not exist for exchangeID : " + exchangeId);
		}
				
		//Creating Final query
		if(WFSConstant.EXPORT_OPERATION.equalsIgnoreCase(configTypeStr))
		{
		if(relationExistFlag && "Y".equalsIgnoreCase(updateIfExist))
		{
			Set<String> keys = relationExistsMap.keySet(); 
			for (String key : keys) 
			{
				String relExist = relationExistsMap.get(key);
				if("Y".equalsIgnoreCase(relExist))
				{
					    String filter = relationUpdateCol.toString().substring(0, relationUpdateCol.length()-1);
					    List<String> columnlist = (List<String>) tableColumnsMap.get(key);
					    List<String> valuelist = (List<String>) tableValuesMap.get(key);
					    for(int i =0;i<columnlist.size();i++)
					    {
					    	relationUpdateCol.append(columnlist.get(i) + " = " + valuelist.get(i) + ",");
					    }
					    finalQuery.append("UPDATE " + key + " SET " + relationUpdateCol.toString().substring(0, relationUpdateCol.length()-1) +" where "+filter);
			     }
				else
				{
					List<String> columnlist = (List<String>) tableColumnsMap.get(key);
				    List<String> valuelist = (List<String>) tableValuesMap.get(key);
				    for(int i =0;i<columnlist.size();i++)
				    {
				    	relationInsertCol.append(columnlist.get(i)+",");
				    	relationInsertColValue.append(valuelist.get(i) + ",");
				    }
				    finalQuery.append("INSERT INTO " + key + "(" + relationInsertCol.toString().substring(0, relationInsertCol.length()-1) + ") values (" + relationInsertColValue.toString().substring(0, relationInsertColValue.length()-1) + ")");
				
				}
			}
		}
		else
		{ 
			Set<String> keys = tableColumnsMap.keySet();
			for (String key : keys) 
			{
			    List<String> columnlist = (List<String>) tableColumnsMap.get(key);
			    List<String> valuelist = (List<String>) tableValuesMap.get(key);
			    for(int i =0;i<columnlist.size();i++)
			    {
			    	relationInsertCol.append(columnlist.get(i)+",");
			    	relationInsertColValue.append(valuelist.get(i) + ",");
			    }
			    finalQuery.append("INSERT INTO " + key + "(" + relationInsertCol.toString().substring(0, relationInsertCol.length()-1) + ") values (" + relationInsertColValue.toString().substring(0, relationInsertColValue.length()-1) + ")");
			 } 	
		}
		}
		else
		{
			Set<String> keys = relationExistsMap.keySet(); 
			for (String key : keys) 
			{
				String relExist = relationExistsMap.get(key);
				if("Y".equalsIgnoreCase(relExist))
				{
					finalQuery.append(" where "+relationUpdateCol.toString().substring(0, relationUpdateCol.length()-1));
					 if(userFilterString != null && !userFilterString.isEmpty())
						 finalQuery.append(" AND "+userFilterString);
				}
				else
				{
					finalQuery = null;
					WFSUtil.printOut(engine, "Relation does not exist for Data exchange table "+key+" and exchangeId "+exchangeId );					
				}
			}
		}
				
		if(finalQuery != null)
		{
		String query = finalQuery.toString();
		WFSUtil.printOut(engine, "==========================================");
		WFSUtil.printOut(engine, "Final DB Query :: => " + query);
		WFSUtil.printOut(engine, "==========================================");

		//Actual execution of the query
		pstmt = targetConn.prepareStatement(query, ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
		if(WFSConstant.IMPORT_OPERATION.equalsIgnoreCase(configTypeStr) /*WFSConstant.RETRIEVE_RULE*/){
			rs = pstmt.executeQuery();
			rs.last();
			result = rs.getRow();
			rs.beforeFirst();
			if(result > 1){
				WFSUtil.printErr(engine, "Retrieve Query returned more than one row : " + query + ", No of rows : " + result);
	    		throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_ERROR_QUERY_RETURNED_MORE_THAN_ONE_ROW, WFSError.WF_TMP, 
						WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WF_ERROR_QUERY_RETURNED_MORE_THAN_ONE_ROW));
			}
		}
		else{
			result = pstmt.executeUpdate();
		}
		exchangeIdRowCountMap.put(exchangeId, result);
		
		if(WFSConstant.IMPORT_OPERATION.equalsIgnoreCase(configTypeStr) /*WFSConstant.RETRIEVE_RULE*/){
			if(rs!=null && rs.next()){
				ResultSetMetaData rsmd = rs.getMetaData();
				WFSUtil.printOut(engine, "No of columns in the retrieve query : " + rsmd.getColumnCount());
				for(int fieldInx = 1; fieldInx <= rsmd.getColumnCount(); fieldInx++){
					String columnName = rsmd.getColumnName(fieldInx);
					String columnValue = rs.getString(fieldInx);
					String mappedColmKey = selectColsList.get(0);
					workitem.updateVarValue(mappedColmKey, columnValue, engine,0);
					selectColsList.remove(0);
				}
			}
		}
		if(!selectColsList.isEmpty()){
			String mappedColmKey = selectColsList.get(selectColsList.size()-1);
			if(mappedColmKey != null && !mappedColmKey.isEmpty()){
				workitem.updateVarValue(mappedColmKey, result+"", engine,0);
			}
		}
		}
		try {

            if (rs != null) {
            	rs.close();
            	rs = null;
            }
        } catch (Exception e) {
        }
	 }
	else
		{
		    
		    HashMap<String,List<String>> tablefinalQueriesListMap =  new HashMap<String,List<String>>();
		    StringBuilder selectComplexCol = new StringBuilder();
		    StringBuilder filterString = new StringBuilder();			
		    StringBuilder complexTableQuery = new StringBuilder();
			HashMap<String,String> varfieldComplexTableMap =  new HashMap<String,String>();
			HashMap<String,String> dxTableComplexTableMap =  new HashMap<String,String>();
			HashMap<String,String> complexTableRelationMap =  new HashMap<String,String>();
			HashMap<String,String> relationInsertColMap =  new HashMap<String,String>();
			HashMap<String,String> relationInsertColValueMap =  new HashMap<String,String>();
			HashMap<String,String> relationUpdateColMap =  new HashMap<String,String>();
			HashMap<String,String> filterStringMap =  new HashMap<String,String>();
			MultiValueMap tableColumnTypeMap = new MultiValueMap();
			MultiValueMap tableColumnNullableMap = new MultiValueMap();
			MultiValueMap complexColumnsMap = new MultiValueMap();
			MultiValueMap tableMappedFieldMap = new MultiValueMap();
			StringBuilder selectColumns = new StringBuilder();
			Map<String, List<String>> complexRelationKeyValueListmap = new HashMap<String, List<String>>();
			HashMap<String,String> tableIsArrayMap =  new HashMap<String,String>();
			HashMap<String,String> complexColumnDxColumnMap =  new HashMap<String,String>();
			HashMap<String,WFAttribute> tableAttributeMap =  new HashMap<String,WFAttribute>();
			HashMap<String, List<String>> dxRelationKeyValueListMap =  new HashMap<String, List<String>>();
			HashMap<String,String> dxParentChildMap =  new HashMap<String,String>();
			MultiValueMap dxTableChildMapper =  new MultiValueMap();
			HashMap<String,String> dxTableParentMapper =  new HashMap<String,String>();
			HashMap<String,WFAttribute> parentAttributeMap =  new HashMap<String,WFAttribute>();
			HashMap<String,WFAttribute> childAttributeMap =  new HashMap<String,WFAttribute>();
			HashMap<String,String> rootTableMap =  new HashMap<String,String>();
			MultiValueMap parentChildMapperKeyMap = new MultiValueMap();
			HashMap<String,Boolean> deleteQueryExistMap =  new HashMap<String,Boolean>();
			Boolean isArrayCase = false;
			  WFAttribute rootAttrib = null;
			if(WFSConstant.EXPORT_OPERATION.equalsIgnoreCase(configTypeStr) /*WFSConstant.INSERT_RULE*/)
			{
				WFSUtil.printOut(engine, "WFSUtil.evaluateDBRuleAndUpdateWorkitem:: constructing query for Export DB Operation, exchangeId : " + exchangeId);
				List<WFMappedColumn> insertMap = dbOperation.getInsertMap();
				int noOfColumns = insertMap.size();	
				if("N".equalsIgnoreCase(dxVarType))
				{
					for(int iCount = 0; iCount < noOfColumns; iCount++)
					{
						WFMappedColumn mappedColumn = insertMap.get(iCount);
						String tableFilterString = mappedColumn.getFilterString();
						if(tableFilterString!=null && !tableFilterString.isEmpty())
						{
							String complexTableName = getComplexName(mappedColumn,sourceConn,processDefId,varfieldComplexTableMap,sourceDBType);
							if(!tableFilterMap.containsKey(complexTableName))
							{
								tableFilterMap.put(complexTableName,tableFilterString);
							}
							
						}
						
					}
					
				}
				for(int iCount = 0; iCount < noOfColumns; iCount++){
					WFMappedColumn mappedColumn = insertMap.get(iCount);
					String tableName = mappedColumn.getTableName();
					String columnName = mappedColumn.getColumnName();
					userFilterString = mappedColumn.getFilterString();
					int expressionDataType = mappedColumn.getDbColumnDatatype();
					tableColumnNullableMap.put(tableName, mappedColumn.isNullable());
					tableColumnTypeMap.put(tableName, expressionDataType);
					if(userFilterString!=null && !userFilterString.isEmpty())
					{
					tableFilterMap.put(tableName,userFilterString);
					}
					tableColumnsMap.put(tableName, columnName);
					getComplexInfo(mappedColumn,sourceConn,processDefId,varfieldComplexTableMap,dxTableComplexTableMap,complexColumnsMap,complexTableRelationMap,engine,processInstanceId,workitemId,dbType,complexRelationKeyValueListmap,sourceDBType,tableFilterMap);
					WFAttribute attrib = workitem.getVarIdAttributeMap().get(mappedColumn.getMappedField());
					if(!exchangeIdTableMap.containsKey(exchangeId) && attrib.getParentAttribute().isRoot )
						exchangeIdTableMap.put(exchangeId,tableName);
				   if(isarray(attrib))
				   {
					   tableIsArrayMap.put(tableName, "Y");
				   }
				}
			}
			
			else if(WFSConstant.IMPORT_OPERATION.equalsIgnoreCase(configTypeStr)  /*WFSConstant.RETRIEVE_RULE*/)
			{
				WFSUtil.printOut(engine, "WFSUtil.evaluateDBRuleAndUpdateWorkitem:: constructing query for Import DB Operation, exchangeId : " + exchangeId);
				String tableName ="";
				List<WFMappedColumn> selectList = dbOperation.getSelectMap();
				 int noOfColumns = selectList.size();

				for(int iCol = 0; iCol < noOfColumns; iCol++){
					WFMappedColumn mappedColumn = selectList.get(iCol);
					//String mappedColumnName = mappedColumn.getTableName() + "." + mappedColumn.getColumnName();
				    tableName = mappedColumn.getTableName();
					String columnName = mappedColumn.getColumnName();
					tableColumnsMap.put(tableName, columnName);
					userFilterString = mappedColumn.getFilterString();
					if(userFilterString!=null && !userFilterString.isEmpty())
					{
					tableFilterMap.put(tableName,userFilterString);
					}
					String mappedField = mappedColumn.getMappedField();
					tableMappedFieldMap.put(tableName, mappedField);
					getComplexInfo(mappedColumn,sourceConn,processDefId,varfieldComplexTableMap,dxTableComplexTableMap,complexColumnsMap,complexTableRelationMap,engine,processInstanceId,workitemId,dbType,complexRelationKeyValueListmap,sourceDBType,tableFilterMap);
					WFAttribute attrib = workitem.getVarIdAttributeMap().get(mappedColumn.getMappedField());
					if(!exchangeIdTableMap.containsKey(exchangeId) && attrib.getParentAttribute().isRoot )
						exchangeIdTableMap.put(exchangeId,tableName);
					   if(isarray(attrib))
					   {
						   isArrayCase = true;   
						   tableIsArrayMap.put(tableName, "Y");
					   }
					 rootAttrib = getRootAttribute(attrib);
					//selectColsList.add(mappedField);
					//selectColumns.append(columnName + ",");
				}						
			}
			
			populateSelectedColsList(selectColsList, dbOperation, workitem.isRPACall(), engine);
			WFSUtil.printOut(engine, "WFSUtil.evaluateDBRuleAndUpdateWorkitem:: selectColsList size after calling populateSelectedColsList : " + selectColsList.size());
			
			//Relation Part
			List<WFMappedColumn> RelationMap = dbOperation.getRelationMap();
			int noOfColumns = RelationMap.size();		
			for(int iCount = 0; iCount < noOfColumns; iCount++)
			{
				WFMappedColumn mappedColumn = RelationMap.get(iCount);
				String tableName = mappedColumn.getEntityName();
				String columnName = mappedColumn.getEntityColumnName();
				List<String> columnValue = new ArrayList<String>();
				if(WFSConstant.EXPORT_OPERATION.equalsIgnoreCase(configTypeStr))
				{
				columnValue = getRelationColumnValueForComplexArray(mappedColumn,engine,sourceConn,processInstanceId,workitemId,dxVarType,dbType,processDefId,sourceDBType,tableFilterMap);
				}
				else
				{
				columnValue =getRelationColumnValueForComplexArrayImport(mappedColumn,engine,sourceConn,dbType,complexTableRelationMap,complexRelationKeyValueListmap,targetConn,dxParentChildMap,dxTableChildMapper,dxTableParentMapper,sourceDBType,activityId,tableFilterMap,processDefId);
				}
				relationColumnsMap.put(tableName, columnName);
				relationValuesMap.put(tableName, columnValue);
				tableColumnsMap.put(tableName, columnName);
				tableColumnNullableMap.put(tableName, true);
				tableColumnTypeMap.put(tableName,  mappedColumn.getDbColumnDatatype());
				complexColumnsMap.put(mappedColumn.getComplexTableName(), mappedColumn.getRelationColumnName());
				complexColumnDxColumnMap.put(mappedColumn.getComplexTableName()+"#"+mappedColumn.getRelationColumnName(), columnName);
				dxRelationKeyValueListMap.put(tableName+"#"+columnName,columnValue);
			}
			
			if( !(relationColumnsMap.isEmpty() && relationValuesMap.isEmpty()))
			{
				relationExistFlag = true;
				String qStr="";
				Set<String> keys = relationColumnsMap.keySet();
	            for (String key : keys) 
				{	            	
	            	relationInsertCol.delete(0,  relationInsertCol.length());
	            	relationInsertColValue.delete(0,  relationInsertColValue.length());
	            	relationUpdateCol.delete(0,  relationUpdateCol.length());
	            	filterString.delete(0,  filterString.length());
	            	List<String> columnlist = (List<String>) relationColumnsMap.get(key);
				    List<List<String>> listOfValuelist = (List<List<String>>) relationValuesMap.get(key);
				       for(int i =0;i<columnlist.size();i++)
					    {
				    	   if((columnlist.get(i)).equalsIgnoreCase(complexColumnDxColumnMap.get(dxTableComplexTableMap.get(key)+"#"+complexTableRelationMap.get(dxTableComplexTableMap.get(key)))))
				    	   {
					    	relationInsertCol.append(columnlist.get(i)+",");
					    	List<String> valuelist = (List<String>)listOfValuelist.get(i);	
					    	if("Y".equalsIgnoreCase(tableIsArrayMap.get(key)))
					    	{
					    		String valuelistString="";
					    		for(int j=0;j<valuelist.size();j++)
					    		{
					    			valuelistString = valuelistString+","+valuelist.get(j);
					    		}
					    		filterString.append(columnlist.get(i) + " IN ( " +valuelistString.substring(1, valuelistString.length()) + " ) AND ");
						    	
					    	}
					    	else
					    	{
					    	relationInsertColValue.append(valuelist.get(0) + ",");
					    	relationUpdateCol.append(columnlist.get(i) + " = " + valuelist.get(0) + ",");
					    	filterString.append(columnlist.get(i) + " = " + valuelist.get(0) + " AND ");
					    	}
				    	   }
					    }
					    relationInsertColMap.put(key, relationInsertCol.toString());
					    relationInsertColValueMap.put(key, relationInsertColValue.toString());
					    relationUpdateColMap.put(key, relationUpdateCol.toString());
					    filterStringMap.put(key, filterString.toString());
					    qStr="SELECT " + relationInsertCol.toString().substring(0, relationInsertCol.length()-1) + " FROM " + key +" "+ getTableLockHintStr(dbType) +" where "+
					    		filterString.toString().substring(0, filterString.length()-4);
					    pstmt = targetConn.prepareStatement(qStr);
					    rs = pstmt.executeQuery();
					    if(rs.next())
					    {
					    	relationExists = "Y";
					    }
					    relationExistsMap.put(key, relationExists);
					    if(rs != null){
							rs.close();
							rs = null;
		                }
		                if(pstmt != null){
		                	pstmt.close();
		                	pstmt = null;
		                }
					 } 
				
				
				
			}
			else
			{
				WFSUtil.printOut(engine, "WFSUtil.evaluateDBRuleAndUpdateWorkitem:: Relation does not exist for exchangeID : " + exchangeId);
			}
			if(WFSConstant.EXPORT_OPERATION.equalsIgnoreCase(configTypeStr))
			{
			if(relationExistFlag && "Y".equalsIgnoreCase(updateIfExist))
			{
				Set<String> keys = relationExistsMap.keySet(); 
				for (String key : keys) 
				{ 
					finalQuery.delete(0,  finalQuery.length());
					complexTableQuery.delete(0,  complexTableQuery.length());
					selectComplexCol.delete(0,  selectComplexCol.length());
					String relExist = relationExistsMap.get(key);
					if("Y".equalsIgnoreCase(relExist))
					{
						if("Y".equalsIgnoreCase(tableIsArrayMap.get(key)))
		                    {
							    List<String> finalQueriesList = new ArrayList<String>();
								String filterString1 = filterStringMap.get(key).toString().substring(0, filterStringMap.get(key).length()-4);
							   	complexTableQuery.delete(0,  complexTableQuery.length());
			    				finalQuery.delete(0,  finalQuery.length());
		    					selectComplexCol.delete(0,  selectComplexCol.length());
		    					List<String> dxColumnlist = (List<String>) tableColumnsMap.get(key);
		    				    String complexTableName = dxTableComplexTableMap.get(key);
		    				    List<Integer> columnTypeList = (List<Integer>) tableColumnTypeMap.get(key);
		    				    List<Boolean> columnNullableList = (List<Boolean>) tableColumnNullableMap.get(key);
		    				    List<String> complexColumnlist = (List<String>) complexColumnsMap.get(complexTableName);
		    				    String relationKey = complexTableRelationMap.get(complexTableName);
		    				    List<String> relationValuelist = (List<String>)complexRelationKeyValueListmap.get(complexTableName+"#"+relationKey);
		    				    ///Delete query from Data Exchange table
		    				    finalQuery.append("Delete From "+key+" where "+filterString1);
		    				    deleteQueryExistMap.put(key, true);
		    				    finalQueriesList.add(finalQuery.toString());
		    				    for(int i =0;i<complexColumnlist.size();i++)
		    				    {
		    				    	selectComplexCol.append(complexColumnlist.get(i)+",");
		    				    }
		    				    complexTableQuery.append("SELECT " + selectComplexCol.toString().substring(0, selectComplexCol.length()-1) + " FROM " + complexTableName + " "+ getTableLockHintStr(sourceDBType) +" where "+relationKey+" =? " );
		    				    if(tableFilterMap.get(key) != null && !tableFilterMap.get(key).isEmpty())
		    				    	complexTableQuery.append(" AND "+tableFilterMap.get(key));
		    				    for(int i =0;i<relationValuelist.size();i++)
		    				    {
		    				    	if(relationValuelist.get(i)!= null && !relationValuelist.get(i).isEmpty())
		    				    	{
		    				    	List<List<String>> listOfValuelist = new ArrayList<List<String>>(); 
		    				    	pstmt = sourceConn.prepareStatement(complexTableQuery.toString());			    				           				    
		    				    	try
		    				    	{
		    				       	pstmt.setString(1, relationValuelist.get(i));
		    				    	rs = pstmt.executeQuery();
		    				    	}
		    				    	catch( Exception e)
		    				    	{
		    				    		pstmt.setLong(1, Long.parseLong(relationValuelist.get(i)));
		    				    		rs = pstmt.executeQuery();
		    				    	}
		    				    while(rs.next())
		    				    {
		    				    	 List<String> valuelist = new ArrayList<String>();    	    				    
		    				    	for(int j =0;j<complexColumnlist.size();j++)
		    					    {
		    				    		String finalValue = rs.getString(complexColumnlist.get(j));
		    				    		if(finalValue != null && !finalValue.isEmpty()){
		    				    			finalValue = TO_SQL(finalValue, columnTypeList.get(j), dbType, true);
		    				    		}
		    				    		else{
		    				    			if(columnNullableList.get(j) ){
		    				    				finalValue = " NULL ";
		    				    			}
		    				    			else{
		    				    				WFSUtil.printErr(engine, "Cannot insert null value in the not null column : " + complexColumnlist.get(i), null);
		    				    				throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_INSERTING_NULL_IN_NOT_NULL_COLUMN, WFSError.WF_TMP, WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WF_INSERTING_NULL_IN_NOT_NULL_COLUMN));
		    				    			}
		    				    		}
		    				    		
		    				    		valuelist.add(finalValue);    
		    					    }
		    				    	listOfValuelist.add(valuelist);
		    				    }
		    				    if(rs != null){
		    						rs.close();
		    						rs = null;
		    	                }
		    	                if(pstmt != null){
		    	                	pstmt.close();
		    	                	pstmt = null;
		    	                }
		    	                 if(listOfValuelist.isEmpty())
		    	                {
		    	                	finalQuery.append("");
		    						WFSUtil.printOut(engine, "Values does not Exist for applied filter on complex table "+complexTableName );
		    						WFSUtil.printOut(engine, "Final query for complex table "+complexTableName+" ---->> "+ complexTableQuery);
		    												
		    	                }
		    	                else
		    	                {
		    				    for(int j =0;j<listOfValuelist.size();j++)
		    				    {
		    				    	finalQuery.delete(0,  finalQuery.length());
		    				    	List<String> valuelist = listOfValuelist.get(j);
		    				    	StringBuilder insertCol = new StringBuilder();
		        	                StringBuilder insertColValue = new StringBuilder();        	               
		    				    	 for(int k =0;k<valuelist.size();k++)
		    						    {
		    						    	insertCol.append(dxColumnlist.get(k)+",");
		    						    	insertColValue.append(valuelist.get(k) + ",");
		    						    }
		    						    finalQuery.append("INSERT INTO " + key + "(" + insertCol.toString().substring(0, insertCol.length()-1) + ") values (" + insertColValue.toString().substring(0, insertColValue.length()-1) + ")");
		    						    finalQueriesList.add(finalQuery.toString()); 
		    				    }
		    	                }
		    				  }
	    				   } 	
		    				    tablefinalQueriesListMap.put(key, finalQueriesList);
		                 }
					else	
						{
						    List<String> finalQueriesList = new ArrayList<String>();
						    List<String> dxColumnlist = (List<String>) tableColumnsMap.get(key);
						    String complexTableName = dxTableComplexTableMap.get(key);
						    List<Integer> columnTypeList = (List<Integer>) tableColumnTypeMap.get(key);
						    List<Boolean> columnNullableList = (List<Boolean>) tableColumnNullableMap.get(key);
						    List<String> complexColumnlist = (List<String>) complexColumnsMap.get(complexTableName);
						    String relationKey = complexTableRelationMap.get(complexTableName);
	    				    List<String> relationValuelist = (List<String>)complexRelationKeyValueListmap.get(complexTableName+"#"+relationKey);
	    				    for(int i =0;i<complexColumnlist.size();i++)
						    {
						    	selectComplexCol.append(complexColumnlist.get(i)+",");
						    }
						    complexTableQuery.append("SELECT " + selectComplexCol.toString().substring(0, selectComplexCol.length()-1) + " FROM " + complexTableName + " "+ getTableLockHintStr(sourceDBType) +" where "+relationKey+" =? "  );
						    if(tableFilterMap.get(key) != null && !tableFilterMap.get(key).isEmpty())
						    	complexTableQuery.append(" AND "+tableFilterMap.get(key));
						    for(int i =0;i<relationValuelist.size();i++)
	    				    {
						    	if(relationValuelist.get(i)!= null && !relationValuelist.get(i).isEmpty())
	    				    	{
						    	finalQuery.delete(0,  finalQuery.length());
						    	List<String> valuelist = new ArrayList<String>();
						    	 pstmt = sourceConn.prepareStatement(complexTableQuery.toString());								   
						    	 try
		    				    	{
		    				       	pstmt.setString(1, relationValuelist.get(i));
		    				    	rs = pstmt.executeQuery();
		    				    	}
		    				    	catch( Exception e)
		    				    	{
		    				    		pstmt.setLong(1, Long.parseLong(relationValuelist.get(i)));
		    				    		rs = pstmt.executeQuery();
		    				    	}
							    if(rs.next())
							    {
							    	for(int j =0;j<complexColumnlist.size();j++)
								    {
							    		String finalValue = rs.getString(complexColumnlist.get(j));
							    		if(finalValue != null && !finalValue.isEmpty()){
							    			finalValue = TO_SQL(finalValue, columnTypeList.get(j), dbType, true);
							    		}
							    		else{
							    			if(columnNullableList.get(j) ){
							    				finalValue = " NULL ";
							    			}
							    			else{
							    				WFSUtil.printErr(engine, "Cannot insert null value in the not null column : " + complexColumnlist.get(i), null);
							    				throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_INSERTING_NULL_IN_NOT_NULL_COLUMN, WFSError.WF_TMP, WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WF_INSERTING_NULL_IN_NOT_NULL_COLUMN));
							    			}
							    		}
							    		
							    		valuelist.add(finalValue);    
								    }
						    }
						    if(rs != null){
								rs.close();
								rs = null;
			                }
			                if(pstmt != null){
			                	pstmt.close();
			                	pstmt = null;
			                }
			                String filterUpdate = complexColumnDxColumnMap.get(complexTableName+"#"+relationKey)+" = '"+relationValuelist.get(i)+"'";
			                StringBuilder updateCol = new StringBuilder();
			                if(valuelist.isEmpty())
			                {
			                	finalQuery.append("");
								WFSUtil.printOut(engine, "Values does not Exist for applied filter on complex table "+complexTableName );
								WFSUtil.printOut(engine, "Final query for complex table "+complexTableName+" ---->> "+ complexTableQuery);
															
			                }
			                else
			                {
						    for(int j =0;j<valuelist.size();j++)
						    {
						    	updateCol.append(dxColumnlist.get(j) + " = " + valuelist.get(j) + ",");
						    }
						    finalQuery.append("UPDATE " + key + " SET " + updateCol.toString().substring(0, updateCol.length()-1) +" where "+filterUpdate);
			                }
						    finalQueriesList.add(finalQuery.toString());
	    				    }
	    				    } 	
						    tablefinalQueriesListMap.put(key, finalQueriesList);
					    }
					}
					else
					{ 
						        List<String> finalQueriesList = new ArrayList<String>();
						        complexTableQuery.delete(0,  complexTableQuery.length());
		    					finalQuery.delete(0,  finalQuery.length());
		    					selectComplexCol.delete(0,  selectComplexCol.length());
		    					List<String> dxColumnlist = (List<String>) tableColumnsMap.get(key);
		    				    String complexTableName = dxTableComplexTableMap.get(key);
		    				    List<Integer> columnTypeList = (List<Integer>) tableColumnTypeMap.get(key);
		    				    List<Boolean> columnNullableList = (List<Boolean>) tableColumnNullableMap.get(key);
		    				    List<String> complexColumnlist = (List<String>) complexColumnsMap.get(complexTableName);
		    				    String relationKey = complexTableRelationMap.get(complexTableName);
		    				    List<String> relationValuelist = (List<String>)complexRelationKeyValueListmap.get(complexTableName+"#"+relationKey);
		    				    for(int i =0;i<complexColumnlist.size();i++)
		    				    {
		    				    	selectComplexCol.append(complexColumnlist.get(i)+",");
		    				    }
		    				    complexTableQuery.append("SELECT " + selectComplexCol.toString().substring(0, selectComplexCol.length()-1) + " FROM " + complexTableName + " "+ getTableLockHintStr(sourceDBType) +" where "+relationKey+" =? " );
		    				    if(tableFilterMap.get(key) != null && !tableFilterMap.get(key).isEmpty())
		    				    	complexTableQuery.append(" AND "+tableFilterMap.get(key));
		    				    for(int i =0;i<relationValuelist.size();i++)
		    				    {
		    				    	if(relationValuelist.get(i)!= null && !relationValuelist.get(i).isEmpty())
		    				    	{
		    				    	List<List<String>> listOfValuelist = new ArrayList<List<String>>();
		    				    	pstmt = sourceConn.prepareStatement(complexTableQuery.toString());
		    				    	try
		    				    	{
		    				       	pstmt.setString(1, relationValuelist.get(i));
		    				    	rs = pstmt.executeQuery();
		    				    	}
		    				    	catch( Exception e)
		    				    	{
		    				    		pstmt.setLong(1, Long.parseLong(relationValuelist.get(i)));
		    				    		rs = pstmt.executeQuery();
		    				    	}
		    				    while(rs.next())
		    				    {
		    				    	 List<String> valuelist = new ArrayList<String>();    	    				    
		    				    	for(int j =0;j<complexColumnlist.size();j++)
		    					    {
		    				    		String finalValue = rs.getString(complexColumnlist.get(j));
		    				    		if(finalValue != null && !finalValue.isEmpty()){
		    				    			finalValue = TO_SQL(finalValue, columnTypeList.get(j), dbType, true);
		    				    		}
		    				    		else{
		    				    			if(columnNullableList.get(j) ){
		    				    				finalValue = " NULL ";
		    				    			}
		    				    			else{
		    				    				WFSUtil.printErr(engine, "Cannot insert null value in the not null column : " + complexColumnlist.get(i), null);
		    				    				throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_INSERTING_NULL_IN_NOT_NULL_COLUMN, WFSError.WF_TMP, WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WF_INSERTING_NULL_IN_NOT_NULL_COLUMN));
		    				    			}
		    				    		}
		    				    		
		    				    		valuelist.add(finalValue);    
		    					    }
		    				    	listOfValuelist.add(valuelist);
		    				    }
		    				    if(rs != null){
		    						rs.close();
		    						rs = null;
		    	                }
		    	                if(pstmt != null){
		    	                	pstmt.close();
		    	                	pstmt = null;
		    	                }
		    	                 if(listOfValuelist.isEmpty())
		    	                {
		    	                	finalQuery.append("");
		    						WFSUtil.printOut(engine, "Values does not Exist for applied filter on complex table "+complexTableName );
		    						WFSUtil.printOut(engine, "Final query for complex table "+complexTableName+" ---->> "+ complexTableQuery);
		    												
		    	                }
		    	                else
		    	                {
		    				    for(int j =0;j<listOfValuelist.size();j++)
		    				    {
		    				    	finalQuery.delete(0,  finalQuery.length());
		    				    	List<String> valuelist = listOfValuelist.get(j);
		    				    	StringBuilder insertCol = new StringBuilder();
		        	                StringBuilder insertColValue = new StringBuilder();        	               
		    				    	 for(int k =0;k<valuelist.size();k++)
		    						    {
		    						    	insertCol.append(dxColumnlist.get(k)+",");
		    						    	insertColValue.append(valuelist.get(k) + ",");
		    						    }
		    						    finalQuery.append("INSERT INTO " + key + "(" + insertCol.toString().substring(0, insertCol.length()-1) + ") values (" + insertColValue.toString().substring(0, insertColValue.length()-1) + ")");
		    						    finalQueriesList.add(finalQuery.toString());
		    				    }
		    	                }
		    				   }
		    				  }
		    				    tablefinalQueriesListMap.put(key, finalQueriesList);
						}
				}
			}
			else
			{ 
				Set<String> keys = tableColumnsMap.keySet();
				for (String key : keys) 
				{ 
					    List<String> finalQueriesList = new ArrayList<String>();
					    complexTableQuery.delete(0,  complexTableQuery.length());
    					finalQuery.delete(0,  finalQuery.length());
    					selectComplexCol.delete(0,  selectComplexCol.length());
    					List<String> dxColumnlist = (List<String>) tableColumnsMap.get(key);
    				    String complexTableName = dxTableComplexTableMap.get(key);
    				    List<Integer> columnTypeList = (List<Integer>) tableColumnTypeMap.get(key);
    				    List<Boolean> columnNullableList = (List<Boolean>) tableColumnNullableMap.get(key);
    				    List<String> complexColumnlist = (List<String>) complexColumnsMap.get(complexTableName);
    				    String relationKey = complexTableRelationMap.get(complexTableName);
    				    List<String> relationValuelist = (List<String>)complexRelationKeyValueListmap.get(complexTableName+"#"+relationKey);
    				    for(int i =0;i<complexColumnlist.size();i++)
    				    {
    				    	selectComplexCol.append(complexColumnlist.get(i)+",");
    				    }
    				    complexTableQuery.append("SELECT " + selectComplexCol.toString().substring(0, selectComplexCol.length()-1) + " FROM " + complexTableName + " "+ getTableLockHintStr(sourceDBType) +" where "+relationKey+" =? " );
    				    if(tableFilterMap.get(key) != null && !tableFilterMap.get(key).isEmpty())
    				    	complexTableQuery.append(" AND "+tableFilterMap.get(key));
    				    for(int i =0;i<relationValuelist.size();i++)
    				    {
    				    	if(relationValuelist.get(i)!= null && !relationValuelist.get(i).isEmpty())
    				    	{
    				    	List<List<String>> listOfValuelist = new ArrayList<List<String>>(); 
    				    	pstmt = sourceConn.prepareStatement(complexTableQuery.toString());        				    
    				    	try
    				    	{
    				       	pstmt.setString(1, relationValuelist.get(i));
    				    	rs = pstmt.executeQuery();
    				    	}
    				    	catch( Exception e)
    				    	{
    				    		pstmt.setLong(1, Long.parseLong(relationValuelist.get(i)));
    				    		rs = pstmt.executeQuery();
    				    	}
    				    while(rs.next())
    				    {
    				    	 List<String> valuelist = new ArrayList<String>();    	    				    
    				    	for(int j =0;j<complexColumnlist.size();j++)
    					    {
    				    		String finalValue = rs.getString(complexColumnlist.get(j));
    				    		if(finalValue != null && !finalValue.isEmpty()){
    				    			finalValue = TO_SQL(finalValue, columnTypeList.get(j), dbType, true);
    				    		}
    				    		else{
    				    			if(columnNullableList.get(j) ){
    				    				finalValue = " NULL ";
    				    			}
    				    			else{
    				    				WFSUtil.printErr(engine, "Cannot insert null value in the not null column : " + complexColumnlist.get(i), null);
    				    				throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_INSERTING_NULL_IN_NOT_NULL_COLUMN, WFSError.WF_TMP, WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WF_INSERTING_NULL_IN_NOT_NULL_COLUMN));
    				    			}
    				    		}
    				    		
    				    		valuelist.add(finalValue);    
    					    }
    				    	listOfValuelist.add(valuelist);
    				    }
    				    if(rs != null){
    						rs.close();
    						rs = null;
    	                }
    	                if(pstmt != null){
    	                	pstmt.close();
    	                	pstmt = null;
    	                }
    	                 if(listOfValuelist.isEmpty())
    	                {
    	                	finalQuery.append("");
    						WFSUtil.printOut(engine, "Values does not Exist for applied filter on complex table "+complexTableName );
    						WFSUtil.printOut(engine, "Final query for complex table "+complexTableName+" ---->> "+ complexTableQuery);
    												
    	                }
    	                else
    	                {
    				    for(int j =0;j<listOfValuelist.size();j++)
    				    {
    				    	finalQuery.delete(0,  finalQuery.length());
    				    	List<String> valuelist = listOfValuelist.get(j);
    				    	StringBuilder insertCol = new StringBuilder();
        	                StringBuilder insertColValue = new StringBuilder();        	               
    				    	 for(int k =0;k<valuelist.size();k++)
    						    {
    						    	insertCol.append(dxColumnlist.get(k)+",");
    						    	insertColValue.append(valuelist.get(k) + ",");
    						    }
    						    finalQuery.append("INSERT INTO " + key + "(" + insertCol.toString().substring(0, insertCol.length()-1) + ") values (" + insertColValue.toString().substring(0, insertColValue.length()-1) + ")");
    						    finalQueriesList.add(finalQuery.toString());
    	    	          }
    	                }
    				   } 
    				  }  	
    				    tablefinalQueriesListMap.put(key, finalQueriesList);
                  }
		    }
		}
			else
			{
				Set<String> keys = relationExistsMap.keySet(); 
				for (String key : keys) 
				{
					List<String> finalQueriesList = new ArrayList<String>();
					finalQuery.delete(0,  finalQuery.length());
					selectColumns.delete(0,  selectColumns.length());
					String relExist = relationExistsMap.get(key);
					if("Y".equalsIgnoreCase(relExist))
					{
						 List<String> dxColumnlist = (List<String>) tableColumnsMap.get(key);
						 for(int i =0;i<dxColumnlist.size();i++)
						    {
							 selectColumns.append(dxColumnlist.get(i) + ",");
						    }
						 finalQuery.append("SELECT " + selectColumns.toString().substring(0, selectColumns.length()-1) + " FROM " + key +" "+ getTableLockHintStr(sourceDBType));
						finalQuery.append(" where "+filterStringMap.get(key).toString().substring(0, filterStringMap.get(key).length()-4));
						 if(tableFilterMap.get(key) != null && !tableFilterMap.get(key).isEmpty())
							 finalQuery.append(" AND "+tableFilterMap.get(key));
					}
					else
					{
						finalQuery.append("");
						WFSUtil.printOut(engine, "Relation does not exist for Data exchange table "+key+" and exchangeId "+exchangeId );					
					}
					finalQueriesList.add(finalQuery.toString());
					tablefinalQueriesListMap.put(key, finalQueriesList);
				}
			}
			Set<String> tableNames = tablefinalQueriesListMap.keySet();
			for(String tableName : tableNames)
				{
					List<String> queriesList = (List<String>)tablefinalQueriesListMap.get(tableName);
					int rowCount = 0;
				for(int i =0;i<queriesList.size();i++)
						{
							if(queriesList.get(i)!=null && !queriesList.get(i).isEmpty())
									{
								    String query = queriesList.get(i);
									WFSUtil.printOut(engine, "==========================================");
									WFSUtil.printOut(engine, "Final DB Query :: => " + query);
									WFSUtil.printOut(engine, "==========================================");
						
									//Actual execution of the query
									pstmt = targetConn.prepareStatement(query, ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
									if(WFSConstant.IMPORT_OPERATION.equalsIgnoreCase(configTypeStr) /*WFSConstant.RETRIEVE_RULE*/){
										rs = pstmt.executeQuery();
										rs.last();
										result = rs.getRow();
										if(tableName.equalsIgnoreCase(exchangeIdTableMap.get(exchangeId)))
										{
											rowCount = result;
										}
										rs.beforeFirst();
										/*if(result > 1){
											WFSUtil.printErr(engine, "Retrieve Query returned more than one row : " + query + ", No of rows : " + result);
								    		throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_ERROR_QUERY_RETURNED_MORE_THAN_ONE_ROW, WFSError.WF_TMP, 
													WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WF_ERROR_QUERY_RETURNED_MORE_THAN_ONE_ROW));
										}*/
									}
									else{
										result = pstmt.executeUpdate();
										if(tableName.equalsIgnoreCase(exchangeIdTableMap.get(exchangeId)))
										{
										if(deleteQueryExistMap.containsKey(tableName))
										{
											if(i!=0)
											{
												rowCount = rowCount + result;
											}	
										}
										else
										{
											rowCount = rowCount + result;	
										}
										}
									}
									
									if(WFSConstant.IMPORT_OPERATION.equalsIgnoreCase(configTypeStr) /*WFSConstant.RETRIEVE_RULE*/){
										int level = 0;
										Boolean isDeletmarked = false;
										while(rs.next()){
											ResultSetMetaData rsmd = rs.getMetaData();
											WFSUtil.printOut(engine, "No of columns in the retrieve query : " + rsmd.getColumnCount());
											String dxTableName = rsmd.getTableName( rsmd.getColumnCount());
											if(dxTableName == null || "".equalsIgnoreCase(dxTableName) || dxTableName.isEmpty())
											{
												String tempTableName = query.toLowerCase();
												tempTableName = tempTableName.substring(tempTableName.indexOf("from")+4);
												tempTableName = tempTableName.substring(0, tempTableName.indexOf("where"));
												dxTableName = tempTableName.trim();												
											}
											WFSUtil.printOut(engine, "Importing Data from DX table " + dxTableName);
											Set<String> keys = tableMappedFieldMap.keySet(); 
											for (String key : keys) 
											{
												if(dxTableName.equalsIgnoreCase(key))
												{
													dxParentChildMap.get(key);
													List<String> childmapperList = new ArrayList<String>();
													List<String> childMapperColumnlist = (List<String>)dxTableChildMapper .get(key);
													String childMapperColumnValue = null;
													String childMapperKey = new String();
													if(childMapperColumnlist!=null && !childMapperColumnlist.isEmpty())
													{
													for(int k =0;k<childMapperColumnlist.size();k++)
							    				    {
														String childMapperColumn = childMapperColumnlist.get(k);
													if(childMapperColumn!= null && !childMapperColumn.isEmpty())
													{
														childMapperColumnValue = rs.getString(childMapperColumn);	
														childMapperKey = key+"#"+childMapperColumn+"#"+childMapperColumnValue;
														childmapperList.add(childMapperKey);
													}
							    				    }
													}
													String parentMapperColumn = dxTableParentMapper.get(key);
													String parentMapperColumnValue = null;
													String parentMapperKey = null;
													if(parentMapperColumn!= null && !parentMapperColumn.isEmpty())
													{
														parentMapperColumnValue = rs.getString(parentMapperColumn);
														 parentMapperKey = key+"#"+parentMapperColumn+"#"+parentMapperColumnValue;	
													}
													else
													{
														rootTableMap.put(key,"Y");
													}
													
													 List<String> mappedColmKeyList = (List<String>) tableMappedFieldMap.get(key);
													 List<String> mappedColmKeyListTemp = new ArrayList<String>(mappedColmKeyList);
														for(int fieldInx = 1; fieldInx <= rsmd.getColumnCount(); fieldInx++){
															String columnName = rsmd.getColumnName(fieldInx);							
															String columnValue = rs.getString(fieldInx);
															if(!mappedColmKeyListTemp.isEmpty())
															{
															String mappedColmKey = mappedColmKeyListTemp.get(0);
															workitem.updateVarValueforcomplex(mappedColmKey, columnValue, engine,level,tableAttributeMap,key,childMapperKey,parentMapperKey,parentAttributeMap,childAttributeMap,parentChildMapperKeyMap,updateIfExist,isArrayCase,isDeletmarked);
															isDeletmarked = true;
															mappedColmKeyListTemp.remove(0);
															}
														}
														if(childmapperList!=null && !childmapperList.isEmpty() && childmapperList.size()>1)
														{
															for(int j =0;j<childmapperList.size();j++)
									    				    {
																if(parentAttributeMap.get(childmapperList.get(j))== null)
																	parentAttributeMap.put(childmapperList.get(j), parentAttributeMap.get(childMapperKey));
																
												}
												
											}
												}
												
											}
											level++;						
										}
									}
								}
						}
					if(tableName.equalsIgnoreCase(exchangeIdTableMap.get(exchangeId)))
					{
						if(!selectColsList.isEmpty()){
							String mappedColmKey = selectColsList.get(0);
							if(mappedColmKey != null && !mappedColmKey.isEmpty()){
								workitem.updateVarValue(mappedColmKey, rowCount+"", engine,0);
							}
						}
						exchangeIdRowCountMap.put(exchangeId, rowCount);
					}
					
				}
			if(WFSConstant.IMPORT_OPERATION.equalsIgnoreCase(configTypeStr) /*WFSConstant.RETRIEVE_RULE*/){
				Set<String> keys = dxTableChildMapper.keySet();
				HashMap<String,String> AttrchangedMap =  new HashMap<String,String>();
				
				for (String key : keys) 
				{
					
					workitem.parentChildMapping(key,dxTableChildMapper,parentAttributeMap,childAttributeMap,dxRelationKeyValueListMap,dxParentChildMap,parentChildMapperKeyMap,AttrchangedMap,rootTableMap,rootAttrib);
				}
			}
		}
		return;
	}
	
	private static String getComplexName(WFMappedColumn mappedColumn, Connection sourceConn, int processDefId,
			HashMap<String, String> varfieldComplexTableMap, int sourceDBType) throws SQLException {
		int variableId= mappedColumn.getVariableId();
		int variableFieldId= mappedColumn.getVarFieldId();
		String complexTableName = null;
		PreparedStatement ipstmt = null;
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		ResultSet res = null;
		int relationId = 0;
		String iquery = "Select ParentVarFieldId FROM WFUDTVarMappingTable "+getTableLockHintStr(sourceDBType)+" WHERE ProcessDefId = ? AND VariableId = ? AND VarFieldId = ?";
		ipstmt = sourceConn.prepareStatement(iquery);
		ipstmt.setInt(1, processDefId);
		ipstmt.setInt(2, variableId);	
		ipstmt.setInt(3, variableFieldId);
		res = ipstmt.executeQuery();
		if(res.next())
		{
			int ParentVarFieldId = res.getInt("ParentVarFieldId");
			if(varfieldComplexTableMap.containsKey(variableId+"#"+ParentVarFieldId+"#getComplexname"))
				 complexTableName = varfieldComplexTableMap.get(variableId+"#"+ParentVarFieldId+"#getComplexname");
			else
			{
				String query = "Select MappedObjectName FROM WFUDTVarMappingTable "+getTableLockHintStr(sourceDBType)+" WHERE ProcessDefId = ? AND VariableId = ? AND VarFieldId = ? ";
			    pstmt = sourceConn.prepareStatement(query);
				pstmt.setInt(1, processDefId);
				pstmt.setInt(2, variableId);	
				pstmt.setInt(3, ParentVarFieldId);
				rs = pstmt.executeQuery();
				if(rs.next())
				{
					complexTableName = rs.getString("MappedObjectName");
					varfieldComplexTableMap.put(variableId+"#"+ParentVarFieldId+"#getComplexname", complexTableName);
				}
				else
				{
					//throw error
				}
				try {

	                if (rs != null) {
	                	rs.close();
	                	rs = null;
	                }
	            } catch (Exception e) {
	            }
				try {

	                if (pstmt != null) {
	                	pstmt.close();
	                	pstmt = null;
	                }
	            } catch (Exception e) {
	            }
			}
		}
		try {

            if (res != null) {
            	res.close();
            	res = null;
            }
        } catch (Exception e) {
        }
		try {

            if (ipstmt != null) {
            	ipstmt.close();
            	ipstmt = null;
            }
        } catch (Exception e) {
        }
		
		return complexTableName;
	}

	private static WFAttribute getRootAttribute(WFAttribute attrib)
	{
		if(attrib.isRoot)
		{
			return attrib;
		}
		else
		{
			return getRootAttribute(attrib.parentAttribute);
		}
		
	}

	private static boolean isarray(WFAttribute attrib) 
	{
		if(attrib.isRoot)
		{
			if(attrib.isArray())
			{
				return true;
			}
			else
				return false;
			
		}
		else
		{
		if(attrib.isArray())
		{
			return true;
		}
		else
			return isarray(attrib.getParentAttribute());
		}
	}

	private static List<String> getRelationColumnValueForComplexArrayImport(WFMappedColumn mappedColumn, String engine,
			Connection sourceConn, int dbType, HashMap<String, String> complexTableRelationMap, Map<String, List<String>> complexRelationKeyValueListmap, Connection targetConn, HashMap<String, String> dxParentChildMap, MultiValueMap dxTableChildMapper, HashMap<String, String> dxTableParentMapper, int sourceDBType, int activityId, HashMap<String, String> tableFilterMap, int processDefId) throws SQLException, WFSException
	{
		String finalValue ="";
		List<String> finalValueList = new ArrayList<String>();
		List<String> valueList = new ArrayList<String>();
		int expressionDataType = mappedColumn.getDbColumnDatatype();
				
		valueList = getRelationValueImport(sourceConn,targetConn,mappedColumn.getComplexTableName(), mappedColumn.getRelationColumnName(),mappedColumn.getEntityName(),mappedColumn.getEntityColumnName(),complexTableRelationMap,complexRelationKeyValueListmap,dxParentChildMap,dxTableChildMapper,dxTableParentMapper,sourceDBType,dbType,activityId,mappedColumn.getExchangeId(),tableFilterMap,processDefId);
		WFSUtil.printOut(engine, "WFSUtil.getRelationColumnValue :: final Relation valueList for table "+ mappedColumn.getEntityName() +" column "+mappedColumn.getEntityColumnName()+" : " + valueList);
		if(valueList.isEmpty())
		{
			finalValueList.add("null")	;
		}
		else
		{
		for(int i =0;i<valueList.size();i++)
		{
		if(valueList.get(i) != null && !valueList.get(i).isEmpty()){
			finalValue = TO_SQL(valueList.get(i), expressionDataType, dbType, true);
		}
		else{
			finalValue = "null";
			WFSUtil.printOut(engine, "WFSUtil.getRelationColumnValue :: Inserting NULL in relation column "+ mappedColumn.getEntityColumnName()+" in Table "+mappedColumn.getEntityName());
			}
		finalValueList.add(finalValue);
		}
		}
		return finalValueList;
		
	}

	private static List<String> getRelationValueImport(Connection sourceConn, Connection targetConn, String complexTableName, String complexColumnName,
			String entityName, String entityColumnName, HashMap<String, String> complexTableRelationMap,
			Map<String, List<String>> complexRelationKeyValueListmap, HashMap<String, String> dxParentChildMap, MultiValueMap dxTableChildMapper, HashMap<String, String> dxTableParentMapper, int sourceDBType, int dbType, int activityId, int exchangeId, HashMap<String, String> tableFilterMap, int processDefId) throws SQLException 
	{
		List<String> valueList = new ArrayList<String>();
		String query = null;
		PreparedStatement pstmt = null;
	    ResultSet rs = null;	
	    query = "Select EntityColumnName,ComplexTableName,RelationColumnName,ColumnType from WFDETableRelationdetails "+ getTableLockHintStr(sourceDBType) +" where EntityName = ? AND RelationType =? AND ActivityId =? AND ExchangeId = ? AND ProcessDefId =?";
		pstmt = sourceConn.prepareStatement(query);
		pstmt.setString(1, entityName);
		pstmt.setString(2, "D");
		pstmt.setInt(3, activityId);
		pstmt.setInt(4, exchangeId);
		pstmt.setInt(5, processDefId);
		rs = pstmt.executeQuery();
		String iquery = null;
		PreparedStatement ipstmt = null;
	    ResultSet irs = null;
	    PreparedStatement rpstmt = null;
	    ResultSet res = null;
		
		if(rs.next())
		{
			if(!dxParentChildMap.containsKey(rs.getString("ComplexTableName")+"#"+rs.getString("RelationColumnName")))
			{
				dxParentChildMap.put(rs.getString("ComplexTableName")+"#"+rs.getString("RelationColumnName"), entityName+"#"+rs.getString("EntityColumnName"));
				dxTableChildMapper.put(rs.getString("ComplexTableName"),rs.getString("RelationColumnName"));
				dxTableParentMapper.put(entityName,rs.getString("EntityColumnName"));
			}
			
			if((entityColumnName).equalsIgnoreCase(rs.getString("EntityColumnName")))
            {
				iquery = "Select ComplexTableName,RelationColumnName from WFDETableRelationdetails "+ getTableLockHintStr(sourceDBType) +" where EntityName = ? AND EntityColumnName = ?  AND RelationType =? AND ActivityId =? AND ExchangeId = ? AND ProcessDefId =?";
				ipstmt = sourceConn.prepareStatement(iquery);
				ipstmt.setString(1,rs.getString("ComplexTableName"));
				ipstmt.setString(2,rs.getString("RelationColumnName"));
				ipstmt.setString(3,"P");
				ipstmt.setInt(4, activityId);
				ipstmt.setInt(5, exchangeId);
				ipstmt.setInt(6, processDefId);
				irs = ipstmt.executeQuery();
				if(irs.next())
				{
					valueList = getRelationValueImport(sourceConn,targetConn,irs.getString("ComplexTableName"),irs.getString("RelationColumnName"),rs.getString("ComplexTableName"),rs.getString("RelationColumnName"),complexTableRelationMap,complexRelationKeyValueListmap,dxParentChildMap,dxTableChildMapper,dxTableParentMapper,sourceDBType,dbType,activityId,exchangeId,tableFilterMap,processDefId); 
				}
            }
			else
			{
				List<String> refKeyValueList = new ArrayList<String>();
				iquery = "Select "+TO_SANITIZE_STRING(entityColumnName,true)+" from "+TO_SANITIZE_STRING(entityName,true)+" "+ getTableLockHintStr(dbType) +" where "+TO_SANITIZE_STRING(rs.getString("EntityColumnName"),true) +" = ?";
				if(tableFilterMap.containsKey(entityName))
				{
					iquery = iquery + " AND "+tableFilterMap.get(entityName);
				}
				String str = "Select ComplexTableName,RelationColumnName from WFDETableRelationdetails "+ getTableLockHintStr(sourceDBType) +" where EntityName = ? AND EntityColumnName = ?  AND RelationType =? AND ActivityId =? AND ExchangeId = ? AND ProcessDefId =?";
				rpstmt = sourceConn.prepareStatement(str);
				rpstmt.setString(1,entityName);
				rpstmt.setString(2,rs.getString("EntityColumnName"));
				rpstmt.setString(3,"P");
				rpstmt.setInt(4, activityId);
				rpstmt.setInt(5, exchangeId);
				rpstmt.setInt(6, processDefId);
				res = rpstmt.executeQuery();
				if(res.next())
				{
					refKeyValueList = getRelationValueImport(sourceConn,targetConn,res.getString("ComplexTableName"),res.getString("RelationColumnName"),entityName,rs.getString("EntityColumnName"),complexTableRelationMap,complexRelationKeyValueListmap,dxParentChildMap,dxTableChildMapper,dxTableParentMapper,sourceDBType,dbType,activityId,exchangeId,tableFilterMap,processDefId); 
				}
				try {

	                if (res != null) {
	                	res.close();
	                	res = null;
	                }
	            } catch (Exception e) {
	            }
				try {

	                if (rpstmt != null) {
	                	rpstmt.close();
	                	rpstmt = null;
	                }
	            } catch (Exception e) {
	            }
				for(int i =0;i<refKeyValueList.size();i++)
				{
					if(refKeyValueList.get(i)!=null && !("null".equalsIgnoreCase(refKeyValueList.get(i))))
					{
					ipstmt = targetConn.prepareStatement(iquery);
					if("10".equalsIgnoreCase(rs.getString("ColumnType")))
					{
					ipstmt.setString(1, refKeyValueList.get(i));
					}
					else
					{
						ipstmt.setLong(1, Long.parseLong(refKeyValueList.get(i)));
					}
						irs = ipstmt.executeQuery();
					while(irs.next())
					{
						valueList.add(irs.getString(entityColumnName));
					}
					}
				}
			}
			try {

                if (irs != null) {
                	irs.close();
                	irs = null;
                }
            } catch (Exception e) {
            }
			try {

                if (ipstmt != null) {
                	ipstmt.close();
                	ipstmt = null;
                }
            } catch (Exception e) {
            }
			
		}
		else
		{
			if(complexRelationKeyValueListmap.containsKey(complexTableName+"#"+complexColumnName))
			{
				complexTableRelationMap.put(entityName, entityColumnName);
				complexRelationKeyValueListmap.put(entityName+"#"+entityColumnName,complexRelationKeyValueListmap.get(complexTableName+"#"+complexColumnName));
				valueList = complexRelationKeyValueListmap.get(complexTableName+"#"+complexColumnName);
			}
			else
			{
				String str = "Select EntityColumnName,ColumnType from WFDETableRelationdetails "+ getTableLockHintStr(sourceDBType) +" where EntityName = ? and ComplexTableName = ? and RelationColumnName = ? AND ActivityId =? AND ExchangeId = ? AND ProcessDefId =?";
				ipstmt = sourceConn.prepareStatement(str);
				ipstmt.setString(1,entityName);
				ipstmt.setString(2,complexTableName);
				ipstmt.setString(3,complexTableRelationMap.get(complexTableName));
				ipstmt.setInt(4, activityId);
				ipstmt.setInt(5, exchangeId);
				ipstmt.setInt(6, processDefId);
				irs = ipstmt.executeQuery();
				if(irs.next())
				{
					iquery = "Select "+TO_SANITIZE_STRING(entityColumnName,true)+" from "+TO_SANITIZE_STRING(entityName,true)+" "+ getTableLockHintStr(dbType) +" where "+TO_SANITIZE_STRING(irs.getString("EntityColumnName"),true)+" = ?";
					if(tableFilterMap.containsKey(entityName))
					{
						iquery = iquery + " AND "+tableFilterMap.get(entityName);
					}
					List<String> refKeyValueList = getRelationValueImport(sourceConn,targetConn,complexTableName,complexTableRelationMap.get(complexTableName),entityName,irs.getString("EntityColumnName"),complexTableRelationMap,complexRelationKeyValueListmap,dxParentChildMap,dxTableChildMapper,dxTableParentMapper,sourceDBType,dbType,activityId,exchangeId,tableFilterMap,processDefId); 
					for(int i =0;i<refKeyValueList.size();i++)
					{
						 rpstmt = targetConn.prepareStatement(iquery);
						 if("10".equalsIgnoreCase(irs.getString("ColumnType")))
						 {
						rpstmt.setString(1, refKeyValueList.get(i));
						 } 
						else
							{
							rpstmt.setLong(1, Long.parseLong(refKeyValueList.get(i)));
							}
						 res = rpstmt.executeQuery();
						while(res.next())
						{
							valueList.add(res.getString(entityColumnName));
						}
					}
					complexRelationKeyValueListmap.put(entityName+"#"+entityColumnName, valueList);
					if(res != null){
						res.close();
						res = null;
	                }
	                if(rpstmt != null){
	                	rpstmt.close();
	                	rpstmt = null;
	                }
					
				}
				if(irs != null){
					irs.close();
					irs = null;
                }
                if(ipstmt != null){
                	ipstmt.close();
                	ipstmt = null;
                }
			}
			
		}
		try {

            if (rs != null) {
            	rs.close();
            	rs = null;
            }
        } catch (Exception e) {
        }
		try {

            if (pstmt != null) {
            	pstmt.close();
            	pstmt = null;
            }
        } catch (Exception e) {
        }
		
		return valueList;
	}

	private static  void getComplexInfo(WFMappedColumn mappedColumn, Connection sourceConn, int processdefid,
			HashMap<String, String> varfieldComplexTableMap, HashMap<String, String> dxTableComplexTableMap,
			MultiValueMap complexColumnsMap, HashMap<String, String> complexTableRelationMap, String engine, String processInstanceId, int workitemId, int dbType, Map<String, List<String>> complexRelationKeyValueListmap, int sourceDBType, HashMap<String, String> tableFilterMap) throws Exception
	{
		int variableId= mappedColumn.getVariableId();
		int variableFieldId= mappedColumn.getVarFieldId();
		String complexTableName = null;
		PreparedStatement ipstmt = null;
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		ResultSet res = null;
		int relationId = 0;
		String iquery = "Select MappedObjectName,ParentVarFieldId FROM WFUDTVarMappingTable "+getTableLockHintStr(sourceDBType)+" WHERE ProcessDefId = ? AND VariableId = ? AND VarFieldId = ?";
		ipstmt = sourceConn.prepareStatement(iquery);
		ipstmt.setInt(1, processdefid);
		ipstmt.setInt(2, variableId);	
		ipstmt.setInt(3, variableFieldId);
		res = ipstmt.executeQuery();
		if(res.next())
		{
			String MappedObjectName = res.getString("MappedObjectName");
			int ParentVarFieldId = res.getInt("ParentVarFieldId");
			if(varfieldComplexTableMap.containsKey(variableId+"#"+ParentVarFieldId))
				 complexTableName = varfieldComplexTableMap.get(variableId+"#"+ParentVarFieldId);
			else
			{
				String query = "Select MappedObjectName,RelationId FROM WFUDTVarMappingTable "+getTableLockHintStr(sourceDBType)+" WHERE ProcessDefId = ? AND VariableId = ? AND VarFieldId = ? ";
			    pstmt = sourceConn.prepareStatement(query);
				pstmt.setInt(1, processdefid);
				pstmt.setInt(2, variableId);	
				pstmt.setInt(3, ParentVarFieldId);
				rs = pstmt.executeQuery();
				if(rs.next())
				{
					relationId = rs.getInt("RelationId");
					complexTableName = rs.getString("MappedObjectName");
					varfieldComplexTableMap.put(variableId+"#"+ParentVarFieldId, complexTableName);
				}
				else
				{
					//throw error
				}
				try {

	                if (rs != null) {
	                	rs.close();
	                	rs = null;
	                }
	            } catch (Exception e) {
	            }
				try {

	                if (pstmt != null) {
	                	pstmt.close();
	                	pstmt = null;
	                }
	            } catch (Exception e) {
	            }
			}
			dxTableComplexTableMap.put(mappedColumn.getTableName(), complexTableName);
			complexColumnsMap.put(complexTableName, MappedObjectName);
			if(!complexTableRelationMap.containsKey(complexTableName))
			{
				String query = "Select ParentObject,ForeignKey,ChildObject,RefKey FROM WFVarRelationTable "+getTableLockHintStr(sourceDBType)+" WHERE ProcessDefId = ? AND RelationId = ? ";
				pstmt = sourceConn.prepareStatement(query);
				pstmt.setInt(1, processdefid);
				pstmt.setInt(2, relationId);
				rs = pstmt.executeQuery();
				if(rs.next())
				{
					 String parentObject = TO_SANITIZE_STRING(rs.getString("ParentObject"),true);
					 String foreignKey = TO_SANITIZE_STRING(rs.getString("ForeignKey"),true);
					 String childObject = TO_SANITIZE_STRING(rs.getString("ChildObject"),true);
					 String refKey = TO_SANITIZE_STRING(rs.getString("RefKey"),true);
					 List<String> refKeyValueList = getComplexRelationvalue(sourceConn,parentObject,foreignKey,childObject,refKey,engine,processInstanceId,workitemId,dbType,sourceDBType,tableFilterMap);
					 complexTableRelationMap.put(complexTableName,refKey );
					 complexRelationKeyValueListmap.put(complexTableName+"#"+refKey, refKeyValueList);
				}
				
				try {

	                if (rs != null) {
	                	rs.close();
	                	rs = null;
	                }
	            } catch (Exception e) {
	            }
				try {

	                if (pstmt != null) {
	                	pstmt.close();
	                	pstmt = null;
	                }
	            } catch (Exception e) {
	            }
			}
		}
		else
		{
			//throws error check variable id and varfieldid
		}
		
		try {

            if (res != null) {
            	res.close();
            	res = null;
            }
        } catch (Exception e) {
        }
		try {

            if (ipstmt != null) {
            	ipstmt.close();
            	ipstmt = null;
            }
        } catch (Exception e) {
        }
		
		
		return ;
	}

	private static List<String> getComplexRelationvalue(Connection sourceConn, String parentObject, String foreignKey, String childObject,
			String refKey, String engine, String processInstanceId, int workitemId, int dbType, int sourceDBType, HashMap<String, String> tableFilterMap) throws SQLException 
	{
		PreparedStatement ipstmt = null;
		PreparedStatement pstmt = null;
		List<String> valueList = new ArrayList<String>();
		String value = "";
		ResultSet rs = null;
		ResultSet res = null;
		String query = "Select ParentObject,ForeignKey,RefKey FROM WFVarRelationTable "+getTableLockHintStr(sourceDBType)+" WHERE ChildObject =?";
		try
		{
		pstmt = sourceConn.prepareStatement(query);
		pstmt.setString(1,parentObject );
		rs = pstmt.executeQuery();
		if(rs.next())
		{
			String refKey1 = rs.getString("RefKey");
			String parentObject1 = TO_SANITIZE_STRING(rs.getString("ParentObject"),true);
			String foreignKey1 = rs.getString("ForeignKey");
			String childObject1 = parentObject;
			String iquery = "Select "+TO_SANITIZE_STRING(foreignKey,true)+" FROM "+TO_SANITIZE_STRING(parentObject,true)+" "+getTableLockHintStr(sourceDBType)+" where "+TO_SANITIZE_STRING(refKey1,true)+" = ?";
			if(tableFilterMap.containsKey(parentObject))
			{
				iquery = iquery + " AND "+tableFilterMap.get(parentObject);
			}
			List<String> innerValueList = new ArrayList<String>();
			innerValueList = getComplexRelationvalue(sourceConn,parentObject1,foreignKey1,childObject1,refKey1,engine,processInstanceId,workitemId,dbType, sourceDBType,tableFilterMap) ;
			for(int i= 0;i<innerValueList.size();i++)
			{
				if(innerValueList.get(i)!= null && !innerValueList.get(i).isEmpty())
				{
					ipstmt = sourceConn.prepareStatement(iquery);
					try{
					ipstmt.setString(1,innerValueList.get(i));
					res = ipstmt.executeQuery();
					}
					catch( Exception e)
					{
						ipstmt.setLong(1,Long.parseLong(innerValueList.get(i)));
						res = ipstmt.executeQuery();
					}
				    while(res.next())
					{
						value = res.getString(foreignKey);
						valueList.add(value);
					}
				    try {

		                if (res != null) {
		                	res.close();
		                	res = null;
		                }
		            } catch (Exception e) {
		            }
					try {

		                if (ipstmt != null) {
		                	ipstmt.close();
		                	ipstmt = null;
		                }
		            } catch (Exception e) {
		            }
			    }
			}
         }
		else
		{ 
			
			String itemindex = null;
			String itemtype = null;
			String tableName = parentObject;
            String columnName = foreignKey;
			if("WFINSTRUMENTTABLE".equalsIgnoreCase(tableName) && "processInstanceId".equalsIgnoreCase(columnName))
			{
				value = processInstanceId;
				valueList.add(value);
			 }
			else 
			{ 
				if("WFINSTRUMENTTABLE".equalsIgnoreCase(tableName)) 
				{	
					query = "Select "+TO_SANITIZE_STRING(columnName,true)+" from "+TO_SANITIZE_STRING(tableName,true)+" "+getTableLockHintStr(sourceDBType)+" where processInstanceId = ? AND workitemId = ?";
				}
				else
				{
					String wfsQuery = "Select Var_Rec_1,Var_Rec_2 from WFINSTRUMENTTABLE "+getTableLockHintStr(sourceDBType)+" where processInstanceId = ? AND workitemId = ?";
					try {
						ipstmt = sourceConn.prepareStatement(wfsQuery);
						ipstmt.setString(1, processInstanceId);
						ipstmt.setInt(2, workitemId);
						res = ipstmt.executeQuery();
						if(res.next())
						{
							itemindex = res.getString("Var_Rec_1");
							itemtype = res.getString("Var_Rec_2");
						}
						if(res != null){
							res.close();
							res = null;
                        }
                        if(ipstmt != null){
                        	ipstmt.close();
                        	ipstmt = null;
                        }
						} 
					catch (SQLException e) 
					       {
							WFSUtil.printErr(engine, "", e);
							}
					query = "Select "+TO_SANITIZE_STRING(columnName,true)+" from "+TO_SANITIZE_STRING(tableName,true)+" "+getTableLockHintStr(sourceDBType)+" where itemindex = ? AND itemtype = ?";
					ipstmt = sourceConn.prepareStatement(query);
					ipstmt.setString(1, itemindex);
					ipstmt.setString(2, itemtype);					
				}
				try 
				{
					if(ipstmt == null)
					{
						ipstmt = sourceConn.prepareStatement(query);
						ipstmt.setString(1, processInstanceId);
						ipstmt.setInt(2, workitemId);
					}
					res = ipstmt.executeQuery();
					if(res.next())
					{
						value = res.getString(columnName);
						valueList.add(value);
					}
					if(res != null){
						res.close();
						res = null;
                    }
                    if(ipstmt != null){
                    	ipstmt.close();
                    	ipstmt = null;
                    }
				} 
				catch (SQLException e) 
				{
					WFSUtil.printErr(engine, "", e);
				}
				
			}
		}
		try {

            if (rs != null) {
            	rs.close();
            	rs = null;
            }
        } catch (Exception e) {
        }
		try {

            if (pstmt != null) {
            	pstmt.close();
            	pstmt = null;
            }
        } catch (Exception e) {
        }
		
		}
		catch (Exception e) 
		{
			WFSUtil.printErr(engine, "", e);
		}
		return valueList;
	}

	/**
	 * Method Name : getColumnValue
	 * @param mappedColumn
	 * @param workitem
	 * @param engine
	 * @param dbType
	 * @return
	 * @throws Exception
	 */
	/**
	 * variable details :
	 * 
	 * varType : variable type (S/M/U/I) of operand1
	 * type : variable data type(3/6/8/10) of operand1
	 * 
	 * varType1 : variable type (S/M/U/I) of operand2
	 * type1 : variable data type(3/6/8/10) of operand2
	 * 
	 * finalValue : final value of the expression (if its expression type) OR variable (if its variable).
	 * 
	 * DBColumnType : Data Type of the expresssion (DB Column)
	 * 
	 */
	private static String getColumnValue(WFMappedColumn mappedColumn, WFWorkitem workitem, String engine, int dbType) throws Exception {
		String varType = mappedColumn.getVariableType();
		String varName = mappedColumn.getVariableName();
		boolean isNullable = mappedColumn.isNullable();
		String varValue = "";
		int type = 0;
		String finalValue = "";
		int expressionDataType = mappedColumn.getDbColumnDatatype();
		
		if("U".equalsIgnoreCase(varType) || "I".equalsIgnoreCase(varType)){
			if(workitem.isRPACall()){
				varValue = workitem.getMappedColumnsList().get(varName.toUpperCase()).getVariableValue();
				type = workitem.getMappedColumnsList().get(varName.toUpperCase()).getVarDataType();
			}
			else{
				varValue = workitem.getVarIdAttributeMap().get(mappedColumn.getVariableId() + "#" + mappedColumn.getVarFieldId()).getValue();
				type = workitem.getVarIdAttributeMap().get(mappedColumn.getVariableId() + "#" + mappedColumn.getVarFieldId()).getType();
			}
		}
		else if("C".equalsIgnoreCase(varType)){
			varValue = varName;
			type = mappedColumn.getVarDataType();
		}
		
		WFSUtil.printOut(engine, "WFSUtil.getColumnValue :: VarName : " + varName + ", VarType : " + varType + ", isNullable : " + isNullable + ", varValue : " + varValue);

		//Calculate the second part of the expression, if its of update type rule and set operation contains valid operator.
		/*if(mappedColumn.getRuleTypeId() == WFSConstant.UPDATE_RULE && mappedColumn.isValidExpressionOperator()){
			WFSUtil.printOut(engine, "WFSUtil.getColumnValue :: Expressions found in update operation..calculating the second operand value.");
			String varType1 = mappedColumn.getVariableType1();
			String varName1 = mappedColumn.getVariableName1();
			int operator = mappedColumn.getOperator();
			String varValue1 = "";
			int type1 = 0;
			
			if("U".equalsIgnoreCase(varType1) || "I".equalsIgnoreCase(varType1)){
				if(workitem.isRPACall()){
					varValue1 = workitem.getMappedColumnsList().get(varName1.toUpperCase()).getVariableValue();
					type1 = workitem.getMappedColumnsList().get(varName1.toUpperCase()).getVarDataType();
				}
				else{
					varValue1 = workitem.getVarIdAttributeMap().get(mappedColumn.getVariableId1() + "#" + mappedColumn.getVarFieldId1()).getValue();
					type1 = workitem.getVarIdAttributeMap().get(mappedColumn.getVariableId1() + "#" + mappedColumn.getVarFieldId1()).getType();
				}
			}
			else if("C".equalsIgnoreCase(varType1)){
				varValue1 = varName1;
				type1 = mappedColumn.getVarDataType1();
			}
			
			//Till this point we have both the operand values into varValue and varValue1. Now evaluate the final expression.
			WFSUtil.printOut(engine, "WFSUtil.getColumnValue :: Checking if the Variable types are compatible with the given operator :: type : " + type + ", type1 : " + type1 + ", operator : " + operator);
			if(WFMappedColumn.areExpressionCompatibleTypes(type, type1, operator)){
				try{
					finalValue = Utility.evaluateExpression(expressionDataType, operator, varValue, type, varValue1, type1);
					WFSUtil.printOut(engine, "WFSUtil.getColumnValue :: VarName1 : " + varName1 + ", VarType1 : " + varType1 + ", isNullable : " + isNullable + ", varValue1 : " + varValue1);
				}catch(AppException ex){
					WFSUtil.printErr(engine, "Error occurred while evaluating the set expression for ruleID : " + mappedColumn.getRuleId(), ex);
					int errCode = ex.getErrorCode();
					String errMsg = ex.getErrorMessage();
					throw new WFSException(WFSError.WF_INVALID_INPUT_DX, errCode, WFSError.WF_TMP, errMsg, WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX));
				}catch(Exception ex){
					WFSUtil.printErr(engine, "Error occurred while evaluating the set expression for ruleID : " + mappedColumn.getRuleId(), ex);
					throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_ERROR_EVALUATING_EXPRESSION, WFSError.WF_TMP, WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WF_ERROR_EVALUATING_EXPRESSION));
				}
			}
			else{
				WFSUtil.printErr(engine, "WFSUtil.getColumnValue :: Operation type is not compatible with the given Variable types");
				throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WM_INVALID_OPERATION_TYPE, WFSError.WF_TMP, WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WM_INVALID_OPERATION_TYPE));
			}
		}
		else{
			finalValue = varValue;
		}*/
		finalValue = varValue;
		WFSUtil.printOut(engine, "WFSUtil.getColumnValue :: final expression value: " + finalValue);
		
		if(finalValue != null && !finalValue.isEmpty()){
			finalValue = TO_SQL(finalValue, expressionDataType, dbType, true);
		}
		else{
			if( isNullable ){
				finalValue = " NULL ";
			}
			else{
				WFSUtil.printErr(engine, "Cannot insert null value in the not null column : " + varName, null);
				throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_INSERTING_NULL_IN_NOT_NULL_COLUMN, WFSError.WF_TMP, WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WF_INSERTING_NULL_IN_NOT_NULL_COLUMN));
			}
		}
		
		return finalValue;
	}
	
	private static void populateSelectedColsList(List<String> selectColsList, WFDBOperation dbOperation, boolean isRPACall, String engine) {
		//Populate the query output mapped column (it can be mapped for any type of query)
		WFMappedColumn queryOutputColumn = dbOperation.getQueryOutputColumn();
		String mappedKey = "";
		if(queryOutputColumn != null){
			if(isRPACall){
				if(queryOutputColumn.getVariableName() != null &&  !queryOutputColumn.getVariableName().isEmpty() 
						&& "U".equalsIgnoreCase(queryOutputColumn.getVariableType())){
					mappedKey = queryOutputColumn.getVariableName().toUpperCase();
				}
			}
			else{
				if( queryOutputColumn.getVariableId() != 0 &&  "U".equalsIgnoreCase(queryOutputColumn.getVariableType()) ){
					mappedKey = queryOutputColumn.getVariableId() + "#" + queryOutputColumn.getVarFieldId();
				}
			}
			if(mappedKey != null && !mappedKey.isEmpty()){
				selectColsList.add(mappedKey);
				WFSUtil.printOut(engine, "WFSUtil.populateSelectedColsList :: adding column to update with the query return count : " + mappedKey + ", RPA Flag " + isRPACall);
			}
		}
	}

	private static void evaluateIfRuleGroup(int prev_indent, Stack<WFRule> mainStack, Stack<WFRule> conditionStack, WFWorkitem workitem, String engine) throws Exception {
		//IF Result is already evaluated in the main stack and result of previous evaluation is present at the top
		if(!mainStack.isEmpty() && mainStack.peek().getIndentLevel() == prev_indent && mainStack.peek().getRuleTypeId() == WFSConstant.RESULT_RULE){
			return;
		}
		
		//Otherwise Result is not evaluated. Evaluate it and keep it at the top with same level of indentation.
		//AND with TRUE will always return the same value (TRUE AND true = true, TRUE AND false = false)
		boolean result = true;
		
		//Copying the conditions from main stack into condition stack in order of input for the evaluation
		while(true){
			if(!mainStack.isEmpty() && mainStack.peek().getIndentLevel() == prev_indent && mainStack.peek().getRuleTypeId() == WFSConstant.IF_RULE){
				conditionStack.push(mainStack.pop());
			}else{
				break;
			}
		}

		WFSUtil.printOut(engine, "WFSUtil.evaluateIfRuleGroup:: No Of Open IF Rules in Main Stack : " + mainStack.size());
		WFSUtil.printOut(engine, "WFSUtil.evaluateIfRuleGroup:: No of Conditions in the Rule : " + conditionStack.size());
		
		//New logic to eveluate multiple conditions.
		StringBuilder rulesOutput = new StringBuilder();
		while(true){
			if(conditionStack.isEmpty()){
				break;
			}
			WFRule cRule = conditionStack.pop();
			boolean indivResult = cRule.evaluateConditionRule(workitem, engine);
			int logicalOp = cRule.getLogicalOp();
			
			if(indivResult){
				rulesOutput.append("T");
			}
			else{
				rulesOutput.append("F");
			}
			
			switch(logicalOp){
			case WFSConstant.WF_OPERATOR_AND :
				rulesOutput.append(" AND ");
				break;
			case WFSConstant.WF_OPERATOR_OR :
				rulesOutput.append(" OR ");
				break;
			case WFSConstant.WF_OPERATOR_EOE :
				break;
			default:
				WFSUtil.printErr(engine, "WFSUtil.evaluateIfRuleGroup:: Invalid Logical Operator", null);
	    		throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_INVALID_RULE, WFSError.WF_TMP, 
						WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX), WFSErrorMsg.getMessage(WFSError.WF_INVALID_RULE));
			}
		}
		
		//This method evaluates the complete output expression based on the 
		//operator precedence of OR & AND Operators instead of left to right evaluation
		result = evaluateExpression(rulesOutput.toString());
		WFSUtil.printOut(engine, "WFSUtil.evaluateIfRuleGroup :: Complete TRUE FALSE Expression before evaluation : " + rulesOutput.toString() + ", Final Output : " + result);
		
		//Keeping the evaluated result into the main stack again.
		//result = true;
		mainStack.push(new WFRule(result, WFSConstant.RESULT_RULE, prev_indent));
		return;
	}
	
	private static boolean evaluateExpression(String initialInput) {
		boolean result = true;
		if(initialInput == null || initialInput.trim().isEmpty()){
			return false;
		}
		String[] orStr = initialInput.trim().split("OR");
		for(String orExpr : orStr){
			String[] andStr = orExpr.trim().split("AND");
			boolean andResult = true;
			boolean firstResult = true;
			for(String andExpr : andStr){
				boolean tmpResult = "T".equalsIgnoreCase(andExpr.trim());
				if(!firstResult){
					andResult = andResult && tmpResult;
				}
				else{
					andResult = tmpResult;
					firstResult = false;
				}
			}
			result = andResult;
			if(result){
				break;
			}
		}
		return result;
	}
	
	public static Connection getConnectionFromDataSource(WFDataExchangeActivity dxActivityInfo, String engine) throws Exception {
		/*int configurationId = dxActivityInfo.getConfigurationID();
		int targetDBType = dxActivityInfo.getDatabaseType();
		String targetDBName = dxActivityInfo.getCabinetName();
		String targetDBIP = dxActivityInfo.getHostName();
		int targetDBPort = dxActivityInfo.getPort();
		String targetDBServiceName = dxActivityInfo.getDbServiceName();
		String targetDBUserName = dxActivityInfo.getUserName();
		String targetDBPa_ss_word = dxActivityInfo.getPa_ss_word();
		targetDBPa_ss_word = Utility.decode(targetDBPa_ss_word);
		Connection conn = null;
		DataSource dsObj = null;

		// The appending of configId will ensure that the lookup is always unique.
		String lookupKey = targetDBName + "#" + configurationId;
		WFSUtil.printOut(engine, "WFSUtil.getConnectionFromDataSource() :: " + lookupKey);
		WFSUtil.printOut(engine, "WFSUtil.getConnectionFromDataSource() :: targetDBType " + targetDBType);
		WFSUtil.printOut(engine, "WFSUtil.getConnectionFromDataSource() :: targetDBName " + targetDBName);
		WFSUtil.printOut(engine, "WFSUtil.getConnectionFromDataSource() :: targetDBIP " + targetDBIP);
		WFSUtil.printOut(engine, "WFSUtil.getConnectionFromDataSource() :: targetDBPort " + targetDBPort);
		WFSUtil.printOut(engine, "WFSUtil.getConnectionFromDataSource() :: targetDBServiceName " + targetDBServiceName);
		WFSUtil.printOut(engine, "WFSUtil.getConnectionFromDataSource() :: targetDBUserName " + targetDBUserName);
		WFSUtil.printOut(engine, "WFSUtil.getConnectionFromDataSource() :: targetDBPassword " + targetDBPa_ss_word);
		
		if (dataSourceMap.isEmpty() || !dataSourceMap.containsKey(lookupKey) || dataSourceMap.get(lookupKey) == null) {
			WFSUtil.printOut(engine, "WFSUtil.getConnectionFromDataSource() :: Datasource not found in the map, going to create a new Datasource for configurationId " + configurationId);
			
			if (targetDBType == JTSConstant.JTS_MSSQL) {
				SQLServerDataSource sqlDS = new SQLServerDataSource();
				sqlDS.setUser(targetDBUserName);
				sqlDS.setPassword(targetDBPa_ss_word);
				sqlDS.setServerName(targetDBIP);
				sqlDS.setPortNumber(targetDBPort);
				sqlDS.setDatabaseName(targetDBName);
				// ctx.bind(lookupKey, sqlDS);
				dataSourceMap.put(lookupKey, sqlDS);
			} else if (targetDBType == JTSConstant.JTS_ORACLE) {
				OracleDataSource ods = new OracleDataSource();
				ods.setDriverType("thin");
				ods.setServerName(targetDBIP);
				ods.setNetworkProtocol("tcp");
				ods.setDatabaseName(targetDBName);
				ods.setPortNumber(targetDBPort);
				ods.setServiceName(targetDBServiceName);
				ods.setUser(targetDBUserName);
				ods.setPassword(targetDBPa_ss_word);
				dataSourceMap.put(lookupKey, ods);
			} else if (targetDBType == JTSConstant.JTS_POSTGRES) {
				PoolingDataSource pgDs = new PoolingDataSource();
				pgDs.setServerName(targetDBIP);
				pgDs.setPortNumber(targetDBPort);
				pgDs.setDatabaseName(targetDBName);
				pgDs.setUser(targetDBUserName);
				pgDs.setPassword(targetDBPa_ss_word);
				dataSourceMap.put(lookupKey, pgDs);
			} else {
				WFSUtil.printErr(engine, "WFSUtil.getConnectionFromDataSource() :: Invalid DB Type..This should never be the case. Exiting ", null);
				throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_INVALID_DB_DETAILS, WFSError.WF_TMP,
						WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX),
						WFSErrorMsg.getMessage(WFSError.WF_INVALID_DB_DETAILS));
			}
		}
		else{
			WFSUtil.printOut(engine, "WFSUtil.getConnectionFromDataSource() :: Cached entry of data source found...");
		}
		dsObj = (DataSource) dataSourceMap.get(lookupKey);
		if (dsObj == null) {
			// This should not be the case.
			WFSUtil.printErr(engine, "WFSUtil.getConnectionFromDataSource() :: Data Source object is null. Exiting ", null);
			throw new WFSException(WFSError.WF_INVALID_INPUT_DX, WFSError.WF_INVALID_DB_DETAILS, WFSError.WF_TMP,
					WFSErrorMsg.getMessage(WFSError.WF_INVALID_INPUT_DX),
					WFSErrorMsg.getMessage(WFSError.WF_INVALID_DB_DETAILS));
		}*/
		Connection conn = null;
		DataSource dsObj = null;
		InitialContext ctx = new InitialContext();
		dsObj = (DataSource) ctx.lookup(dxActivityInfo.getDataSourceName());
		WFSUtil.printOut(engine, "WFSUtil.getConnectionFromDataSource() :: Getting connection from Data Source.. ");
		//conn = dsObj.getConnection(targetDBUserName, targetDBPa_ss_word);
		conn = dsObj.getConnection();
		if((conn.getMetaData().getDatabaseProductName().contains("Microsoft"))|| (conn.getMetaData().getDatabaseProductName().toLowerCase().contains("microsoft")))
		{
			dxActivityInfo.setDatabaseType(JTSConstant.JTS_MSSQL);
		}
		else if((conn.getMetaData().getDatabaseProductName().contains("ORACLE"))|| (conn.getMetaData().getDatabaseProductName().toLowerCase().contains("oracle")))
		{
			dxActivityInfo.setDatabaseType(JTSConstant.JTS_ORACLE);
		}
		else 
		{
			dxActivityInfo.setDatabaseType(JTSConstant.JTS_POSTGRES);
		}
		return conn;
	}

    public static String DBExpression_DateToString(String in, int len, int style, int dbType) {
        StringBuilder sOutput = new StringBuilder();
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                sOutput.append("CONVERT( varchar(" + len + ") , ");
                sOutput.append(in);
                sOutput.append("," + style);
                sOutput.append(") ");
                break;
            case JTSConstant.JTS_ORACLE:
                sOutput.append(" TO_CHAR( ");
                sOutput.append(in);
                sOutput.append(",'YYYY-MM-DD HH24:MI:SS') ");
                break;
            case JTSConstant.JTS_POSTGRES:
                sOutput.append(" TO_CHAR( ");
                sOutput.append(in);
                sOutput.append(", 'YYYY-MM-DD HH24:MI:SS') ");
                break;
            case JTSConstant.JTS_DB2:
                sOutput.append("VARCHAR_FORMAT(");
                sOutput.append(in);
                sOutput.append(",'YYYY-MM-DD HH24:MI:SS') ");
                break;
        }
        return sOutput.toString();
    }

	private static String getRelationColumnValue(WFMappedColumn mappedColumn, String engine, Connection sourceConn,
			String processInstanceId, int workitemId,String varType,int dbType, int processdefid, int sourceDBType) throws SQLException, WFSException 
	{
		String value ="";
		String query = null;
		String itemindex= null;
		String itemtype = null;
		PreparedStatement pstmt = null;
	    ResultSet rs = null;
		String tableName = mappedColumn.getComplexTableName();
		String columnName = mappedColumn.getRelationColumnName();
		int expressionDataType = mappedColumn.getDbColumnDatatype();
		if("P".equalsIgnoreCase(varType))
		{
			if("WFINSTRUMENTTABLE".equalsIgnoreCase(tableName) && "processInstanceId".equalsIgnoreCase(columnName))
			{
				value = processInstanceId;
			 }
			else 
			{ 
				if("WFINSTRUMENTTABLE".equalsIgnoreCase(tableName)) 
				{	
					query = "Select "+columnName+" from "+tableName+ getTableLockHintStr(sourceDBType)+" where processInstanceId = ? AND workitemId = ?";
				}
				else
				{
					String wfsQuery = "Select Var_Rec_1,Var_Rec_2 from WFINSTRUMENTTABLE "+ getTableLockHintStr(sourceDBType) +" where processInstanceId = ? AND workitemId = ?";
					try {
						pstmt = sourceConn.prepareStatement(wfsQuery);
						pstmt.setString(1, processInstanceId);
						pstmt.setInt(2, workitemId);
						rs = pstmt.executeQuery();
						if(rs.next())
						{
							itemindex = rs.getString("Var_Rec_1");
							itemtype = rs.getString("Var_Rec_2");
						}
						try {

			                if (rs != null) {
			                	rs.close();
			                	rs = null;
			                }
			            } catch (Exception e) {
			            }
						try {

			                if (pstmt != null) {
			                	pstmt.close();
			                	pstmt = null;
			                }
			            } catch (Exception e) {
			            }
						} 
					catch (SQLException e) 
					       {
							WFSUtil.printErr(engine, "", e);
							}
					query = "Select "+columnName+" from "+tableName+ getTableLockHintStr(sourceDBType) +" where itemindex = ? AND itemtype = ?";
					pstmt = sourceConn.prepareStatement(query);
					pstmt.setString(1, itemindex);
					pstmt.setString(2, itemtype);					
				}
				try 
				{
					if(pstmt == null)
					{
						pstmt = sourceConn.prepareStatement(query);
						pstmt.setString(1, processInstanceId);
						pstmt.setInt(2, workitemId);
					}
					rs = pstmt.executeQuery();
					if(rs.next())
					{
						value = rs.getString(columnName);
					}
					try {

		                if (rs != null) {
		                	rs.close();
		                	rs = null;
		                }
		            } catch (Exception e) {
		            }
					try {

		                if (pstmt != null) {
		                	pstmt.close();
		                	pstmt = null;
		                }
		            } catch (Exception e) {
		            }
				} 
				catch (SQLException e) 
				{
					WFSUtil.printErr(engine, "", e);
				}
				
			}
		}
				
		WFSUtil.printOut(engine, "WFSUtil.getRelationColumnValue :: final Relation value for table "+ mappedColumn.getEntityName() +" column "+mappedColumn.getEntityColumnName()+" : " + value);
		
		if(value != null && !value.isEmpty()){
			value = TO_SQL(value, expressionDataType, dbType, true);
		}
		else{
			value = " NULL ";
			WFSUtil.printOut(engine, "WFSUtil.getRelationColumnValue :: Inserting NULL in relation column "+ mappedColumn.getEntityColumnName()+" in Table "+mappedColumn.getEntityName());
			}
		
		return value;
		
	}
	
	private static List<String> getRelationColumnValueForComplexArray(WFMappedColumn mappedColumn, String engine, Connection sourceConn,
			String processInstanceId, int workitemId,String varType,int dbType, int processdefid, int sourceDBType, HashMap<String, String> tableFilterMap) throws SQLException, WFSException 
	{
		String value ="";
		String finalValue ="";
		List<String> finalValueList = new ArrayList<String>();
		List<String> valueList = new ArrayList<String>();
		List<String> innerValueList = new ArrayList<String>();
		String query = null;
		String itemindex= null;
		String itemtype = null;
		PreparedStatement pstmt = null;
	    ResultSet rs = null;
		String tableName = mappedColumn.getComplexTableName();
		String columnName = mappedColumn.getRelationColumnName();
		int expressionDataType = mappedColumn.getDbColumnDatatype();

		    query = "Select ParentObject,ForeignKey FROM WFVarRelationTable "+ getTableLockHintStr(sourceDBType) +" WHERE ProcessDefId = ? AND ChildObject = ? AND RefKey = ?";
			pstmt = sourceConn.prepareStatement(query);
			pstmt.setInt(1, processdefid);
			pstmt.setString(2, tableName);
			pstmt.setString(3, columnName);
			rs = pstmt.executeQuery();
			if(rs.next())
			{
				valueList = getComplexRelationvalue(sourceConn, TO_SANITIZE_STRING(rs.getString("ParentObject"),true), TO_SANITIZE_STRING(rs.getString("ForeignKey"),true), tableName, columnName, engine, processInstanceId, workitemId, dbType,sourceDBType,tableFilterMap);
			}
			else
			{
				String refKey = null;
				query = "Select ParentObject,ForeignKey,Refkey FROM WFVarRelationTable "+ getTableLockHintStr(sourceDBType) +" WHERE ProcessDefId = ? AND ChildObject = ?";
				pstmt = sourceConn.prepareStatement(query);
				pstmt.setInt(1, processdefid);
				pstmt.setString(2, tableName);
				rs = pstmt.executeQuery();
				if(rs.next())
				{
				    refKey = rs.getString("Refkey");
				    innerValueList = getComplexRelationvalue(sourceConn, TO_SANITIZE_STRING(rs.getString("ParentObject"),true), TO_SANITIZE_STRING(rs.getString("ForeignKey"),true), tableName,refKey , engine, processInstanceId, workitemId, dbType,sourceDBType,tableFilterMap);
				}
				else
				{
					WFSUtil.printOut(engine, "Relation does not exis in WFVarRelationTable for table "+tableName);
				}
				try {

	                if (rs != null) {
	                	rs.close();
	                	rs = null;
	                }
	            } catch (Exception e) {
	            }
				try {

	                if (pstmt != null) {
	                	pstmt.close();
	                	pstmt = null;
	                }
	            } catch (Exception e) {
	            }
                if(refKey != null && !innerValueList.isEmpty())
                {
                query = "Select "+columnName+" from "+tableName+" "+ getTableLockHintStr(sourceDBType) +" where "+ TO_SANITIZE_STRING(refKey,true) +"= ? ";
                if(tableFilterMap.containsKey(tableName))
                {
                	query = query +" AND "+tableFilterMap.get(tableName);
                }
				
				for(int i =0;i<innerValueList.size();i++)
				{
					pstmt = sourceConn.prepareStatement(query);
					if(innerValueList.get(i)!= null && !innerValueList.get(i).isEmpty())
					{
								try{
									pstmt.setString(1,innerValueList.get(i));
								rs = pstmt.executeQuery();
								}
								catch( Exception e)
								{
									pstmt.setLong(1,Long.parseLong(innerValueList.get(i)));
									rs = pstmt.executeQuery();
								}
						while(rs.next())
						{
							value = rs.getString(columnName);
							valueList.add(value);
						}
                    }
					try {

		                if (rs != null) {
		                	rs.close();
		                	rs = null;
		                }
		            } catch (Exception e) {
		            }
					try {

		                if (pstmt != null) {
		                	pstmt.close();
		                	pstmt = null;
		                }
		            } catch (Exception e) {
		            }
                }
                }
			}
			
		
		
		WFSUtil.printOut(engine, "WFSUtil.getRelationColumnValue :: final Relation valueList for table "+ mappedColumn.getEntityName() +" column "+mappedColumn.getEntityColumnName()+" : " + valueList);
		if(valueList.isEmpty())
		{
			finalValueList.add("NULL")	;
		}
		else
		{
		for(int i =0;i<valueList.size();i++)
		{
		if(valueList.get(i) != null && !valueList.get(i).isEmpty()){
			finalValue = TO_SQL(valueList.get(i), expressionDataType, dbType, true);
		}
		else{
			finalValue = " NULL ";
			WFSUtil.printOut(engine, "WFSUtil.getRelationColumnValue :: Inserting NULL in relation column "+ mappedColumn.getEntityColumnName()+" in Table "+mappedColumn.getEntityName());
			}
		finalValueList.add(finalValue);
		}
		}
		return finalValueList;
		
	}


    public static String DBExpression_ParametricStringToDate(Integer iDBType) {
        StringBuilder sOutput = new StringBuilder();
        switch (iDBType) {
            case JTSConstant.JTS_MSSQL:
                sOutput.append("CONVERT(DateTime , ?)");
                break;
            case JTSConstant.JTS_ORACLE:
                sOutput.append("TO_DATE(?, 'YYYY-MM-DD HH24:MI:SS')");
                break;
            case JTSConstant.JTS_POSTGRES:
                sOutput.append("CAST(? AS TIMESTAMP)");
                break;
            case JTSConstant.JTS_DB2:
                sOutput.append("TIMESTAMP_FORMAT(?, 'YYYY-MM-DD HH24:MI:SS')");
                break;
        }
        return sOutput.toString();
    }

    public static void GenerateServiceAudit(Connection con, String engineName, int PSID, String ServiceName, String ServiceType, int ActionId, String Username, String ServerDetails, String ServiceParamsInfo) {
        PreparedStatement pstmt = null;
        try {
            pstmt = con.prepareStatement("INSERT INTO WFServiceAuditTable(PSID, ServiceName, ServiceType, ActionId, Username, ServerDetails, ServiceParamDetails) VALUES (?, ?, ?, ?, ?, ?, ?)");
            pstmt.setInt(1, PSID);
            pstmt.setString(2, ServiceName);
            pstmt.setString(3, ServiceType);
            pstmt.setInt(4, ActionId);
            pstmt.setString(5, Username);
            pstmt.setString(6, ServerDetails);
            pstmt.setString(7, ServiceParamsInfo);
            pstmt.executeUpdate();
            pstmt.close();
            pstmt = null;
        } catch (Exception | Error e) {
            WFSUtil.printErr(engineName, "", e);
        } finally {
            if (pstmt != null) {
                try {
                    pstmt.close();
                } catch (SQLException ignore) {
                }
            }
        }
    }
    /**
     * *************************************************************
     * Function Name    :   getLockPrefixWithoutReadPast
     * Programmer' Name :   Mohnish Chopra
     * Date Written     :   June 8th 2020
     * Input Parameters :   int -> dbType
     * Output Parameters:   NONE
     * Return Value     :   String -> prefix string for database lock
     * Description      :   Query prefix string for locking row
     *                      in Database
     * *************************************************************
     */
    public static String getLockPrefixWithoutReadPast(int dbType) {
        String prefixStr = null;
        switch (dbType) {
            case JTSConstant.JTS_MSSQL:
                prefixStr = " WITH (UPDLOCK) "; 
                break;
            case JTSConstant.JTS_ORACLE:
            case JTSConstant.JTS_DB2:
            case JTSConstant.JTS_POSTGRES:
            default:
                prefixStr = "";
        }
        return prefixStr;
    }
 public static void setValidationCheck(String sVarValidationRequired) {
        //sVarVal = sVarValidationRequired;
    }
 
 
 public static String encodeForLDAP(String input, boolean encodeWildcards) {
	    if( input == null ) {
	    	return null;	
	    }
	    StringBuilder sb = new StringBuilder();
	    for (int i = 0; i < input.length(); i++) {
	        char c = input.charAt(i);

	        switch (c) {
	            case '\\':
	                sb.append("\\5c");
	                break;
	            case '*': 
	                if (encodeWildcards) {
	                    sb.append("\\2a"); 
	                }
	                else {
	                    sb.append(c);
	                }
	                
	                break;
	            case '(':
	                sb.append("\\28");
	                break;
	            case ')':
	                sb.append("\\29");
	                break;
	            case '\0':
	                sb.append("\\00");
	                break;
	            default:
	                sb.append(c);
	        }
	    }
		return sb.toString();
	}
 
 /**
  * *************************************************************
  * Function Name    :   getCurrentDateTimeFromDB
  * Programmer' Name :   Ravi Raj Mewara
  * Date Written     :   Oct 4th 2021
  * Input Parameters :   int -> dbType, con -> connection, engine-> string
  * Output Parameters:   None
  * Return Value     :   String -> current date time from database
  * Description      :   Method to return current date time from database
  * *************************************************************
  */

public static String getCurrentDateTimeFromDB(Connection con, String engine, int dbType) throws SQLException {
	
		PreparedStatement pstmt = null;
		StringBuilder query = new StringBuilder();
		ResultSet rs = null;
		query.append("Select ").append(WFSUtil.getDate(dbType)).append(WFSUtil.getDummyTableName(dbType));
		
		pstmt=con.prepareStatement(query.toString());
		rs=pstmt.executeQuery();
		Date currDate=null;
		if(rs.next()){
			currDate=rs.getTimestamp(1);
		}
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");       					
		String currentDateTime=sdf.format(currDate);
        try {

            if (rs != null) {
            	rs.close();
            	rs = null;
            }
        } catch (Exception e) {
        }
		try {

            if (pstmt != null) {
            	pstmt.close();
            	pstmt = null;
            }
        } catch (Exception e) {
        }
		
	return currentDateTime;
}

/**
 * *************************************************************
 * Function Name    :   createTableForFileUploadArtifactMigration()
 * Author			:   Ravi raj Mewara
 * Date Written     :   28/12/2021
 * Input Parameters :  Connection con,String engine,int dbType,int pDefId, int actId
 * Output Parameters:   none
 * Return Value     :   none
 * Description      :   Creates a Table in DataBase for File Uploader Utility 
                        when the Unique Field is true at the time of Registering the Utility.
 * *************************************************************
 */
public static void createTableForFileUploadArtifactMigration(Connection con,String engine,int dbType,int pDefId, int actId){
	Statement stmt =null ;
	ResultSet rs = null;
	DatabaseMetaData dbmt  = null;
	StringBuffer qStr = new StringBuffer(200);
	try{
		String TableName = "WFIMPORTFILEDATA_" + pDefId + "_" + actId;
		dbmt = con.getMetaData();
		rs = dbmt.getTables(null, null, TableName, null);
		if(!rs.next()) {
				//table does not exist. 
			qStr.append("CREATE TABLE ");
			qStr.append(TableName);
			if(dbType == JTSConstant.JTS_MSSQL){
					qStr.append(" (FILEINDEX INTEGER, FILENAME NVARCHAR(256), UPLOADTIME DATETIME)");
			}else if(dbType == JTSConstant.JTS_ORACLE){
					qStr.append(" (FILEINDEX INTEGER, FILENAME NVARCHAR2(256), UPLOADTIME DATE)");
			}else if(dbType == JTSConstant.JTS_POSTGRES){
					qStr.append(" (FILEINDEX INTEGER, FILENAME VARCHAR(256), UPLOADTIME TIMESTAMP)");
			}     
		}
		stmt = con.createStatement();
		stmt.execute(qStr.toString());
	}catch(Exception ex){
                printErr(engine,"",ex);
            }
	finally{
                try{
		if(stmt != null){
			stmt.close();
			stmt = null;
		}
		if(rs != null){
			rs.close();
			rs = null;
		}                   
                }catch(SQLException exp){
                    printErr(engine,"",exp);
                }
                    
            }
	
}

    private static WFFieldInfo getSortingFieldInfo(String sSortingFieldName, WFFieldInfo wffieldinfo) {
        WFFieldInfo oSortingFieldInfo = null;
        if (!"insertionorderid".equalsIgnoreCase(sSortingFieldName)) {
            Iterator<Map.Entry> itr = wffieldinfo.getChildInfoMap().entrySet().iterator();
            while (itr.hasNext()) {
                Map.Entry next = itr.next();
                if (sSortingFieldName.equalsIgnoreCase(String.valueOf(next.getKey()))) {
                    oSortingFieldInfo = ((WFFieldInfo) next.getValue());
                    break;
                }
            }
        }
        return oSortingFieldInfo;
    }
    private static String getdefaultqueue(Connection con, int dbType ) {
   	 PreparedStatement pstmt = null;
   	 ResultSet rs= null;
   	 HashSet<String> queueset=new HashSet();
   	 List<String> missingqueue = new ArrayList<String>();
   	 queueset.add("SystemPFEQueue");
   	 queueset.add("SystemArchiveQueue");
   	 queueset.add("SystemSharepointQueue");
   	 queueset.add("SystemWSQueue");
   	 queueset.add("SystemSAPQueue");
   	 queueset.add("SystemBRMSQueue");
   	 queueset.add("SystemDXQueue");


   	 try {
   	 pstmt = con.prepareStatement("select QueueId, QueueName from QueueDefTable "
   	 + WFSUtil.getTableLockHintStr(dbType)
   	 + " where QueueName= " + TO_STRING("SystemPFEQueue", true, dbType)
   	 + " OR QueueName = " + TO_STRING("SystemArchiveQueue", true, dbType)
   	 + " OR QueueName = " + TO_STRING("SystemSharepointQueue", true, dbType)
   	 + " OR QueueName = " + TO_STRING("SystemWSQueue", true, dbType)
   	 + " OR QueueName = " + TO_STRING("SystemSAPQueue", true, dbType)
   	 + " OR QueueName = " + TO_STRING("SystemBRMSQueue", true, dbType)
   	 + " OR QueueName = " + TO_STRING("SystemDXQueue", true, dbType)
   	 + " Order By QueueName ");
   	 rs= pstmt.executeQuery();

   	 while(rs.next()) {
   	 String queueName=rs.getString("QueueName");
   	 missingqueue.add(queueName);
   	 }
   	 queueset.removeAll(missingqueue);
   	 
   	 if(rs != null){
            rs.close();
            rs = null;
        }
        if(pstmt != null){
        	pstmt.close();
        	pstmt = null;
        	
        }
   	 

   	 } catch (SQLException e) {
   	 // TODO Auto-generated catch block
   	 System.out.println(e);
   	 e.printStackTrace();
   	 }


   	 return queueset.toString();
   	 
    }
    
    public static String getTargetCabinetName(Connection con){
   	   
		PreparedStatement pstmt = null;
		ResultSet rs = null;
        try {
			if(targetCabineName == null){
				if(con != null){
					
					pstmt = con.prepareStatement("SELECT PROPERTYVALUE FROM WFSYSTEMPROPERTIESTABLE WHERE PROPERTYKEY = ?") ;
					pstmt.setString(1, "ARCHIVALCABINETNAME");
					rs = pstmt.executeQuery();
					while(rs.next()){
						targetCabineName = rs.getString("PROPERTYVALUE");
					}
				} 
			
       
				if(pstmt != null)
					pstmt.close();
				if(rs != null)
					rs.close();
			}
		} 
		catch (Exception ignored) {
            targetCabineName = null ;
        }
        return targetCabineName;
   }
   
   
   public static Boolean checkIfHistoryLoggingOnTarget(String targetCabinetName){
   
		if(tarHistoryLog == null){
			try {
				tarHistoryLog = ((String) WFFindClass.wfGetServerPropertyMap().get(WFSConstant.HISTORY_LOG_ON_TARGET)).equalsIgnoreCase("Y") ? true : false;
				if(tarHistoryLog && (targetCabinetName != null  && !targetCabinetName.equalsIgnoreCase(""))){
					tarHistoryLog = true;
				}else{
					tarHistoryLog = false;
				}
				
			} catch (Exception ignored) {
				tarHistoryLog = false ;
			}
		}
        return tarHistoryLog;
   }
 
} // class WFSUtil
class ActionFieldPair {

    public int actionId;
    public String name;
    public String value;
	public long fieldId;

    public ActionFieldPair(int actionId, String name, String value,long fieldId) {
        this.actionId = actionId;
        this.name = name;
        this.value = value;
		this.fieldId = fieldId;
    }
    
}// class ActionFieldPair
  class ComplexDataClass {
    public String complexTableName;
    public String complexFieldName;
    public String parentObj;
    public String foreignKey;
    public String refKey;
    public int varType;
    public ComplexDataClass(String complexTableName,String complexFieldName,String parentObj,String  foreignKey, String refKey,int varType) {
        this.complexTableName = complexTableName;
        this.complexFieldName = complexFieldName;
        this.parentObj = parentObj;
        this.foreignKey = foreignKey;
        this.refKey = refKey;
        this.varType = varType;
    }
}//ComplexDataClass Class
  
